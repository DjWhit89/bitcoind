<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="secp256k1_8c" kind="file" language="C++">
    <compoundname>secp256k1.c</compoundname>
    <includes refid="secp256k1_8h" local="yes">../include/secp256k1.h</includes>
    <includes refid="secp256k1__preallocated_8h" local="yes">../include/secp256k1_preallocated.h</includes>
    <includes refid="secp256k1_2src_2assumptions_8h" local="yes">assumptions.h</includes>
    <includes refid="checkmem_8h" local="yes">checkmem.h</includes>
    <includes refid="secp256k1_2src_2util_8h" local="yes">util.h</includes>
    <includes refid="field__impl_8h" local="yes">field_impl.h</includes>
    <includes refid="scalar__impl_8h" local="yes">scalar_impl.h</includes>
    <includes refid="group__impl_8h" local="yes">group_impl.h</includes>
    <includes refid="ecmult__impl_8h" local="yes">ecmult_impl.h</includes>
    <includes refid="ecmult__const__impl_8h" local="yes">ecmult_const_impl.h</includes>
    <includes refid="ecmult__gen__impl_8h" local="yes">ecmult_gen_impl.h</includes>
    <includes refid="ecdsa__impl_8h" local="yes">ecdsa_impl.h</includes>
    <includes refid="eckey__impl_8h" local="yes">eckey_impl.h</includes>
    <includes refid="hash__impl_8h" local="yes">hash_impl.h</includes>
    <includes refid="int128__impl_8h" local="yes">int128_impl.h</includes>
    <includes refid="scratch__impl_8h" local="yes">scratch_impl.h</includes>
    <includes refid="selftest_8h" local="yes">selftest.h</includes>
    <includes refid="hsort__impl_8h" local="yes">hsort_impl.h</includes>
    <includedby refid="bench__ecmult_8c" local="yes">src/secp256k1/src/bench_ecmult.c</includedby>
    <includedby refid="bench__internal_8c" local="yes">src/secp256k1/src/bench_internal.c</includedby>
    <includedby refid="tests_8c" local="yes">src/secp256k1/src/tests.c</includedby>
    <includedby refid="tests__exhaustive_8c" local="yes">src/secp256k1/src/tests_exhaustive.c</includedby>
    <incdepgraph>
      <node id="2">
        <label>../include/secp256k1.h</label>
        <link refid="secp256k1_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>../include/secp256k1_preallocated.h</label>
        <link refid="secp256k1__preallocated_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>assumptions.h</label>
        <link refid="secp256k1_2src_2assumptions_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>checkmem.h</label>
        <link refid="checkmem_8h"/>
      </node>
      <node id="55">
        <label>ecdsa.h</label>
        <link refid="ecdsa_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="54">
        <label>ecdsa_impl.h</label>
        <link refid="ecdsa__impl_8h"/>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="57">
        <label>eckey.h</label>
        <link refid="eckey_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
      </node>
      <node id="56">
        <label>eckey_impl.h</label>
        <link refid="eckey__impl_8h"/>
        <childnode refid="57" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>ecmult.h</label>
        <link refid="ecmult_8h"/>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="48">
        <label>ecmult_const.h</label>
        <link refid="ecmult__const_8h"/>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="47">
        <label>ecmult_const_impl.h</label>
        <link refid="ecmult__const__impl_8h"/>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="48" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
      </node>
      <node id="50">
        <label>ecmult_gen.h</label>
        <link refid="ecmult__gen_8h"/>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="49">
        <label>ecmult_gen_impl.h</label>
        <link refid="ecmult__gen__impl_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
        <childnode refid="51" relation="include">
        </childnode>
        <childnode refid="53" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>ecmult_impl.h</label>
        <link refid="ecmult__impl_8h"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
      </node>
      <node id="28">
        <label>field.h</label>
        <link refid="field_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="29">
        <label>field_5x52.h</label>
        <link refid="field__5x52_8h"/>
        <childnode refid="25" relation="include">
        </childnode>
      </node>
      <node id="30">
        <label>field_5x52_impl.h</label>
        <link refid="field__5x52__impl_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
      </node>
      <node id="35">
        <label>field_5x52_int128_impl.h</label>
        <link refid="field__5x52__int128__impl_8h"/>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="27">
        <label>field_impl.h</label>
        <link refid="field__impl_8h"/>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>group.h</label>
        <link refid="group_8h"/>
        <childnode refid="28" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>group_impl.h</label>
        <link refid="group__impl_8h"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="52">
        <label>hash.h</label>
        <link refid="secp256k1_2src_2hash_8h"/>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
      </node>
      <node id="51">
        <label>hash_impl.h</label>
        <link refid="hash__impl_8h"/>
        <childnode refid="52" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="63">
        <label>hsort.h</label>
        <link refid="hsort_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="62">
        <label>hsort_impl.h</label>
        <link refid="hsort__impl_8h"/>
        <childnode refid="63" relation="include">
        </childnode>
      </node>
      <node id="32">
        <label>int128.h</label>
        <link refid="int128_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
      </node>
      <node id="58">
        <label>int128_impl.h</label>
        <link refid="int128__impl_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="59" relation="include">
        </childnode>
      </node>
      <node id="33">
        <label>int128_struct.h</label>
        <link refid="int128__struct_8h"/>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="59">
        <label>int128_struct_impl.h</label>
        <link refid="int128__struct__impl_8h"/>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>modinv64.h</label>
        <link refid="modinv64_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="31">
        <label>modinv64_impl.h</label>
        <link refid="modinv64__impl_8h"/>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
      </node>
      <node id="45">
        <label>precomputed_ecmult.h</label>
        <link refid="precomputed__ecmult_8h"/>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="53">
        <label>precomputed_ecmult_gen.h</label>
        <link refid="precomputed__ecmult__gen_8h"/>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="37">
        <label>scalar.h</label>
        <link refid="scalar_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
      </node>
      <node id="38">
        <label>scalar_4x64.h</label>
        <link refid="scalar__4x64_8h"/>
        <childnode refid="25" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>scalar_4x64_impl.h</label>
        <link refid="scalar__4x64__impl_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="36">
        <label>scalar_impl.h</label>
        <link refid="scalar__impl_8h"/>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>scratch.h</label>
        <link refid="scratch_8h"/>
      </node>
      <node id="60">
        <label>scratch_impl.h</label>
        <link refid="scratch__impl_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/secp256k1/src/secp256k1.c</label>
        <link refid="secp256k1_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="47" relation="include">
        </childnode>
        <childnode refid="49" relation="include">
        </childnode>
        <childnode refid="54" relation="include">
        </childnode>
        <childnode refid="56" relation="include">
        </childnode>
        <childnode refid="51" relation="include">
        </childnode>
        <childnode refid="58" relation="include">
        </childnode>
        <childnode refid="60" relation="include">
        </childnode>
        <childnode refid="61" relation="include">
        </childnode>
        <childnode refid="62" relation="include">
        </childnode>
      </node>
      <node id="61">
        <label>selftest.h</label>
        <link refid="selftest_8h"/>
        <childnode refid="52" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>util.h</label>
        <link refid="secp256k1_2src_2util_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="46">
        <label>util_local_visibility.h</label>
        <link refid="util__local__visibility_8h"/>
      </node>
      <node id="10">
        <label>span.h</label>
        <link refid="span_8h"/>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>string.h</label>
        <link refid="string_8h"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="16">
        <label>array</label>
      </node>
      <node id="11">
        <label>cassert</label>
      </node>
      <node id="12">
        <label>cstddef</label>
      </node>
      <node id="17">
        <label>cstdint</label>
      </node>
      <node id="18">
        <label>cstring</label>
      </node>
      <node id="6">
        <label>limits.h</label>
      </node>
      <node id="19">
        <label>locale</label>
      </node>
      <node id="13">
        <label>span</label>
      </node>
      <node id="20">
        <label>sstream</label>
      </node>
      <node id="3">
        <label>stddef.h</label>
      </node>
      <node id="25">
        <label>stdint.h</label>
      </node>
      <node id="26">
        <label>stdio.h</label>
      </node>
      <node id="24">
        <label>stdlib.h</label>
      </node>
      <node id="21">
        <label>string</label>
      </node>
      <node id="22">
        <label>string_view</label>
      </node>
      <node id="14">
        <label>type_traits</label>
      </node>
      <node id="15">
        <label>utility</label>
      </node>
      <node id="23">
        <label>vector</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="2">
        <label>src/secp256k1/src/bench_ecmult.c</label>
        <link refid="bench__ecmult_8c"/>
      </node>
      <node id="3">
        <label>src/secp256k1/src/bench_internal.c</label>
        <link refid="bench__internal_8c"/>
      </node>
      <node id="1">
        <label>src/secp256k1/src/secp256k1.c</label>
        <link refid="secp256k1_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>src/secp256k1/src/tests.c</label>
        <link refid="tests_8c"/>
      </node>
      <node id="5">
        <label>src/secp256k1/src/tests_exhaustive.c</label>
        <link refid="tests__exhaustive_8c"/>
      </node>
    </invincdepgraph>
    <innerclass refid="structsecp256k1__context__struct" prot="public">secp256k1_context_struct</innerclass>
    <sectiondef kind="define">
      <memberdef kind="define" id="secp256k1_8c_1a1c49db739b76634ccbd0db4233e6cd8a" prot="public" static="no">
        <name>SECP256K1_BUILD</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="18" column="9" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" prot="public" static="no">
        <name>ARG_CHECK</name>
        <param><defname>cond</defname></param>
        <initializer>    do { \
    <ref refid="bitcoin-cli_8cpp_1a33ca945cbc30c0f7b2a7e5393a99d5d4" kindref="member">if</ref> (<ref refid="minisketch_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>(!(cond), 0)) { \
        secp256k1_callback_call(&amp;ctx-&gt;illegal_callback, #cond); \
        return 0; \
    } \
} while(0)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="45" column="9" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="45" bodyend="50"/>
      </memberdef>
      <memberdef kind="define" id="secp256k1_8c_1afb9791f4e16ba663d93c7cd3259398f5" prot="public" static="no">
        <name>ARG_CHECK_VOID</name>
        <param><defname>cond</defname></param>
        <initializer>    do { \
    <ref refid="bitcoin-cli_8cpp_1a33ca945cbc30c0f7b2a7e5393a99d5d4" kindref="member">if</ref> (<ref refid="minisketch_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>(!(cond), 0)) { \
        secp256k1_callback_call(&amp;ctx-&gt;illegal_callback, #cond); \
        return; \
    } \
} while(0)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="52" column="9" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="52" bodyend="57"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="secp256k1_8c_1ae4ba499692b1abd865233f87146a34e9" prot="public" static="yes" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref></type>
        <definition>const secp256k1_context secp256k1_context_static_</definition>
        <argsstring></argsstring>
        <name>secp256k1_context_static_</name>
        <initializer>= {
    { 0 },
    { secp256k1_default_illegal_callback_fn, 0 },
    { secp256k1_default_error_callback_fn, 0 },
    0
}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="68" column="32" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="68" bodyend="73"/>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1aed87bf9186c495548cb8a99b3321a961" prot="public" static="no" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *const</type>
        <definition>const secp256k1_context* const secp256k1_context_static</definition>
        <argsstring></argsstring>
        <name>secp256k1_context_static</name>
        <initializer>= &amp;secp256k1_context_static_</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="74" column="32" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="74" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1a3f6dbb9269438555c89ff1e557d77fc9" prot="public" static="no" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *const</type>
        <definition>const secp256k1_context* const secp256k1_context_no_precomp</definition>
        <argsstring></argsstring>
        <name>secp256k1_context_no_precomp</name>
        <initializer>= &amp;secp256k1_context_static_</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="75" column="32" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="75" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1a2ac052a733aac60ef5c19f1f79e3c1dd" prot="public" static="no" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
        <definition>const secp256k1_nonce_function secp256k1_nonce_function_rfc6979</definition>
        <argsstring></argsstring>
        <name>secp256k1_nonce_function_rfc6979</name>
        <initializer>= nonce_function_rfc6979</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="507" column="32" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="507" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" prot="public" static="no" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
        <definition>const secp256k1_nonce_function secp256k1_nonce_function_default</definition>
        <argsstring></argsstring>
        <name>secp256k1_nonce_function_default</name>
        <initializer>= nonce_function_rfc6979</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="508" column="32" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="508" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="secp256k1_8c_1a60247aad18b177cb47850fcf6dcbe52f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_context_is_proper</definition>
        <argsstring>(const secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_is_proper</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="82" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="82" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1acf942e835990dd24ce71e93022c932c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_selftest</definition>
        <argsstring>(void)</argsstring>
        <name>secp256k1_selftest</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Perform basic self tests (to be used in conjunction with secp256k1_context_static)</para>
<para>This function performs self tests that detect some serious usage errors and similar conditions, e.g., when the library is compiled for the wrong endianness. This is a last resort measure to be used in production. The performed tests are very rudimentary and are not intended as a replacement for running the test binaries.</para>
<para>It is highly recommended to call this before using secp256k1_context_static. It is not necessary to call this function before using a context created with secp256k1_context_create (or secp256k1_context_preallocated_create), which will take care of performing the self tests.</para>
<para>If the tests fail, this function will call the default error callback to abort the program (see secp256k1_context_set_error_callback). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="86" column="6" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="86" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a9f5faeec85b85bdaccd7ddda899dbfa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t secp256k1_context_preallocated_size</definition>
        <argsstring>(unsigned int flags)</argsstring>
        <name>secp256k1_context_preallocated_size</name>
        <param>
          <type>unsigned int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determine the memory size of a secp256k1 context object to be created in caller-provided memory.</para>
<para>The purpose of this function is to determine how much memory must be provided to secp256k1_context_preallocated_create.</para>
<para>Returns: the required size of the caller-provided memory block In: flags: which parts of the context to initialize. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="92" column="8" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="92" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a5665930bf606d6a7262cebc936eda949" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t secp256k1_context_preallocated_clone_size</definition>
        <argsstring>(const secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_preallocated_clone_size</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determine the memory size of a secp256k1 context object to be copied into caller-provided memory.</para>
<para>Returns: the required size of the caller-provided memory block. In: ctx: pointer to a context to copy. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="112" column="8" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="112" bodyend="116"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1af4866e9619f06679358fe6338ed42cd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
        <definition>secp256k1_context * secp256k1_context_preallocated_create</definition>
        <argsstring>(void *prealloc, unsigned int flags)</argsstring>
        <name>secp256k1_context_preallocated_create</name>
        <param>
          <type>void *</type>
          <declname>prealloc</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a secp256k1 context object in caller-provided memory.</para>
<para>The caller must provide a pointer to a rewritable contiguous block of memory of size at least secp256k1_context_preallocated_size(flags) bytes, suitably aligned to hold an object of any type.</para>
<para>The block of memory is exclusively owned by the created context object during the lifetime of this context object, which begins with the call to this function and ends when a call to secp256k1_context_preallocated_destroy (which destroys the context object again) returns. During the lifetime of the context object, the caller is obligated not to access this block of memory, i.e., the caller may not read or write the memory, e.g., by copying the memory contents to a different location or trying to create a second context object in the memory. In simpler words, the prealloc pointer (or any pointer derived from it) should not be used during the lifetime of the context object.</para>
<para>Returns: pointer to newly created context object. In: prealloc: pointer to a rewritable contiguous block of memory of size at least secp256k1_context_preallocated_size(flags) bytes, as detailed above. flags: which parts of the context to initialize.</para>
<para>See secp256k1_context_create (in <ref refid="secp256k1_8h" kindref="compound">secp256k1.h</ref>) for further details.</para>
<para>See also secp256k1_context_randomize (in <ref refid="secp256k1_8h" kindref="compound">secp256k1.h</ref>) and secp256k1_context_preallocated_destroy. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="118" column="19" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="118" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a861ce6fc7ee5e9fc346a5fee7093adb1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
        <definition>secp256k1_context * secp256k1_context_create</definition>
        <argsstring>(unsigned int flags)</argsstring>
        <name>secp256k1_context_create</name>
        <param>
          <type>unsigned int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a secp256k1 context object (in dynamically allocated memory).</para>
<para>This function uses malloc to allocate memory. It is guaranteed that malloc is called at most once for every call of this function. If you need to avoid dynamic memory allocation entirely, see secp256k1_context_static and the functions in <ref refid="secp256k1__preallocated_8h" kindref="compound">secp256k1_preallocated.h</ref>.</para>
<para>Returns: pointer to a newly created context object. In: flags: Always set to SECP256K1_CONTEXT_NONE (see below).</para>
<para>The only valid non-deprecated flag in recent library versions is SECP256K1_CONTEXT_NONE, which will create a context sufficient for all functionality offered by the library. All other (deprecated) flags will be treated as equivalent to the SECP256K1_CONTEXT_NONE flag. Though the flags parameter primarily exists for historical reasons, future versions of the library may introduce new flags.</para>
<para>If the context is intended to be used for API functions that perform computations involving secret keys, e.g., signing and public key generation, then it is highly recommended to call secp256k1_context_randomize on the context before calling those API functions. This will provide enhanced protection against side-channel leakage, see secp256k1_context_randomize for details.</para>
<para>Do not create a new context object for each operation, as construction and randomization can take non-negligible time. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="141" column="19" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="141" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a2a2e39dbcd6d55d8e6faaad194261a71" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
        <definition>secp256k1_context * secp256k1_context_preallocated_clone</definition>
        <argsstring>(const secp256k1_context *ctx, void *prealloc)</argsstring>
        <name>secp256k1_context_preallocated_clone</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>prealloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy a secp256k1 context object into caller-provided memory.</para>
<para>The caller must provide a pointer to a rewritable contiguous block of memory of size at least secp256k1_context_preallocated_size(flags) bytes, suitably aligned to hold an object of any type.</para>
<para>The block of memory is exclusively owned by the created context object during the lifetime of this context object, see the description of secp256k1_context_preallocated_create for details.</para>
<para>Cloning secp256k1_context_static is not possible, and should not be emulated by the caller (e.g., using memcpy). Create a new context instead.</para>
<para>Returns: pointer to a newly created context object. Args: ctx: pointer to a context to copy (not secp256k1_context_static). In: prealloc: pointer to a rewritable contiguous block of memory of size at least secp256k1_context_preallocated_size(flags) bytes, as detailed above. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="152" column="19" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="152" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1adb5e8056701518fc6aac1738ff58fec1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
        <definition>secp256k1_context * secp256k1_context_clone</definition>
        <argsstring>(const secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_clone</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy a secp256k1 context object (into dynamically allocated memory).</para>
<para>This function uses malloc to allocate memory. It is guaranteed that malloc is called at most once for every call of this function. If you need to avoid dynamic memory allocation entirely, see the functions in <ref refid="secp256k1__preallocated_8h" kindref="compound">secp256k1_preallocated.h</ref>.</para>
<para>Cloning secp256k1_context_static is not possible, and should not be emulated by the caller (e.g., using memcpy). Create a new context instead.</para>
<para>Returns: pointer to a newly created context object. Args: ctx: pointer to a context to copy (not secp256k1_context_static). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="163" column="19" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="163" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a62b32b6a46f53b6aef01d3888496a79f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_preallocated_destroy</definition>
        <argsstring>(secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_preallocated_destroy</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroy a secp256k1 context object that has been created in caller-provided memory.</para>
<para>The context pointer may not be used afterwards.</para>
<para>The context to destroy must have been created using secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone. If the context has instead been created using secp256k1_context_create or secp256k1_context_clone, the behaviour is undefined. In that case, secp256k1_context_destroy must be used instead.</para>
<para>If required, it is the responsibility of the caller to deallocate the block of memory properly after this function returns, e.g., by calling free on the preallocated pointer given to secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone.</para>
<para>Args: ctx: pointer to a context to destroy, constructed using secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone (i.e., not secp256k1_context_static). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="176" column="6" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="176" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ac80c186f8ff22d87441240267a2c8100" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_destroy</definition>
        <argsstring>(secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_destroy</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroy a secp256k1 context object (created in dynamically allocated memory).</para>
<para>The context pointer may not be used afterwards.</para>
<para>The context to destroy must have been created using secp256k1_context_create or secp256k1_context_clone. If the context has instead been created using secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must be used instead.</para>
<para>Args: ctx: pointer to a context to destroy, constructed using secp256k1_context_create or secp256k1_context_clone (i.e., not secp256k1_context_static). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="187" column="6" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="187" bodyend="197"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a947ba36e0fe0bced91d4c9a7ef3b1f09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_set_illegal_callback</definition>
        <argsstring>(secp256k1_context *ctx, void(*fun)(const char *message, void *data), const void *data)</argsstring>
        <name>secp256k1_context_set_illegal_callback</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>void(*)(const char *message, void *data)</type>
          <declname>fun</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a callback function to be called when an illegal argument is passed to an API call. It will only trigger for violations that are mentioned explicitly in the header.</para>
<para>The philosophy is that these shouldn&apos;t be dealt with through a specific return value, as calling code should not have branches to deal with the case that this code itself is broken.</para>
<para>On the other hand, during debug stage, one would want to be informed about such mistakes, and the default (crashing) may be inadvisable. Should this callback return instead of crashing, the return value and output arguments of the API function call are undefined. Moreover, the same API call may trigger the callback again in this case.</para>
<para>When this function has not been called (or called with fun==NULL), then the default callback will be used. The library provides a default callback which writes the message to stderr and calls abort. This default callback can be replaced at link time if the preprocessor macro USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build has been configured with <ndash/>enable-external-default-callbacks. Then the following two symbols must be provided to link against:<itemizedlist>
<listitem><para>void secp256k1_default_illegal_callback_fn(const char *message, void *data);</para>
</listitem><listitem><para>void secp256k1_default_error_callback_fn(const char *message, void *data); The library may call a default callback even before a proper callback data pointer could have been set using secp256k1_context_set_illegal_callback or secp256k1_context_set_error_callback, e.g., when the creation of a context fails. In this case, the corresponding default callback will be called with the data pointer argument set to NULL.</para>
</listitem></itemizedlist>
</para>
<para>Args: ctx: pointer to a context object. In: fun: pointer to a function to call when an illegal argument is passed to the API, taking a message and an opaque pointer. (NULL restores the default callback.) data: the opaque pointer to pass to fun above, must be NULL for the default callback.</para>
<para>See also secp256k1_context_set_error_callback. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="199" column="6" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="199" bodyend="209"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a7384d60163d08fae0c5e8d1e1fdef60a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_set_error_callback</definition>
        <argsstring>(secp256k1_context *ctx, void(*fun)(const char *message, void *data), const void *data)</argsstring>
        <name>secp256k1_context_set_error_callback</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>void(*)(const char *message, void *data)</type>
          <declname>fun</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a callback function to be called when an internal consistency check fails.</para>
<para>The default callback writes an error message to stderr and calls abort to abort the program.</para>
<para>This can only trigger in case of a hardware failure, miscompilation, memory corruption, serious bug in the library, or other error that would result in undefined behaviour. It will not trigger due to mere incorrect usage of the API (see secp256k1_context_set_illegal_callback for that). After this callback returns, anything may happen, including crashing.</para>
<para>Args: ctx: pointer to a context object. In: fun: pointer to a function to call when an internal error occurs, taking a message and an opaque pointer (NULL restores the default callback, see secp256k1_context_set_illegal_callback for details). data: the opaque pointer to pass to fun above, must be NULL for the default callback.</para>
<para>See also secp256k1_context_set_illegal_callback. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="211" column="6" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="211" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a958e6e8bc49f2799beb84647067bd326" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="scratch_8h_1a13c17a5e196534c7df988c0aa6e5a6fa" kindref="member">secp256k1_scratch_space</ref> *</type>
        <definition>static secp256k1_scratch_space * secp256k1_scratch_space_create</definition>
        <argsstring>(const secp256k1_context *ctx, size_t max_size)</argsstring>
        <name>secp256k1_scratch_space_create</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="223" column="32" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="223" bodyend="226"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a4ad99eb716704a17d2d3f909e195853e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_scratch_space_destroy</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_scratch_space *scratch)</argsstring>
        <name>secp256k1_scratch_space_destroy</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="scratch_8h_1a13c17a5e196534c7df988c0aa6e5a6fa" kindref="member">secp256k1_scratch_space</ref> *</type>
          <declname>scratch</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="228" column="13" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="228" bodyend="231"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a84529c904ab01133aa747b5e747ac517" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_2src_2util_8h_1a7ddc487fd46aee88f21cabedb7268b1e" kindref="member">SECP256K1_INLINE</ref> void</type>
        <definition>static SECP256K1_INLINE void secp256k1_declassify</definition>
        <argsstring>(const secp256k1_context *ctx, const void *p, size_t len)</argsstring>
        <name>secp256k1_declassify</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="236" column="30" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="236" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a9966ec041e71010d1593ae2211ffb843" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_pubkey_load</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ge *ge, const secp256k1_pubkey *pubkey)</argsstring>
        <name>secp256k1_pubkey_load</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>ge</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="240" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="240" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aa061c9c5c861017bef990e5c4653e0f4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_pubkey_save</definition>
        <argsstring>(secp256k1_pubkey *pubkey, secp256k1_ge *ge)</argsstring>
        <name>secp256k1_pubkey_save</name>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>ge</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="246" column="13" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="246" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a4a359778a7faf65fba9d34db17642d20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_parse</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *input, size_t inputlen)</argsstring>
        <name>secp256k1_ec_pubkey_parse</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>inputlen</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a variable-length public key into the pubkey object.</para>
<para>Returns: 1 if the public key was fully valid. 0 if the public key could not be parsed or is invalid. Args: ctx: pointer to a context object. Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a parsed version of input. If not, its value is undefined. In: input: pointer to a serialized public key inputlen: length of the array pointed to by input</para>
<para>This function supports parsing compressed (33 bytes, header byte 0x02 or 0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header byte 0x06 or 0x07) format public keys. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="250" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="250" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_serialize</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey *pubkey, unsigned int flags)</argsstring>
        <name>secp256k1_ec_pubkey_serialize</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>outputlen</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize a pubkey object into a serialized byte sequence.</para>
<para>Returns: 1 always. Args: ctx: pointer to a context object. Out: output: pointer to a 65-byte (if compressed==0) or 33-byte (if compressed==1) byte array to place the serialized key in. In/Out: outputlen: pointer to an integer which is initially set to the size of output, and is overwritten with the written size. In: pubkey: pointer to a <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> containing an initialized public key. flags: SECP256K1_EC_COMPRESSED if serialization should be in compressed format, otherwise SECP256K1_EC_UNCOMPRESSED. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="268" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="268" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a88fd105847bf65f59db29fed819570c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_cmp</definition>
        <argsstring>(const secp256k1_context *ctx, const secp256k1_pubkey *pubkey0, const secp256k1_pubkey *pubkey1)</argsstring>
        <name>secp256k1_ec_pubkey_cmp</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey1</declname>
          <defname>pubkey0</defname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey2</declname>
          <defname>pubkey1</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compare two public keys using lexicographic (of compressed serialization) order</para>
<para>Returns: &lt;0 if the first public key is less than the second &gt;0 if the first public key is greater than the second 0 if the two public keys are equal Args: ctx: pointer to a context object In: pubkey1: first public key to compare pubkey2: second public key to compare </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="291" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="291" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aa40229a69b4535b493b78491173d2c3e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_ec_pubkey_sort_cmp</definition>
        <argsstring>(const void *pk1, const void *pk2, void *ctx)</argsstring>
        <name>secp256k1_ec_pubkey_sort_cmp</name>
        <param>
          <type>const void *</type>
          <declname>pk1</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>pk2</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="317" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="317" bodyend="321"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a611a9e8a6ccd0bf460611286a6def7f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_sort</definition>
        <argsstring>(const secp256k1_context *ctx, const secp256k1_pubkey **pubkeys, size_t n_pubkeys)</argsstring>
        <name>secp256k1_ec_pubkey_sort</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> **</type>
          <declname>pubkeys</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n_pubkeys</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sort public keys using lexicographic (of compressed serialization) order</para>
<para>Returns: 0 if the arguments are invalid. 1 otherwise.</para>
<para>Args: ctx: pointer to a context object In: pubkeys: array of pointers to pubkeys to sort n_pubkeys: number of elements in the pubkeys array </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="323" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="323" bodyend="343"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1af2027241c9dfc85fa5b6a3bb5fe41d18" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_ecdsa_signature_load</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_scalar *r, secp256k1_scalar *s, const secp256k1_ecdsa_signature *sig)</argsstring>
        <name>secp256k1_ecdsa_signature_load</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="345" column="13" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="345" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a94e522f94c4819bebf8e854952eb6a8f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_ecdsa_signature_save</definition>
        <argsstring>(secp256k1_ecdsa_signature *sig, const secp256k1_scalar *r, const secp256k1_scalar *s)</argsstring>
        <name>secp256k1_ecdsa_signature_save</name>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="359" column="13" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="359" bodyend="367"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a7bd08fb7f758494d5011849b6ca0ef13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_parse_der</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input, size_t inputlen)</argsstring>
        <name>secp256k1_ecdsa_signature_parse_der</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>inputlen</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a DER ECDSA signature.</para>
<para>Returns: 1 when the signature could be parsed, 0 otherwise. Args: ctx: pointer to a context object Out: sig: pointer to a signature object In: input: pointer to the signature to be parsed inputlen: the length of the array pointed to be input</para>
<para>This function will accept any valid DER encoded signature, even if the encoded numbers are out of range.</para>
<para>After the call, sig will always be initialized. If parsing failed or the encoded numbers are out of range, signature verification with it is guaranteed to fail for every message and public key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="369" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="369" bodyend="383"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a933083356e7171e174bc958b8233f758" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_parse_compact</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input64)</argsstring>
        <name>secp256k1_ecdsa_signature_parse_compact</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input64</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse an ECDSA signature in compact (64 bytes) format.</para>
<para>Returns: 1 when the signature could be parsed, 0 otherwise. Args: ctx: pointer to a context object Out: sig: pointer to a signature object In: input64: pointer to the 64-byte array to parse</para>
<para>The signature must consist of a 32-byte big endian R value, followed by a 32-byte big endian S value. If R or S fall outside of [0..order-1], the encoding is invalid. R and S with value 0 are allowed in the encoding.</para>
<para>After the call, sig will always be initialized. If parsing failed or R or S are zero, the resulting sig value is guaranteed to fail verification for any message and public key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="385" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="385" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a3f1fbd9cfe9bd6b6303bdd8f6c0687ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_serialize_der</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature *sig)</argsstring>
        <name>secp256k1_ecdsa_signature_serialize_der</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>outputlen</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize an ECDSA signature in DER format.</para>
<para>Returns: 1 if enough space was available to serialize, 0 otherwise Args: ctx: pointer to a context object Out: output: pointer to an array to store the DER serialization In/Out: outputlen: pointer to a length integer. Initially, this integer should be set to the length of output. After the call it will be set to the length of the serialization (even if 0 was returned). In: sig: pointer to an initialized signature object </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="406" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="406" bodyend="416"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ac369bdcc5f8d5ced129e84895bf739db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_serialize_compact</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output64, const secp256k1_ecdsa_signature *sig)</argsstring>
        <name>secp256k1_ecdsa_signature_serialize_compact</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output64</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize an ECDSA signature in compact (64 byte) format.</para>
<para>Returns: 1 Args: ctx: pointer to a context object Out: output64: pointer to a 64-byte array to store the compact serialization In: sig: pointer to an initialized signature object</para>
<para>See secp256k1_ecdsa_signature_parse_compact for details about the encoding. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="418" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="418" bodyend="429"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6ebd89d119f3da65e165947573ebd3ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_normalize</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout, const secp256k1_ecdsa_signature *sigin)</argsstring>
        <name>secp256k1_ecdsa_signature_normalize</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sigout</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sigin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a signature to a normalized lower-S form.</para>
<para>Returns: 1 if sigin was not normalized, 0 if it already was. Args: ctx: pointer to a context object Out: sigout: pointer to a signature to fill with the normalized form, or copy if the input was already normalized. (can be NULL if you&apos;re only interested in whether the input was already normalized). In: sigin: pointer to a signature to check/normalize (can be identical to sigout)</para>
<para>With ECDSA a third-party can forge a second distinct signature of the same message, given a single initial signature, but without knowing the key. This is done by negating the S value modulo the order of the curve, &apos;flipping&apos; the sign of the random point R which is not included in the signature.</para>
<para>Forgery of the same message isn&apos;t universally problematic, but in systems where message malleability or uniqueness of signatures is important this can cause issues. This forgery can be blocked by all verifiers forcing signers to use a normalized form.</para>
<para>The lower-S form reduces the size of signatures slightly on average when variable length encodings (such as DER) are used and is cheap to verify, making it a good choice. Security of always using lower-S is assured because anyone can trivially modify a signature after the fact to enforce this property anyway.</para>
<para>The lower S value is always between 0x1 and 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, inclusive.</para>
<para>No other forms of ECDSA malleability are known and none seem likely, but there is no formal proof that ECDSA, even with this additional restriction, is free of other malleability. Commonly used serialization schemes will also accept various non-unique encodings, so care should be taken when this property is required for an application.</para>
<para>The secp256k1_ecdsa_sign function will by default create signatures in the lower-S form, and secp256k1_ecdsa_verify will not accept others. In case signatures come from a system that cannot enforce this property, secp256k1_ecdsa_signature_normalize must be called before verification. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="431" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="431" bodyend="448"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1abd11af3da8d88984e87ec8f06fb0087a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_verify</definition>
        <argsstring>(const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msghash32, const secp256k1_pubkey *pubkey)</argsstring>
        <name>secp256k1_ecdsa_verify</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msghash32</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Verify an ECDSA signature.</para>
<para>Returns: 1: correct signature 0: incorrect or unparseable signature Args: ctx: pointer to a context object In: sig: the signature being verified. msghash32: the 32-byte message hash being verified. The verifier must make sure to apply a cryptographic hash function to the message by itself and not accept an msghash32 value directly. Otherwise, it would be easy to create a &quot;valid&quot; signature without knowledge of the secret key. See also <ulink url="https://bitcoin.stackexchange.com/a/81116/35586">https://bitcoin.stackexchange.com/a/81116/35586</ulink> for more background on this topic. pubkey: pointer to an initialized public key to verify with.</para>
<para>To avoid accepting malleable signatures, only ECDSA signatures in lower-S form are accepted.</para>
<para>If you need to accept ECDSA signatures from sources that do not obey this rule, apply secp256k1_ecdsa_signature_normalize to the signature prior to verification, but be aware that doing so results in malleable signatures.</para>
<para>For details, see the comments for that function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="450" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="450" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aa57a2897f891af44de368cccd683f6cc" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_2src_2util_8h_1a7ddc487fd46aee88f21cabedb7268b1e" kindref="member">SECP256K1_INLINE</ref> void</type>
        <definition>static SECP256K1_INLINE void buffer_append</definition>
        <argsstring>(unsigned char *buf, unsigned int *offset, const void *data, unsigned int len)</argsstring>
        <name>buffer_append</name>
        <param>
          <type>unsigned char *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>unsigned int *</type>
          <declname>offset</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="466" column="30" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="466" bodyend="469"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aaeed37b3a1d669fc6031755d37a5b2c4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int nonce_function_rfc6979</definition>
        <argsstring>(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter)</argsstring>
        <name>nonce_function_rfc6979</name>
        <param>
          <type>unsigned char *</type>
          <declname>nonce32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>key32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>algo16</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>counter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="471" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="471" bodyend="505"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1afe2f8280c1abb92f6201db4c46e8e7ad" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_ecdsa_sign_inner</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_scalar *r, secp256k1_scalar *s, int *recid, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *noncedata)</argsstring>
        <name>secp256k1_ecdsa_sign_inner</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>recid</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
          <declname>noncefp</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>noncedata</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="510" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="510" bodyend="564"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1af5ff5bb2cad5c58e90c653092648c63a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_sign</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *noncedata)</argsstring>
        <name>secp256k1_ecdsa_sign</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
          <defname>signature</defname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msghash32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
          <declname>noncefp</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>ndata</declname>
          <defname>noncedata</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create an ECDSA signature.</para>
<para>Returns: 1: signature created 0: the nonce generation function failed, or the secret key was invalid. Args: ctx: pointer to a context object (not secp256k1_context_static). Out: sig: pointer to an array where the signature will be placed. In: msghash32: the 32-byte message hash being signed. seckey: pointer to a 32-byte secret key. noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used. ndata: pointer to arbitrary data used by the nonce generation function (can be NULL). If it is non-NULL and secp256k1_nonce_function_default is used, then ndata must be a pointer to 32-bytes of additional data.</para>
<para>The created signature is always in lower-S form. See secp256k1_ecdsa_signature_normalize for more details. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="566" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="566" bodyend="578"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6015346bdaee22c65e5ebca71693d9b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_seckey_verify</definition>
        <argsstring>(const secp256k1_context *ctx, const unsigned char *seckey)</argsstring>
        <name>secp256k1_ec_seckey_verify</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Verify an elliptic curve secret key.</para>
<para>A secret key is valid if it is not 0 and less than the secp256k1 curve order when interpreted as an integer (most significant byte first). The probability of choosing a 32-byte string uniformly at random which is an invalid secret key is negligible. However, if it does happen it should be assumed that the randomness source is severely broken and there should be no retry.</para>
<para>Returns: 1: secret key is valid 0: secret key is invalid Args: ctx: pointer to a context object. In: seckey: pointer to a 32-byte secret key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="580" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="580" bodyend="589"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6eb48ce9f422bf6c197e7995748fefe4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_ec_pubkey_create_helper</definition>
        <argsstring>(const secp256k1_ecmult_gen_context *ecmult_gen_ctx, secp256k1_scalar *seckey_scalar, secp256k1_ge *p, const unsigned char *seckey)</argsstring>
        <name>secp256k1_ec_pubkey_create_helper</name>
        <param>
          <type>const <ref refid="structsecp256k1__ecmult__gen__context" kindref="compound">secp256k1_ecmult_gen_context</ref> *</type>
          <declname>ecmult_gen_ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>seckey_scalar</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="591" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="591" bodyend="602"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ac5806cffd3278e64f863027eaa8e1284" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_create</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey)</argsstring>
        <name>secp256k1_ec_pubkey_create</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compute the public key for a secret key.</para>
<para>Returns: 1: secret was valid, public key stores. 0: secret was invalid, try again. Args: ctx: pointer to a context object (not secp256k1_context_static). Out: pubkey: pointer to the created public key. In: seckey: pointer to a 32-byte secret key. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="604" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="604" bodyend="620"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a877d2d85643148d932a95868f5660e26" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_seckey_negate</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *seckey)</argsstring>
        <name>secp256k1_ec_seckey_negate</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Negates a secret key in place.</para>
<para>Returns: 0 if the given secret key is invalid according to secp256k1_ec_seckey_verify. 1 otherwise Args: ctx: pointer to a context object In/Out: seckey: pointer to the 32-byte secret key to be negated. If the secret key is invalid according to secp256k1_ec_seckey_verify, this function returns 0 and seckey will be set to some unspecified value. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="622" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="622" bodyend="635"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1afb380139bce6f6722e35add4c375debb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_negate</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey)</argsstring>
        <name>secp256k1_ec_pubkey_negate</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Negates a public key in place.</para>
<para>Returns: 1 always Args: ctx: pointer to a context object In/Out: pubkey: pointer to the public key to be negated. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="637" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="637" bodyend="650"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a40b447b575811a01694d3db5568f08ed" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_ec_seckey_tweak_add_helper</definition>
        <argsstring>(secp256k1_scalar *sec, const unsigned char *tweak32)</argsstring>
        <name>secp256k1_ec_seckey_tweak_add_helper</name>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>sec</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="653" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="653" bodyend="662"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a615cecca9de98d5f67333c76564ed6bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_seckey_tweak_add</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)</argsstring>
        <name>secp256k1_ec_seckey_tweak_add</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a secret key by adding tweak to it.</para>
<para>Returns: 0 if the arguments are invalid or the resulting secret key would be invalid (only when the tweak is the negation of the secret key). 1 otherwise. Args: ctx: pointer to a context object. In/Out: seckey: pointer to a 32-byte secret key. If the secret key is invalid according to secp256k1_ec_seckey_verify, this function returns 0. seckey will be set to some unspecified value if this function returns 0. In: tweak32: pointer to a 32-byte tweak, which must be valid according to secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly random 32-byte tweaks, the chance of being invalid is negligible (around 1 in 2^128). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="664" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="664" bodyend="678"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aa6c24f715716da4f8bece4704aaae2e1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_ec_pubkey_tweak_add_helper</definition>
        <argsstring>(secp256k1_ge *p, const unsigned char *tweak32)</argsstring>
        <name>secp256k1_ec_pubkey_tweak_add_helper</name>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="680" column="12" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="680" bodyend="685"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a37cae594daf23e05431eda1b20610f73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_tweak_add</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)</argsstring>
        <name>secp256k1_ec_pubkey_tweak_add</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a public key by adding tweak times the generator to it.</para>
<para>Returns: 0 if the arguments are invalid or the resulting public key would be invalid (only when the tweak is the negation of the corresponding secret key). 1 otherwise. Args: ctx: pointer to a context object. In/Out: pubkey: pointer to a public key object. pubkey will be set to an invalid value if this function returns 0. In: tweak32: pointer to a 32-byte tweak, which must be valid according to secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly random 32-byte tweaks, the chance of being invalid is negligible (around 1 in 2^128). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="687" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="687" bodyend="702"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a42895c7fad28c83d4373a40ba49323f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_seckey_tweak_mul</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak32)</argsstring>
        <name>secp256k1_ec_seckey_tweak_mul</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a secret key by multiplying it by a tweak.</para>
<para>Returns: 0 if the arguments are invalid. 1 otherwise. Args: ctx: pointer to a context object. In/Out: seckey: pointer to a 32-byte secret key. If the secret key is invalid according to secp256k1_ec_seckey_verify, this function returns 0. seckey will be set to some unspecified value if this function returns 0. In: tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to secp256k1_ec_seckey_verify, this function returns 0. For uniformly random 32-byte arrays the chance of being invalid is negligible (around 1 in 2^128). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="704" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="704" bodyend="722"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aef753193bf672b7c5e6156daa962bf55" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_tweak_mul</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak32)</argsstring>
        <name>secp256k1_ec_pubkey_tweak_mul</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a public key by multiplying it by a tweak value.</para>
<para>Returns: 0 if the arguments are invalid. 1 otherwise. Args: ctx: pointer to a context object. In/Out: pubkey: pointer to a public key object. pubkey will be set to an invalid value if this function returns 0. In: tweak32: pointer to a 32-byte tweak. If the tweak is invalid according to secp256k1_ec_seckey_verify, this function returns 0. For uniformly random 32-byte arrays the chance of being invalid is negligible (around 1 in 2^128). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="724" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="724" bodyend="745"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aba25f5f986a05a1cd06f5452b26ff868" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_context_randomize</definition>
        <argsstring>(secp256k1_context *ctx, const unsigned char *seed32)</argsstring>
        <name>secp256k1_context_randomize</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seed32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Randomizes the context to provide enhanced protection against side-channel leakage.</para>
<para>Returns: 1: randomization successful 0: error Args: ctx: pointer to a context object (not secp256k1_context_static). In: seed32: pointer to a 32-byte random seed (NULL resets to initial state).</para>
<para>While secp256k1 code is written and tested to be constant-time no matter what secret values are, it is possible that a compiler may output code which is not, and also that the CPU may not emit the same radio frequencies or draw the same amount of power for all values. Randomization of the context shields against side-channel observations which aim to exploit secret-dependent behaviour in certain computations which involve secret keys.</para>
<para>It is highly recommended to call this function on contexts returned from secp256k1_context_create or secp256k1_context_clone (or from the corresponding functions in <ref refid="secp256k1__preallocated_8h" kindref="compound">secp256k1_preallocated.h</ref>) before using these contexts to call API functions that perform computations involving secret keys, e.g., signing and public key generation. It is possible to call this function more than once on the same context, and doing so before every few computations involving secret keys is recommended as a defense-in-depth measure. Randomization of the static context secp256k1_context_static is not supported.</para>
<para>Currently, the random seed is mainly used for blinding multiplications of a secret scalar with the elliptic curve base point. Multiplications of this kind are performed by exactly those API functions which are documented to require a context that is not secp256k1_context_static. As a rule of thumb, these are all functions which take a secret key (or a keypair) as an input. A notable exception to that rule is the ECDH module, which relies on a different kind of elliptic curve point multiplication and thus does not benefit from enhanced protection against side-channel leakage currently. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="747" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="747" bodyend="755"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a92498665c38198fc1943e463c017c140" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_combine</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubnonce, const secp256k1_pubkey *const *pubnonces, size_t n)</argsstring>
        <name>secp256k1_ec_pubkey_combine</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>out</declname>
          <defname>pubnonce</defname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *const *</type>
          <declname>ins</declname>
          <defname>pubnonces</defname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a number of public keys together.</para>
<para>Returns: 1: the sum of the public keys is valid. 0: the sum of the public keys is not valid. Args: ctx: pointer to a context object. Out: out: pointer to a public key object for placing the resulting public key. In: ins: pointer to array of pointers to public keys. n: the number of public keys to add together (must be at least 1). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="757" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="757" bodyend="781"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a364d53929192054916b1207a22e701ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_tagged_sha256</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *hash32, const unsigned char *tag, size_t taglen, const unsigned char *msg, size_t msglen)</argsstring>
        <name>secp256k1_tagged_sha256</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>hash32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tag</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>taglen</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>msglen</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compute a tagged hash as defined in BIP-340.</para>
<para>This is useful for creating a message hash and achieving domain separation through an application-specific tag. This function returns SHA256(SHA256(tag)||SHA256(tag)||msg). Therefore, tagged hash implementations optimized for a specific tag can precompute the SHA256 state after hashing the tag hashes.</para>
<para>Returns: 1 always. Args: ctx: pointer to a context object Out: hash32: pointer to a 32-byte array to store the resulting hash In: tag: pointer to an array containing the tag taglen: length of the tag array msg: pointer to an array containing the message msglen: length of the message array </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/secp256k1.c" line="783" column="5" bodyfile="src/secp256k1/src/secp256k1.c" bodystart="783" bodyend="795"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/***********************************************************************</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2013-2015<sp/>Pieter<sp/>Wuille<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>Distributed<sp/>under<sp/>the<sp/>MIT<sp/>software<sp/>license,<sp/>see<sp/>the<sp/>accompanying<sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>file<sp/>COPYING<sp/>or<sp/>https://www.opensource.org/licenses/mit-license.php.*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>***********************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>This<sp/>is<sp/>a<sp/>C<sp/>project.<sp/>It<sp/>should<sp/>not<sp/>be<sp/>compiled<sp/>with<sp/>a<sp/>C++<sp/>compiler,</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*<sp/>and<sp/>we<sp/>error<sp/>out<sp/>if<sp/>we<sp/>detect<sp/>one.</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/>We<sp/>still<sp/>want<sp/>to<sp/>be<sp/>able<sp/>to<sp/>test<sp/>the<sp/>project<sp/>with<sp/>a<sp/>C++<sp/>compiler</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*<sp/>because<sp/>it<sp/>is<sp/>still<sp/>good<sp/>to<sp/>know<sp/>if<sp/>this<sp/>will<sp/>lead<sp/>to<sp/>real<sp/>trouble,<sp/>so</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*<sp/>there<sp/>is<sp/>a<sp/>possibility<sp/>to<sp/>override<sp/>the<sp/>check.<sp/>But<sp/>be<sp/>warned<sp/>that</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/>compiling<sp/>with<sp/>a<sp/>C++<sp/>compiler<sp/>is<sp/>not<sp/>supported.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__cplusplus)<sp/>&amp;&amp;<sp/>!defined(SECP256K1_CPLUSPLUS_TEST_OVERRIDE)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#error<sp/>Trying<sp/>to<sp/>compile<sp/>a<sp/>C<sp/>project<sp/>with<sp/>a<sp/>C++<sp/>compiler.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight></codeline>
<codeline lineno="18" refid="secp256k1_8c_1a1c49db739b76634ccbd0db4233e6cd8a" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SECP256K1_BUILD</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1_8h" kindref="compound">../include/secp256k1.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1__preallocated_8h" kindref="compound">../include/secp256k1_preallocated.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1_2src_2assumptions_8h" kindref="compound">assumptions.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="checkmem_8h" kindref="compound">checkmem.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1_2src_2util_8h" kindref="compound">util.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="field__impl_8h" kindref="compound">field_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="scalar__impl_8h" kindref="compound">scalar_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="group__impl_8h" kindref="compound">group_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__impl_8h" kindref="compound">ecmult_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__const__impl_8h" kindref="compound">ecmult_const_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__gen__impl_8h" kindref="compound">ecmult_gen_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecdsa__impl_8h" kindref="compound">ecdsa_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="eckey__impl_8h" kindref="compound">eckey_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="hash__impl_8h" kindref="compound">hash_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="int128__impl_8h" kindref="compound">int128_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="scratch__impl_8h" kindref="compound">scratch_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="selftest_8h" kindref="compound">selftest.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="hsort__impl_8h" kindref="compound">hsort_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>SECP256K1_NO_BUILD</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>error<sp/>&quot;secp256k1.h<sp/>processed<sp/>without<sp/>SECP256K1_BUILD<sp/>defined<sp/>while<sp/>building<sp/>secp256k1.c&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="45" refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ARG_CHECK(cond)<sp/>do<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="46"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(EXPECT(!(cond),<sp/>0))<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="47"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;ctx-&gt;illegal_callback,<sp/>#cond);<sp/>\</highlight></codeline>
<codeline lineno="48"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;<sp/>\</highlight></codeline>
<codeline lineno="49"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>}<sp/>\</highlight></codeline>
<codeline lineno="50"><highlight class="preprocessor">}<sp/>while(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight></codeline>
<codeline lineno="52" refid="secp256k1_8c_1afb9791f4e16ba663d93c7cd3259398f5" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ARG_CHECK_VOID(cond)<sp/>do<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="53"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(EXPECT(!(cond),<sp/>0))<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="54"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;ctx-&gt;illegal_callback,<sp/>#cond);<sp/>\</highlight></codeline>
<codeline lineno="55"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return;<sp/>\</highlight></codeline>
<codeline lineno="56"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>}<sp/>\</highlight></codeline>
<codeline lineno="57"><highlight class="preprocessor">}<sp/>while(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Note<sp/>that<sp/>whenever<sp/>you<sp/>change<sp/>the<sp/>context<sp/>struct,<sp/>you<sp/>must<sp/>also<sp/>change<sp/>the</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>*<sp/>context_eq<sp/>function.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61" refid="structsecp256k1__context__struct" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context_struct</ref><sp/>{</highlight></codeline>
<codeline lineno="62" refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ecmult__gen__context" kindref="compound">secp256k1_ecmult_gen_context</ref><sp/><ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>;</highlight></codeline>
<codeline lineno="63" refid="structsecp256k1__context__struct_1a6beeae94f98bec9d642011ba6f10cd7f" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref><sp/><ref refid="structsecp256k1__context__struct_1a6beeae94f98bec9d642011ba6f10cd7f" kindref="member">illegal_callback</ref>;</highlight></codeline>
<codeline lineno="64" refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref><sp/><ref refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" kindref="member">error_callback</ref>;</highlight></codeline>
<codeline lineno="65" refid="structsecp256k1__context__struct_1a3475a1a68da4bdbc44b39eb6fe8477ef" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct_1a3475a1a68da4bdbc44b39eb6fe8477ef" kindref="member">declassify</ref>;</highlight></codeline>
<codeline lineno="66"><highlight class="normal">};</highlight></codeline>
<codeline lineno="67"><highlight class="normal"></highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>secp256k1_context_static_<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>0<sp/>},</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>secp256k1_default_illegal_callback_fn,<sp/>0<sp/>},</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/>{<sp/>secp256k1_default_error_callback_fn,<sp/>0<sp/>},</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>0</highlight></codeline>
<codeline lineno="73"><highlight class="normal">};</highlight></codeline>
<codeline lineno="74" refid="secp256k1_8c_1aed87bf9186c495548cb8a99b3321a961" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a9254966d2821ffb7bf204fb31a6e0ad7" kindref="member">secp256k1_context_static</ref><sp/>=<sp/>&amp;secp256k1_context_static_;</highlight></codeline>
<codeline lineno="75" refid="secp256k1_8c_1a3f6dbb9269438555c89ff1e557d77fc9" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a3f6dbb9269438555c89ff1e557d77fc9" kindref="member">secp256k1_context_no_precomp</ref><sp/>=<sp/>&amp;secp256k1_context_static_;</highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Helper<sp/>function<sp/>that<sp/>determines<sp/>if<sp/>a<sp/>context<sp/>is<sp/>proper,<sp/>i.e.,<sp/>is<sp/>not<sp/>the<sp/>static<sp/>context<sp/>or<sp/>a<sp/>copy<sp/>thereof.</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>intended<sp/>for<sp/>&quot;context&quot;<sp/>functions<sp/>such<sp/>as<sp/>secp256k1_context_clone.<sp/>Functions<sp/>that<sp/>need<sp/>specific</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>*<sp/>features<sp/>of<sp/>a<sp/>context<sp/>should<sp/>still<sp/>check<sp/>for<sp/>these<sp/>features<sp/>directly.<sp/>For<sp/>example,<sp/>a<sp/>function<sp/>that<sp/>needs</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/>*<sp/>ecmult_gen<sp/>should<sp/>directly<sp/>check<sp/>for<sp/>the<sp/>existence<sp/>of<sp/>the<sp/>ecmult_gen<sp/>context.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_context_is_proper(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>);</highlight></codeline>
<codeline lineno="84"><highlight class="normal">}</highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight></codeline>
<codeline lineno="86" refid="secp256k1_8h_1a68175f71981ee9a883d24aabf90073e3" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1acf942e835990dd24ce71e93022c932c1" kindref="member">secp256k1_selftest</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_selftest_passes())<sp/>{</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;default_error_callback,<sp/></highlight><highlight class="stringliteral">&quot;self<sp/>test<sp/>failed&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="90"><highlight class="normal">}</highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight></codeline>
<codeline lineno="92" refid="secp256k1__preallocated_8h_1af6942b255e9715e64af285bcf0bafe4b" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a9f5faeec85b85bdaccd7ddda899dbfa2" kindref="member">secp256k1_context_preallocated_size</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>)<sp/>{</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>);</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>A<sp/>return<sp/>value<sp/>of<sp/>0<sp/>is<sp/>reserved<sp/>as<sp/>an<sp/>indicator<sp/>for<sp/>errors<sp/>when<sp/>we<sp/>call<sp/>this<sp/>function<sp/>internally.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>!=<sp/>0);</highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="minisketch_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>((<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" kindref="member">SECP256K1_FLAGS_TYPE_MASK</ref>)<sp/>!=<sp/><ref refid="secp256k1_8h_1ad96f13de52c4c94f5d11d53fd04c529f" kindref="member">SECP256K1_FLAGS_TYPE_CONTEXT</ref>,<sp/>0))<sp/>{</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;default_illegal_callback,</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Invalid<sp/>flags&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="minisketch_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>(!<ref refid="checkmem_8h_1afed00e3ff908581990ba1b911932315e" kindref="member">SECP256K1_CHECKMEM_RUNNING</ref>()<sp/>&amp;&amp;<sp/>(<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1a459a70e8b474694c71f238f91a0d7921" kindref="member">SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY</ref>),<sp/>0))<sp/>{</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;default_illegal_callback,</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Declassify<sp/>flag<sp/>requires<sp/>running<sp/>with<sp/>memory<sp/>checking&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="110"><highlight class="normal">}</highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112" refid="secp256k1__preallocated_8h_1a7bb1e7240fc9ffabe07e565603a4dfee" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a5665930bf606d6a7262cebc936eda949" kindref="member">secp256k1_context_preallocated_clone_size</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_context_is_proper(ctx));</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>);</highlight></codeline>
<codeline lineno="116"><highlight class="normal">}</highlight></codeline>
<codeline lineno="117"><highlight class="normal"></highlight></codeline>
<codeline lineno="118" refid="secp256k1__preallocated_8h_1ae5490f09b147364c44bf1129b624405f" refkind="member"><highlight class="normal"><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="secp256k1_8c_1af4866e9619f06679358fe6338ed42cd0" kindref="member">secp256k1_context_preallocated_create</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>prealloc,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>)<sp/>{</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prealloc_size;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1acf942e835990dd24ce71e93022c932c1" kindref="member">secp256k1_selftest</ref>();</highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>prealloc_size<sp/>=<sp/><ref refid="secp256k1_8c_1a9f5faeec85b85bdaccd7ddda899dbfa2" kindref="member">secp256k1_context_preallocated_size</ref>(<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>);</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(prealloc_size<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(prealloc<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*)prealloc;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>-&gt;illegal_callback<sp/>=<sp/>default_illegal_callback;</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>-&gt;error_callback<sp/>=<sp/>default_error_callback;</highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Flags<sp/>have<sp/>been<sp/>checked<sp/>by<sp/>secp256k1_context_preallocated_size.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>((<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" kindref="member">SECP256K1_FLAGS_TYPE_MASK</ref>)<sp/>==<sp/><ref refid="secp256k1_8h_1ad96f13de52c4c94f5d11d53fd04c529f" kindref="member">SECP256K1_FLAGS_TYPE_CONTEXT</ref>);</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_context_build(&amp;<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>-&gt;ecmult_gen_ctx);</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>-&gt;declassify<sp/>=<sp/>!!(<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1a459a70e8b474694c71f238f91a0d7921" kindref="member">SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY</ref>);</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="139"><highlight class="normal">}</highlight></codeline>
<codeline lineno="140"><highlight class="normal"></highlight></codeline>
<codeline lineno="141" refid="secp256k1_8h_1a3aaa9fcc3ab67bc8f841779a049069c5" refkind="member"><highlight class="normal"><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="secp256k1_8c_1a861ce6fc7ee5e9fc346a5fee7093adb1" kindref="member">secp256k1_context_create</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>)<sp/>{</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>prealloc_size<sp/>=<sp/><ref refid="secp256k1_8c_1a9f5faeec85b85bdaccd7ddda899dbfa2" kindref="member">secp256k1_context_preallocated_size</ref>(<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx<sp/>=<sp/>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*)checked_malloc(&amp;default_error_callback,<sp/>prealloc_size);</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="minisketch_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>(<ref refid="secp256k1_8c_1af4866e9619f06679358fe6338ed42cd0" kindref="member">secp256k1_context_preallocated_create</ref>(ctx,<sp/><ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>)<sp/>==<sp/>NULL,<sp/>0))<sp/>{</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(ctx);</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ctx;</highlight></codeline>
<codeline lineno="150"><highlight class="normal">}</highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight></codeline>
<codeline lineno="152" refid="secp256k1__preallocated_8h_1afbe046709184f275b585435091ddb5c3" refkind="member"><highlight class="normal"><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="secp256k1_8c_1a2a2e39dbcd6d55d8e6faaad194261a71" kindref="member">secp256k1_context_preallocated_clone</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>prealloc)<sp/>{</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(prealloc<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_context_is_proper(ctx));</highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*)prealloc;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/>*<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>*ctx;</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="161"><highlight class="normal">}</highlight></codeline>
<codeline lineno="162"><highlight class="normal"></highlight></codeline>
<codeline lineno="163" refid="secp256k1_8h_1aa999f2e6f81210fc8970af81cf75bef8" refkind="member"><highlight class="normal"><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="secp256k1_8c_1adb5e8056701518fc6aac1738ff58fec1" kindref="member">secp256k1_context_clone</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>prealloc_size;</highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_context_is_proper(ctx));</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>prealloc_size<sp/>=<sp/><ref refid="secp256k1_8c_1a5665930bf606d6a7262cebc936eda949" kindref="member">secp256k1_context_preallocated_clone_size</ref>(ctx);</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*)checked_malloc(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" kindref="member">error_callback</ref>,<sp/>prealloc_size);</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/><ref refid="secp256k1_8c_1a2a2e39dbcd6d55d8e6faaad194261a71" kindref="member">secp256k1_context_preallocated_clone</ref>(ctx,<sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="174"><highlight class="normal">}</highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight></codeline>
<codeline lineno="176" refid="secp256k1__preallocated_8h_1ae51bf3c2ed533998dab9c7b2ce180664" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a62b32b6a46f53b6aef01d3888496a79f" kindref="member">secp256k1_context_preallocated_destroy</ref>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1afb9791f4e16ba663d93c7cd3259398f5" kindref="member">ARG_CHECK_VOID</ref>(ctx<sp/>==<sp/>NULL<sp/>||<sp/>secp256k1_context_is_proper(ctx));</highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Defined<sp/>as<sp/>noop<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ctx<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="183"><highlight class="normal"></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_context_clear(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>);</highlight></codeline>
<codeline lineno="185"><highlight class="normal">}</highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight></codeline>
<codeline lineno="187" refid="secp256k1_8h_1a026db914e3723531825ecf25a0cbd699" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ac80c186f8ff22d87441240267a2c8100" kindref="member">secp256k1_context_destroy</ref>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1afb9791f4e16ba663d93c7cd3259398f5" kindref="member">ARG_CHECK_VOID</ref>(ctx<sp/>==<sp/>NULL<sp/>||<sp/>secp256k1_context_is_proper(ctx));</highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Defined<sp/>as<sp/>noop<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ctx<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="194"><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a62b32b6a46f53b6aef01d3888496a79f" kindref="member">secp256k1_context_preallocated_destroy</ref>(ctx);</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/>free(ctx);</highlight></codeline>
<codeline lineno="197"><highlight class="normal">}</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight></codeline>
<codeline lineno="199" refid="secp256k1_8h_1a3ec29bece9974f9535337eb7d91b351c" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a947ba36e0fe0bced91d4c9a7ef3b1f09" kindref="member">secp256k1_context_set_illegal_callback</ref>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(*fun)(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>message,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data),<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data)<sp/>{</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>compare<sp/>pointers<sp/>instead<sp/>of<sp/>checking<sp/>secp256k1_context_is_proper()<sp/>here</highlight></codeline>
<codeline lineno="201"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>because<sp/>setting<sp/>callbacks<sp/>is<sp/>allowed<sp/>on<sp/>*copies*<sp/>of<sp/>the<sp/>static<sp/>context:</highlight></codeline>
<codeline lineno="202"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it&apos;s<sp/>harmless<sp/>and<sp/>makes<sp/>testing<sp/>easier.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1afb9791f4e16ba663d93c7cd3259398f5" kindref="member">ARG_CHECK_VOID</ref>(ctx<sp/>!=<sp/><ref refid="secp256k1_8h_1a9254966d2821ffb7bf204fb31a6e0ad7" kindref="member">secp256k1_context_static</ref>);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fun<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fun<sp/>=<sp/>secp256k1_default_illegal_callback_fn;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1a6beeae94f98bec9d642011ba6f10cd7f" kindref="member">illegal_callback</ref>.<ref refid="structsecp256k1__callback_1ac59100084f88918a6e29f3aab761dc1e" kindref="member">fn</ref><sp/>=<sp/>fun;</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1a6beeae94f98bec9d642011ba6f10cd7f" kindref="member">illegal_callback</ref>.<ref refid="structsecp256k1__callback_1a0d49d74db4c035719c3867723cf7e779" kindref="member">data</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="209"><highlight class="normal">}</highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="211" refid="secp256k1_8h_1a35106efb325f03468bcf5faa524c1cc4" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a7384d60163d08fae0c5e8d1e1fdef60a" kindref="member">secp256k1_context_set_error_callback</ref>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(*fun)(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>message,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data),<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data)<sp/>{</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>compare<sp/>pointers<sp/>instead<sp/>of<sp/>checking<sp/>secp256k1_context_is_proper()<sp/>here</highlight></codeline>
<codeline lineno="213"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>because<sp/>setting<sp/>callbacks<sp/>is<sp/>allowed<sp/>on<sp/>*copies*<sp/>of<sp/>the<sp/>static<sp/>context:</highlight></codeline>
<codeline lineno="214"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>it&apos;s<sp/>harmless<sp/>and<sp/>makes<sp/>testing<sp/>easier.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1afb9791f4e16ba663d93c7cd3259398f5" kindref="member">ARG_CHECK_VOID</ref>(ctx<sp/>!=<sp/><ref refid="secp256k1_8h_1a9254966d2821ffb7bf204fb31a6e0ad7" kindref="member">secp256k1_context_static</ref>);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fun<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fun<sp/>=<sp/>secp256k1_default_error_callback_fn;</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" kindref="member">error_callback</ref>.<ref refid="structsecp256k1__callback_1ac59100084f88918a6e29f3aab761dc1e" kindref="member">fn</ref><sp/>=<sp/>fun;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" kindref="member">error_callback</ref>.<ref refid="structsecp256k1__callback_1a0d49d74db4c035719c3867723cf7e779" kindref="member">data</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="221"><highlight class="normal">}</highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="scratch_8h_1a13c17a5e196534c7df988c0aa6e5a6fa" kindref="member">secp256k1_scratch_space</ref>*<sp/>secp256k1_scratch_space_create(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>max_size)<sp/>{</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secp256k1_scratch_create(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" kindref="member">error_callback</ref>,<sp/>max_size);</highlight></codeline>
<codeline lineno="226"><highlight class="normal">}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_scratch_space_destroy(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*ctx,<sp/><ref refid="scratch_8h_1a13c17a5e196534c7df988c0aa6e5a6fa" kindref="member">secp256k1_scratch_space</ref>*<sp/>scratch)<sp/>{</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scratch_destroy(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1af19d0afeed943bdece4311571cf7aaa5" kindref="member">error_callback</ref>,<sp/>scratch);</highlight></codeline>
<codeline lineno="231"><highlight class="normal">}</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Mark<sp/>memory<sp/>as<sp/>no-longer-secret<sp/>for<sp/>the<sp/>purpose<sp/>of<sp/>analysing<sp/>constant-time<sp/>behaviour</highlight></codeline>
<codeline lineno="234"><highlight class="comment"><sp/>*<sp/><sp/>of<sp/>the<sp/>software.</highlight></codeline>
<codeline lineno="235"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="secp256k1_2src_2util_8h_1a7ddc487fd46aee88f21cabedb7268b1e" kindref="member">SECP256K1_INLINE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_declassify(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*p,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len)<sp/>{</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="minisketch_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>(ctx-&gt;<ref refid="structsecp256k1__context__struct_1a3475a1a68da4bdbc44b39eb6fe8477ef" kindref="member">declassify</ref>,<sp/>0))<sp/><ref refid="checkmem_8h_1a9921cd547989e6389f105e26b89397a6" kindref="member">SECP256K1_CHECKMEM_DEFINE</ref>(p,<sp/>len);</highlight></codeline>
<codeline lineno="238"><highlight class="normal">}</highlight></codeline>
<codeline lineno="239"><highlight class="normal"></highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_pubkey_load(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref>*<sp/>ge,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey)<sp/>{</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_from_bytes(ge,<sp/>pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>);</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(!<ref refid="field_8h_1aa1804f8a6c059e491cfb95452103ce86" kindref="member">secp256k1_fe_is_zero</ref>(&amp;ge-&gt;<ref refid="structsecp256k1__ge_1af089d748d95dc12c1185adae8e11972d" kindref="member">x</ref>));</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="244"><highlight class="normal">}</highlight></codeline>
<codeline lineno="245"><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_pubkey_save(<ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey,<sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref>*<sp/>ge)<sp/>{</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_to_bytes(pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>,<sp/>ge);</highlight></codeline>
<codeline lineno="248"><highlight class="normal">}</highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight></codeline>
<codeline lineno="250" refid="secp256k1_8h_1a4e5dc8952c9a7e791376505ef2023ca1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a4a359778a7faf65fba9d34db17642d20" kindref="member">secp256k1_ec_pubkey_parse</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>inputlen)<sp/>{</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Q;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(input<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_eckey_pubkey_parse(&amp;Q,<sp/>input,<sp/>inputlen))<sp/>{</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_ge_is_in_correct_subgroup(&amp;Q))<sp/>{</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;Q);</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_clear(&amp;Q);</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="266"><highlight class="normal">}</highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight></codeline>
<codeline lineno="268" refid="secp256k1_8h_1a34977bf00322e510e881160c421836d7" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" kindref="member">secp256k1_ec_pubkey_serialize</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*outputlen,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref>)<sp/>{</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Q;</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len;</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(outputlen<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(*outputlen<sp/>&gt;=<sp/>((<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1ac26f7c3f665e6422a651d2eb910f1a03" kindref="member">SECP256K1_FLAGS_BIT_COMPRESSION</ref>)<sp/>?<sp/>33u<sp/>:<sp/>65u));</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/>len<sp/>=<sp/>*outputlen;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>*outputlen<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(output<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(output,<sp/>0,<sp/>len);</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>((<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" kindref="member">SECP256K1_FLAGS_TYPE_MASK</ref>)<sp/>==<sp/><ref refid="secp256k1_8h_1af8d4e9ca93634062735b7f998ef9f68a" kindref="member">SECP256K1_FLAGS_TYPE_COMPRESSION</ref>);</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_pubkey_load(ctx,<sp/>&amp;Q,<sp/>pubkey))<sp/>{</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_eckey_pubkey_serialize(&amp;Q,<sp/>output,<sp/>&amp;len,<sp/>!!(<ref refid="bitcoin-tx_8cpp_1ac8bf36fe0577cba66bccda3a6f7e80a4" kindref="member">flags</ref><sp/>&amp;<sp/><ref refid="secp256k1_8h_1ac26f7c3f665e6422a651d2eb910f1a03" kindref="member">SECP256K1_FLAGS_BIT_COMPRESSION</ref>));</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*outputlen<sp/>=<sp/>len;</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="289"><highlight class="normal">}</highlight></codeline>
<codeline lineno="290"><highlight class="normal"></highlight></codeline>
<codeline lineno="291" refid="secp256k1_8h_1a3607442049a415a5f649f53b089e766a" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a88fd105847bf65f59db29fed819570c6" kindref="member">secp256k1_ec_pubkey_cmp</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey0,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey1)<sp/>{</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>out[2][33];</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pk[2];</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/>pk[0]<sp/>=<sp/>pubkey0;<sp/>pk[1]<sp/>=<sp/>pubkey1;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>2;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>out_size<sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(out[i]);</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>If<sp/>the<sp/>public<sp/>key<sp/>is<sp/>NULL<sp/>or<sp/>invalid,<sp/>ec_pubkey_serialize<sp/>will<sp/>call</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>illegal_callback<sp/>and<sp/>return<sp/>0.<sp/>In<sp/>that<sp/>case<sp/>we<sp/>will<sp/>serialize<sp/>the</highlight></codeline>
<codeline lineno="302"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>key<sp/>as<sp/>all<sp/>zeros<sp/>which<sp/>is<sp/>less<sp/>than<sp/>any<sp/>valid<sp/>public<sp/>key.<sp/>This</highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>results<sp/>in<sp/>consistent<sp/>comparisons<sp/>even<sp/>if<sp/>NULL<sp/>or<sp/>invalid<sp/>pubkeys<sp/>are</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>involved<sp/>and<sp/>prevents<sp/>edge<sp/>cases<sp/>such<sp/>as<sp/>sorting<sp/>algorithms<sp/>that<sp/>use</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>this<sp/>function<sp/>and<sp/>do<sp/>not<sp/>terminate<sp/>as<sp/>a<sp/>result.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" kindref="member">secp256k1_ec_pubkey_serialize</ref>(ctx,<sp/>out[i],<sp/>&amp;out_size,<sp/>pk[i],<sp/><ref refid="secp256k1_8h_1a7b8f642c65e8b5c81fa4421b7c42ab57" kindref="member">SECP256K1_EC_COMPRESSED</ref>))<sp/>{</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Note<sp/>that<sp/>ec_pubkey_serialize<sp/>should<sp/>already<sp/>set<sp/>the<sp/>output<sp/>to</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>zero<sp/>in<sp/>that<sp/>case,<sp/>but<sp/>it&apos;s<sp/>not<sp/>guaranteed<sp/>by<sp/>the<sp/>API,<sp/>we<sp/>can&apos;t</highlight></codeline>
<codeline lineno="309"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>test<sp/>it<sp/>and<sp/>writing<sp/>a<sp/>VERIFY_CHECK<sp/>is<sp/>more<sp/>complex<sp/>than</highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>explicitly<sp/>memsetting<sp/>(again).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(out[i],<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(out[i]));</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secp256k1_memcmp_var(out[0],<sp/>out[1],<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(out[0]));</highlight></codeline>
<codeline lineno="315"><highlight class="normal">}</highlight></codeline>
<codeline lineno="316"><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_ec_pubkey_sort_cmp(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pk1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>pk2,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*ctx)<sp/>{</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a88fd105847bf65f59db29fed819570c6" kindref="member">secp256k1_ec_pubkey_cmp</ref>((<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*)ctx,</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*(<ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>**)pk1,</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*(<ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>**)pk2);</highlight></codeline>
<codeline lineno="321"><highlight class="normal">}</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight></codeline>
<codeline lineno="323" refid="secp256k1_8h_1ace5e4824419ef5e099f920eaa8e7cafb" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a611a9e8a6ccd0bf460611286a6def7f6" kindref="member">secp256k1_ec_pubkey_sort</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>**pubkeys,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n_pubkeys)<sp/>{</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkeys<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="326"><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Suppress<sp/>wrong<sp/>warning<sp/>(fixed<sp/>in<sp/>MSVC<sp/>19.33)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="328"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>defined(_MSC_VER)<sp/>&amp;&amp;<sp/>(_MSC_VER<sp/>&lt;<sp/>1933)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#pragma<sp/>warning(push)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#pragma<sp/>warning(disable:<sp/>4090)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="331"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Casting<sp/>away<sp/>const<sp/>is<sp/>fine<sp/>because<sp/>neither<sp/>secp256k1_hsort<sp/>nor</highlight></codeline>
<codeline lineno="334"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>secp256k1_ec_pubkey_sort_cmp<sp/>modify<sp/>the<sp/>data<sp/>pointed<sp/>to<sp/>by<sp/>the<sp/>cmp_data</highlight></codeline>
<codeline lineno="335"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>argument.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_hsort(pubkeys,<sp/>n_pubkeys,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkeys),<sp/>secp256k1_ec_pubkey_sort_cmp,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ctx);</highlight></codeline>
<codeline lineno="337"><highlight class="normal"></highlight></codeline>
<codeline lineno="338"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#if<sp/>defined(_MSC_VER)<sp/>&amp;&amp;<sp/>(_MSC_VER<sp/>&lt;<sp/>1933)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="339"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#pragma<sp/>warning(pop)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="343"><highlight class="normal">}</highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_signature_load(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>r,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>s,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig)<sp/>{</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>)<sp/>==<sp/>32)<sp/>{</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>When<sp/>the<sp/>secp256k1_scalar<sp/>type<sp/>is<sp/>exactly<sp/>32<sp/>byte,<sp/>use<sp/>its</highlight></codeline>
<codeline lineno="349"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>representation<sp/>inside<sp/>secp256k1_ecdsa_signature,<sp/>as<sp/>conversion<sp/>is<sp/>very<sp/>fast.</highlight></codeline>
<codeline lineno="350"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>Note<sp/>that<sp/>secp256k1_ecdsa_signature_save<sp/>must<sp/>use<sp/>the<sp/>same<sp/>representation.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(r,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[0],<sp/>32);</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(s,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[32],<sp/>32);</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(r,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[0],<sp/>NULL);</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(s,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[32],<sp/>NULL);</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="357"><highlight class="normal">}</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_signature_save(<ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>r,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>s)<sp/>{</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>)<sp/>==<sp/>32)<sp/>{</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[0],<sp/>r,<sp/>32);</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[32],<sp/>s,<sp/>32);</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[0],<sp/>r);</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a8a8dd994e57fbe5afc89ea8619498a8a" kindref="member">data</ref>[32],<sp/>s);</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="367"><highlight class="normal">}</highlight></codeline>
<codeline lineno="368"><highlight class="normal"></highlight></codeline>
<codeline lineno="369" refid="secp256k1_8h_1a57d390dd5baa54855b0cb20628034b90" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a7bd08fb7f758494d5011849b6ca0ef13" kindref="member">secp256k1_ecdsa_signature_parse_der</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>inputlen)<sp/>{</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(input<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="375"><highlight class="normal"></highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_ecdsa_sig_parse(&amp;r,<sp/>&amp;s,<sp/>input,<sp/>inputlen))<sp/>{</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(sig,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(sig,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*sig));</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="383"><highlight class="normal">}</highlight></codeline>
<codeline lineno="384"><highlight class="normal"></highlight></codeline>
<codeline lineno="385" refid="secp256k1_8h_1a2aff2802eca3d15ec54298e879579897" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a933083356e7171e174bc958b8233f758" kindref="member">secp256k1_ecdsa_signature_parse_compact</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input64)<sp/>{</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="389"><highlight class="normal"></highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(input64<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="393"><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;r,<sp/>&amp;input64[0],<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>&amp;=<sp/>!overflow;</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;s,<sp/>&amp;input64[32],<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>&amp;=<sp/>!overflow;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(sig,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(sig,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*sig));</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="404"><highlight class="normal">}</highlight></codeline>
<codeline lineno="405"><highlight class="normal"></highlight></codeline>
<codeline lineno="406" refid="secp256k1_8h_1ac07809ca872ec967ab4d3b1a95eafe0b" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a3f1fbd9cfe9bd6b6303bdd8f6c0687ba" kindref="member">secp256k1_ecdsa_signature_serialize_der</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*outputlen,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig)<sp/>{</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(output<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(outputlen<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="413"><highlight class="normal"></highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sig);</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_sig_serialize(output,<sp/>outputlen,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="416"><highlight class="normal">}</highlight></codeline>
<codeline lineno="417"><highlight class="normal"></highlight></codeline>
<codeline lineno="418" refid="secp256k1_8h_1af8571ca8dcfb7f892519b337504dc700" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ac369bdcc5f8d5ced129e84895bf739db" kindref="member">secp256k1_ecdsa_signature_serialize_compact</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output64,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig)<sp/>{</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="420"><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(output64<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="424"><highlight class="normal"></highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sig);</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;output64[0],<sp/>&amp;r);</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;output64[32],<sp/>&amp;s);</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="429"><highlight class="normal">}</highlight></codeline>
<codeline lineno="430"><highlight class="normal"></highlight></codeline>
<codeline lineno="431" refid="secp256k1_8h_1a93ec36a19229f08acc5ff1ca613ab3a1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a6ebd89d119f3da65e165947573ebd3ce" kindref="member">secp256k1_ecdsa_signature_normalize</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sigout,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sigin)<sp/>{</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="434"><highlight class="normal"></highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sigin<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sigin);</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_scalar_is_high(&amp;s);</highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sigout<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_negate(&amp;s,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(sigout,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="446"><highlight class="normal"></highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="448"><highlight class="normal">}</highlight></codeline>
<codeline lineno="449"><highlight class="normal"></highlight></codeline>
<codeline lineno="450" refid="secp256k1_8h_1a7dd6acb7ef7100a6aebff91ecb7ede30" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1abd11af3da8d88984e87ec8f06fb0087a" kindref="member">secp256k1_ecdsa_verify</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msghash32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey)<sp/>{</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>q;</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/><ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2ca6f8f57715090da2632453988d9a1501b" kindref="member">m</ref>;</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(msghash32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="458"><highlight class="normal"></highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2ca6f8f57715090da2632453988d9a1501b" kindref="member">m</ref>,<sp/>msghash32,<sp/>NULL);</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sig);</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(!secp256k1_scalar_is_high(&amp;s)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;q,<sp/>pubkey)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_sig_verify(&amp;r,<sp/>&amp;s,<sp/>&amp;q,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2ca6f8f57715090da2632453988d9a1501b" kindref="member">m</ref>));</highlight></codeline>
<codeline lineno="464"><highlight class="normal">}</highlight></codeline>
<codeline lineno="465"><highlight class="normal"></highlight></codeline>
<codeline lineno="466"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="secp256k1_2src_2util_8h_1a7ddc487fd46aee88f21cabedb7268b1e" kindref="member">SECP256K1_INLINE</ref><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>buffer_append(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*buf,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*offset,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*data,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>len)<sp/>{</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(buf<sp/>+<sp/>*offset,<sp/>data,<sp/>len);</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>*offset<sp/>+=<sp/>len;</highlight></codeline>
<codeline lineno="469"><highlight class="normal">}</highlight></codeline>
<codeline lineno="470"><highlight class="normal"></highlight></codeline>
<codeline lineno="471"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nonce_function_rfc6979(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*nonce32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*key32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*algo16,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*data,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>counter)<sp/>{</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>keydata[112];</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><ref refid="structsecp256k1__rfc6979__hmac__sha256" kindref="compound">secp256k1_rfc6979_hmac_sha256</ref><sp/>rng;</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/><ref refid="namespacetests__wycheproof__generate__ecdsa_1a10a0f35066079abd150539d0d13dbf3e" kindref="member">msg</ref>;</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>msgmod32[32];</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;msg,<sp/>msg32,<sp/>NULL);</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/>secp256k1_scalar_get_b32(msgmod32,<sp/>&amp;msg);</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>feed<sp/>a<sp/>byte<sp/>array<sp/>to<sp/>the<sp/>PRNG<sp/>as<sp/>input,<sp/>consisting<sp/>of:</highlight></codeline>
<codeline lineno="481"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>-<sp/>the<sp/>private<sp/>key<sp/>(32<sp/>bytes)<sp/>and<sp/>reduced<sp/>message<sp/>(32<sp/>bytes),<sp/>see<sp/>RFC<sp/>6979<sp/>3.2d.</highlight></codeline>
<codeline lineno="482"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>-<sp/>optionally<sp/>32<sp/>extra<sp/>bytes<sp/>of<sp/>data,<sp/>see<sp/>RFC<sp/>6979<sp/>3.6<sp/>Additional<sp/>Data.</highlight></codeline>
<codeline lineno="483"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>-<sp/>optionally<sp/>16<sp/>extra<sp/>bytes<sp/>with<sp/>the<sp/>algorithm<sp/>name.</highlight></codeline>
<codeline lineno="484"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Because<sp/>the<sp/>arguments<sp/>have<sp/>distinct<sp/>fixed<sp/>lengths<sp/>it<sp/>is<sp/>not<sp/>possible<sp/>for</highlight></codeline>
<codeline lineno="485"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/>different<sp/>argument<sp/>mixtures<sp/>to<sp/>emulate<sp/>each<sp/>other<sp/>and<sp/>result<sp/>in<sp/>the<sp/>same</highlight></codeline>
<codeline lineno="486"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/>nonces.</highlight></codeline>
<codeline lineno="487"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/>buffer_append(keydata,<sp/>&amp;offset,<sp/>key32,<sp/>32);</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/>buffer_append(keydata,<sp/>&amp;offset,<sp/>msgmod32,<sp/>32);</highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(data<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>buffer_append(keydata,<sp/>&amp;offset,<sp/>data,<sp/>32);</highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(algo16<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>buffer_append(keydata,<sp/>&amp;offset,<sp/>algo16,<sp/>16);</highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_initialize(&amp;rng,<sp/>keydata,<sp/>offset);</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;=<sp/>counter;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_generate(&amp;rng,<sp/>nonce32,<sp/>32);</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_finalize(&amp;rng);</highlight></codeline>
<codeline lineno="501"><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/>secp256k1_memclear_explicit(keydata,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(keydata));</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_clear(&amp;rng);</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="505"><highlight class="normal">}</highlight></codeline>
<codeline lineno="506"><highlight class="normal"></highlight></codeline>
<codeline lineno="507" refid="secp256k1_8c_1a2ac052a733aac60ef5c19f1f79e3c1dd" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/><ref refid="secp256k1_8h_1ac03ab067f194eb561175a6b522def2d8" kindref="member">secp256k1_nonce_function_rfc6979</ref><sp/>=<sp/>nonce_function_rfc6979;</highlight></codeline>
<codeline lineno="508" refid="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/><ref refid="secp256k1_8h_1a22f44df7786a1be5ad93aadfed75b932" kindref="member">secp256k1_nonce_function_default</ref><sp/>=<sp/>nonce_function_rfc6979;</highlight></codeline>
<codeline lineno="509"><highlight class="normal"></highlight></codeline>
<codeline lineno="510"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_sign_inner(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>r,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>s,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>recid,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/>noncefp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>noncedata)<sp/>{</highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec,<sp/>non,<sp/>msg;</highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>is_sec_valid;</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>nonce32[32];</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Default<sp/>initialization<sp/>here<sp/>is<sp/>important<sp/>so<sp/>we<sp/>won&apos;t<sp/>pass<sp/>uninit<sp/>values<sp/>to<sp/>the<sp/>cmov<sp/>in<sp/>the<sp/>end<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="517"><highlight class="normal"><sp/><sp/><sp/><sp/>*r<sp/>=<sp/>secp256k1_scalar_zero;</highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/>*s<sp/>=<sp/>secp256k1_scalar_zero;</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(recid)<sp/>{</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*recid<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(noncefp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>noncefp<sp/>=<sp/><ref refid="secp256k1_8h_1a22f44df7786a1be5ad93aadfed75b932" kindref="member">secp256k1_nonce_function_default</ref>;</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="525"><highlight class="normal"></highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Fail<sp/>if<sp/>the<sp/>secret<sp/>key<sp/>is<sp/>invalid.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/>is_sec_valid<sp/>=<sp/>secp256k1_scalar_set_b32_seckey(&amp;sec,<sp/>seckey);</highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(&amp;sec,<sp/>&amp;secp256k1_scalar_one,<sp/>!is_sec_valid);</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;msg,<sp/>msg32,<sp/>NULL);</highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>is_nonce_valid;</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>!!noncefp(nonce32,<sp/>msg32,<sp/>seckey,<sp/>NULL,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)noncedata,<sp/>count);</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>is_nonce_valid<sp/>=<sp/>secp256k1_scalar_set_b32_seckey(&amp;non,<sp/>nonce32);</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>nonce<sp/>is<sp/>still<sp/>secret<sp/>here,<sp/>but<sp/>it<sp/>being<sp/>invalid<sp/>is<sp/>less<sp/>likely<sp/>than<sp/>1:2^255.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_declassify(ctx,<sp/>&amp;is_nonce_valid,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(is_nonce_valid));</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(is_nonce_valid)<sp/>{</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_ecdsa_sig_sign(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>,<sp/>r,<sp/>s,<sp/>&amp;sec,<sp/>&amp;msg,<sp/>&amp;non,<sp/>recid);</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>final<sp/>signature<sp/>is<sp/>no<sp/>longer<sp/>a<sp/>secret,<sp/>nor<sp/>is<sp/>the<sp/>fact<sp/>that<sp/>we<sp/>were<sp/>successful<sp/>or<sp/>not.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_declassify(ctx,<sp/>&amp;<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>));</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>don&apos;t<sp/>want<sp/>to<sp/>declassify<sp/>is_sec_valid<sp/>and<sp/>therefore<sp/>the<sp/>range<sp/>of</highlight></codeline>
<codeline lineno="550"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>seckey.<sp/>As<sp/>a<sp/>result<sp/>is_sec_valid<sp/>is<sp/>included<sp/>in<sp/>ret<sp/>only<sp/>after<sp/>ret<sp/>was</highlight></codeline>
<codeline lineno="551"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>used<sp/>as<sp/>a<sp/>branching<sp/>variable.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>&amp;=<sp/>is_sec_valid;</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_memclear_explicit(nonce32,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(nonce32));</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;msg);</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;non);</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(r,<sp/>&amp;secp256k1_scalar_zero,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(s,<sp/>&amp;secp256k1_scalar_zero,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(recid)<sp/>{</highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>zero<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_int_cmov(recid,<sp/>&amp;zero,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="564"><highlight class="normal">}</highlight></codeline>
<codeline lineno="565"><highlight class="normal"></highlight></codeline>
<codeline lineno="566" refid="secp256k1_8h_1a4185cc9a9de502e52cfe5350f7dc8438" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1af5ff5bb2cad5c58e90c653092648c63a" kindref="member">secp256k1_ecdsa_sign</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*signature,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msghash32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/>noncefp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>noncedata)<sp/>{</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>));</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(msghash32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(signature<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="574"><highlight class="normal"></highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_ecdsa_sign_inner(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>NULL,<sp/>msghash32,<sp/>seckey,<sp/>noncefp,<sp/>noncedata);</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(signature,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="578"><highlight class="normal">}</highlight></codeline>
<codeline lineno="579"><highlight class="normal"></highlight></codeline>
<codeline lineno="580" refid="secp256k1_8h_1a366f922fc0c787351e82ff8e3a95f652" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a6015346bdaee22c65e5ebca71693d9b1" kindref="member">secp256k1_ec_seckey_verify</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey)<sp/>{</highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="582"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="585"><highlight class="normal"></highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_scalar_set_b32_seckey(&amp;sec,<sp/>seckey);</highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="589"><highlight class="normal">}</highlight></codeline>
<codeline lineno="590"><highlight class="normal"></highlight></codeline>
<codeline lineno="591"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_ec_pubkey_create_helper(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecmult__gen__context" kindref="compound">secp256k1_ecmult_gen_context</ref><sp/>*ecmult_gen_ctx,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>*seckey_scalar,<sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*p,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey)<sp/>{</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>pj;</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="594"><highlight class="normal"></highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_scalar_set_b32_seckey(seckey_scalar,<sp/>seckey);</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(seckey_scalar,<sp/>&amp;secp256k1_scalar_one,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="597"><highlight class="normal"></highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen(ecmult_gen_ctx,<sp/>&amp;pj,<sp/>seckey_scalar);</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej(p,<sp/>&amp;pj);</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_gej_clear(&amp;pj);</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="602"><highlight class="normal">}</highlight></codeline>
<codeline lineno="603"><highlight class="normal"></highlight></codeline>
<codeline lineno="604" refid="secp256k1_8h_1a7438071aa8a6dc4697abe4f4659f2161" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ac5806cffd3278e64f863027eaa8e1284" kindref="member">secp256k1_ec_pubkey_create</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey)<sp/>{</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>seckey_scalar;</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>));</highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="613"><highlight class="normal"></highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_ec_pubkey_create_helper(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>,<sp/>&amp;seckey_scalar,<sp/>&amp;p,<sp/>seckey);</highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_memczero(pubkey,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey),<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight></codeline>
<codeline lineno="618"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;seckey_scalar);</highlight></codeline>
<codeline lineno="619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="620"><highlight class="normal">}</highlight></codeline>
<codeline lineno="621"><highlight class="normal"></highlight></codeline>
<codeline lineno="622" refid="secp256k1_8h_1a1eb33149d14095c8480319441b2477a8" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a877d2d85643148d932a95868f5660e26" kindref="member">secp256k1_ec_seckey_negate</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey)<sp/>{</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="627"><highlight class="normal"></highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_scalar_set_b32_seckey(&amp;sec,<sp/>seckey);</highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(&amp;sec,<sp/>&amp;secp256k1_scalar_zero,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_negate(&amp;sec,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(seckey,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="632"><highlight class="normal"></highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="634"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="635"><highlight class="normal">}</highlight></codeline>
<codeline lineno="636"><highlight class="normal"></highlight></codeline>
<codeline lineno="637" refid="secp256k1_8h_1a35851df9113ecb93860e7f4bbe3d185b" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1afb380139bce6f6722e35add4c375debb" kindref="member">secp256k1_ec_pubkey_negate</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey)<sp/>{</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="639"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="642"><highlight class="normal"></highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;p,<sp/>pubkey);</highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ge_neg(&amp;p,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="650"><highlight class="normal">}</highlight></codeline>
<codeline lineno="651"><highlight class="normal"></highlight></codeline>
<codeline lineno="652"><highlight class="normal"></highlight></codeline>
<codeline lineno="653"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_ec_seckey_tweak_add_helper(<ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>*sec,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak32)<sp/>{</highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>term;</highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="657"><highlight class="normal"></highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;term,<sp/>tweak32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>(!overflow)<sp/>&amp;<sp/>secp256k1_eckey_privkey_tweak_add(sec,<sp/>&amp;term);</highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;term);</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="662"><highlight class="normal">}</highlight></codeline>
<codeline lineno="663"><highlight class="normal"></highlight></codeline>
<codeline lineno="664" refid="secp256k1_8h_1af190f597732ce69f0829c40cda6854b8" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a615cecca9de98d5f67333c76564ed6bf" kindref="member">secp256k1_ec_seckey_tweak_add</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak32)<sp/>{</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="670"><highlight class="normal"></highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_scalar_set_b32_seckey(&amp;sec,<sp/>seckey);</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>&amp;=<sp/>secp256k1_ec_seckey_tweak_add_helper(&amp;sec,<sp/>tweak32);</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(&amp;sec,<sp/>&amp;secp256k1_scalar_zero,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(seckey,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="675"><highlight class="normal"></highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="678"><highlight class="normal">}</highlight></codeline>
<codeline lineno="679"><highlight class="normal"></highlight></codeline>
<codeline lineno="680"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_ec_pubkey_tweak_add_helper(<ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*p,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak32)<sp/>{</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>term;</highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;term,<sp/>tweak32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>!overflow<sp/>&amp;&amp;<sp/>secp256k1_eckey_pubkey_tweak_add(p,<sp/>&amp;term);</highlight></codeline>
<codeline lineno="685"><highlight class="normal">}</highlight></codeline>
<codeline lineno="686"><highlight class="normal"></highlight></codeline>
<codeline lineno="687" refid="secp256k1_8h_1aaac0a0211f7ebfa1af55ab571cd57751" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a37cae594daf23e05431eda1b20610f73" kindref="member">secp256k1_ec_pubkey_tweak_add</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak32)<sp/>{</highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="690"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="692"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="693"><highlight class="normal"></highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;p,<sp/>pubkey);</highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>&amp;&amp;<sp/>secp256k1_ec_pubkey_tweak_add_helper(&amp;p,<sp/>tweak32);</highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="700"><highlight class="normal"></highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="702"><highlight class="normal">}</highlight></codeline>
<codeline lineno="703"><highlight class="normal"></highlight></codeline>
<codeline lineno="704" refid="secp256k1_8h_1a034600fa5f0174c0d11a991a842e4edc" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a42895c7fad28c83d4373a40ba49323f1" kindref="member">secp256k1_ec_seckey_tweak_mul</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak32)<sp/>{</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>factor;</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="712"><highlight class="normal"></highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;factor,<sp/>tweak32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>secp256k1_scalar_set_b32_seckey(&amp;sec,<sp/>seckey);</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>&amp;=<sp/>(!overflow)<sp/>&amp;<sp/>secp256k1_eckey_privkey_tweak_mul(&amp;sec,<sp/>&amp;factor);</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_cmov(&amp;sec,<sp/>&amp;secp256k1_scalar_zero,<sp/>!<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>);</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(seckey,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="718"><highlight class="normal"></highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;factor);</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="722"><highlight class="normal">}</highlight></codeline>
<codeline lineno="723"><highlight class="normal"></highlight></codeline>
<codeline lineno="724" refid="secp256k1_8h_1af64066f6c9fdb64070569f37a6cc025d" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1aef753193bf672b7c5e6156daa962bf55" kindref="member">secp256k1_ec_pubkey_tweak_mul</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak32)<sp/>{</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>factor;</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="732"><highlight class="normal"></highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;factor,<sp/>tweak32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>!overflow<sp/>&amp;&amp;<sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;p,<sp/>pubkey);</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>)<sp/>{</highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_eckey_pubkey_tweak_mul(&amp;p,<sp/>&amp;factor))<sp/>{</highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="743"><highlight class="normal"></highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="bitcoin-cli_8cpp_1a339672ff94e6199019102f50d317c3d7" kindref="member">ret</ref>;</highlight></codeline>
<codeline lineno="745"><highlight class="normal">}</highlight></codeline>
<codeline lineno="746"><highlight class="normal"></highlight></codeline>
<codeline lineno="747" refid="secp256k1_8h_1a1b81d70feb6ed24dc902cbbd5ba569e7" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1aba25f5f986a05a1cd06f5452b26ff868" kindref="member">secp256k1_context_randomize</ref>(<ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seed32)<sp/>{</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_context_is_proper(ctx));</highlight></codeline>
<codeline lineno="750"><highlight class="normal"></highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>))<sp/>{</highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_blind(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1abb65f6e84b17f93f74cd8b4eb2910a47" kindref="member">ecmult_gen_ctx</ref>,<sp/>seed32);</highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="755"><highlight class="normal">}</highlight></codeline>
<codeline lineno="756"><highlight class="normal"></highlight></codeline>
<codeline lineno="757" refid="secp256k1_8h_1a1cb5a7cf0d89b1f8eb9e7881a9cdd6eb" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a92498665c38198fc1943e463c017c140" kindref="member">secp256k1_ec_pubkey_combine</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubnonce,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*pubnonces,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n)<sp/>{</highlight></codeline>
<codeline lineno="758"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="759"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>Qj;</highlight></codeline>
<codeline lineno="760"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Q;</highlight></codeline>
<codeline lineno="761"><highlight class="normal"></highlight></codeline>
<codeline lineno="762"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubnonce<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubnonce,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubnonce));</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(n<sp/>&gt;=<sp/>1);</highlight></codeline>
<codeline lineno="766"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubnonces<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="767"><highlight class="normal"></highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_gej_set_infinity(&amp;Qj);</highlight></codeline>
<codeline lineno="769"><highlight class="normal"></highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubnonces[i]<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;Q,<sp/>pubnonces[i]);</highlight></codeline>
<codeline lineno="773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_add_ge(&amp;Qj,<sp/>&amp;Qj,<sp/>&amp;Q);</highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_gej_is_infinity(&amp;Qj))<sp/>{</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej(&amp;Q,<sp/>&amp;Qj);</highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubnonce,<sp/>&amp;Q);</highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="781"><highlight class="normal">}</highlight></codeline>
<codeline lineno="782"><highlight class="normal"></highlight></codeline>
<codeline lineno="783" refid="secp256k1_8h_1a8878ae25e9dfd56db13798a8ac2c2f9c" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a364d53929192054916b1207a22e701ec" kindref="member">secp256k1_tagged_sha256</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*hash32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tag,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>taglen,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>msglen)<sp/>{</highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__sha256" kindref="compound">secp256k1_sha256</ref><sp/>sha;</highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(hash32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tag<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(msg<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="789"><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_sha256_initialize_tagged(&amp;sha,<sp/>tag,<sp/>taglen);</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_sha256_write(&amp;sha,<sp/>msg,<sp/>msglen);</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_sha256_finalize(&amp;sha,<sp/>hash32);</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_sha256_clear(&amp;sha);</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="795"><highlight class="normal">}</highlight></codeline>
<codeline lineno="796"><highlight class="normal"></highlight></codeline>
<codeline lineno="797"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_ECDH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="798"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="ecdh_2main__impl_8h" kindref="compound">modules/ecdh/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="799"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="800"><highlight class="normal"></highlight></codeline>
<codeline lineno="801"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_RECOVERY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="802"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="recovery_2main__impl_8h" kindref="compound">modules/recovery/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="803"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="804"><highlight class="normal"></highlight></codeline>
<codeline lineno="805"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_EXTRAKEYS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="806"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="extrakeys_2main__impl_8h" kindref="compound">modules/extrakeys/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="807"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="808"><highlight class="normal"></highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_SCHNORRSIG</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="schnorrsig_2main__impl_8h" kindref="compound">modules/schnorrsig/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="812"><highlight class="normal"></highlight></codeline>
<codeline lineno="813"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_MUSIG</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="814"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="musig_2main__impl_8h" kindref="compound">modules/musig/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="815"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="816"><highlight class="normal"></highlight></codeline>
<codeline lineno="817"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_ELLSWIFT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="818"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="ellswift_2main__impl_8h" kindref="compound">modules/ellswift/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="819"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
    </programlisting>
    <location file="src/secp256k1/src/secp256k1.c"/>
  </compounddef>
</doxygen>
