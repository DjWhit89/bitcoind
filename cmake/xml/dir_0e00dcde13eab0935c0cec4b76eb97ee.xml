<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="dir_0e00dcde13eab0935c0cec4b76eb97ee" kind="dir">
    <compoundname>src/leveldb</compoundname>
    <innerdir refid="dir_1ed7938b56ccb5a0d5f36b4c317afbf3">src/leveldb/benchmarks</innerdir>
    <innerdir refid="dir_a48b0001415afebe08867b131cea33b8">src/leveldb/db</innerdir>
    <innerdir refid="dir_64a542e04cbf4ae049fbda343e0e4c6a">src/leveldb/doc</innerdir>
    <innerdir refid="dir_ee3f5b56e10d6c6af1268049df6bc179">src/leveldb/helpers</innerdir>
    <innerdir refid="dir_21766b5cf1f9847269bf75ec75f0b0e0">src/leveldb/include</innerdir>
    <innerdir refid="dir_81cec10400bcdbfc9f426e7ee5d3e377">src/leveldb/issues</innerdir>
    <innerdir refid="dir_92aaa8568e1851800dade842aea56d6a">src/leveldb/port</innerdir>
    <innerdir refid="dir_1a7a550b3d9d541f8a60143ed5008e78">src/leveldb/table</innerdir>
    <innerdir refid="dir_bbfe65362906d8110ad4e0d33b7b75f1">src/leveldb/util</innerdir>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>**LevelDB is a fast key-value storage library written at Google that provides an ordered mapping from string keys to string values.**</para>
<para><ulink url="https://travis-ci.org/google/leveldb"><image type="html" name="https://travis-ci.org/google/leveldb.svg?branch=master" alt="Build Status" inline="yes"></image>
</ulink> <ulink url="https://ci.appveyor.com/project/pwnall/leveldb"><image type="html" name="https://ci.appveyor.com/api/projects/status/g2j5j4rfkda6eyw5/branch/master?svg=true" alt="Build status" inline="yes"></image>
</ulink></para>
<para>Authors: Sanjay Ghemawat (<ulink url="mailto:sanjay@google.com">sanjay@google.com</ulink>) and Jeff Dean (<ulink url="mailto:jeff@google.com">jeff@google.com</ulink>)</para>
<sect1 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md69">
<title>Features</title><para><itemizedlist>
<listitem><para>Keys and values are arbitrary byte arrays.</para>
</listitem><listitem><para>Data is stored sorted by key.</para>
</listitem><listitem><para>Callers can provide a custom comparison function to override the sort order.</para>
</listitem><listitem><para>The basic operations are <computeroutput>Put(key,value)</computeroutput>, <computeroutput>Get(key)</computeroutput>, <computeroutput>Delete(key)</computeroutput>.</para>
</listitem><listitem><para>Multiple changes can be made in one atomic batch.</para>
</listitem><listitem><para>Users can create a transient snapshot to get a consistent view of data.</para>
</listitem><listitem><para>Forward and backward iteration is supported over the data.</para>
</listitem><listitem><para>Data is automatically compressed using the <ulink url="http://google.github.io/snappy/">Snappy compression library</ulink>.</para>
</listitem><listitem><para>External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md70">
<title>Documentation</title><para><ulink url="https://github.com/google/leveldb/blob/master/doc/index.md">LevelDB library documentation</ulink> is online and bundled with the source code.</para>
</sect1>
<sect1 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md71">
<title>Limitations</title><para><itemizedlist>
<listitem><para>This is not a SQL database. It does not have a relational data model, it does not support SQL queries, and it has no support for indexes.</para>
</listitem><listitem><para>Only a single process (possibly multi-threaded) can access a particular database at a time.</para>
</listitem><listitem><para>There is no client-server support builtin to the library. An application that needs such support will have to wrap their own server around the library.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md72">
<title>Building</title><para>This project supports <ulink url="https://cmake.org/">CMake</ulink> out of the box.</para>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md73_1s2"><sect3 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md73">
<title>Build for POSIX</title><para>Quick start:</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">mkdir<sp/>-p<sp/>build<sp/>&amp;&amp;<sp/>cd<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cmake<sp/>-DCMAKE_BUILD_TYPE=Release<sp/>..<sp/>&amp;&amp;<sp/>cmake<sp/>--build<sp/>.</highlight></codeline>
</programlisting></para>
</sect3></sect2>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md74_1s2"><sect3 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md74">
<title>Building for Windows</title><para>First generate the Visual Studio 2017 project/solution files:</para>
<para><programlisting filename=".cmd"><codeline><highlight class="normal">mkdir<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cd<sp/>build</highlight></codeline>
<codeline><highlight class="normal">cmake<sp/>-G<sp/>&quot;Visual<sp/>Studio<sp/>15&quot;<sp/>..</highlight></codeline>
</programlisting> The default will build for x86. For 64-bit run:</para>
<para><programlisting filename=".cmd"><codeline><highlight class="normal">cmake<sp/>-G<sp/>&quot;Visual<sp/>Studio<sp/>15<sp/>Win64&quot;<sp/>..</highlight></codeline>
</programlisting></para>
<para>To compile the Windows solution from the command-line:</para>
<para><programlisting filename=".cmd"><codeline><highlight class="normal">devenv<sp/>/build<sp/>Debug<sp/>leveldb.sln</highlight></codeline>
</programlisting></para>
<para>or open leveldb.sln in Visual Studio and build from within.</para>
<para>Please see the CMake documentation and <computeroutput>CMakeLists.txt</computeroutput> for more advanced usage.</para>
</sect3></sect2>
</sect1>
<sect1 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md75">
<title>Contributing to the leveldb Project</title><para>The leveldb project welcomes contributions. leveldb&apos;s primary goal is to be a reliable and fast key/value store. Changes that are in line with the features/limitations outlined above, and meet the requirements below, will be considered.</para>
<para>Contribution requirements:</para>
<para><orderedlist>
<listitem><para><bold>Tested platforms only</bold>. We <emphasis>generally</emphasis> will only accept changes for platforms that are compiled and tested. This means POSIX (for Linux and macOS) or Windows. Very small changes will sometimes be accepted, but consider that more of an exception than the rule.</para>
</listitem><listitem><para><bold>Stable API</bold>. We strive very hard to maintain a stable API. Changes that require changes for projects using leveldb <emphasis>might</emphasis> be rejected without sufficient benefit to the project.</para>
</listitem><listitem><para><bold>Tests</bold>: All changes must be accompanied by a new (or changed) test, or a sufficient explanation as to why a new (or changed) test is not required.</para>
</listitem><listitem><para><bold>Consistent Style</bold>: This project conforms to the <ulink url="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</ulink>. To ensure your changes are properly formatted please run:</para>
<para><programlisting><codeline><highlight class="normal">clang-format<sp/>-i<sp/>--style=file<sp/>&lt;file&gt;</highlight></codeline>
</programlisting></para>
</listitem></orderedlist>
</para>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md76">
<title>Submitting a Pull Request</title><para>Before any pull request will be accepted the author must first sign a Contributor License Agreement (CLA) at <ulink url="https://cla.developers.google.com/">https://cla.developers.google.com/</ulink>.</para>
<para>In order to keep the commit timeline linear <ulink url="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History#Squashing-Commits">squash</ulink> your changes down to a single commit and <ulink url="https://git-scm.com/docs/git-rebase">rebase</ulink> on google/leveldb/master. This keeps the commit timeline linear and more easily sync&apos;ed with the internal repository at Google. More information at GitHub&apos;s <ulink url="https://help.github.com/articles/about-git-rebase/">About Git rebase</ulink> page.</para>
</sect2>
</sect1>
<sect1 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md77">
<title>Performance</title><para>Here is a performance report (with explanations) from the run of the included db_bench program. The results are somewhat noisy, but should be enough to get a ballpark performance estimate.</para>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md78">
<title>Setup</title><para>We use a database with a million entries. Each entry has a 16 byte key, and a 100 byte value. Values used by the benchmark compress to about half their original size. <verbatim>LevelDB:    version 1.1
Date:       Sun May  1 12:11:26 2011
CPU:        4 x Intel(R) Core(TM)2 Quad CPU    Q6600  @ 2.40GHz
CPUCache:   4096 KB
Keys:       16 bytes each
Values:     100 bytes each (50 bytes after compression)
Entries:    1000000
Raw Size:   110.6 MB (estimated)
File Size:  62.9 MB (estimated)
</verbatim></para>
</sect2>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md79">
<title>Write performance</title><para>The &quot;fill&quot; benchmarks create a brand new database, in either sequential, or random order. The &quot;fillsync&quot; benchmark flushes data from the operating system to the disk after every operation; the other write operations leave the data sitting in the operating system buffer cache for a while. The &quot;overwrite&quot; benchmark does random writes that update existing keys in the database. <verbatim>fillseq      :       1.765 micros/op;   62.7 MB/s
fillsync     :     268.409 micros/op;    0.4 MB/s (10000 ops)
fillrandom   :       2.460 micros/op;   45.0 MB/s
overwrite    :       2.380 micros/op;   46.5 MB/s
</verbatim></para>
<para>Each &quot;op&quot; above corresponds to a write of a single key/value pair. I.e., a random write benchmark goes at approximately 400,000 writes per second.</para>
<para>Each &quot;fillsync&quot; operation costs much less (0.3 millisecond) than a disk seek (typically 10 milliseconds). We suspect that this is because the hard disk itself is buffering the update in its memory and responding before the data has been written to the platter. This may or may not be safe based on whether or not the hard disk has enough power to save its memory in the event of a power failure.</para>
</sect2>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md80">
<title>Read performance</title><para>We list the performance of reading sequentially in both the forward and reverse direction, and also the performance of a random lookup. Note that the database created by the benchmark is quite small. Therefore the report characterizes the performance of leveldb when the working set fits in memory. The cost of reading a piece of data that is not present in the operating system buffer cache will be dominated by the one or two disk seeks needed to fetch the data from disk. Write performance will be mostly unaffected by whether or not the working set fits in memory. <verbatim>readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)
readseq     :  0.476 micros/op;  232.3 MB/s
readreverse :  0.724 micros/op;  152.9 MB/s
</verbatim></para>
<para>LevelDB compacts its underlying storage data in the background to improve read performance. The results listed above were done immediately after a lot of random writes. The results after compactions (which are usually triggered automatically) are better. <verbatim>readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)
readseq     :  0.423 micros/op;  261.8 MB/s
readreverse :  0.663 micros/op;  166.9 MB/s
</verbatim></para>
<para>Some of the high cost of reads comes from repeated decompression of blocks read from disk. If we supply enough cache to the leveldb so it can hold the uncompressed blocks in memory, the read performance improves again: <verbatim>readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)
readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction)
</verbatim></para>
</sect2>
<sect2 id="dir_0e00dcde13eab0935c0cec4b76eb97ee_1autotoc_md81">
<title>Repository contents</title><para>See <ref refid="md_src_2leveldb_2doc_2index" kindref="compound">doc/index.md</ref> for more explanation. See <ref refid="md_src_2leveldb_2doc_2impl" kindref="compound">doc/impl.md</ref> for a brief overview of the implementation.</para>
<para>The public interface is in include/leveldb/*.h. Callers should not include or rely on the details of any other header files in this package. Those internal APIs may be changed without warning.</para>
<para>Guide to header files:</para>
<para><itemizedlist>
<listitem><para><bold><ref refid="leveldb_2include_2leveldb_2db_8h" kindref="compound">include/leveldb/db.h</ref></bold>: Main interface to the <ref refid="class_d_b" kindref="compound">DB</ref>: Start here.</para>
</listitem><listitem><para><bold><ref refid="options_8h" kindref="compound">include/leveldb/options.h</ref></bold>: Control over the behavior of an entire database, and also control over the behavior of individual reads and writes.</para>
</listitem><listitem><para><bold><ref refid="comparator_8h" kindref="compound">include/leveldb/comparator.h</ref></bold>: Abstraction for user-specified comparison function. If you want just bytewise comparison of keys, you can use the default comparator, but clients can write their own comparator implementations if they want custom ordering (e.g. to handle different character encodings, etc.).</para>
</listitem><listitem><para><bold><ref refid="iterator_8h" kindref="compound">include/leveldb/iterator.h</ref></bold>: Interface for iterating over data. You can get an iterator from a <ref refid="class_d_b" kindref="compound">DB</ref> object.</para>
</listitem><listitem><para><bold><ref refid="write__batch_8h" kindref="compound">include/leveldb/write_batch.h</ref></bold>: Interface for atomically applying multiple updates to a database.</para>
</listitem><listitem><para><bold><ref refid="slice_8h" kindref="compound">include/leveldb/slice.h</ref></bold>: A simple module for maintaining a pointer and a length into some other byte array.</para>
</listitem><listitem><para><bold><ref refid="status_8h" kindref="compound">include/leveldb/status.h</ref></bold>: <ref refid="class_status" kindref="compound">Status</ref> is returned from many of the public interfaces and is used to report success and various kinds of errors.</para>
</listitem><listitem><para><bold><ref refid="env_8h" kindref="compound">include/leveldb/env.h</ref></bold>: Abstraction of the OS environment. A posix implementation of this interface is in <ref refid="env__posix_8cc" kindref="compound">util/env_posix.cc</ref>.</para>
</listitem><listitem><para><bold><ref refid="table_8h" kindref="compound">include/leveldb/table.h</ref>, <ref refid="table__builder_8h" kindref="compound">include/leveldb/table_builder.h</ref></bold>: Lower-level modules that most clients probably won&apos;t use directly. </para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="src/leveldb/"/>
  </compounddef>
</doxygen>
