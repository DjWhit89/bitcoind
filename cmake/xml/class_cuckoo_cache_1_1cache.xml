<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_cuckoo_cache_1_1cache" kind="class" language="C++" prot="public">
    <compoundname>CuckooCache::cache</compoundname>
    <includes refid="cuckoocache_8h" local="no">cuckoocache.h</includes>
    <templateparamlist>
      <param>
        <type>typename Element</type>
      </param>
      <param>
        <type>typename <ref refid="hash_8h_1ac49a4a382d911138c745234f2fe7986d" kindref="member">Hash</ref></type>
      </param>
    </templateparamlist>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1aee8f41b84308e3d49083fa183f004107" prot="private" static="no" mutable="no">
        <type>std::vector&lt; Element &gt;</type>
        <definition>std::vector&lt;Element&gt; table</definition>
        <argsstring></argsstring>
        <name>table</name>
        <qualifiedname>CuckooCache::cache::table</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>table stores all the elements </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="165" column="17" bodyfile="src/cuckoocache.h" bodystart="165" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1ab2c6b258f02add8fdf4cfc7c371dd772" prot="private" static="no" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t size</definition>
        <argsstring></argsstring>
        <name>size</name>
        <qualifiedname>CuckooCache::cache::size</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>size stores the total available slots in the hash table </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="168" column="14" bodyfile="src/cuckoocache.h" bodystart="168" bodyend="168"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1ae26c37dadfe7459732caec2cc22ef630" prot="private" static="no" mutable="yes">
        <type><ref refid="class_cuckoo_cache_1_1bit__packed__atomic__flags" kindref="compound">bit_packed_atomic_flags</ref></type>
        <definition>bit_packed_atomic_flags collection_flags</definition>
        <argsstring></argsstring>
        <name>collection_flags</name>
        <qualifiedname>CuckooCache::cache::collection_flags</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The <ref refid="class_cuckoo_cache_1_1bit__packed__atomic__flags" kindref="compound">bit_packed_atomic_flags</ref> array is marked mutable because we want garbage collection to be allowed to occur from const methods </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="172" column="37" bodyfile="src/cuckoocache.h" bodystart="172" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1a70edfc1722fdfd58b0241b1fb6ad6342" prot="private" static="no" mutable="yes">
        <type>std::vector&lt; bool &gt;</type>
        <definition>std::vector&lt;bool&gt; epoch_flags</definition>
        <argsstring></argsstring>
        <name>epoch_flags</name>
        <qualifiedname>CuckooCache::cache::epoch_flags</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>epoch_flags tracks how recently an element was inserted into the cache. true denotes recent, false denotes not-recent. See <ref refid="class_cuckoo_cache_1_1cache_1ad890f3cd4e0725ea56d7e4a3305a3487" kindref="member">insert()</ref> method for full semantics. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="178" column="25" bodyfile="src/cuckoocache.h" bodystart="178" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1aa42f70982518738260ed05fa6f360b48" prot="private" static="no" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t epoch_heuristic_counter</definition>
        <argsstring></argsstring>
        <name>epoch_heuristic_counter</name>
        <qualifiedname>CuckooCache::cache::epoch_heuristic_counter</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>epoch_heuristic_counter is used to determine when an epoch might be aged &amp; an expensive scan should be done. epoch_heuristic_counter is decremented on insert and reset to the new number of inserts which would cause the epoch to reach epoch_size when it reaches zero. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="185" column="14" bodyfile="src/cuckoocache.h" bodystart="185" bodyend="185"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1a541f06f2ce0b0102d323b730c5c11a80" prot="private" static="no" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t epoch_size</definition>
        <argsstring></argsstring>
        <name>epoch_size</name>
        <qualifiedname>CuckooCache::cache::epoch_size</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>epoch_size is set to be the number of elements supposed to be in a epoch. When the number of non-erased elements in an epoch exceeds epoch_size, a new epoch should be started and all current entries demoted. epoch_size is set to be 45% of size because we want to keep load around 90%, and we support 3 epochs at once <ndash/> one &quot;dead&quot; which has been erased, one &quot;dying&quot; which has been marked to be erased next, and one &quot;living&quot; which new inserts add to. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="195" column="14" bodyfile="src/cuckoocache.h" bodystart="195" bodyend="195"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1a04a5de3687fba01e0ce007dedcc2f366" prot="private" static="no" mutable="no">
        <type>uint8_t</type>
        <definition>uint8_t depth_limit</definition>
        <argsstring></argsstring>
        <name>depth_limit</name>
        <qualifiedname>CuckooCache::cache::depth_limit</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>depth_limit determines how many elements insert should try to replace. Should be set to log2(n). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="200" column="13" bodyfile="src/cuckoocache.h" bodystart="200" bodyend="200"/>
      </memberdef>
      <memberdef kind="variable" id="class_cuckoo_cache_1_1cache_1a396a6938f2df8bb306861c8ad8263920" prot="private" static="no" mutable="no">
        <type>const <ref refid="hash_8h_1ac49a4a382d911138c745234f2fe7986d" kindref="member">Hash</ref></type>
        <definition>const Hash hash_function</definition>
        <argsstring></argsstring>
        <name>hash_function</name>
        <qualifiedname>CuckooCache::cache::hash_function</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>hash_function is a const instance of the hash function. It cannot be static or initialized at call time as it may have internal state (such as a nonce). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="206" column="16" bodyfile="src/cuckoocache.h" bodystart="206" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1ad9d604b949d0676b7e77b2a670a759dc" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::array&lt; uint32_t, 8 &gt;</type>
        <definition>std::array&lt; uint32_t, 8 &gt; compute_hashes</definition>
        <argsstring>(const Element &amp;e) const</argsstring>
        <name>compute_hashes</name>
        <qualifiedname>CuckooCache::cache::compute_hashes</qualifiedname>
        <param>
          <type>const Element &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>compute_hashes is convenience for not having to write out this expression everywhere we use the hash values of an Element.</para>
<para>We need to map the 32-bit input hash onto a hash bucket in a range [0, size) in a manner which preserves as much of the hash&apos;s uniformity as possible. Ideally this would be done by bitmasking but the size is usually not a power of two.</para>
<para>The naive approach would be to use a mod <ndash/> which isn&apos;t perfectly uniform but so long as the hash is much larger than size it is not that bad. Unfortunately, mod/division is fairly slow on ordinary microprocessors (e.g. 90-ish cycles on haswell, ARM doesn&apos;t even have an instruction for it.); when the divisor is a constant the compiler will do clever tricks to turn it into a multiply+add+shift, but size is a run-time value so the compiler can&apos;t do that here.</para>
<para>One option would be to implement the same trick the compiler uses and compute the constants for exact division based on the size, as described in &quot;{N}-bit Unsigned
 Division via {N}-bit Multiply-Add&quot; by Arch D. Robison in 2005. But that code is somewhat complicated and the result is still slower than an even simpler option: see the FastRange32 function in <ref refid="fastrange_8h" kindref="compound">util/fastrange.h</ref>.</para>
<para>The resulting non-uniformity is also more equally distributed which would be advantageous for something like linear probing, though it shouldn&apos;t matter one way or the other for a cuckoo table.</para>
<para>The primary disadvantage of this approach is increased intermediate precision is required but for a 32-bit random number we only need the high 32 bits of a 32*32-&gt;64 multiply, which means the operation is reasonably fast even on a typical 32-bit processor.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The element whose hashes will be returned </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Deterministic hashes derived from <computeroutput>e</computeroutput> uniformly mapped onto the range [0, size) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="240" column="23" bodyfile="src/cuckoocache.h" bodystart="240" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1aabb0efc3e7c4ca873f12e76ce1e8d710" prot="private" static="no" constexpr="yes" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t invalid</definition>
        <argsstring>() const</argsstring>
        <name>invalid</name>
        <qualifiedname>CuckooCache::cache::invalid</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>invalid returns a special index that can never be inserted to <simplesect kind="return"><para>the special constexpr index that can never be inserted to </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="254" column="24" bodyfile="src/cuckoocache.h" bodystart="254" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1a59308e9aab0218356a39fa78703d3319" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void allow_erase</definition>
        <argsstring>(uint32_t n) const</argsstring>
        <name>allow_erase</name>
        <qualifiedname>CuckooCache::cache::allow_erase</qualifiedname>
        <param>
          <type>uint32_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>allow_erase marks the element at index <computeroutput>n</computeroutput> as discardable. Threadsafe without any concurrent insert. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the index to allow erasure of </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="263" column="17" bodyfile="src/cuckoocache.h" bodystart="263" bodyend="266"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1a0608b6c06c09b6bb6140b731ddf62bc1" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void please_keep</definition>
        <argsstring>(uint32_t n) const</argsstring>
        <name>please_keep</name>
        <qualifiedname>CuckooCache::cache::please_keep</qualifiedname>
        <param>
          <type>uint32_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>please_keep marks the element at index <computeroutput>n</computeroutput> as an entry that should be kept. Threadsafe without any concurrent insert. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>the index to prioritize keeping </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="272" column="17" bodyfile="src/cuckoocache.h" bodystart="272" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1a28124e50c6505b910bfbb6d22c2a4e9e" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void epoch_check</definition>
        <argsstring>()</argsstring>
        <name>epoch_check</name>
        <qualifiedname>CuckooCache::cache::epoch_check</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>epoch_check handles the changing of epochs for elements stored in the cache. epoch_check should be run before every insert.</para>
<para>First, epoch_check decrements and checks the cheap heuristic, and then does a more expensive scan if the cheap heuristic runs out. If the expensive scan succeeds, the epochs are aged and old elements are allow_erased. The cheap heuristic is reset to retrigger after the worst case growth of the current epoch&apos;s elements would exceed the epoch_size. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="286" column="10" bodyfile="src/cuckoocache.h" bodystart="286" bodyend="318"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1ab23554f62408c63d48b826b5f2bf85d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>cache</definition>
        <argsstring>()</argsstring>
        <name>cache</name>
        <qualifiedname>CuckooCache::cache::cache</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>You must always construct a cache with some elements via a subsequent call to setup or setup_bytes, otherwise operations may segfault. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="324" column="5" bodyfile="src/cuckoocache.h" bodystart="324" bodyend="326"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1a285a84ed8df980e01cf6675f5129a506" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t setup</definition>
        <argsstring>(uint32_t new_size)</argsstring>
        <name>setup</name>
        <qualifiedname>CuckooCache::cache::setup</qualifiedname>
        <param>
          <type>uint32_t</type>
          <declname>new_size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>setup initializes the container to store no more than new_size elements and no less than 2 elements.</para>
<para>setup should only be called once.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>new_size</parametername>
</parameternamelist>
<parameterdescription>
<para>the desired number of elements to store </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the maximum number of elements storable </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="336" column="14" bodyfile="src/cuckoocache.h" bodystart="336" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1abc547a231db5bfa46b6f3912bb894380" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::pair&lt; uint32_t, size_t &gt;</type>
        <definition>std::pair&lt; uint32_t, size_t &gt; setup_bytes</definition>
        <argsstring>(size_t bytes)</argsstring>
        <name>setup_bytes</name>
        <qualifiedname>CuckooCache::cache::setup_bytes</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>setup_bytes is a convenience function which accounts for internal memory usage when deciding how many elements to store. It isn&apos;t perfect because it doesn&apos;t account for any overhead (struct size, MallocUsage, collection and epoch flags). This was done to simplify selecting a power of two size. In the expected use case, an extra two bits per entry should be negligible compared to the size of the elements.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>the approximate number of bytes to use for this data structure </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A pair of the maximum number of elements storable (see <ref refid="class_cuckoo_cache_1_1cache_1a285a84ed8df980e01cf6675f5129a506" kindref="member">setup()</ref> documentation for more detail) and the approximate total size of these elements in bytes. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="364" column="15" bodyfile="src/cuckoocache.h" bodystart="364" bodyend="374"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1ad890f3cd4e0725ea56d7e4a3305a3487" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void insert</definition>
        <argsstring>(Element e)</argsstring>
        <name>insert</name>
        <qualifiedname>CuckooCache::cache::insert</qualifiedname>
        <param>
          <type>Element</type>
          <declname>e</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>insert loops at most depth_limit times trying to insert a hash at various locations in the table via a variant of the Cuckoo Algorithm with eight hash locations.</para>
<para>It drops the last tried element if it runs out of depth before encountering an open slot.</para>
<para>Thus:</para>
<para><programlisting><codeline><highlight class="normal"><ref refid="class_cuckoo_cache_1_1cache_1ad890f3cd4e0725ea56d7e4a3305a3487" kindref="member">insert</ref>(x);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" kindref="member">contains</ref>(x,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>is not guaranteed to return true.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>the element to insert </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="post"><para>one of the following: All previously inserted elements and e are now in the table, one previously inserted element is evicted from the table, the entry attempted to be inserted is evicted. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
<para>Swap with the element at the location that was not the last one looked at. Example:</para>
<para><orderedlist>
<listitem><para>On first iteration, last_loc == invalid(), find returns last, so last_loc defaults to locs[0].</para>
</listitem><listitem><para>On further iterations, where last_loc == locs[k], last_loc will go to locs[k+1 % 8], i.e., next of the 8 indices wrapping around to 0 if needed.</para>
</listitem></orderedlist>
</para>
<para>This prevents moving the element we just put in.</para>
<para>The swap is not a move <ndash/> we must switch onto the evicted element for the next iteration.</para>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="397" column="17" bodyfile="src/cuckoocache.h" bodystart="397" bodyend="445"/>
      </memberdef>
      <memberdef kind="function" id="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool contains</definition>
        <argsstring>(const Element &amp;e, const bool erase) const</argsstring>
        <name>contains</name>
        <qualifiedname>CuckooCache::cache::contains</qualifiedname>
        <param>
          <type>const Element &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>erase</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>contains iterates through the hash locations for a given element and checks to see if it is present.</para>
<para>contains does not check garbage collected state (in other words, garbage is only collected when the space is needed), so:</para>
<para><programlisting><codeline><highlight class="normal"><ref refid="class_cuckoo_cache_1_1cache_1ad890f3cd4e0725ea56d7e4a3305a3487" kindref="member">insert</ref>(x);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" kindref="member">contains</ref>(x,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" kindref="member">contains</ref>(x,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para>
<para>executed on a single thread will always return true!</para>
<para>This is a great property for re-org performance for example.</para>
<para>contains returns a bool set true if the element was found.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>the element to check </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>erase</parametername>
</parameternamelist>
<parameterdescription>
<para>whether to attempt setting the garbage collect flag</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="post"><para>if erase is true and the element is found, then the garbage collect flag is set </para>
</simplesect>
<simplesect kind="return"><para>true if the element is found, false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cuckoocache.h" line="474" column="17" bodyfile="src/cuckoocache.h" bodystart="474" bodyend="484"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><ref refid="class_cuckoo_cache_1_1cache" kindref="compound">cache</ref> implements a cache with properties similar to a cuckoo-set.</para>
<para>The cache is able to hold up to <computeroutput>(~(uint32_t)0) - 1</computeroutput> elements.</para>
<para>Read Operations:<itemizedlist>
<listitem><para><ref refid="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" kindref="member">contains()</ref> for <computeroutput>erase=false</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Read+Erase Operations:<itemizedlist>
<listitem><para><ref refid="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" kindref="member">contains()</ref> for <computeroutput>erase=true</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Erase Operations:<itemizedlist>
<listitem><para>allow_erase()</para>
</listitem></itemizedlist>
</para>
<para>Write Operations:<itemizedlist>
<listitem><para><ref refid="class_cuckoo_cache_1_1cache_1a285a84ed8df980e01cf6675f5129a506" kindref="member">setup()</ref></para>
</listitem><listitem><para><ref refid="class_cuckoo_cache_1_1cache_1abc547a231db5bfa46b6f3912bb894380" kindref="member">setup_bytes()</ref></para>
</listitem><listitem><para><ref refid="class_cuckoo_cache_1_1cache_1ad890f3cd4e0725ea56d7e4a3305a3487" kindref="member">insert()</ref></para>
</listitem><listitem><para>please_keep()</para>
</listitem></itemizedlist>
</para>
<para>Synchronization Free Operations:<itemizedlist>
<listitem><para>invalid()</para>
</listitem><listitem><para>compute_hashes()</para>
</listitem></itemizedlist>
</para>
<para>User Must Guarantee:</para>
<para><orderedlist>
<listitem><para>Write requires synchronized access (e.g. a lock)</para>
</listitem><listitem><para>Read requires no concurrent Write, synchronized with last insert.</para>
</listitem><listitem><para>Erase requires no concurrent Write, synchronized with last insert.</para>
</listitem><listitem><para>An Erase caller must release all memory before allowing a new Writer.</para>
</listitem></orderedlist>
</para>
<para>Note on function names:<itemizedlist>
<listitem><para>The name &quot;allow_erase&quot; is used because the real discard happens later.</para>
</listitem><listitem><para>The name &quot;please_keep&quot; is used because elements may be erased anyways on insert.</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Element</parametername>
</parameternamelist>
<parameterdescription>
<para>should be a movable and copyable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Hash</parametername>
</parameternamelist>
<parameterdescription>
<para>should be a function/callable which takes a template parameter hash_select and an Element and extracts a hash from it. Should return high-entropy uint32_t hashes for <computeroutput><ref refid="hash_8h_1ac49a4a382d911138c745234f2fe7986d" kindref="member">Hash</ref> h; h&lt;0&gt;(e) ... h&lt;7&gt;(e)</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
    </detaileddescription>
    <location file="src/cuckoocache.h" line="161" column="1" bodyfile="src/cuckoocache.h" bodystart="162" bodyend="485"/>
    <listofallmembers>
      <member refid="class_cuckoo_cache_1_1cache_1a59308e9aab0218356a39fa78703d3319" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>allow_erase</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1ab23554f62408c63d48b826b5f2bf85d1" prot="public" virt="non-virtual"><scope>CuckooCache::cache</scope><name>cache</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1ae26c37dadfe7459732caec2cc22ef630" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>collection_flags</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1ad9d604b949d0676b7e77b2a670a759dc" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>compute_hashes</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a0c6c8da8f3b8de3c38a99ed23d92099e" prot="public" virt="non-virtual"><scope>CuckooCache::cache</scope><name>contains</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a04a5de3687fba01e0ce007dedcc2f366" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>depth_limit</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a28124e50c6505b910bfbb6d22c2a4e9e" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>epoch_check</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a70edfc1722fdfd58b0241b1fb6ad6342" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>epoch_flags</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1aa42f70982518738260ed05fa6f360b48" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>epoch_heuristic_counter</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a541f06f2ce0b0102d323b730c5c11a80" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>epoch_size</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a396a6938f2df8bb306861c8ad8263920" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>hash_function</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1ad890f3cd4e0725ea56d7e4a3305a3487" prot="public" virt="non-virtual"><scope>CuckooCache::cache</scope><name>insert</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1aabb0efc3e7c4ca873f12e76ce1e8d710" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>invalid</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a0608b6c06c09b6bb6140b731ddf62bc1" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>please_keep</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1a285a84ed8df980e01cf6675f5129a506" prot="public" virt="non-virtual"><scope>CuckooCache::cache</scope><name>setup</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1abc547a231db5bfa46b6f3912bb894380" prot="public" virt="non-virtual"><scope>CuckooCache::cache</scope><name>setup_bytes</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1ab2c6b258f02add8fdf4cfc7c371dd772" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>size</name></member>
      <member refid="class_cuckoo_cache_1_1cache_1aee8f41b84308e3d49083fa183f004107" prot="private" virt="non-virtual"><scope>CuckooCache::cache</scope><name>table</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
