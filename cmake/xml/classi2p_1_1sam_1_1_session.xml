<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classi2p_1_1sam_1_1_session" kind="class" language="C++" prot="public">
    <compoundname>i2p::sam::Session</compoundname>
    <includes refid="i2p_8h" local="no">i2p.h</includes>
    <innerclass refid="structi2p_1_1sam_1_1_session_1_1_reply" prot="private">i2p::sam::Session::Reply</innerclass>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classi2p_1_1sam_1_1_session_1a70d78a175858ab01a83ead14bf4585ab" prot="private" static="no" mutable="no">
        <type>const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref></type>
        <definition>const fs::path m_private_key_file</definition>
        <argsstring></argsstring>
        <name>m_private_key_file</name>
        <qualifiedname>i2p::sam::Session::m_private_key_file</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The name of the file where this peer&apos;s private key is stored (in binary). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="224" column="20" bodyfile="src/i2p.h" bodystart="224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classi2p_1_1sam_1_1_session_1a1613dc00d2e88085669838f23e319e6d" prot="private" static="no" mutable="no">
        <type>const <ref refid="class_proxy" kindref="compound">Proxy</ref></type>
        <definition>const Proxy m_control_host</definition>
        <argsstring></argsstring>
        <name>m_control_host</name>
        <qualifiedname>i2p::sam::Session::m_control_host</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The SAM control service proxy. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="229" column="17" bodyfile="src/i2p.h" bodystart="229" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classi2p_1_1sam_1_1_session_1afedab8eaf79b0b0971c77ce2db573463" prot="private" static="no" mutable="no">
        <type>const std::shared_ptr&lt; <ref refid="class_c_thread_interrupt" kindref="compound">CThreadInterrupt</ref> &gt;</type>
        <definition>const std::shared_ptr&lt;CThreadInterrupt&gt; m_interrupt</definition>
        <argsstring></argsstring>
        <name>m_interrupt</name>
        <qualifiedname>i2p::sam::Session::m_interrupt</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Cease network activity when this is signaled. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="234" column="27" bodyfile="src/i2p.h" bodystart="234" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classi2p_1_1sam_1_1_session_1a71aaf23d91d7b7a5611738c4f06e3577" prot="private" static="no" mutable="yes">
        <type><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref></type>
        <definition>Mutex m_mutex</definition>
        <argsstring></argsstring>
        <name>m_mutex</name>
        <qualifiedname>i2p::sam::Session::m_mutex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref> protecting the members that can be concurrently accessed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="239" column="19" bodyfile="src/i2p.h" bodystart="239" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classi2p_1_1sam_1_1_session_1a5d689121ab3f1f6672e2dc2cfd7f10b9" prot="private" static="no" mutable="no">
        <type>const bool</type>
        <definition>const bool m_transient</definition>
        <argsstring></argsstring>
        <name>m_transient</name>
        <qualifiedname>i2p::sam::Session::m_transient</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Whether this is a transient session (the I2P private key will not be read or written to disk). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="273" column="16" bodyfile="src/i2p.h" bodystart="273" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a85658cb9a754d70a1fe1ce0d645625c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Session</definition>
        <argsstring>(const fs::path &amp;private_key_file, const Proxy &amp;control_host, std::shared_ptr&lt; CThreadInterrupt &gt; interrupt)</argsstring>
        <name>Session</name>
        <qualifiedname>i2p::sam::Session::Session</qualifiedname>
        <param>
          <type>const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref> &amp;</type>
          <declname>private_key_file</declname>
        </param>
        <param>
          <type>const <ref refid="class_proxy" kindref="compound">Proxy</ref> &amp;</type>
          <declname>control_host</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="class_c_thread_interrupt" kindref="compound">CThreadInterrupt</ref> &gt;</type>
          <declname>interrupt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct a session. This will not initiate any IO, the session will be lazily created later when first used. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">private_key_file</parametername>
</parameternamelist>
<parameterdescription>
<para>Path to a private key file. If the file does not exist then the private key will be generated and saved into the file. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">control_host</parametername>
</parameternamelist>
<parameterdescription>
<para>Location of the SAM proxy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">interrupt</parametername>
</parameternamelist>
<parameterdescription>
<para>If this is signaled then all operations are canceled as soon as possible and executing methods throw an exception. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="68" column="5" bodyfile="src/i2p.cpp" bodystart="120" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a814a19231bc9101a3be5e3dad542333f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Session</definition>
        <argsstring>(const Proxy &amp;control_host, std::shared_ptr&lt; CThreadInterrupt &gt; interrupt)</argsstring>
        <name>Session</name>
        <qualifiedname>i2p::sam::Session::Session</qualifiedname>
        <param>
          <type>const <ref refid="class_proxy" kindref="compound">Proxy</ref> &amp;</type>
          <declname>control_host</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="class_c_thread_interrupt" kindref="compound">CThreadInterrupt</ref> &gt;</type>
          <declname>interrupt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct a transient session which will generate its own I2P private key rather than read the one from disk (it will not be saved on disk either and will be lost once this object is destroyed). This will not initiate any IO, the session will be lazily created later when first used. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">control_host</parametername>
</parameternamelist>
<parameterdescription>
<para>Location of the SAM proxy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">interrupt</parametername>
</parameternamelist>
<parameterdescription>
<para>If this is signaled then all operations are canceled as soon as possible and executing methods throw an exception. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="81" column="5" bodyfile="src/i2p.cpp" bodystart="130" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a12455f5db8475fe429d3ebf3aa84d7eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~Session</definition>
        <argsstring>()</argsstring>
        <name>~Session</name>
        <qualifiedname>i2p::sam::Session::~Session</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroy the session, closing the internally used sockets. The sockets that have been returned by <computeroutput><ref refid="classi2p_1_1sam_1_1_session_1a374ecfa4bb67dfadeeec44e8c1481766" kindref="member">Accept()</ref></computeroutput> or <computeroutput><ref refid="classi2p_1_1sam_1_1_session_1a89c66ea021e473f04482e4871d9e9bf9" kindref="member">Connect()</ref></computeroutput> will not be closed, but they will be closed by the SAM proxy because the session is destroyed. So they will return an error next time we try to read or write to them. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="89" column="5" bodyfile="src/i2p.cpp" bodystart="137" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a96bbb63bd36a0974e6cbf9777b11520e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Listen</definition>
        <argsstring>(Connection &amp;conn) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>Listen</name>
        <qualifiedname>i2p::sam::Session::Listen</qualifiedname>
        <param>
          <type><ref refid="structi2p_1_1_connection" kindref="compound">Connection</ref> &amp;</type>
          <declname>conn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Start listening for an incoming connection. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">conn</parametername>
</parameternamelist>
<parameterdescription>
<para>Upon successful completion the <computeroutput>sock</computeroutput> and <computeroutput>me</computeroutput> members will be set to the listening socket and address. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="97" column="10" bodyfile="src/i2p.cpp" bodystart="143" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a374ecfa4bb67dfadeeec44e8c1481766" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Accept</definition>
        <argsstring>(Connection &amp;conn) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>Accept</name>
        <qualifiedname>i2p::sam::Session::Accept</qualifiedname>
        <param>
          <type><ref refid="structi2p_1_1_connection" kindref="compound">Connection</ref> &amp;</type>
          <declname>conn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Wait for and accept a new incoming connection. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">conn</parametername>
</parameternamelist>
<parameterdescription>
<para>The <computeroutput>sock</computeroutput> member is used for waiting and accepting. Upon successful completion the <computeroutput>peer</computeroutput> member will be set to the address of the incoming peer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="105" column="10" bodyfile="src/i2p.cpp" bodystart="158" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a89c66ea021e473f04482e4871d9e9bf9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Connect</definition>
        <argsstring>(const CService &amp;to, Connection &amp;conn, bool &amp;proxy_error) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>Connect</name>
        <qualifiedname>i2p::sam::Session::Connect</qualifiedname>
        <param>
          <type>const <ref refid="class_c_service" kindref="compound">CService</ref> &amp;</type>
          <declname>to</declname>
        </param>
        <param>
          <type><ref refid="structi2p_1_1_connection" kindref="compound">Connection</ref> &amp;</type>
          <declname>conn</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>proxy_error</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Connect to an I2P peer. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">to</parametername>
</parameternamelist>
<parameterdescription>
<para>Peer to connect to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">conn</parametername>
</parameternamelist>
<parameterdescription>
<para>Established connection. Only set if <computeroutput>true</computeroutput> is returned. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">proxy_error</parametername>
</parameternamelist>
<parameterdescription>
<para>If an error occurs due to proxy or general network failure, then this is set to <computeroutput>true</computeroutput>. If an error occurs due to unreachable peer (likely peer is down), then it is set to <computeroutput>false</computeroutput>. Only set if <computeroutput>false</computeroutput> is returned. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="116" column="10" bodyfile="src/i2p.cpp" bodystart="222" bodyend="279"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a3cc3c95e375f73c875dc5614dba508b6" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>Reply</type>
        <definition>Session::Reply SendRequestAndGetReply</definition>
        <argsstring>(const Sock &amp;sock, const std::string &amp;request, bool check_result_ok=true) const</argsstring>
        <name>SendRequestAndGetReply</name>
        <qualifiedname>i2p::sam::Session::SendRequestAndGetReply</qualifiedname>
        <param>
          <type>const <ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
          <declname>sock</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>request</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>check_result_ok</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Send request and get a reply from the SAM proxy. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sock</parametername>
</parameternamelist>
<parameterdescription>
<para>A socket that is connected to the SAM proxy. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">request</parametername>
</parameternamelist>
<parameterdescription>
<para>Raw request to send, a newline terminator is appended to it. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">check_result_ok</parametername>
</parameternamelist>
<parameterdescription>
<para>If true then after receiving the reply a check is made whether it contains &quot;RESULT=OK&quot; and an exception is thrown if it does not. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if an error occurs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="163" column="11" bodyfile="src/i2p.cpp" bodystart="293" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a61ae66903f20131d9865ffe95ca169cb" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="class_sock" kindref="compound">Sock</ref> &gt;</type>
        <definition>std::unique_ptr&lt; Sock &gt; Hello</definition>
        <argsstring>() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>Hello</name>
        <qualifiedname>i2p::sam::Session::Hello</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Open a new connection to the SAM proxy. <simplesect kind="return"><para>a connected socket </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if an error occurs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="172" column="21" bodyfile="src/i2p.cpp" bodystart="329" bodyend="340"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a06f25cc6ffb222223fb39732f6c5a482" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CheckControlSock</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>CheckControlSock</name>
        <qualifiedname>i2p::sam::Session::CheckControlSock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check the control socket for errors and possibly disconnect. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="177" column="10" bodyfile="src/i2p.cpp" bodystart="342" bodyend="351"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1af9ac8699496f82e54ef4ce06f3cd093b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void DestGenerate</definition>
        <argsstring>(const Sock &amp;sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>DestGenerate</name>
        <qualifiedname>i2p::sam::Session::DestGenerate</qualifiedname>
        <param>
          <type>const <ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
          <declname>sock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate a new destination with the SAM proxy and set <computeroutput>m_private_key</computeroutput> to it. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sock</parametername>
</parameternamelist>
<parameterdescription>
<para>Socket to use for talking to the SAM proxy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if an error occurs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="184" column="10" bodyfile="src/i2p.cpp" bodystart="353" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1ad6f46a2c16e7063ee6323a70b429566d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void GenerateAndSavePrivateKey</definition>
        <argsstring>(const Sock &amp;sock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>GenerateAndSavePrivateKey</name>
        <qualifiedname>i2p::sam::Session::GenerateAndSavePrivateKey</qualifiedname>
        <param>
          <type>const <ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
          <declname>sock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generate a new destination with the SAM proxy, set <computeroutput>m_private_key</computeroutput> to it and save it on disk to <computeroutput>m_private_key_file</computeroutput>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">sock</parametername>
</parameternamelist>
<parameterdescription>
<para>Socket to use for talking to the SAM proxy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if an error occurs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="192" column="10" bodyfile="src/i2p.cpp" bodystart="364" bodyend="374"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a3e65ec601a07982a3ca4aa4b61aa925c" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacei2p_1a0c2c8c24e046352a206da6a3a0080fb3" kindref="member">Binary</ref></type>
        <definition>Binary MyDestination</definition>
        <argsstring>() const EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>MyDestination</name>
        <qualifiedname>i2p::sam::Session::MyDestination</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Derive own destination from <computeroutput>m_private_key</computeroutput>. <simplesect kind="see"><para><ulink url="https://geti2p.net/spec/common-structures#destination">https://geti2p.net/spec/common-structures#destination</ulink> </para>
</simplesect>
<simplesect kind="return"><para>an I2P destination </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="199" column="12" bodyfile="src/i2p.cpp" bodystart="376" bodyend="406"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a89ed5812ce8c644406c059d862a8a300" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void CreateIfNotCreatedAlready</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>CreateIfNotCreatedAlready</name>
        <qualifiedname>i2p::sam::Session::CreateIfNotCreatedAlready</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create the session if not already created. Reads the private key file and connects to the SAM proxy. <parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if an error occurs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="206" column="10" bodyfile="src/i2p.cpp" bodystart="408" bodyend="459"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1aaf9d95011a0fdb4aabe5dbf7f9a11c8d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="class_sock" kindref="compound">Sock</ref> &gt;</type>
        <definition>std::unique_ptr&lt; Sock &gt; StreamAccept</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>StreamAccept</name>
        <qualifiedname>i2p::sam::Session::StreamAccept</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Open a new connection to the SAM proxy and issue &quot;STREAM ACCEPT&quot; request using the existing session id. <simplesect kind="return"><para>the idle socket that is waiting for a peer to connect to us </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if an error occurs </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="214" column="21" bodyfile="src/i2p.cpp" bodystart="461" bodyend="480"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1ac241bf030069a227043275c909c243d4" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Disconnect</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>Disconnect</name>
        <qualifiedname>i2p::sam::Session::Disconnect</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroy the session, closing the internally used sockets. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="219" column="10" bodyfile="src/i2p.cpp" bodystart="482" bodyend="493"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a8e13c0c44ff9d773f7d5cb13673bf63f" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacei2p_1a0c2c8c24e046352a206da6a3a0080fb3" kindref="member">Binary</ref> m_private_key</type>
        <definition>Binary m_private_key GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>i2p::sam::Session::GUARDED_BY</qualifiedname>
        <param>
          <type>m_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The private key of this peer. <simplesect kind="see"><para>The reply to the &quot;DEST GENERATE&quot; <ref refid="bitcoin-wallet_8cpp_1a64b0c5844a38fc862dcb5b4e30b1ca49" kindref="member">command</ref> in <ulink url="https://geti2p.net/en/docs/api/samv3">https://geti2p.net/en/docs/api/samv3</ulink> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="245" column="26"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1aff808764c252538c101d4f5471cbe692" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="class_sock" kindref="compound">Sock</ref> &gt; m_control_sock</type>
        <definition>std::unique_ptr&lt; Sock &gt; m_control_sock GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>i2p::sam::Session::GUARDED_BY</qualifiedname>
        <param>
          <type>m_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>SAM control socket. Used to connect to the I2P SAM service and create a session (&quot;SESSION CREATE&quot;). With the established session id we later open other connections to the SAM service to accept incoming I2P connections and make outgoing ones. If not connected then this unique_ptr will be empty. See <ulink url="https://geti2p.net/en/docs/api/samv3">https://geti2p.net/en/docs/api/samv3</ulink> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="256" column="36"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1adad9b35ed802f20329240ed49ae457c3" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_c_service" kindref="compound">CService</ref> m_my_addr</type>
        <definition>CService m_my_addr GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>i2p::sam::Session::GUARDED_BY</qualifiedname>
        <param>
          <type>m_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Our .b32.i2p address. <ref refid="class_derived" kindref="compound">Derived</ref> from <computeroutput>m_private_key</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="262" column="24"/>
      </memberdef>
      <memberdef kind="function" id="classi2p_1_1sam_1_1_session_1a58853fc34d6d6694de936fd8cc4da0cb" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::string m_session_id</type>
        <definition>std::string m_session_id GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>i2p::sam::Session::GUARDED_BY</qualifiedname>
        <param>
          <type>m_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>SAM session id. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/i2p.h" line="267" column="30"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>I2P SAM session. </para>
    </detaileddescription>
    <location file="src/i2p.h" line="56" column="1" bodyfile="src/i2p.h" bodystart="57" bodyend="274"/>
    <listofallmembers>
      <member refid="classi2p_1_1sam_1_1_session_1a374ecfa4bb67dfadeeec44e8c1481766" prot="public" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Accept</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a06f25cc6ffb222223fb39732f6c5a482" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>CheckControlSock</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a89c66ea021e473f04482e4871d9e9bf9" prot="public" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Connect</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a89ed5812ce8c644406c059d862a8a300" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>CreateIfNotCreatedAlready</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1af9ac8699496f82e54ef4ce06f3cd093b" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>DestGenerate</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1ac241bf030069a227043275c909c243d4" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Disconnect</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1ad6f46a2c16e7063ee6323a70b429566d" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>GenerateAndSavePrivateKey</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a8e13c0c44ff9d773f7d5cb13673bf63f" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>GUARDED_BY</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1aff808764c252538c101d4f5471cbe692" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>GUARDED_BY</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1adad9b35ed802f20329240ed49ae457c3" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>GUARDED_BY</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a58853fc34d6d6694de936fd8cc4da0cb" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>GUARDED_BY</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a61ae66903f20131d9865ffe95ca169cb" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Hello</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a96bbb63bd36a0974e6cbf9777b11520e" prot="public" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Listen</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a1613dc00d2e88085669838f23e319e6d" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>m_control_host</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1afedab8eaf79b0b0971c77ce2db573463" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>m_interrupt</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a71aaf23d91d7b7a5611738c4f06e3577" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>m_mutex</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a70d78a175858ab01a83ead14bf4585ab" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>m_private_key_file</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a5d689121ab3f1f6672e2dc2cfd7f10b9" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>m_transient</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a3e65ec601a07982a3ca4aa4b61aa925c" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>MyDestination</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a3cc3c95e375f73c875dc5614dba508b6" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>SendRequestAndGetReply</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a85658cb9a754d70a1fe1ce0d645625c1" prot="public" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Session</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a814a19231bc9101a3be5e3dad542333f" prot="public" virt="non-virtual"><scope>i2p::sam::Session</scope><name>Session</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1aaf9d95011a0fdb4aabe5dbf7f9a11c8d" prot="private" virt="non-virtual"><scope>i2p::sam::Session</scope><name>StreamAccept</name></member>
      <member refid="classi2p_1_1sam_1_1_session_1a12455f5db8475fe429d3ebf3aa84d7eb" prot="public" virt="non-virtual"><scope>i2p::sam::Session</scope><name>~Session</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
