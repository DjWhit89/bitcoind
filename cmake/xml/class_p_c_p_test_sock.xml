<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_p_c_p_test_sock" kind="class" language="C++" prot="public" final="yes">
    <compoundname>PCPTestSock</compoundname>
    <basecompoundref refid="class_sock" prot="public" virt="non-virtual">Sock</basecompoundref>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_p_c_p_test_sock_1a143321d4d0d1bdcda3701f6140a029c2" prot="private" static="no" mutable="no">
        <type>const std::vector&lt; <ref refid="struct_test_op" kindref="compound">TestOp</ref> &gt;</type>
        <definition>const std::vector&lt;TestOp&gt; m_script</definition>
        <argsstring></argsstring>
        <name>m_script</name>
        <qualifiedname>PCPTestSock::m_script</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="222" column="23" bodyfile="src/test/pcp_tests.cpp" bodystart="222" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1ad592ac22f45961af3f03d2f6299a345d" prot="private" static="no" mutable="yes">
        <type>size_t</type>
        <definition>size_t m_script_ptr</definition>
        <argsstring></argsstring>
        <name>m_script_ptr</name>
        <qualifiedname>PCPTestSock::m_script_ptr</qualifiedname>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="223" column="20" bodyfile="src/test/pcp_tests.cpp" bodystart="223" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1a7120f7387b6a4035e31ae3b392d9fd06" prot="private" static="no" mutable="yes">
        <type>std::chrono::milliseconds</type>
        <definition>std::chrono::milliseconds m_time_left</definition>
        <argsstring></argsstring>
        <name>m_time_left</name>
        <qualifiedname>PCPTestSock::m_time_left</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="224" column="39" bodyfile="src/test/pcp_tests.cpp" bodystart="224" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1ab1548a718bc29451100da5876aa57c15" prot="private" static="no" mutable="yes">
        <type>std::chrono::milliseconds</type>
        <definition>std::chrono::milliseconds m_time</definition>
        <argsstring></argsstring>
        <name>m_time</name>
        <qualifiedname>PCPTestSock::m_time</qualifiedname>
        <initializer>{<ref refid="struct_mockable_steady_clock_1a2390269ab525d633b303f84528593f84" kindref="member">MockableSteadyClock::INITIAL_MOCK_TIME</ref>}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="225" column="39" bodyfile="src/test/pcp_tests.cpp" bodystart="225" bodyend="225"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1a7fb58ea70e4937457a6a0c252cd5c4bb" prot="private" static="no" mutable="yes">
        <type>bool</type>
        <definition>bool m_connected</definition>
        <argsstring></argsstring>
        <name>m_connected</name>
        <qualifiedname>PCPTestSock::m_connected</qualifiedname>
        <initializer>{false}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="226" column="18" bodyfile="src/test/pcp_tests.cpp" bodystart="226" bodyend="226"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1acd864ec258fdf610108731b500871e4d" prot="private" static="no" mutable="yes">
        <type><ref refid="class_c_service" kindref="compound">CService</ref></type>
        <definition>CService m_bound</definition>
        <argsstring></argsstring>
        <name>m_bound</name>
        <qualifiedname>PCPTestSock::m_bound</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="227" column="22" bodyfile="src/test/pcp_tests.cpp" bodystart="227" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1ab52d834ff9827e4f6b046987e610309d" prot="private" static="no" mutable="yes">
        <type><ref refid="class_c_net_addr" kindref="compound">CNetAddr</ref></type>
        <definition>CNetAddr m_local_ip</definition>
        <argsstring></argsstring>
        <name>m_local_ip</name>
        <qualifiedname>PCPTestSock::m_local_ip</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="228" column="22" bodyfile="src/test/pcp_tests.cpp" bodystart="228" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_p_c_p_test_sock_1a9c3a5677acf714091fd78df63c9e6995" prot="private" static="no" mutable="yes">
        <type><ref refid="class_c_net_addr" kindref="compound">CNetAddr</ref></type>
        <definition>CNetAddr m_gateway_ip</definition>
        <argsstring></argsstring>
        <name>m_gateway_ip</name>
        <qualifiedname>PCPTestSock::m_gateway_ip</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="229" column="22" bodyfile="src/test/pcp_tests.cpp" bodystart="229" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_p_c_p_test_sock_1a50f9e698d15b0f78804e32c2e39b3f81" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>PCPTestSock</definition>
        <argsstring>(const CNetAddr &amp;local_ip, const CNetAddr &amp;gateway_ip, const std::vector&lt; TestOp &gt; &amp;script)</argsstring>
        <name>PCPTestSock</name>
        <qualifiedname>PCPTestSock::PCPTestSock</qualifiedname>
        <param>
          <type>const <ref refid="class_c_net_addr" kindref="compound">CNetAddr</ref> &amp;</type>
          <declname>local_ip</declname>
        </param>
        <param>
          <type>const <ref refid="class_c_net_addr" kindref="compound">CNetAddr</ref> &amp;</type>
          <declname>gateway_ip</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="struct_test_op" kindref="compound">TestOp</ref> &gt; &amp;</type>
          <declname>script</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="88" column="14" bodyfile="src/test/pcp_tests.cpp" bodystart="88" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a9a8dd74dd909f175c3cc342c65e3e19c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="class_p_c_p_test_sock" kindref="compound">PCPTestSock</ref> &amp;</type>
        <definition>PCPTestSock &amp; operator=</definition>
        <argsstring>(Sock &amp;&amp;other) override</argsstring>
        <name>operator=</name>
        <qualifiedname>PCPTestSock::operator=</qualifiedname>
        <reimplements refid="class_sock_1aed8298a36ba25760ceb8d1207a39f8db">operator=</reimplements>
        <param>
          <type><ref refid="class_sock" kindref="compound">Sock</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move assignment operator, grab the socket from another object and close ours (if set). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="98" column="17" bodyfile="src/test/pcp_tests.cpp" bodystart="98" bodyend="102"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1ac2038678b0e7c9edc578bc68a5871b17" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>ssize_t</type>
        <definition>ssize_t Send</definition>
        <argsstring>(const void *data, size_t len, int) const override</argsstring>
        <name>Send</name>
        <qualifiedname>PCPTestSock::Send</qualifiedname>
        <reimplements refid="class_sock_1ad50f4b43d2b968d64162193e9254d6b5">Send</reimplements>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>send(2) wrapper. Equivalent to <computeroutput>send(m_socket, data, len, flags);</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="104" column="13" bodyfile="src/test/pcp_tests.cpp" bodystart="104" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1acc57da900d09bf26675b155ff9f4ac89" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>ssize_t</type>
        <definition>ssize_t Recv</definition>
        <argsstring>(void *buf, size_t len, int flags) const override</argsstring>
        <name>Recv</name>
        <qualifiedname>PCPTestSock::Recv</qualifiedname>
        <reimplements refid="class_sock_1ad5d478226aba69810d73757744e13317">Recv</reimplements>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>recv(2) wrapper. Equivalent to <computeroutput>recv(m_socket, buf, len, flags);</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="122" column="13" bodyfile="src/test/pcp_tests.cpp" bodystart="122" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a4c7f5777ead2f1ab3b2d80669b5b3925" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int Connect</definition>
        <argsstring>(const sockaddr *sa, socklen_t sa_len) const override</argsstring>
        <name>Connect</name>
        <qualifiedname>PCPTestSock::Connect</qualifiedname>
        <reimplements refid="class_sock_1a5f5be77492fb494cd6b2effd50d18435">Connect</reimplements>
        <param>
          <type>const sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>connect(2) wrapper. Equivalent to <computeroutput>connect(m_socket, addr, addrlen)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="137" column="9" bodyfile="src/test/pcp_tests.cpp" bodystart="137" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1ac775d2a939e07c034c199227da9a4f26" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int Bind</definition>
        <argsstring>(const sockaddr *sa, socklen_t sa_len) const override</argsstring>
        <name>Bind</name>
        <qualifiedname>PCPTestSock::Bind</qualifiedname>
        <reimplements refid="class_sock_1ae84297efb7d81f94d5c839a4b3b2abd8">Bind</reimplements>
        <param>
          <type>const sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>bind(2) wrapper. Equivalent to <computeroutput>bind(m_socket, addr, addr_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="152" column="9" bodyfile="src/test/pcp_tests.cpp" bodystart="152" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a172d2ef5e777674d5445aac1387bab41" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int Listen</definition>
        <argsstring>(int) const override</argsstring>
        <name>Listen</name>
        <qualifiedname>PCPTestSock::Listen</qualifiedname>
        <reimplements refid="class_sock_1a88c18587b3e874ee2a5fde74d6bb3cc2">Listen</reimplements>
        <param>
          <type>int</type>
          <declname>backlog</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>listen(2) wrapper. Equivalent to <computeroutput>listen(m_socket, backlog)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="165" column="9" bodyfile="src/test/pcp_tests.cpp" bodystart="165" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a36b4abe351193181c883d465020aa101" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>std::unique_ptr&lt; <ref refid="class_sock" kindref="compound">Sock</ref> &gt;</type>
        <definition>std::unique_ptr&lt; Sock &gt; Accept</definition>
        <argsstring>(sockaddr *addr, socklen_t *addr_len) const override</argsstring>
        <name>Accept</name>
        <qualifiedname>PCPTestSock::Accept</qualifiedname>
        <reimplements refid="class_sock_1a0478fe1f85686563dafce68f30878fa6">Accept</reimplements>
        <param>
          <type>sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>accept(2) wrapper. Equivalent to <computeroutput>std::make_unique&lt;<ref refid="class_sock" kindref="compound">Sock</ref>&gt;(accept(m_socket, addr, addr_len))</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. The returned unique_ptr is empty if <computeroutput>accept()</computeroutput> failed in which case errno will be set. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="167" column="21" bodyfile="src/test/pcp_tests.cpp" bodystart="167" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a5b5845e5aca634a6f79c82afecbc37fd" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int GetSockOpt</definition>
        <argsstring>(int level, int opt_name, void *opt_val, socklen_t *opt_len) const override</argsstring>
        <name>GetSockOpt</name>
        <qualifiedname>PCPTestSock::GetSockOpt</qualifiedname>
        <reimplements refid="class_sock_1a36a481d2609f5c4626a8c6136ee1f26f">GetSockOpt</reimplements>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int</type>
          <declname>opt_name</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>opt_val</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>opt_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>getsockopt(2) wrapper. Equivalent to <computeroutput>getsockopt(m_socket, level, opt_name, opt_val, opt_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="172" column="9" bodyfile="src/test/pcp_tests.cpp" bodystart="172" bodyend="175"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a94f895afc687c06525ac15ccb10ce2b0" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int SetSockOpt</definition>
        <argsstring>(int, int, const void *, socklen_t) const override</argsstring>
        <name>SetSockOpt</name>
        <qualifiedname>PCPTestSock::SetSockOpt</qualifiedname>
        <reimplements refid="class_sock_1a72351052778d8f7107546f9e32159dc9">SetSockOpt</reimplements>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int</type>
          <declname>opt_name</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>opt_val</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>opt_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>setsockopt(2) wrapper. Equivalent to <computeroutput>setsockopt(m_socket, level, opt_name, opt_val, opt_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="177" column="9" bodyfile="src/test/pcp_tests.cpp" bodystart="177" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a16930ee6ded3a8fe47a7adaf178affff" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>int</type>
        <definition>int GetSockName</definition>
        <argsstring>(sockaddr *name, socklen_t *name_len) const override</argsstring>
        <name>GetSockName</name>
        <qualifiedname>PCPTestSock::GetSockName</qualifiedname>
        <reimplements refid="class_sock_1a8544fa939816100e03ecba0a79fde2b1">GetSockName</reimplements>
        <param>
          <type>sockaddr *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>name_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>getsockname(2) wrapper. Equivalent to <computeroutput>getsockname(m_socket, name, name_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="179" column="9" bodyfile="src/test/pcp_tests.cpp" bodystart="179" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a8a6517d31b9c4c9a895c1cbb83387c86" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool SetNonBlocking</definition>
        <argsstring>() const override</argsstring>
        <name>SetNonBlocking</name>
        <qualifiedname>PCPTestSock::SetNonBlocking</qualifiedname>
        <reimplements refid="class_sock_1a11c30b8078693d82b98b44a8b81bb71d">SetNonBlocking</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the non-blocking option on the socket. <simplesect kind="return"><para>true if set successfully </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="185" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="185" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a598fdcc705deaa438fba72650d51fe20" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool IsSelectable</definition>
        <argsstring>() const override</argsstring>
        <name>IsSelectable</name>
        <qualifiedname>PCPTestSock::IsSelectable</qualifiedname>
        <reimplements refid="class_sock_1a39fd9751352b6030c42c342066a1b887">IsSelectable</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if the underlying socket can be used for <computeroutput>select(2)</computeroutput> (or the <computeroutput><ref refid="class_p_c_p_test_sock_1aa9d44903b57505d9f8765404cb04f35f" kindref="member">Wait()</ref></computeroutput> method). <simplesect kind="return"><para>true if selectable </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="187" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="187" bodyend="187"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1aa9d44903b57505d9f8765404cb04f35f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool Wait</definition>
        <argsstring>(std::chrono::milliseconds timeout, Event requested, Event *occurred=nullptr) const override</argsstring>
        <name>Wait</name>
        <qualifiedname>PCPTestSock::Wait</qualifiedname>
        <reimplements refid="class_sock_1a851a09613d347a157da032137020065a">Wait</reimplements>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref></type>
          <declname>requested</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref> *</type>
          <declname>occurred</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Wait for readiness for input (recv) or output (send). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait this much for at least one of the requested events to occur. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">requested</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait for those events, bitwise-or of <computeroutput><ref refid="class_sock_1ae15d539512bccb6583fc75310b0d2f86" kindref="member">RECV</ref></computeroutput> and <computeroutput><ref refid="class_sock_1ac739f9398eaa67718961a5ac331fba4a" kindref="member">SEND</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">occurred</parametername>
</parameternamelist>
<parameterdescription>
<para>If not nullptr and the function returns <computeroutput>true</computeroutput>, then this indicates which of the requested events occurred (<computeroutput><ref refid="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" kindref="member">ERR</ref></computeroutput> will be added, even if not requested, if an exceptional event occurs on the socket). A timeout is indicated by return value of <computeroutput>true</computeroutput> and <computeroutput>occurred</computeroutput> being set to 0. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success (or timeout, if <computeroutput>occurred</computeroutput> of 0 is returned), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="189" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="189" bodyend="209"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1af35a7663942bba32c947f387114bc068" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool WaitMany</definition>
        <argsstring>(std::chrono::milliseconds timeout, EventsPerSock &amp;events_per_sock) const override</argsstring>
        <name>WaitMany</name>
        <qualifiedname>PCPTestSock::WaitMany</qualifiedname>
        <reimplements refid="class_sock_1a6ec7a34cbf87594ed9b7eac590cf965f">WaitMany</reimplements>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" kindref="member">EventsPerSock</ref> &amp;</type>
          <declname>events_per_sock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as <computeroutput><ref refid="class_p_c_p_test_sock_1aa9d44903b57505d9f8765404cb04f35f" kindref="member">Wait()</ref></computeroutput>, but wait on many sockets within the same timeout. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait this long for at least one of the requested events to occur. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">events_per_sock</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait for the requested events on these sockets and set <computeroutput>occurred</computeroutput> for the events that actually occurred. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success (or timeout, if all <computeroutput>what[].occurred</computeroutput> are returned as 0), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="211" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="211" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1aa18949f10a1aafa5498ee991e5f61fcd" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>bool IsConnected</definition>
        <argsstring>(std::string &amp;) const override</argsstring>
        <name>IsConnected</name>
        <qualifiedname>PCPTestSock::IsConnected</qualifiedname>
        <reimplements refid="class_sock_1a395f618148d26468dc12324ffcddbd4a">IsConnected</reimplements>
        <param>
          <type>std::string &amp;</type>
          <declname>errmsg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if still connected. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">errmsg</parametername>
</parameternamelist>
<parameterdescription>
<para>The error string, if the socket has been disconnected. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if connected </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="216" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="216" bodyend="219"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_p_c_p_test_sock_1a89c2d2ae497ad75724d7cac49692a0ac" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void ElapseTime</definition>
        <argsstring>(std::chrono::milliseconds duration) const</argsstring>
        <name>ElapseTime</name>
        <qualifiedname>PCPTestSock::ElapseTime</qualifiedname>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>duration</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="231" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="231" bodyend="235"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a534e4d8f7425bbcdfbc6df46609ee809" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool AtEndOfScript</definition>
        <argsstring>() const</argsstring>
        <name>AtEndOfScript</name>
        <qualifiedname>PCPTestSock::AtEndOfScript</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="237" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="237" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a113f50011f54eeb611c7b6ef04b213ee" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="struct_test_op" kindref="compound">TestOp</ref> &amp;</type>
        <definition>const TestOp &amp; CurOp</definition>
        <argsstring>() const</argsstring>
        <name>CurOp</name>
        <qualifiedname>PCPTestSock::CurOp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="238" column="18" bodyfile="src/test/pcp_tests.cpp" bodystart="238" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a26632d9f75d2f283cf7331e39db03008" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void PrepareOp</definition>
        <argsstring>() const</argsstring>
        <name>PrepareOp</name>
        <qualifiedname>PCPTestSock::PrepareOp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="243" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="243" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1ae7a019e69a1c94087baf2fe8c20b370b" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void AdvanceOp</definition>
        <argsstring>() const</argsstring>
        <name>AdvanceOp</name>
        <qualifiedname>PCPTestSock::AdvanceOp</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="248" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="248" bodyend="252"/>
      </memberdef>
      <memberdef kind="function" id="class_p_c_p_test_sock_1a176f4887add2c148e26446da5b358312" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void FailScript</definition>
        <argsstring>() const</argsstring>
        <name>FailScript</name>
        <qualifiedname>PCPTestSock::FailScript</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/pcp_tests.cpp" line="254" column="10" bodyfile="src/test/pcp_tests.cpp" bodystart="254" bodyend="254"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Simple scripted UDP server emulation for testing. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>PCPTestSock</label>
        <link refid="class_p_c_p_test_sock"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>Sock</label>
        <link refid="class_sock"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>PCPTestSock</label>
        <link refid="class_p_c_p_test_sock"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>Sock</label>
        <link refid="class_sock"/>
      </node>
    </collaborationgraph>
    <location file="src/test/pcp_tests.cpp" line="83" column="1" bodyfile="src/test/pcp_tests.cpp" bodystart="84" bodyend="255"/>
    <listofallmembers>
      <member refid="class_p_c_p_test_sock_1a36b4abe351193181c883d465020aa101" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Accept</name></member>
      <member refid="class_p_c_p_test_sock_1ae7a019e69a1c94087baf2fe8c20b370b" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>AdvanceOp</name></member>
      <member refid="class_p_c_p_test_sock_1a534e4d8f7425bbcdfbc6df46609ee809" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>AtEndOfScript</name></member>
      <member refid="class_p_c_p_test_sock_1ac775d2a939e07c034c199227da9a4f26" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Bind</name></member>
      <member refid="class_p_c_p_test_sock_1a4c7f5777ead2f1ab3b2d80669b5b3925" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Connect</name></member>
      <member refid="class_p_c_p_test_sock_1a113f50011f54eeb611c7b6ef04b213ee" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>CurOp</name></member>
      <member refid="class_p_c_p_test_sock_1a89c2d2ae497ad75724d7cac49692a0ac" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>ElapseTime</name></member>
      <member refid="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>ERR</name></member>
      <member refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>Event</name></member>
      <member refid="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>EventsPerSock</name></member>
      <member refid="class_p_c_p_test_sock_1a176f4887add2c148e26446da5b358312" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>FailScript</name></member>
      <member refid="class_p_c_p_test_sock_1a16930ee6ded3a8fe47a7adaf178affff" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>GetSockName</name></member>
      <member refid="class_p_c_p_test_sock_1a5b5845e5aca634a6f79c82afecbc37fd" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>GetSockOpt</name></member>
      <member refid="class_p_c_p_test_sock_1aa18949f10a1aafa5498ee991e5f61fcd" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>IsConnected</name></member>
      <member refid="class_p_c_p_test_sock_1a598fdcc705deaa438fba72650d51fe20" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>IsSelectable</name></member>
      <member refid="class_p_c_p_test_sock_1a172d2ef5e777674d5445aac1387bab41" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Listen</name></member>
      <member refid="class_p_c_p_test_sock_1acd864ec258fdf610108731b500871e4d" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_bound</name></member>
      <member refid="class_p_c_p_test_sock_1a7fb58ea70e4937457a6a0c252cd5c4bb" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_connected</name></member>
      <member refid="class_p_c_p_test_sock_1a9c3a5677acf714091fd78df63c9e6995" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_gateway_ip</name></member>
      <member refid="class_p_c_p_test_sock_1ab52d834ff9827e4f6b046987e610309d" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_local_ip</name></member>
      <member refid="class_p_c_p_test_sock_1a143321d4d0d1bdcda3701f6140a029c2" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_script</name></member>
      <member refid="class_p_c_p_test_sock_1ad592ac22f45961af3f03d2f6299a345d" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_script_ptr</name></member>
      <member refid="class_sock_1a453ef0b211974cc0b3f59651f2759a85" prot="protected" virt="non-virtual"><scope>PCPTestSock</scope><name>m_socket</name></member>
      <member refid="class_p_c_p_test_sock_1ab1548a718bc29451100da5876aa57c15" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_time</name></member>
      <member refid="class_p_c_p_test_sock_1a7120f7387b6a4035e31ae3b392d9fd06" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>m_time_left</name></member>
      <member refid="class_p_c_p_test_sock_1a9a8dd74dd909f175c3cc342c65e3e19c" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>operator=</name></member>
      <member refid="class_sock_1a4c90c4a9a6886cb68a9ee851522afff1" prot="public" virt="non-virtual" ambiguityscope="Sock::"><scope>PCPTestSock</scope><name>operator=</name></member>
      <member refid="class_sock_1a0e4e0f6358b1a1c9d549037d265cc729" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>operator==</name></member>
      <member refid="class_p_c_p_test_sock_1a50f9e698d15b0f78804e32c2e39b3f81" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>PCPTestSock</name></member>
      <member refid="class_p_c_p_test_sock_1a26632d9f75d2f283cf7331e39db03008" prot="private" virt="non-virtual"><scope>PCPTestSock</scope><name>PrepareOp</name></member>
      <member refid="class_sock_1ae15d539512bccb6583fc75310b0d2f86" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>RECV</name></member>
      <member refid="class_p_c_p_test_sock_1acc57da900d09bf26675b155ff9f4ac89" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Recv</name></member>
      <member refid="class_sock_1a27107f318fb56aa730ab7572ac613479" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>RecvUntilTerminator</name></member>
      <member refid="class_sock_1ac739f9398eaa67718961a5ac331fba4a" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>SEND</name></member>
      <member refid="class_p_c_p_test_sock_1ac2038678b0e7c9edc578bc68a5871b17" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Send</name></member>
      <member refid="class_sock_1a43f09a43a02f01718f04fd139c2a5ed4" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>SendComplete</name></member>
      <member refid="class_sock_1a885ca2c5b4d6185c0393595967115e6d" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>SendComplete</name></member>
      <member refid="class_p_c_p_test_sock_1a8a6517d31b9c4c9a895c1cbb83387c86" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>SetNonBlocking</name></member>
      <member refid="class_p_c_p_test_sock_1a94f895afc687c06525ac15ccb10ce2b0" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>SetSockOpt</name></member>
      <member refid="class_sock_1aa514692e524d2d55d80976eac6456d12" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>Sock</name></member>
      <member refid="class_sock_1a76264c08d7dff8a6c0521733d5bd850c" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>Sock</name></member>
      <member refid="class_sock_1a000e1d0f0c23801b9a15043312d90b15" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>Sock</name></member>
      <member refid="class_sock_1a014eef261ec754e8e3586d5d11f260fb" prot="public" virt="non-virtual"><scope>PCPTestSock</scope><name>Sock</name></member>
      <member refid="class_p_c_p_test_sock_1aa9d44903b57505d9f8765404cb04f35f" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>Wait</name></member>
      <member refid="class_p_c_p_test_sock_1af35a7663942bba32c947f387114bc068" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>WaitMany</name></member>
      <member refid="class_sock_1a6c6d5559856121d4b1a18465e2901c94" prot="public" virt="virtual"><scope>PCPTestSock</scope><name>~Sock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
