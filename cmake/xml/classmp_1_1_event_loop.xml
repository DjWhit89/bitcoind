<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classmp_1_1_event_loop" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>mp::EventLoop</compoundname>
    <includes refid="proxy-io_8h" local="no">proxy-io.h</includes>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a2a779802443c51d72db5bd158c31c964" prot="public" static="no" mutable="no">
        <type>const char *</type>
        <definition>const char* m_exe_name</definition>
        <argsstring></argsstring>
        <name>m_exe_name</name>
        <qualifiedname>mp::EventLoop::m_exe_name</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Process name included in thread names so combined debug output from multiple processes is easier to understand. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="271" column="16" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="271" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1aaee8fe6bf715daa70d55a732218dcfe5" prot="public" static="no" mutable="no">
        <type>std::thread::id</type>
        <definition>std::thread::id m_thread_id</definition>
        <argsstring></argsstring>
        <name>m_thread_id</name>
        <qualifiedname>mp::EventLoop::m_thread_id</qualifiedname>
        <initializer>= std::this_thread::get_id()</initializer>
        <briefdescription>
<para>ID of the event loop thread. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="274" column="21" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="274" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a7ff706a17a3571c9b28db11e81dc7585" prot="public" static="no" mutable="no">
        <type>std::thread</type>
        <definition>std::thread m_async_thread</definition>
        <argsstring></argsstring>
        <name>m_async_thread</name>
        <qualifiedname>mp::EventLoop::m_async_thread</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Handle of an async worker thread. Joined on destruction. Unset if async method has not been called. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="278" column="17" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="278" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a5ca6d7b6e9cca718db8c78de06dde777" prot="public" static="no" mutable="no">
        <type>int</type>
        <definition>int m_wait_fd</definition>
        <argsstring></argsstring>
        <name>m_wait_fd</name>
        <qualifiedname>mp::EventLoop::m_wait_fd</qualifiedname>
        <initializer>= -1</initializer>
        <briefdescription>
<para>Pipe read handle used to wake up the event loop thread. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="287" column="9" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="287" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a59f59d4a0735009e1d98f835eeccdb87" prot="public" static="no" mutable="no">
        <type>int</type>
        <definition>int m_post_fd</definition>
        <argsstring></argsstring>
        <name>m_post_fd</name>
        <qualifiedname>mp::EventLoop::m_post_fd</qualifiedname>
        <initializer>= -1</initializer>
        <briefdescription>
<para>Pipe write handle used to wake up the event loop thread. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="290" column="9" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="290" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" prot="public" static="no" mutable="no">
        <type><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref></type>
        <definition>Mutex m_mutex</definition>
        <argsstring></argsstring>
        <name>m_mutex</name>
        <qualifiedname>mp::EventLoop::m_mutex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref> and condition variable used to post tasks to event loop and async thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="298" column="11" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="298" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1accca0ab294feb9061406ae9c73a3ceb5" prot="public" static="no" mutable="no">
        <type>std::condition_variable</type>
        <definition>std::condition_variable m_cv</definition>
        <argsstring></argsstring>
        <name>m_cv</name>
        <qualifiedname>mp::EventLoop::m_cv</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="299" column="29" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="299" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1ae9ed3a7b20562f71d91760034e7100f1" prot="public" static="no" mutable="no">
        <type>kj::AsyncIoContext</type>
        <definition>kj::AsyncIoContext m_io_context</definition>
        <argsstring></argsstring>
        <name>m_io_context</name>
        <qualifiedname>mp::EventLoop::m_io_context</qualifiedname>
        <briefdescription>
<para>Capnp IO context. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="302" column="24" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="302" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1aa3a0b29328e0fc0ec8b26132feb0fcc5" prot="public" static="no" mutable="no">
        <type><ref refid="classmp_1_1_logging_error_handler" kindref="compound">LoggingErrorHandler</ref></type>
        <definition>LoggingErrorHandler m_error_handler</definition>
        <argsstring></argsstring>
        <name>m_error_handler</name>
        <qualifiedname>mp::EventLoop::m_error_handler</qualifiedname>
        <initializer>{*this}</initializer>
        <briefdescription>
<para>Capnp error handler. Needs to outlive m_task_set. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="305" column="25" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="305" bodyend="305"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a4867e4e832e2d05e777ed32a795214ad" prot="public" static="no" mutable="no">
        <type>std::unique_ptr&lt; kj::TaskSet &gt;</type>
        <definition>std::unique_ptr&lt;kj::TaskSet&gt; m_task_set</definition>
        <argsstring></argsstring>
        <name>m_task_set</name>
        <qualifiedname>mp::EventLoop::m_task_set</qualifiedname>
        <briefdescription>
<para>Capnp list of pending promises. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="308" column="21" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="308" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1ace117e2546e02ad25eb0044315aa4ac9" prot="public" static="no" mutable="no">
        <type>std::list&lt; <ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> &gt;</type>
        <definition>std::list&lt;Connection&gt; m_incoming_connections</definition>
        <argsstring></argsstring>
        <name>m_incoming_connections</name>
        <qualifiedname>mp::EventLoop::m_incoming_connections</qualifiedname>
        <briefdescription>
<para>List of connections. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="311" column="15" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="311" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1ab1f44d16de891fa65b054ee4ead90294" prot="public" static="no" mutable="no">
        <type><ref refid="structmp_1_1_log_options" kindref="compound">LogOptions</ref></type>
        <definition>LogOptions m_log_opts</definition>
        <argsstring></argsstring>
        <name>m_log_opts</name>
        <qualifiedname>mp::EventLoop::m_log_opts</qualifiedname>
        <briefdescription>
<para>Logging options. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="314" column="16" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="314" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classmp_1_1_event_loop_1a92efa486d18e81bd893ff18bc8a22926" prot="public" static="no" mutable="no">
        <type>void *</type>
        <definition>void* m_context</definition>
        <argsstring></argsstring>
        <name>m_context</name>
        <qualifiedname>mp::EventLoop::m_context</qualifiedname>
        <briefdescription>
<para>External context pointer. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="317" column="10" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="317" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classmp_1_1_event_loop_1af4e2d623f57fae116fc13c423109871b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>EventLoop</definition>
        <argsstring>(const char *exe_name, LogFn log_fn, void *context=nullptr)</argsstring>
        <name>EventLoop</name>
        <qualifiedname>mp::EventLoop::EventLoop</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <param>
          <type><ref refid="namespacemp_1a61ffb74e9f97c3924b3904a35a5f20b2" kindref="member">LogFn</ref></type>
          <declname>log_fn</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>context</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
<para>Construct event loop object with default logging options. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="217" column="5" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="217" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1adedf492d5d51065481b58d3020c40840" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>EventLoop</definition>
        <argsstring>(const char *exe_name, LogOptions log_opts, void *context=nullptr)</argsstring>
        <name>EventLoop</name>
        <qualifiedname>mp::EventLoop::EventLoop</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <param>
          <type><ref refid="structmp_1_1_log_options" kindref="compound">LogOptions</ref></type>
          <declname>log_opts</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>context</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
<para>Construct event loop object with specified logging options. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="221" column="5" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="195" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1a97dc677b923c4253bb089b99a4e24e4c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>EventLoop</definition>
        <argsstring>(const char *exe_name, std::function&lt; void(bool, std::string)&gt; old_callback, void *context=nullptr)</argsstring>
        <name>EventLoop</name>
        <qualifiedname>mp::EventLoop::EventLoop</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <param>
          <type>std::function&lt; void(bool, std::string)&gt;</type>
          <declname>old_callback</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>context</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
<para>Backwards-compatible constructor for previous (deprecated) logging callback signature. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="224" column="5" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="224" bodyend="227"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1ad39d140230e71b90198d0ed03e0c21f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~EventLoop</definition>
        <argsstring>()</argsstring>
        <name>~EventLoop</name>
        <qualifiedname>mp::EventLoop::~EventLoop</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="229" column="5" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="208" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1afe461d27b9c48d5921c00d521181f12f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void loop</definition>
        <argsstring>()</argsstring>
        <name>loop</name>
        <qualifiedname>mp::EventLoop::loop</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Run event loop. Does not return until shutdown. This should only be called once from the m_thread_id thread. This will block until the m_num_clients reference count is 0. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="234" column="10" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="223" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1a4e6f3fba72d4c182f3e7474a2fd76667" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void post</definition>
        <argsstring>(kj::Function&lt; void()&gt; fn)</argsstring>
        <name>post</name>
        <qualifiedname>mp::EventLoop::post</qualifiedname>
        <param>
          <type>kj::Function&lt; void()&gt;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Run function on event loop thread. Does not return until function completes. Must be called while the <ref refid="classmp_1_1_event_loop_1afe461d27b9c48d5921c00d521181f12f" kindref="member">loop()</ref> function is active. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="238" column="10" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="267" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1ad322c973d237a8efe56f3c4ffbb3cb0c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Callable</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void sync</definition>
        <argsstring>(Callable &amp;&amp;callable)</argsstring>
        <name>sync</name>
        <qualifiedname>mp::EventLoop::sync</qualifiedname>
        <param>
          <type>Callable &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="class_wrapper" kindref="compound">Wrapper</ref> around <ref refid="classmp_1_1_event_loop_1a4e6f3fba72d4c182f3e7474a2fd76667" kindref="member">EventLoop::post</ref> that takes advantage of the fact that callable will not go out of scope to avoid requirement that it be copyable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="244" column="10" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="244" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1ae50c7c1f98f078876e3241d909d36da9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void addAsyncCleanup</definition>
        <argsstring>(std::function&lt; void()&gt; fn)</argsstring>
        <name>addAsyncCleanup</name>
        <qualifiedname>mp::EventLoop::addAsyncCleanup</qualifiedname>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Register cleanup function to run on asynchronous worker thread without blocking the event loop thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="251" column="10" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="172" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1a97b4cd12dc18c9198ee6657c936e9fdd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void startAsyncThread</definition>
        <argsstring>() MP_REQUIRES(m_mutex)</argsstring>
        <name>startAsyncThread</name>
        <qualifiedname>mp::EventLoop::startAsyncThread</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Start asynchronous worker thread if necessary. This is only done if there are <ref refid="structmp_1_1_proxy_server_base_1a47b0d7e7413d0c7eb592ccf544a24f13" kindref="member">ProxyServerBase::m_impl</ref> objects that need to be destroyed asynchronously, without tying up the event loop thread. This can happen when an interface does not declare a destroy() method that would allow the client to wait for the destructor to finish and run it on a dedicated thread. It can also happen whenever this is a broken connection and the client is no longer around to call the destructors and the server objects need to be garbage collected. In both cases, it is important that ProxyServer::m_impl destructors do not run on the eventloop thread because they may need it to do I/O if they perform other IPC calls. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="264" column="10" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="285" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1af0c4e1593f96387b1fc05c902f72a509" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool done</definition>
        <argsstring>() const MP_REQUIRES(m_mutex)</argsstring>
        <name>done</name>
        <qualifiedname>mp::EventLoop::done</qualifiedname>
        <briefdescription>
<para>Check if loop should exit. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="267" column="10" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="311" bodyend="315"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1a18e06ab543770b1d48dd06243faa75eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>kj::Function&lt; void()&gt; *m_post_fn</type>
        <definition>kj::Function&lt; void()&gt; *m_post_fn MP_GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>MP_GUARDED_BY</name>
        <qualifiedname>mp::EventLoop::MP_GUARDED_BY</qualifiedname>
        <param>
          <type><ref refid="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">m_mutex</ref></type>
        </param>
        <briefdescription>
<para>Callback function to run on event loop thread during <ref refid="classmp_1_1_event_loop_1a4e6f3fba72d4c182f3e7474a2fd76667" kindref="member">post()</ref> or <ref refid="classmp_1_1_event_loop_1ad322c973d237a8efe56f3c4ffbb3cb0c" kindref="member">sync()</ref> call. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="281" column="28"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1aaac2885ebd590ea8287845814c6a5b49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="namespacemp_1aa04bf09245b60eb219c446d213cc0390" kindref="member">CleanupList</ref> &gt; m_async_fns</type>
        <definition>std::optional&lt; CleanupList &gt; m_async_fns MP_GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>MP_GUARDED_BY</name>
        <qualifiedname>mp::EventLoop::MP_GUARDED_BY</qualifiedname>
        <param>
          <type><ref refid="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">m_mutex</ref></type>
        </param>
        <briefdescription>
<para>Callback functions to run on async thread. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="284" column="31"/>
      </memberdef>
      <memberdef kind="function" id="classmp_1_1_event_loop_1a75d54c4047fd429274c790929f4dc23e" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>int m_num_clients</type>
        <definition>int m_num_clients MP_GUARDED_BY</definition>
        <argsstring>(m_mutex)=0</argsstring>
        <name>MP_GUARDED_BY</name>
        <qualifiedname>mp::EventLoop::MP_GUARDED_BY</qualifiedname>
        <param>
          <type><ref refid="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">m_mutex</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Number of clients holding references to <ref refid="structmp_1_1_proxy_server_base" kindref="compound">ProxyServerBase</ref> objects that reference this event loop. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="294" column="23"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Event loop implementation.</para>
<para>Cap&apos;n Proto threading model is very simple: all I/O operations are asynchronous and must be performed on a single thread. This includes:</para>
<para><itemizedlist>
<listitem><para>Code starting an asynchronous operation (calling a function that returns a promise object)</para>
</listitem><listitem><para>Code notifying that an asynchronous operation is complete (code using a fulfiller object)</para>
</listitem><listitem><para>Code handling a completed operation (code chaining or waiting for a promise)</para>
</listitem></itemizedlist>
</para>
<para>All of this code needs to access shared state, and there is no mutex that can be acquired to lock this state because Cap&apos;n Proto assumes it will only be accessed from one thread. So all this code needs to actually run on one thread, and the <ref refid="classmp_1_1_event_loop_1afe461d27b9c48d5921c00d521181f12f" kindref="member">EventLoop::loop()</ref> method is the entry point for this thread. <ref refid="structmp_1_1_proxy_client" kindref="compound">ProxyClient</ref> and <ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> objects that use other threads and need to perform I/O operations post to this thread using <ref refid="classmp_1_1_event_loop_1a4e6f3fba72d4c182f3e7474a2fd76667" kindref="member">EventLoop::post()</ref> and <ref refid="classmp_1_1_event_loop_1ad322c973d237a8efe56f3c4ffbb3cb0c" kindref="member">EventLoop::sync()</ref> methods.</para>
<para>Specifically, because <ref refid="structmp_1_1_proxy_client" kindref="compound">ProxyClient</ref> methods can be called from arbitrary threads, and <ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> methods can run on arbitrary threads, <ref refid="structmp_1_1_proxy_client" kindref="compound">ProxyClient</ref> methods use the <ref refid="classmp_1_1_event_loop" kindref="compound">EventLoop</ref> thread to send requests, and <ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> methods use the thread to return results.</para>
<para>Based on <ulink url="https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ">https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ</ulink> </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="2">
        <label>AnnotatedMixin&lt; std::mutex &gt;</label>
        <link refid="class_annotated_mixin"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>EventLoop</label>
        <link refid="classmp_1_1_event_loop"/>
        <childnode refid="2" relation="usage">
          <edgelabel>m_mutex</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_error_handler</edgelabel>
        </childnode>
        <childnode refid="7" relation="usage">
          <edgelabel>m_log_opts</edgelabel>
        </childnode>
      </node>
      <node id="5">
        <label>ErrorHandler</label>
      </node>
      <node id="6">
        <label>EventLoop</label>
        <link refid="classmp_1_1_event_loop"/>
        <childnode refid="2" relation="usage">
          <edgelabel>m_mutex</edgelabel>
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_error_handler</edgelabel>
        </childnode>
        <childnode refid="7" relation="usage">
          <edgelabel>m_log_opts</edgelabel>
        </childnode>
      </node>
      <node id="7">
        <label>LogOptions</label>
        <link refid="structmp_1_1_log_options"/>
      </node>
      <node id="4">
        <label>LoggingErrorHandler</label>
        <link refid="classmp_1_1_logging_error_handler"/>
        <childnode refid="5" relation="public-inheritance">
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>mutex</label>
      </node>
    </collaborationgraph>
    <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="213" column="1" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="214" bodyend="318"/>
    <listofallmembers>
      <member refid="classmp_1_1_event_loop_1ae50c7c1f98f078876e3241d909d36da9" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>addAsyncCleanup</name></member>
      <member refid="classmp_1_1_event_loop_1af0c4e1593f96387b1fc05c902f72a509" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>done</name></member>
      <member refid="classmp_1_1_event_loop_1af4e2d623f57fae116fc13c423109871b" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>EventLoop</name></member>
      <member refid="classmp_1_1_event_loop_1adedf492d5d51065481b58d3020c40840" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>EventLoop</name></member>
      <member refid="classmp_1_1_event_loop_1a97dc677b923c4253bb089b99a4e24e4c" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>EventLoop</name></member>
      <member refid="classmp_1_1_event_loop_1afe461d27b9c48d5921c00d521181f12f" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>loop</name></member>
      <member refid="classmp_1_1_event_loop_1a7ff706a17a3571c9b28db11e81dc7585" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_async_thread</name></member>
      <member refid="classmp_1_1_event_loop_1a92efa486d18e81bd893ff18bc8a22926" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_context</name></member>
      <member refid="classmp_1_1_event_loop_1accca0ab294feb9061406ae9c73a3ceb5" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_cv</name></member>
      <member refid="classmp_1_1_event_loop_1aa3a0b29328e0fc0ec8b26132feb0fcc5" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_error_handler</name></member>
      <member refid="classmp_1_1_event_loop_1a2a779802443c51d72db5bd158c31c964" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_exe_name</name></member>
      <member refid="classmp_1_1_event_loop_1ace117e2546e02ad25eb0044315aa4ac9" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_incoming_connections</name></member>
      <member refid="classmp_1_1_event_loop_1ae9ed3a7b20562f71d91760034e7100f1" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_io_context</name></member>
      <member refid="classmp_1_1_event_loop_1ab1f44d16de891fa65b054ee4ead90294" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_log_opts</name></member>
      <member refid="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_mutex</name></member>
      <member refid="classmp_1_1_event_loop_1a59f59d4a0735009e1d98f835eeccdb87" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_post_fd</name></member>
      <member refid="classmp_1_1_event_loop_1a4867e4e832e2d05e777ed32a795214ad" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_task_set</name></member>
      <member refid="classmp_1_1_event_loop_1aaee8fe6bf715daa70d55a732218dcfe5" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_thread_id</name></member>
      <member refid="classmp_1_1_event_loop_1a5ca6d7b6e9cca718db8c78de06dde777" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>m_wait_fd</name></member>
      <member refid="classmp_1_1_event_loop_1a18e06ab543770b1d48dd06243faa75eb" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>MP_GUARDED_BY</name></member>
      <member refid="classmp_1_1_event_loop_1aaac2885ebd590ea8287845814c6a5b49" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>MP_GUARDED_BY</name></member>
      <member refid="classmp_1_1_event_loop_1a75d54c4047fd429274c790929f4dc23e" prot="public" virt="pure-virtual"><scope>mp::EventLoop</scope><name>MP_GUARDED_BY</name></member>
      <member refid="classmp_1_1_event_loop_1a4e6f3fba72d4c182f3e7474a2fd76667" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>post</name></member>
      <member refid="classmp_1_1_event_loop_1a97b4cd12dc18c9198ee6657c936e9fdd" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>startAsyncThread</name></member>
      <member refid="classmp_1_1_event_loop_1ad322c973d237a8efe56f3c4ffbb3cb0c" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>sync</name></member>
      <member refid="classmp_1_1_event_loop_1ad39d140230e71b90198d0ed03e0c21f2" prot="public" virt="non-virtual"><scope>mp::EventLoop</scope><name>~EventLoop</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
