<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classankerl_1_1nanobench_1_1_bench" kind="class" language="C++" prot="public">
    <compoundname>ankerl::nanobench::Bench</compoundname>
    <includes refid="nanobench_8h" local="no">nanobench.h</includes>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classankerl_1_1nanobench_1_1_bench_1a8cb4bc11d1c85d9087b3b41b60644591" prot="private" static="no" mutable="no">
        <type><ref refid="structankerl_1_1nanobench_1_1_config" kindref="compound">Config</ref></type>
        <definition>Config mConfig</definition>
        <argsstring></argsstring>
        <name>mConfig</name>
        <qualifiedname>ankerl::nanobench::Bench::mConfig</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1011" column="12" bodyfile="src/bench/nanobench.h" bodystart="1011" bodyend="1011"/>
      </memberdef>
      <memberdef kind="variable" id="classankerl_1_1nanobench_1_1_bench_1afe996b837bb23ddf27468f5e5e167512" prot="private" static="no" mutable="no">
        <type>std::vector&lt; <ref refid="classankerl_1_1nanobench_1_1_result" kindref="compound">Result</ref> &gt;</type>
        <definition>std::vector&lt;Result&gt; mResults</definition>
        <argsstring></argsstring>
        <name>mResults</name>
        <qualifiedname>ankerl::nanobench::Bench::mResults</qualifiedname>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1012" column="17" bodyfile="src/bench/nanobench.h" bodystart="1012" bodyend="1012"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Bench</definition>
        <argsstring>()</argsstring>
        <name>Bench</name>
        <qualifiedname>ankerl::nanobench::Bench::Bench</qualifiedname>
        <briefdescription>
<para>Creates a new benchmark for configuration and running of benchmarks. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="632" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a3bf6b595796ee74d22f40c2d0afd99ac" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>Bench</definition>
        <argsstring>(Bench &amp;&amp;other) noexcept</argsstring>
        <name>Bench</name>
        <qualifiedname>ankerl::nanobench::Bench::Bench</qualifiedname>
        <param>
          <type>Bench &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="634" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a8e386768d4be4f31f9f6dda9bfcc9034" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" noexceptexpression="ANKERL_NANOBENCH(NOEXCEPT_STRING_MOVE)" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; operator=</definition>
        <argsstring>(Bench &amp;&amp;other)</argsstring>
        <name>operator=</name>
        <qualifiedname>ankerl::nanobench::Bench::operator=</qualifiedname>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="635" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a2d0881f6e6c3c139ad4956f11038b70a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Bench</definition>
        <argsstring>(Bench const &amp;other)</argsstring>
        <name>Bench</name>
        <qualifiedname>ankerl::nanobench::Bench::Bench</qualifiedname>
        <param>
          <type>Bench const &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="636" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a8b9dc241748631d4a8aaaa9b491895ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; operator=</definition>
        <argsstring>(Bench const &amp;other)</argsstring>
        <name>operator=</name>
        <qualifiedname>ankerl::nanobench::Bench::operator=</qualifiedname>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> const &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="637" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a86dbc9b2f51365303f8bac1bfffe9651" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>~Bench</definition>
        <argsstring>() noexcept</argsstring>
        <name>~Bench</name>
        <qualifiedname>ankerl::nanobench::Bench::~Bench</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="638" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1ae0f1d3ec977f3733d457b759b1f08e9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; run</definition>
        <argsstring>(char const *benchmarkName, Op &amp;&amp;op)</argsstring>
        <name>run</name>
        <qualifiedname>ankerl::nanobench::Bench::run</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>benchmarkName</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Repeatedly calls <computeroutput>op()</computeroutput> based on the configuration, and performs measurements. </para>
        </briefdescription>
        <detaileddescription>
<para>This call is marked with <computeroutput>noinline</computeroutput> to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect on benchmark accuracy.</para>
<para><verbatim>embed:rst
.. note::

  Each call to your lambda must have a side effect that the compiler can&apos;t possibly optimize it away. E.g. add a result to an
  externally defined number (like `x` in the above example), and finally call `doNotOptimizeAway` on the variables the compiler
  must not remove. You can also use :cpp:func:`ankerl::nanobench::doNotOptimizeAway` directly in the lambda, but be aware that
  this has a small overhead.
</verbatim></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The code to benchmark. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="660" column="11" bodyfile="src/bench/nanobench.h" bodystart="1234" bodyend="1237"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a0c763a995ba8b2715ddef0a845207cac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; run</definition>
        <argsstring>(std::string const &amp;benchmarkName, Op &amp;&amp;op)</argsstring>
        <name>run</name>
        <qualifiedname>ankerl::nanobench::Bench::run</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>benchmarkName</declname>
        </param>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="664" column="11" bodyfile="src/bench/nanobench.h" bodystart="1240" bodyend="1243"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a5ed0f9c7a612dc2b0e88fb73dc3840b2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; run</definition>
        <argsstring>(Op &amp;&amp;op)</argsstring>
        <name>run</name>
        <qualifiedname>ankerl::nanobench::Bench::run</qualifiedname>
        <param>
          <type>Op &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Same as run(char const* benchmarkName, Op op), but instead uses the previously set name. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>The code to benchmark. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="672" column="11" bodyfile="src/bench/nanobench.h" bodystart="1212" bodyend="1230"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a4e7209cd88a09e1e2278f0d506dd3aa3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; title</definition>
        <argsstring>(char const *benchmarkTitle)</argsstring>
        <name>title</name>
        <qualifiedname>ankerl::nanobench::Bench::title</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>benchmarkTitle</declname>
        </param>
        <briefdescription>
<para>Title of the benchmark, will be shown in the table header. Changing the title will start a new markdown table. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>benchmarkTitle</parametername>
</parameternamelist>
<parameterdescription>
<para>The title of the benchmark. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="679" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a23306c0c89ae888d98683c58c7e2bec9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; title</definition>
        <argsstring>(std::string const &amp;benchmarkTitle)</argsstring>
        <name>title</name>
        <qualifiedname>ankerl::nanobench::Bench::title</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>benchmarkTitle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="680" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a8a87b6c0978c4d69179ee249beb86c0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; name</definition>
        <argsstring>(char const *benchmarkName)</argsstring>
        <name>name</name>
        <qualifiedname>ankerl::nanobench::Bench::name</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>benchmarkName</declname>
        </param>
        <briefdescription>
<para>Gets the title of the benchmark. </para>
        </briefdescription>
        <detaileddescription>
<para>Name of the benchmark, will be shown in the table row. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="688" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a915d9b1dfd2b915540b31cdedcef09bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; name</definition>
        <argsstring>(std::string const &amp;benchmarkName)</argsstring>
        <name>name</name>
        <qualifiedname>ankerl::nanobench::Bench::name</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>benchmarkName</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="689" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a6c5c13becb6edb48ef7d02cc8caab1bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; context</definition>
        <argsstring>(char const *variableName, char const *variableValue)</argsstring>
        <name>context</name>
        <qualifiedname>ankerl::nanobench::Bench::context</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>variableName</declname>
        </param>
        <param>
          <type>char const *</type>
          <declname>variableValue</declname>
        </param>
        <briefdescription>
<para>Set context information. </para>
        </briefdescription>
        <detaileddescription>
<para>The information can be accessed using custom render templates via <computeroutput>{{context(variableName)}}</computeroutput>. Trying to render a variable that hasn&apos;t been set before raises an exception. Not included in (default) markdown table.</para>
<para><simplesect kind="see"><para><ref refid="classankerl_1_1nanobench_1_1_bench_1a44b3f8a1e4c325215a84ffbf4da7fe89" kindref="member">clearContext</ref>, <ref refid="classankerl_1_1nanobench_1_1_bench_1a249fd9ff213cf963f4ed78262d15fc6f" kindref="member">render</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>variableName</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the context variable. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>variableValue</parametername>
</parameternamelist>
<parameterdescription>
<para>The value of the context variable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="704" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a69b97096c16fe745cedaf3adf25244e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; context</definition>
        <argsstring>(std::string const &amp;variableName, std::string const &amp;variableValue)</argsstring>
        <name>context</name>
        <qualifiedname>ankerl::nanobench::Bench::context</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>variableName</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>variableValue</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="705" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a44b3f8a1e4c325215a84ffbf4da7fe89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; clearContext</definition>
        <argsstring>()</argsstring>
        <name>clearContext</name>
        <qualifiedname>ankerl::nanobench::Bench::clearContext</qualifiedname>
        <briefdescription>
<para>Reset context information. </para>
        </briefdescription>
        <detaileddescription>
<para>This may improve efficiency when using many context entries, or improve robustness by removing spurious context entries.</para>
<para><simplesect kind="see"><para><ref refid="classankerl_1_1nanobench_1_1_bench_1a6c5c13becb6edb48ef7d02cc8caab1bb" kindref="member">context</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="715" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a37d376bc0b00680fc13656e4761f8168" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="hash__tests_8cpp_1ad4971a985148c784a362f962d42aa012" kindref="member">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; batch</definition>
        <argsstring>(T b) noexcept</argsstring>
        <name>batch</name>
        <qualifiedname>ankerl::nanobench::Bench::batch</qualifiedname>
        <param>
          <type><ref refid="hash__tests_8cpp_1ad4971a985148c784a362f962d42aa012" kindref="member">T</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>Sets the batch size. </para>
        </briefdescription>
        <detaileddescription>
<para>E.g. number of processed byte, or some other metric for the size of the processed data in each iteration. If you benchmark hashing of a 1000 byte long string and want byte/sec as a result, you can specify 1000 as the batch size.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any input type is internally cast to <computeroutput>double</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>batch size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="727" column="11" bodyfile="src/bench/nanobench.h" bodystart="1258" bodyend="1261"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) double batch() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="728" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a7fada6f805f9af86b8508e8ef028d936" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; unit</definition>
        <argsstring>(char const *unit)</argsstring>
        <name>unit</name>
        <qualifiedname>ankerl::nanobench::Bench::unit</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>unit</declname>
        </param>
        <briefdescription>
<para>Sets the operation unit. </para>
        </briefdescription>
        <detaileddescription>
<para>Defaults to &quot;op&quot;. Could be e.g. &quot;byte&quot; for string processing. This is used for the table header, e.g. to show <computeroutput>ns/byte</computeroutput>. Use singular (<emphasis>byte</emphasis>, not <emphasis>bytes</emphasis>). A change clears the currently collected results.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>unit</parametername>
</parameternamelist>
<parameterdescription>
<para>The unit name. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="738" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a44bc96023aa24d13b3d96f956478b304" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; unit</definition>
        <argsstring>(std::string const &amp;unit)</argsstring>
        <name>unit</name>
        <qualifiedname>ankerl::nanobench::Bench::unit</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>unit</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="739" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a13e3eaf7b5e9c0cf77da4673571c8e89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; timeUnit</definition>
        <argsstring>(std::chrono::duration&lt; double &gt; const &amp;tu, std::string const &amp;tuName)</argsstring>
        <name>timeUnit</name>
        <qualifiedname>ankerl::nanobench::Bench::timeUnit</qualifiedname>
        <param>
          <type>std::chrono::duration&lt; double &gt; const &amp;</type>
          <declname>tu</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>tuName</declname>
        </param>
        <briefdescription>
<para>Sets the time unit to be used for the default output. </para>
        </briefdescription>
        <detaileddescription>
<para>Nanobench defaults to using ns (nanoseconds) as output in the markdown. For some benchmarks this is too coarse, so it is possible to configure this. E.g. use <computeroutput><ref refid="classankerl_1_1nanobench_1_1_bench_1a13e3eaf7b5e9c0cf77da4673571c8e89" kindref="member">timeUnit</ref>(1ms, "ms")</computeroutput> to show <computeroutput>ms/op</computeroutput> instead of <computeroutput>ns/op</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tu</parametername>
</parameternamelist>
<parameterdescription>
<para>Time unit to display the results in, default is 1ns. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tuName</parametername>
</parameternamelist>
<parameterdescription>
<para>Name for the time unit, default is &quot;ns&quot; </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="751" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a10436f841dad877a2c165f8d00e21fc6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std ANKERL_NANOBENCH(NODISCARD) std Bench &amp; output</definition>
        <argsstring>(std::ostream *outstream) noexcept</argsstring>
        <name>output</name>
        <qualifiedname>ankerl::nanobench::Bench::output</qualifiedname>
        <param>
          <type>std::ostream *</type>
          <declname>outstream</declname>
        </param>
        <briefdescription>
<para>Set the output stream where the resulting markdown table will be printed to. </para>
        </briefdescription>
        <detaileddescription>
<para>The default is <computeroutput>&amp;std::cout</computeroutput>. You can disable all output by setting <computeroutput>nullptr</computeroutput>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>outstream</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to output stream, can be <computeroutput>nullptr</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="762" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a92b3a1e3050c61c1e24e42a116b92a87" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; clockResolutionMultiple</definition>
        <argsstring>(size_t multiple) noexcept</argsstring>
        <name>clockResolutionMultiple</name>
        <qualifiedname>ankerl::nanobench::Bench::clockResolutionMultiple</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>multiple</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This is the main trick nanobech to be so fast: we find out how accurate the clock is, then run the benchmark only so often that the clock&apos;s accuracy is good enough for accurate measurements.</para>
<para>The default is to run one epoch for 1000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of</para>
<para><formula id="5">\[20ns * 1000 * 11 \approx 0.2ms
\]</formula></para>
<para>To be precise, nanobench adds a 0-20% random noise to each evaluation. This is to prevent any aliasing effects, and further improves accuracy.</para>
<para>Total runtime will be higher though: Some initial time is needed to find out the target number of iterations for each epoch, and there is some overhead involved to start &amp; stop timers and calculate resulting statistics and writing the output.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>multiple</parametername>
</parameternamelist>
<parameterdescription>
<para>Target number of times of clock resolution. Usually 1000 is a good compromise between runtime and accuracy. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="785" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1ac445176a2c888e2110ea39da86c55b06" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) size_t clockResolutionMultiple() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="786" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a2aace9b04e1962c6490d7b2bbcbf0269" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; epochs</definition>
        <argsstring>(size_t numEpochs) noexcept</argsstring>
        <name>epochs</name>
        <qualifiedname>ankerl::nanobench::Bench::epochs</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>numEpochs</declname>
        </param>
        <briefdescription>
<para>Controls number of epochs, the number of measurements to perform. </para>
        </briefdescription>
        <detaileddescription>
<para>The reported result will be the median of evaluation of each epoch. The higher you choose this, the more deterministic the result be and outliers will be more easily removed. Also the <computeroutput>err%</computeroutput> will be more accurate the higher this number is. Note that the <computeroutput>err%</computeroutput> will not necessarily decrease when number of epochs is increased. But it will be a more accurate representation of the benchmarked code&apos;s runtime stability.</para>
<para>Choose the value wisely. In practice, 11 has been shown to be a reasonable choice between runtime performance and accuracy. This setting goes hand in hand with <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">minEpochIterations()</ref> (or <ref refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" kindref="member">minEpochTime()</ref>). If you are more interested in <emphasis>median</emphasis> runtime, you might want to increase <ref refid="classankerl_1_1nanobench_1_1_bench_1a2aace9b04e1962c6490d7b2bbcbf0269" kindref="member">epochs()</ref>. If you are more interested in <emphasis>mean</emphasis> runtime, you might want to increase <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">minEpochIterations()</ref> instead.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numEpochs</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of epochs. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="803" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a3059fb8ac12342e1989ee7ed3c88e19a" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) size_t epochs() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="804" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1abb7e4067323a8d7569e9867b03a35b39" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; maxEpochTime</definition>
        <argsstring>(std::chrono::nanoseconds t) noexcept</argsstring>
        <name>maxEpochTime</name>
        <qualifiedname>ankerl::nanobench::Bench::maxEpochTime</qualifiedname>
        <param>
          <type>std::chrono::nanoseconds</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Upper limit for the runtime of each epoch. </para>
        </briefdescription>
        <detaileddescription>
<para>As a safety precaution if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch. Default is 100ms. At least a single evaluation of the benchmark is performed.</para>
<para><simplesect kind="see"><para><ref refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" kindref="member">minEpochTime</ref>, <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">minEpochIterations</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum target runtime for a single epoch. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="816" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; minEpochTime</definition>
        <argsstring>(std::chrono::nanoseconds t) noexcept</argsstring>
        <name>minEpochTime</name>
        <qualifiedname>ankerl::nanobench::Bench::minEpochTime</qualifiedname>
        <param>
          <type>std::chrono::nanoseconds</type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Minimum time each epoch should take. </para>
        </briefdescription>
        <detaileddescription>
<para>Default is zero, so we are fully relying on <ref refid="classankerl_1_1nanobench_1_1_bench_1a92b3a1e3050c61c1e24e42a116b92a87" kindref="member">clockResolutionMultiple()</ref>. In most cases this is exactly what you want. If you see that the evaluation is unreliable with a high <computeroutput>err%</computeroutput>, you can increase either <ref refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" kindref="member">minEpochTime()</ref> or <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">minEpochIterations()</ref>.</para>
<para><simplesect kind="see"><para><ref refid="classankerl_1_1nanobench_1_1_bench_1abb7e4067323a8d7569e9867b03a35b39" kindref="member">maxEpochTime</ref>, <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">minEpochIterations</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum time each epoch should take. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="829" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; minEpochIterations</definition>
        <argsstring>(uint64_t numIters) noexcept</argsstring>
        <name>minEpochIterations</name>
        <qualifiedname>ankerl::nanobench::Bench::minEpochIterations</qualifiedname>
        <param>
          <type>uint64_t</type>
          <declname>numIters</declname>
        </param>
        <briefdescription>
<para>Sets the minimum number of iterations each epoch should take. </para>
        </briefdescription>
        <detaileddescription>
<para>Default is 1, and we rely on <ref refid="classankerl_1_1nanobench_1_1_bench_1a92b3a1e3050c61c1e24e42a116b92a87" kindref="member">clockResolutionMultiple()</ref>. If the <computeroutput>err%</computeroutput> is high and you want a more smooth result, you might want to increase the minimum number of iterations, or increase the <ref refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" kindref="member">minEpochTime()</ref>.</para>
<para><simplesect kind="see"><para><ref refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" kindref="member">minEpochTime</ref>, <ref refid="classankerl_1_1nanobench_1_1_bench_1abb7e4067323a8d7569e9867b03a35b39" kindref="member">maxEpochTime</ref>, <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">minEpochIterations</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numIters</parametername>
</parameternamelist>
<parameterdescription>
<para>Minimum number of iterations per epoch. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="842" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a9e977966aac653eeb88812eb2c8cd896" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) uint64_t minEpochIterations() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="843" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1ae084f501a2a3c61c1d128a519d4a38ae" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; epochIterations</definition>
        <argsstring>(uint64_t numIters) noexcept</argsstring>
        <name>epochIterations</name>
        <qualifiedname>ankerl::nanobench::Bench::epochIterations</qualifiedname>
        <param>
          <type>uint64_t</type>
          <declname>numIters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets exactly the number of iterations for each epoch. Ignores all other epoch limits. This forces nanobench to use exactly the given number of iterations for each epoch, not more and not less. Default is 0 (disabled).</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numIters</parametername>
</parameternamelist>
<parameterdescription>
<para>Exact number of iterations to use. Set to 0 to disable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="851" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a01c68da61eb2e2309afe3750afa9204d" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) uint64_t epochIterations() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="852" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1ae48156567cac1e76706ac0ce076894b7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; warmup</definition>
        <argsstring>(uint64_t numWarmupIters) noexcept</argsstring>
        <name>warmup</name>
        <qualifiedname>ankerl::nanobench::Bench::warmup</qualifiedname>
        <param>
          <type>uint64_t</type>
          <declname>numWarmupIters</declname>
        </param>
        <briefdescription>
<para>Sets a number of iterations that are initially performed without any measurements. </para>
        </briefdescription>
        <detaileddescription>
<para>Some benchmarks need a few evaluations to warm up caches / database / whatever access. Normally this should not be needed, since we show the median result so initial outliers will be filtered away automatically. If the warmup effect is large though, you might want to set it. Default is 0.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numWarmupIters</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of warmup iterations. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="863" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a8d7ff1a0e17181d42be2ff23373e3fd5" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) uint64_t warmup() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="864" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a2b35462c62dcf9e55bf31618dd8008e0" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; relative</definition>
        <argsstring>(bool isRelativeEnabled) noexcept</argsstring>
        <name>relative</name>
        <qualifiedname>ankerl::nanobench::Bench::relative</qualifiedname>
        <param>
          <type>bool</type>
          <declname>isRelativeEnabled</declname>
        </param>
        <briefdescription>
<para>Marks the next run as the baseline. </para>
        </briefdescription>
        <detaileddescription>
<para>Call <computeroutput>relative(true)</computeroutput> to mark the run as the baseline. Successive runs will be compared to this run. It is calculated by</para>
<para><formula id="6">\[100\% * \frac{baseline}{runtime}
\]</formula></para>
<para><itemizedlist>
<listitem><para>100% means it is exactly as fast as the baseline</para>
</listitem><listitem><para>&gt;100% means it is faster than the baseline. E.g. 200% means the current run is twice as fast as the baseline.</para>
</listitem><listitem><para>&lt;100% means it is slower than the baseline. E.g. 50% means it is twice as slow as the baseline.</para>
</listitem></itemizedlist>
</para>
<para>See the tutorial section &quot;Comparing Results&quot; for example usage.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>isRelativeEnabled</parametername>
</parameternamelist>
<parameterdescription>
<para>True to enable processing </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="883" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1aacb57abf02ea943a9c084e0b4574570a" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) bool relative() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="884" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a631a9cd991845ac75991564a9ed80f89" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; performanceCounters</definition>
        <argsstring>(bool showPerformanceCounters) noexcept</argsstring>
        <name>performanceCounters</name>
        <qualifiedname>ankerl::nanobench::Bench::performanceCounters</qualifiedname>
        <param>
          <type>bool</type>
          <declname>showPerformanceCounters</declname>
        </param>
        <briefdescription>
<para>Enables/disables performance counters. </para>
        </briefdescription>
        <detaileddescription>
<para>On Linux nanobench has a powerful feature to use performance counters. This enables counting of retired instructions, count number of branches, missed branches, etc. On default this is enabled, but you can disable it if you don&apos;t need that feature.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>showPerformanceCounters</parametername>
</parameternamelist>
<parameterdescription>
<para>True to enable, false to disable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="894" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a0acd95544ac4925ff0a60740a6c08f5a" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) bool performanceCounters() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="895" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a27f4d44a6c8051915296db99fe3749e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Arg</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" kindref="member">ANKERL_NANOBENCH</ref>(NODISCARD) <ref refid="namespacestd" kindref="compound">std</ref> <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>ANKERL_NANOBENCH(NODISCARD) std Bench &amp; doNotOptimizeAway</definition>
        <argsstring>(Arg &amp;&amp;arg)</argsstring>
        <name>doNotOptimizeAway</name>
        <qualifiedname>ankerl::nanobench::Bench::doNotOptimizeAway</qualifiedname>
        <param>
          <type>Arg &amp;&amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
<para>Retrieves all benchmark results collected by the bench object so far. </para>
        </briefdescription>
        <detaileddescription>
<para>Each call to <ref refid="classankerl_1_1nanobench_1_1_bench_1ae0f1d3ec977f3733d457b759b1f08e9e" kindref="member">run()</ref> generates a <ref refid="classankerl_1_1nanobench_1_1_result" kindref="compound">Result</ref> that is stored within the <ref refid="classankerl_1_1nanobench_1_1_bench" kindref="compound">Bench</ref> instance. This is mostly for advanced users who want to see all the nitty gritty details.</para>
<para><simplesect kind="return"><para>All results collected so far.</para>
</simplesect>
<verbatim>embed:rst

Convenience shortcut to :cpp:func:`ankerl::nanobench::doNotOptimizeAway`.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="915" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a4c2fa1375c3a79a88cfb8532b4017f69" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename <ref refid="hash__tests_8cpp_1ad4971a985148c784a362f962d42aa012" kindref="member">T</ref></type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; complexityN</definition>
        <argsstring>(T n) noexcept</argsstring>
        <name>complexityN</name>
        <qualifiedname>ankerl::nanobench::Bench::complexityN</qualifiedname>
        <param>
          <type><ref refid="hash__tests_8cpp_1ad4971a985148c784a362f962d42aa012" kindref="member">T</ref></type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>embed:rst

Sets N for asymptotic complexity calculation, so it becomes possible to calculate `Big O
&lt;https://en.wikipedia.org/wiki/Big_O_notation&gt;`_ from multiple benchmark evaluations.

Use :cpp:func:`ankerl::nanobench::Bench::complexityBigO` when the evaluation has finished. See the tutorial
:ref:`asymptotic-complexity` for details.
</verbatim></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>Any type is cast to <computeroutput>double</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>Length of N for the next benchmark run, so it is possible to calculate <computeroutput>bigO</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="932" column="11" bodyfile="src/bench/nanobench.h" bodystart="1265" bodyend="1268"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a81b78b56e2d1eecadec93dfaeb6a95f1" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) double complexityN() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="933" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1ad7708f807ad0566c2a2046a21dad077c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="classankerl_1_1nanobench_1_1_big_o" kindref="compound">BigO</ref> &gt;</type>
        <definition>std::vector&lt; BigO &gt; complexityBigO</definition>
        <argsstring>() const</argsstring>
        <name>complexityBigO</name>
        <qualifiedname>ankerl::nanobench::Bench::complexityBigO</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculates <ulink url="https://en.wikipedia.org/wiki/Big_O_notation&gt;">Big O</ulink> of the results with all preconfigured complexity functions. Currently these complexity functions are fitted into the benchmark results:</para>
<para><formula id="7">$ \mathcal{O}(1) $</formula>, <formula id="8">$ \mathcal{O}(n) $</formula>, <formula id="9">$ \mathcal{O}(\log{}n) $</formula>, <formula id="10">$ \mathcal{O}(n\log{}n) $</formula>, <formula id="11">$ \mathcal{O}(n^2) $</formula>, <formula id="12">$ \mathcal{O}(n^3) $</formula>.</para>
<para>If we e.g. evaluate the complexity of <computeroutput>std::sort</computeroutput>, this is the result of <computeroutput>std::cout &lt;&lt; bench.complexityBigO()</computeroutput>:</para>
<para><programlisting><codeline><highlight class="normal">|<sp/><sp/><sp/>coefficient<sp/>|<sp/><sp/><sp/>err%<sp/>|<sp/>complexity</highlight></codeline>
<codeline><highlight class="normal">|--------------:|-------:|------------</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/><sp/>5.08935e-09<sp/>|<sp/><sp/><sp/>2.6%<sp/>|<sp/>O(n<sp/>log<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/><sp/>6.10608e-08<sp/>|<sp/><sp/><sp/>8.0%<sp/>|<sp/>O(n)</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/><sp/>1.29307e-11<sp/>|<sp/><sp/>47.2%<sp/>|<sp/>O(n^2)</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/><sp/>2.48677e-15<sp/>|<sp/><sp/>69.6%<sp/>|<sp/>O(n^3)</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/><sp/>9.88133e-06<sp/>|<sp/>132.3%<sp/>|<sp/>O(log<sp/>n)</highlight></codeline>
<codeline><highlight class="normal">|<sp/><sp/><sp/>5.98793e-05<sp/>|<sp/>162.5%<sp/>|<sp/>O(1)</highlight></codeline>
</programlisting></para>
<para>So in this case <formula id="10">$ \mathcal{O}(n\log{}n) $</formula> provides the best approximation.</para>
<para><verbatim>embed:rst
See the tutorial :ref:`asymptotic-complexity` for details.
</verbatim> <simplesect kind="return"><para>Evaluation results, which can be printed or otherwise inspected. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="966" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a7af356797ebb904408474596f37f8dd1" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_big_o" kindref="compound">BigO</ref></type>
        <definition>BigO complexityBigO</definition>
        <argsstring>(char const *name, Op op) const</argsstring>
        <name>complexityBigO</name>
        <qualifiedname>ankerl::nanobench::Bench::complexityBigO</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>Op</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>Calculates bigO for a custom function. </para>
        </briefdescription>
        <detaileddescription>
<para>E.g. to calculate the mean squared error for <formula id="13">$ \mathcal{O}(\log{}\log{}n) $</formula>, which is not part of the default set of <ref refid="classankerl_1_1nanobench_1_1_bench_1ad7708f807ad0566c2a2046a21dad077c" kindref="member">complexityBigO()</ref>, you can do this:</para>
<para><programlisting><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>logLogN<sp/>=<sp/>bench.complexityBigO(</highlight><highlight class="stringliteral">&quot;O(log<sp/>log<sp/>n)&quot;</highlight><highlight class="normal">,<sp/>[](</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>n)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::log2(std::log2(n));</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para>The resulting mean squared error can be printed with <computeroutput>std::cout &lt;&lt; logLogN</computeroutput>. E.g. it prints something like this:</para>
<para><programlisting filename=".text"><codeline><highlight class="normal">2.46985e-05<sp/>*<sp/>O(log<sp/>log<sp/>n),<sp/>rms=1.48121</highlight></codeline>
</programlisting></para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Op</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of mapping operation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>Name for the function, e.g. &quot;O(log log n)&quot; </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>Op&apos;s operator() maps a <computeroutput>double</computeroutput> with the desired complexity function, e.g. <computeroutput>log2(log2(n))</computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classankerl_1_1nanobench_1_1_big_o" kindref="compound">BigO</ref> Error calculation, which is streamable to std::cout. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="992" column="10" bodyfile="src/bench/nanobench.h" bodystart="1246" bodyend="1248"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a49a469941b5daecfd6b38d962a9aea10" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Op</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_big_o" kindref="compound">BigO</ref></type>
        <definition>BigO complexityBigO</definition>
        <argsstring>(std::string const &amp;name, Op op) const</argsstring>
        <name>complexityBigO</name>
        <qualifiedname>ankerl::nanobench::Bench::complexityBigO</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>Op</type>
          <declname>op</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="995" column="10" bodyfile="src/bench/nanobench.h" bodystart="1251" bodyend="1253"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a249fd9ff213cf963f4ed78262d15fc6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; render</definition>
        <argsstring>(char const *templateContent, std::ostream &amp;os)</argsstring>
        <name>render</name>
        <qualifiedname>ankerl::nanobench::Bench::render</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>templateContent</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><verbatim>embed:rst

Convenience shortcut to :cpp:func:`ankerl::nanobench::render`.
</verbatim> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1004" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a0c983f26db77b68f2f9821ae153244bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; render</definition>
        <argsstring>(std::string const &amp;templateContent, std::ostream &amp;os)</argsstring>
        <name>render</name>
        <qualifiedname>ankerl::nanobench::Bench::render</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>templateContent</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1005" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a625fd2139bfb23bc2f985ee305968e7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; config</definition>
        <argsstring>(Config const &amp;benchmarkConfig)</argsstring>
        <name>config</name>
        <qualifiedname>ankerl::nanobench::Bench::config</qualifiedname>
        <param>
          <type><ref refid="structankerl_1_1nanobench_1_1_config" kindref="compound">Config</ref> const &amp;</type>
          <declname>benchmarkConfig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1007" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a10067e3ac091394f09b839847b5b471c" prot="public" static="no" const="yes" explicit="no" inline="no" refqual="lvalue" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) Config const &amp;config() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Bench::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1008" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_bench_1a31c3c4cae99db0c3efe0c180e9c0a9a9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Arg</type>
          </param>
        </templateparamlist>
        <type><ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench</ref> &amp;</type>
        <definition>Bench &amp; doNotOptimizeAway</definition>
        <argsstring>(Arg &amp;&amp;arg)</argsstring>
        <name>doNotOptimizeAway</name>
        <qualifiedname>ankerl::nanobench::Bench::doNotOptimizeAway</qualifiedname>
        <param>
          <type>Arg &amp;&amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1272" column="7" bodyfile="src/bench/nanobench.h" bodystart="1272" bodyend="1275"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>Main entry point to nanobench&apos;s benchmarking facility. </para>
    </briefdescription>
    <detaileddescription>
<para>It holds configuration and results from one or more benchmark runs. Usually it is used in a single line, where the object is constructed, configured, and then a benchmark is run. E.g. like this: <verbatim>ankerl::nanobench::Bench().unit(&quot;byte&quot;).batch(1000).run(&quot;random fluctuations&quot;, [&amp;] {
    // here be the benchmark code
});
</verbatim></para>
<para>In that example <ref refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" kindref="member">Bench()</ref> constructs the benchmark, it is then configured with <ref refid="classankerl_1_1nanobench_1_1_bench_1a7fada6f805f9af86b8508e8ef028d936" kindref="member">unit()</ref> and <ref refid="classankerl_1_1nanobench_1_1_bench_1a37d376bc0b00680fc13656e4761f8168" kindref="member">batch()</ref>, and after configuration a benchmark is executed with <ref refid="classankerl_1_1nanobench_1_1_bench_1ae0f1d3ec977f3733d457b759b1f08e9e" kindref="member">run()</ref>. Once <ref refid="classankerl_1_1nanobench_1_1_bench_1ae0f1d3ec977f3733d457b759b1f08e9e" kindref="member">run()</ref> has finished, it prints the result to <computeroutput>std::cout</computeroutput>. It would also store the results in the <ref refid="classankerl_1_1nanobench_1_1_bench" kindref="compound">Bench</ref> instance, but in this case the object is immediately destroyed so it&apos;s not available any more. </para>
    </detaileddescription>
    <location file="src/bench/nanobench.h" line="627" column="1" bodyfile="src/bench/nanobench.h" bodystart="627" bodyend="1013"/>
    <listofallmembers>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a63d315ebd863801fd87b91c6d00fb722" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1ac445176a2c888e2110ea39da86c55b06" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a3059fb8ac12342e1989ee7ed3c88e19a" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a9e977966aac653eeb88812eb2c8cd896" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a01c68da61eb2e2309afe3750afa9204d" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a8d7ff1a0e17181d42be2ff23373e3fd5" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1aacb57abf02ea943a9c084e0b4574570a" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a0acd95544ac4925ff0a60740a6c08f5a" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a81b78b56e2d1eecadec93dfaeb6a95f1" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a10067e3ac091394f09b839847b5b471c" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a37d376bc0b00680fc13656e4761f8168" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>batch</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a0369c631cdbbd4e61b4cdcecda634cca" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>Bench</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a3bf6b595796ee74d22f40c2d0afd99ac" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>Bench</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a2d0881f6e6c3c139ad4956f11038b70a" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>Bench</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a44b3f8a1e4c325215a84ffbf4da7fe89" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>clearContext</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a92b3a1e3050c61c1e24e42a116b92a87" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>clockResolutionMultiple</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1ad7708f807ad0566c2a2046a21dad077c" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>complexityBigO</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a7af356797ebb904408474596f37f8dd1" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>complexityBigO</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a49a469941b5daecfd6b38d962a9aea10" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>complexityBigO</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a4c2fa1375c3a79a88cfb8532b4017f69" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>complexityN</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a625fd2139bfb23bc2f985ee305968e7e" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>config</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a6c5c13becb6edb48ef7d02cc8caab1bb" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>context</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a69b97096c16fe745cedaf3adf25244e5" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>context</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a27f4d44a6c8051915296db99fe3749e3" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>doNotOptimizeAway</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a31c3c4cae99db0c3efe0c180e9c0a9a9" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>doNotOptimizeAway</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1ae084f501a2a3c61c1d128a519d4a38ae" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>epochIterations</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a2aace9b04e1962c6490d7b2bbcbf0269" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>epochs</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1abb7e4067323a8d7569e9867b03a35b39" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>maxEpochTime</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a8cb4bc11d1c85d9087b3b41b60644591" prot="private" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>mConfig</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>minEpochIterations</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>minEpochTime</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1afe996b837bb23ddf27468f5e5e167512" prot="private" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>mResults</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a8a87b6c0978c4d69179ee249beb86c0c" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>name</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a915d9b1dfd2b915540b31cdedcef09bf" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>name</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a8e386768d4be4f31f9f6dda9bfcc9034" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>operator=</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a8b9dc241748631d4a8aaaa9b491895ba" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>operator=</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a10436f841dad877a2c165f8d00e21fc6" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>output</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a631a9cd991845ac75991564a9ed80f89" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>performanceCounters</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a2b35462c62dcf9e55bf31618dd8008e0" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>relative</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a249fd9ff213cf963f4ed78262d15fc6f" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>render</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a0c983f26db77b68f2f9821ae153244bc" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>render</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1ae0f1d3ec977f3733d457b759b1f08e9e" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>run</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a0c763a995ba8b2715ddef0a845207cac" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>run</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a5ed0f9c7a612dc2b0e88fb73dc3840b2" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>run</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a13e3eaf7b5e9c0cf77da4673571c8e89" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>timeUnit</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a4e7209cd88a09e1e2278f0d506dd3aa3" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>title</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a23306c0c89ae888d98683c58c7e2bec9" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>title</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a7fada6f805f9af86b8508e8ef028d936" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>unit</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a44bc96023aa24d13b3d96f956478b304" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>unit</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1ae48156567cac1e76706ac0ce076894b7" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>warmup</name></member>
      <member refid="classankerl_1_1nanobench_1_1_bench_1a86dbc9b2f51365303f8bac1bfffe9651" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Bench</scope><name>~Bench</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
