<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="namespacenode" kind="namespace" language="C++">
    <compoundname>node</compoundname>
    <innerclass refid="classnode_1_1_importing_now" prot="public">node::ImportingNow</innerclass>
    <innerclass refid="structnode_1_1_c_block_index_work_comparator" prot="public">node::CBlockIndexWorkComparator</innerclass>
    <innerclass refid="structnode_1_1_c_block_index_height_only_comparator" prot="public">node::CBlockIndexHeightOnlyComparator</innerclass>
    <innerclass refid="structnode_1_1_prune_lock_info" prot="public">node::PruneLockInfo</innerclass>
    <innerclass refid="structnode_1_1_blockfile_cursor" prot="public">node::BlockfileCursor</innerclass>
    <innerclass refid="classnode_1_1_block_manager" prot="public">node::BlockManager</innerclass>
    <innerclass refid="structnode_1_1_index_cache_sizes" prot="public">node::IndexCacheSizes</innerclass>
    <innerclass refid="structnode_1_1_cache_sizes" prot="public">node::CacheSizes</innerclass>
    <innerclass refid="structnode_1_1_chainstate_load_options" prot="public">node::ChainstateLoadOptions</innerclass>
    <innerclass refid="structnode_1_1_node_context" prot="public">node::NodeContext</innerclass>
    <innerclass refid="classnode_1_1_kernel_notifications" prot="public">node::KernelNotifications</innerclass>
    <innerclass refid="structnode_1_1_import_mempool_options" prot="public">node::ImportMempoolOptions</innerclass>
    <innerclass refid="structnode_1_1_c_block_template" prot="public">node::CBlockTemplate</innerclass>
    <innerclass refid="classnode_1_1_block_assembler" prot="public">node::BlockAssembler</innerclass>
    <innerclass refid="structnode_1_1_ancestor_feerate_comparator" prot="public">node::AncestorFeerateComparator</innerclass>
    <innerclass refid="classnode_1_1_mini_miner_mempool_entry" prot="public">node::MiniMinerMempoolEntry</innerclass>
    <innerclass refid="structnode_1_1_iterator_comparator" prot="public">node::IteratorComparator</innerclass>
    <innerclass refid="classnode_1_1_mini_miner" prot="public">node::MiniMiner</innerclass>
    <innerclass refid="structnode_1_1_p_s_b_t_input_analysis" prot="public">node::PSBTInputAnalysis</innerclass>
    <innerclass refid="structnode_1_1_p_s_b_t_analysis" prot="public">node::PSBTAnalysis</innerclass>
    <innerclass refid="structnode_1_1_tx_download_options" prot="public">node::TxDownloadOptions</innerclass>
    <innerclass refid="structnode_1_1_tx_download_connection_info" prot="public">node::TxDownloadConnectionInfo</innerclass>
    <innerclass refid="structnode_1_1_package_to_validate" prot="public">node::PackageToValidate</innerclass>
    <innerclass refid="structnode_1_1_rejected_tx_todo" prot="public">node::RejectedTxTodo</innerclass>
    <innerclass refid="classnode_1_1_tx_download_manager" prot="public">node::TxDownloadManager</innerclass>
    <innerclass refid="classnode_1_1_tx_download_manager_impl" prot="public">node::TxDownloadManagerImpl</innerclass>
    <innerclass refid="classnode_1_1_tx_orphanage_impl" prot="public">node::TxOrphanageImpl</innerclass>
    <innerclass refid="classnode_1_1_tx_orphanage" prot="public">node::TxOrphanage</innerclass>
    <innerclass refid="structnode_1_1_block_create_options" prot="public">node::BlockCreateOptions</innerclass>
    <innerclass refid="structnode_1_1_block_wait_options" prot="public">node::BlockWaitOptions</innerclass>
    <innerclass refid="structnode_1_1_block_check_options" prot="public">node::BlockCheckOptions</innerclass>
    <innerclass refid="classnode_1_1_snapshot_metadata" prot="public">node::SnapshotMetadata</innerclass>
    <innerclass refid="classnode_1_1_warnings" prot="public">node::Warnings</innerclass>
    <innerclass refid="classnode_1_1_c_block_file_info" prot="public">node::CBlockFileInfo</innerclass>
    <innerclass refid="classnode_1_1_block_tree_d_b" prot="public">node::BlockTreeDB</innerclass>
    <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacenode_1a98a425e6239438bd079e4dff7f66122d" prot="public" static="no" strong="no">
        <type></type>
        <name>BlockfileType</name>
        <qualifiedname>node::BlockfileType</qualifiedname>
        <enumvalue id="namespacenode_1a98a425e6239438bd079e4dff7f66122da50d1448013c6f17125caee18aa418af7" prot="public">
          <name>NORMAL</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a98a425e6239438bd079e4dff7f66122da35b41de7d517da5e92177e7e362bbc3d" prot="public">
          <name>ASSUMED</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a98a425e6239438bd079e4dff7f66122da56b5eb4b51d971098daad29eb2c08aa7" prot="public">
          <name>NUM_TYPES</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="150" column="1" bodyfile="src/node/blockstorage.h" bodystart="150" bodyend="155"/>
      </memberdef>
      <memberdef kind="enum" id="namespacenode_1a0fe2809c313929ad0c569d9e1bdf3e90" prot="public" static="no" strong="yes">
        <type></type>
        <name>ReadRawError</name>
        <qualifiedname>node::ReadRawError</qualifiedname>
        <enumvalue id="namespacenode_1a0fe2809c313929ad0c569d9e1bdf3e90acf3882f1c43ab22bff0bd9d82d83251b" prot="public">
          <name>IO</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a0fe2809c313929ad0c569d9e1bdf3e90a281702e2425e1275033f10a7c8b1cff1" prot="public">
          <name>BadPartRange</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="178" column="1" bodyfile="src/node/blockstorage.h" bodystart="178" bodyend="181"/>
      </memberdef>
      <memberdef kind="enum" id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9" prot="public" static="no" strong="yes">
        <type></type>
        <name>ChainstateLoadStatus</name>
        <qualifiedname>node::ChainstateLoadStatus</qualifiedname>
        <enumvalue id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9ad0749aaba8b833466dfcbb0428e4f89c" prot="public">
          <name>SUCCESS</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9a36fc6065a3e970bc3e6b2e59da52bf2a" prot="public">
          <name>FAILURE</name>
          <briefdescription>
<para>Generic failure which reindexing may fix. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9a2fb05d7bdcda3f80f5e3004275f20d9e" prot="public">
          <name>FAILURE_FATAL</name>
          <briefdescription>
<para>Fatal error which should not prompt to reindex. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9a2b38124fce8a1f3817a166a8013baed6" prot="public">
          <name>FAILURE_INCOMPATIBLE_DB</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9abe00d62a90b3cf19eb70f7aa77b4b2af" prot="public">
          <name>FAILURE_INSUFFICIENT_DBCACHE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9a658f2cadfdf09b6046246e9314f7cd43" prot="public">
          <name>INTERRUPTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="class_chainstate" kindref="compound">Chainstate</ref> load status. Simple applications can just check for the success case, and treat other cases as errors. More complex applications may want to try reindexing in the generic failure case, and pass an interrupt callback and exit cleanly in the interrupted case. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstate.h" line="44" column="1" bodyfile="src/node/chainstate.h" bodystart="44" bodyend="51"/>
      </memberdef>
      <memberdef kind="enum" id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867ac" prot="public" static="no" strong="yes">
        <type></type>
        <name>TransactionError</name>
        <qualifiedname>node::TransactionError</qualifiedname>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867acae0aa021e21dddbd6d8cecec71e9cf564" prot="public">
          <name>OK</name>
          <briefdescription>
<para>No error. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867aca13c6cc69fcf1526c4cb5d1dc3cd983b2" prot="public">
          <name>MISSING_INPUTS</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867aca8690b0f0905e6221117ec85c96818031" prot="public">
          <name>ALREADY_IN_UTXO_SET</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867aca1deedb424b3597eb79cef9aa0e9a7984" prot="public">
          <name>MEMPOOL_REJECTED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867aca466537a158d09305601cc6fd5abda0f3" prot="public">
          <name>MEMPOOL_ERROR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867aca2d8cf211b3fe17b760bc0ef03ff34477" prot="public">
          <name>MAX_FEE_EXCEEDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867aca39fa6b6a87d1a6af5d8ff4bc969e054a" prot="public">
          <name>MAX_BURN_EXCEEDED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a857c3bfc8da2a43cebacd0582cc867acaa1d18e98c4cce4119dd68e92ce632b48" prot="public">
          <name>INVALID_PACKAGE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/types.h" line="25" column="1" bodyfile="src/node/types.h" bodystart="25" bodyend="34"/>
      </memberdef>
      <memberdef kind="enum" id="namespacenode_1a634bcbd7f41b10ba1c4e823cf2d0f3b0" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>TxBroadcast</name>
        <qualifiedname>node::TxBroadcast</qualifiedname>
        <enumvalue id="namespacenode_1a634bcbd7f41b10ba1c4e823cf2d0f3b0a4bc6ec227446e14232e4e38661e52eba" prot="public">
          <name>MEMPOOL_AND_BROADCAST_TO_ALL</name>
          <briefdescription>
<para>Add the transaction to the mempool and broadcast to all peers for which tx relay is enabled. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1a634bcbd7f41b10ba1c4e823cf2d0f3b0ad51aa9b04491965f8671738a34151a04" prot="public">
          <name>MEMPOOL_NO_BROADCAST</name>
          <briefdescription>
<para>Add the transaction to the mempool, but don&apos;t broadcast to anybody. </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>How to broadcast a local transaction. Used to influence <computeroutput><ref refid="namespacenode_1a370a682ed5a80a825a4fe2e54c13357e" kindref="member">BroadcastTransaction()</ref></computeroutput> and its callers. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/types.h" line="106" column="1" bodyfile="src/node/types.h" bodystart="106" bodyend="111"/>
      </memberdef>
      <memberdef kind="enum" id="namespacenode_1af6ea07812363481c623a23ea26fbf8ed" prot="public" static="no" strong="yes">
        <type></type>
        <name>Warning</name>
        <qualifiedname>node::Warning</qualifiedname>
        <enumvalue id="namespacenode_1af6ea07812363481c623a23ea26fbf8eda6ea37e77d2663bc9c82859d27b4b5491" prot="public">
          <name>CLOCK_OUT_OF_SYNC</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1af6ea07812363481c623a23ea26fbf8edaf5ca4b7a10867729ef12e80de51b879e" prot="public">
          <name>PRE_RELEASE_TEST_BUILD</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacenode_1af6ea07812363481c623a23ea26fbf8edaefd83e29333c885fe842a464058a2730" prot="public">
          <name>FATAL_INTERNAL_ERROR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/warnings.h" line="23" column="1" bodyfile="src/node/warnings.h" bodystart="23" bodyend="27"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacenode_1acee0086a0c833617dd1532caf93206a3" prot="public" static="no">
        <type>std::unordered_map&lt; <ref refid="classuint256" kindref="compound">uint256</ref>, <ref refid="class_c_block_index" kindref="compound">CBlockIndex</ref>, <ref refid="struct_block_hasher" kindref="compound">BlockHasher</ref> &gt;</type>
        <definition>using BlockMap =  std::unordered_map&lt;uint256, CBlockIndex, BlockHasher&gt;</definition>
        <argsstring></argsstring>
        <name>BlockMap</name>
        <qualifiedname>node::BlockMap</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="135" column="1" bodyfile="src/node/blockstorage.h" bodystart="135" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacenode_1a32a0f7eb760387e8c7bb445014017062" prot="public" static="no">
        <type>std::tuple&lt; <ref refid="namespacenode_1a779805e7cdbdeb11f4034a67cffd8cc9" kindref="member">ChainstateLoadStatus</ref>, <ref refid="structbilingual__str" kindref="compound">bilingual_str</ref> &gt;</type>
        <definition>using ChainstateLoadResult =  std::tuple&lt;ChainstateLoadStatus, bilingual_str&gt;</definition>
        <argsstring></argsstring>
        <name>ChainstateLoadResult</name>
        <qualifiedname>node::ChainstateLoadResult</qualifiedname>
        <briefdescription>
<para><ref refid="class_chainstate" kindref="compound">Chainstate</ref> load status code and optional error string. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstate.h" line="54" column="1" bodyfile="src/node/chainstate.h" bodystart="54" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespacenode_1a233b408b19b7de5f7508fd4779eed412" prot="public" static="yes" mutable="no">
        <type>const unsigned int</type>
        <definition>const unsigned int BLOCKFILE_CHUNK_SIZE</definition>
        <argsstring></argsstring>
        <name>BLOCKFILE_CHUNK_SIZE</name>
        <qualifiedname>node::BLOCKFILE_CHUNK_SIZE</qualifiedname>
        <initializer>= 0x1000000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The pre-allocation chunk size for blk?????.dat files (since 0.8) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="119" column="27" bodyfile="src/node/blockstorage.h" bodystart="119" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a08a488949c94331319f494baf9138533" prot="public" static="yes" mutable="no">
        <type>const unsigned int</type>
        <definition>const unsigned int UNDOFILE_CHUNK_SIZE</definition>
        <argsstring></argsstring>
        <name>UNDOFILE_CHUNK_SIZE</name>
        <qualifiedname>node::UNDOFILE_CHUNK_SIZE</qualifiedname>
        <initializer>= 0x100000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The pre-allocation chunk size for rev?????.dat files (since 0.8) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="121" column="27" bodyfile="src/node/blockstorage.h" bodystart="121" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1ac30cba28d8b99d42860e735cb56649cb" prot="public" static="yes" mutable="no">
        <type>const unsigned int</type>
        <definition>const unsigned int MAX_BLOCKFILE_SIZE</definition>
        <argsstring></argsstring>
        <name>MAX_BLOCKFILE_SIZE</name>
        <qualifiedname>node::MAX_BLOCKFILE_SIZE</qualifiedname>
        <initializer>= 0x8000000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The maximum size of a blk?????.dat file (since 0.8) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="123" column="27" bodyfile="src/node/blockstorage.h" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1acf68e7421c04b9badba3a9d44616ab30" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t STORAGE_HEADER_BYTES</definition>
        <argsstring></argsstring>
        <name>STORAGE_HEADER_BYTES</name>
        <qualifiedname>node::STORAGE_HEADER_BYTES</qualifiedname>
        <initializer>{std::tuple_size_v&lt;<ref refid="messagestartchars_8h_1a36e9a2b67a1635319b4fa1545597c60e" kindref="member">MessageStartChars</ref>&gt; + sizeof(unsigned int)}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Size of header written by WriteBlock before a serialized <ref refid="class_c_block" kindref="compound">CBlock</ref> (8 bytes) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="126" column="27" bodyfile="src/node/blockstorage.h" bodystart="126" bodyend="126"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a7e0ff75790c6cafc96dfe84dbcf58d0a" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t UNDO_DATA_DISK_OVERHEAD</definition>
        <argsstring></argsstring>
        <name>UNDO_DATA_DISK_OVERHEAD</name>
        <qualifiedname>node::UNDO_DATA_DISK_OVERHEAD</qualifiedname>
        <initializer>{STORAGE_HEADER_BYTES + <ref refid="classbase__blob_1aef394d21483a3bd68d158f790aab3b3c" kindref="member">uint256::size</ref>()}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Total overhead when writing undo data: header (8 bytes) plus checksum (32 bytes) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.h" line="129" column="27" bodyfile="src/node/blockstorage.h" bodystart="129" bodyend="129"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1aa9aa7c55ac04fde79d3c8aae4f5afd25" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>int</type>
        <definition>int DEFAULT_STOPATHEIGHT</definition>
        <argsstring></argsstring>
        <name>DEFAULT_STOPATHEIGHT</name>
        <qualifiedname>node::DEFAULT_STOPATHEIGHT</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/kernel_notifications.h" line="30" column="22" bodyfile="src/node/kernel_notifications.h" bodystart="30" bodyend="30"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1ae6f6e66c04e64391957003eafcee24ba" prot="public" static="yes" mutable="no">
        <type>const uint64_t</type>
        <definition>const uint64_t MEMPOOL_DUMP_VERSION_NO_XOR_KEY</definition>
        <argsstring></argsstring>
        <name>MEMPOOL_DUMP_VERSION_NO_XOR_KEY</name>
        <qualifiedname>node::MEMPOOL_DUMP_VERSION_NO_XOR_KEY</qualifiedname>
        <initializer>{1}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist.cpp" line="40" column="23" bodyfile="src/node/mempool_persist.cpp" bodystart="40" bodyend="40"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a0c3f6ddbed83edca2638317f36360b6b" prot="public" static="yes" mutable="no">
        <type>const uint64_t</type>
        <definition>const uint64_t MEMPOOL_DUMP_VERSION</definition>
        <argsstring></argsstring>
        <name>MEMPOOL_DUMP_VERSION</name>
        <qualifiedname>node::MEMPOOL_DUMP_VERSION</qualifiedname>
        <initializer>{2}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist.cpp" line="41" column="23" bodyfile="src/node/mempool_persist.cpp" bodystart="41" bodyend="41"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a54a6e954a9787703d1eedf48e7370f92" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>bool</type>
        <definition>bool DEFAULT_PERSIST_MEMPOOL</definition>
        <argsstring></argsstring>
        <name>DEFAULT_PERSIST_MEMPOOL</name>
        <qualifiedname>node::DEFAULT_PERSIST_MEMPOOL</qualifiedname>
        <initializer>{true}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default for -persistmempool, indicating whether the node should attempt to automatically load the mempool on start and save to disk on shutdown </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist_args.h" line="18" column="23" bodyfile="src/node/mempool_persist_args.h" bodystart="18" bodyend="18"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a6c1615e5fb91cbf96d39e2bad9bb5ab7" prot="public" static="yes" mutable="no">
        <type>const bool</type>
        <definition>const bool DEFAULT_PRINT_MODIFIED_FEE</definition>
        <argsstring></argsstring>
        <name>DEFAULT_PRINT_MODIFIED_FEE</name>
        <qualifiedname>node::DEFAULT_PRINT_MODIFIED_FEE</qualifiedname>
        <initializer>= false</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.h" line="40" column="19" bodyfile="src/node/miner.h" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a07586beb7a689a559b11881e3a866fa4" prot="public" static="yes" mutable="no">
        <type>const <ref refid="class_c_fee_rate" kindref="compound">CFeeRate</ref></type>
        <definition>const CFeeRate DEFAULT_MAX_RAW_TX_FEE_RATE</definition>
        <argsstring></argsstring>
        <name>DEFAULT_MAX_RAW_TX_FEE_RATE</name>
        <qualifiedname>node::DEFAULT_MAX_RAW_TX_FEE_RATE</qualifiedname>
        <initializer>{COIN / 10}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maximum fee rate for sendrawtransaction and testmempoolaccept RPC calls. Also used by the GUI when broadcasting a completed PSBT. By default, a transaction with a fee rate higher than this will be rejected by these RPCs and the GUI. This can be overridden with the maxfeerate argument. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/transaction.h" line="28" column="23" bodyfile="src/node/transaction.h" bodystart="28" bodyend="28"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a1d43a6fab9edfab80e40801e3e7e8514" prot="public" static="yes" mutable="no">
        <type>const <ref refid="amount_8h_1a4eaf3a5239714d8c45b851527f7cb564" kindref="member">CAmount</ref></type>
        <definition>const CAmount DEFAULT_MAX_BURN_AMOUNT</definition>
        <argsstring></argsstring>
        <name>DEFAULT_MAX_BURN_AMOUNT</name>
        <qualifiedname>node::DEFAULT_MAX_BURN_AMOUNT</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maximum burn value for sendrawtransaction, submitpackage, and testmempoolaccept RPC calls. By default, a transaction with a burn value higher than this will be rejected by these RPCs and the GUI. This can be overridden with the maxburnamount argument. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/transaction.h" line="34" column="22" bodyfile="src/node/transaction.h" bodystart="34" bodyend="34"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a7003b0f94c7c5c459ea8f1e3b5ee78d4" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>int32_t</type>
        <definition>int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT</definition>
        <argsstring></argsstring>
        <name>MAX_PEER_TX_REQUEST_IN_FLIGHT</name>
        <qualifiedname>node::MAX_PEER_TX_REQUEST_IN_FLIGHT</qualifiedname>
        <initializer>= 100</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maximum number of in-flight transaction requests from a peer. It is not a hard limit, but the threshold at which point the OVERLOADED_PEER_TX_DELAY kicks in. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txdownloadman.h" line="25" column="26" bodyfile="src/node/txdownloadman.h" bodystart="25" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1ab57e7385311be6d60ec67e94328f0980" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>int32_t</type>
        <definition>int32_t MAX_PEER_TX_ANNOUNCEMENTS</definition>
        <argsstring></argsstring>
        <name>MAX_PEER_TX_ANNOUNCEMENTS</name>
        <qualifiedname>node::MAX_PEER_TX_ANNOUNCEMENTS</qualifiedname>
        <initializer>= 5000</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving the actual transaction (from any peer) in response to requests for them. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txdownloadman.h" line="30" column="26" bodyfile="src/node/txdownloadman.h" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1abbb6e49718cb41bce9628858c303ca2d" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>auto</type>
        <definition>auto TXID_RELAY_DELAY</definition>
        <argsstring></argsstring>
        <name>TXID_RELAY_DELAY</name>
        <qualifiedname>node::TXID_RELAY_DELAY</qualifiedname>
        <initializer>{2s}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>How long to delay requesting transactions via txids, if we have wtxid-relaying peers </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txdownloadman.h" line="32" column="23" bodyfile="src/node/txdownloadman.h" bodystart="32" bodyend="32"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1af7e00ad57c10826e5ca37980a76d132d" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>auto</type>
        <definition>auto NONPREF_PEER_TX_DELAY</definition>
        <argsstring></argsstring>
        <name>NONPREF_PEER_TX_DELAY</name>
        <qualifiedname>node::NONPREF_PEER_TX_DELAY</qualifiedname>
        <initializer>{2s}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>How long to delay requesting transactions from non-preferred peers </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txdownloadman.h" line="34" column="23" bodyfile="src/node/txdownloadman.h" bodystart="34" bodyend="34"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a76ce1dddc70fac2533ece575a90610bd" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>auto</type>
        <definition>auto OVERLOADED_PEER_TX_DELAY</definition>
        <argsstring></argsstring>
        <name>OVERLOADED_PEER_TX_DELAY</name>
        <qualifiedname>node::OVERLOADED_PEER_TX_DELAY</qualifiedname>
        <initializer>{2s}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>How long to delay requesting transactions from overloaded peers (see MAX_PEER_TX_REQUEST_IN_FLIGHT). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txdownloadman.h" line="36" column="23" bodyfile="src/node/txdownloadman.h" bodystart="36" bodyend="36"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1ad2403fb92be63513bee1449299e1f9d9" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>auto</type>
        <definition>auto GETDATA_TX_INTERVAL</definition>
        <argsstring></argsstring>
        <name>GETDATA_TX_INTERVAL</name>
        <qualifiedname>node::GETDATA_TX_INTERVAL</qualifiedname>
        <initializer>{60s}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>How long to wait before downloading a transaction from an additional peer </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txdownloadman.h" line="38" column="23" bodyfile="src/node/txdownloadman.h" bodystart="38" bodyend="38"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a8c5a10ae0865e19f7194f62e89761de9" prot="public" static="yes" constexpr="yes" mutable="no">
        <type><ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref></type>
        <definition>NodeId MIN_PEER</definition>
        <argsstring></argsstring>
        <name>MIN_PEER</name>
        <qualifiedname>node::MIN_PEER</qualifiedname>
        <initializer>{std::numeric_limits&lt;<ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref>&gt;::min()}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Minimum <ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref> for lower_bound lookups (in practice, NodeIds start at 0). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txorphanage.cpp" line="26" column="25" bodyfile="src/node/txorphanage.cpp" bodystart="26" bodyend="26"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a3dc90001ff25b605be8f3e6707144c49" prot="public" static="yes" constexpr="yes" mutable="no">
        <type><ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref></type>
        <definition>NodeId MAX_PEER</definition>
        <argsstring></argsstring>
        <name>MAX_PEER</name>
        <qualifiedname>node::MAX_PEER</qualifiedname>
        <initializer>{std::numeric_limits&lt;<ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref>&gt;::max()}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maximum <ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref> for upper_bound lookups. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txorphanage.cpp" line="28" column="25" bodyfile="src/node/txorphanage.cpp" bodystart="28" bodyend="28"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a04317a3a5246377309b7ccc9d89b6ac6" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>int64_t</type>
        <definition>int64_t DEFAULT_RESERVED_ORPHAN_WEIGHT_PER_PEER</definition>
        <argsstring></argsstring>
        <name>DEFAULT_RESERVED_ORPHAN_WEIGHT_PER_PEER</name>
        <qualifiedname>node::DEFAULT_RESERVED_ORPHAN_WEIGHT_PER_PEER</qualifiedname>
        <initializer>{404&apos;000}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default value for TxOrphanage::m_reserved_usage_per_peer. Helps limit the total amount of memory used by the orphanage. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txorphanage.h" line="20" column="26" bodyfile="src/node/txorphanage.h" bodystart="20" bodyend="20"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1a6229f1c6a096512534a4d093f81bc852" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>unsigned int</type>
        <definition>unsigned int DEFAULT_MAX_ORPHANAGE_LATENCY_SCORE</definition>
        <argsstring></argsstring>
        <name>DEFAULT_MAX_ORPHANAGE_LATENCY_SCORE</name>
        <qualifiedname>node::DEFAULT_MAX_ORPHANAGE_LATENCY_SCORE</qualifiedname>
        <initializer>{3000}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Default value for TxOrphanage::m_max_global_latency_score. Helps limit the maximum latency for operations like EraseForBlock and LimitOrphans. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txorphanage.h" line="23" column="31" bodyfile="src/node/txorphanage.h" bodystart="23" bodyend="23"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1ae40260991115210bae924c07e683ac91" prot="public" static="no" mutable="no">
        <type>const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref></type>
        <definition>const fs::path SNAPSHOT_BLOCKHASH_FILENAME</definition>
        <argsstring></argsstring>
        <name>SNAPSHOT_BLOCKHASH_FILENAME</name>
        <qualifiedname>node::SNAPSHOT_BLOCKHASH_FILENAME</qualifiedname>
        <initializer>{&quot;base_blockhash&quot;}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The file in the snapshot chainstate dir which stores the base blockhash. This is needed to reconstruct snapshot chainstates on init.</para>
<para>Because we only allow loading a single snapshot at a time, there will only be one chainstate directory with this filename present within it. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/utxo_snapshot.h" line="113" column="16" bodyfile="src/node/utxo_snapshot.h" bodystart="113" bodyend="113"/>
      </memberdef>
      <memberdef kind="variable" id="namespacenode_1afefb365ea639adf55cb1729e630c3f0f" prot="public" static="no" constexpr="yes" mutable="no">
        <type>bool <ref refid="namespacenode_1aa28134e14a9f1ba865d7ca064e0486dd" kindref="member">WriteSnapshotBaseBlockhash</ref>(<ref refid="class_chainstate" kindref="compound">Chainstate</ref> &amp;snapshot_chainstate) <ref refid="thread__annotations_8h_1a0e2e86b0f11d9778240b0a0b263047b1" kindref="member">EXCLUSIVE_LOCKS_REQUIRED</ref>(std::optional&lt; <ref refid="classuint256" kindref="compound">uint256</ref> &gt; <ref refid="namespacenode_1a4d2cd11f67bcd44c8e56621eeee89695" kindref="member">ReadSnapshotBaseBlockhash</ref>(<ref refid="classfs_1_1path" kindref="compound">fs::path</ref> chaindir) <ref refid="thread__annotations_8h_1a0e2e86b0f11d9778240b0a0b263047b1" kindref="member">EXCLUSIVE_LOCKS_REQUIRED</ref>(constexpr std::string_vie</type>
        <definition>bool WriteSnapshotBaseBlockhash (Chainstate&amp; snapshot_chainstate) EXCLUSIVE_LOCKS_REQUIRED( std::optional&lt;uint256&gt; ReadSnapshotBaseBlockhash (fs::path chaindir) EXCLUSIVE_LOCKS_REQUIRED( constexpr std::string_vie SNAPSHOT_CHAINSTATE_SUFFIX) </definition>
        <argsstring>)</argsstring>
        <name>SNAPSHOT_CHAINSTATE_SUFFIX</name>
        <qualifiedname>node::SNAPSHOT_CHAINSTATE_SUFFIX</qualifiedname>
        <initializer>= &quot;_snapshot&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write out the blockhash of the snapshot base block that was used to construct this chainstate. This value is read in during subsequent initializations and used to reconstruct snapshot-based chainstates.</para>
<para>Read the blockhash of the snapshot base block that was used to construct the chainstate.</para>
<para>Suffix appended to the chainstate (leveldb) dir when created based upon a snapshot. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/utxo_snapshot.h" line="128" column="28" bodyfile="src/node/utxo_snapshot.h" bodystart="128" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacenode_1a368871e388c86ded0c565744aea7a45f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void AbortNode</definition>
        <argsstring>(const std::function&lt; bool()&gt; &amp;shutdown_request, std::atomic&lt; int &gt; &amp;exit_status, const bilingual_str &amp;message, node::Warnings *warnings)</argsstring>
        <name>AbortNode</name>
        <qualifiedname>node::AbortNode</qualifiedname>
        <param>
          <type>const std::function&lt; bool()&gt; &amp;</type>
          <declname>shutdown_request</declname>
        </param>
        <param>
          <type>std::atomic&lt; int &gt; &amp;</type>
          <declname>exit_status</declname>
        </param>
        <param>
          <type>const <ref refid="structbilingual__str" kindref="compound">bilingual_str</ref> &amp;</type>
          <declname>message</declname>
        </param>
        <param>
          <type><ref refid="classnode_1_1_warnings" kindref="compound">node::Warnings</ref> *</type>
          <declname>warnings</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/abort.cpp" line="18" column="6" bodyfile="src/node/abort.cpp" bodystart="18" bodyend="26" declfile="src/node/abort.h" declline="15" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a6426f2baab5b795996c215224a46506b" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classutil_1_1_result" kindref="compound">util::Result</ref>&lt; void &gt;</type>
        <definition>util::Result&lt; void &gt; ApplyArgsManOptions</definition>
        <argsstring>(const ArgsManager &amp;args, BlockManager::Options &amp;opts)</argsstring>
        <name>ApplyArgsManOptions</name>
        <qualifiedname>node::ApplyArgsManOptions</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type><ref refid="classnode_1_1_block_manager_1a9d388cded97cd9f86c06358bb29abfad" kindref="member">BlockManager::Options</ref> &amp;</type>
          <declname>opts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockmanager_args.cpp" line="18" column="14" bodyfile="src/node/blockmanager_args.cpp" bodystart="18" bodyend="41" declfile="src/node/blockmanager_args.h" declline="15" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a4349df0313f3c50563be3f9aa7f5561c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>auto</type>
        <definition>static auto InitBlocksdirXorKey</definition>
        <argsstring>(const BlockManager::Options &amp;opts)</argsstring>
        <name>InitBlocksdirXorKey</name>
        <qualifiedname>node::InitBlocksdirXorKey</qualifiedname>
        <param>
          <type>const <ref refid="classnode_1_1_block_manager_1a9d388cded97cd9f86c06358bb29abfad" kindref="member">BlockManager::Options</ref> &amp;</type>
          <declname>opts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.cpp" line="1150" column="13" bodyfile="src/node/blockstorage.cpp" bodystart="1150" bodyend="1205"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a50030ce5206985e346250590dabd6d88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ImportBlocks</definition>
        <argsstring>(ChainstateManager &amp;chainman, std::span&lt; const fs::path &gt; import_paths)</argsstring>
        <name>ImportBlocks</name>
        <qualifiedname>node::ImportBlocks</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type>std::span&lt; const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref> &gt;</type>
          <declname>import_paths</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.cpp" line="1244" column="6" bodyfile="src/node/blockstorage.cpp" bodystart="1244" bodyend="1299" declfile="src/node/blockstorage.h" declline="478" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a3dad8e14e2d281a9ba7752916ddf22d3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BlockfileType &amp;type)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>node::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="namespacenode_1a98a425e6239438bd079e4dff7f66122d" kindref="member">BlockfileType</ref> &amp;</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.cpp" line="1301" column="1" bodyfile="src/node/blockstorage.cpp" bodystart="1301" bodyend="1308" declfile="src/node/blockstorage.h" declline="157" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a8c2935402f5ef3018e44e3af4b7e4ba1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const BlockfileCursor &amp;cursor)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>node::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="structnode_1_1_blockfile_cursor" kindref="compound">BlockfileCursor</ref> &amp;</type>
          <declname>cursor</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/blockstorage.cpp" line="1310" column="1" bodyfile="src/node/blockstorage.cpp" bodystart="1310" bodyend="1313" declfile="src/node/blockstorage.h" declline="176" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a60050413c3759b24940261580a5bc25b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t CalculateDbCacheBytes</definition>
        <argsstring>(const ArgsManager &amp;args)</argsstring>
        <name>CalculateDbCacheBytes</name>
        <qualifiedname>node::CalculateDbCacheBytes</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/caches.cpp" line="29" column="8" bodyfile="src/node/caches.cpp" bodystart="29" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1aa1c9faa8f74afc4645721e442c54b9c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_cache_sizes" kindref="compound">CacheSizes</ref></type>
        <definition>CacheSizes CalculateCacheSizes</definition>
        <argsstring>(const ArgsManager &amp;args, size_t n_indexes)</argsstring>
        <name>CalculateCacheSizes</name>
        <qualifiedname>node::CalculateCacheSizes</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n_indexes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/caches.cpp" line="40" column="12" bodyfile="src/node/caches.cpp" bodystart="40" bodyend="53" declfile="src/node/caches.h" declline="29" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a0156a0d2c3be07b28980d8ad967263ee" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void LogOversizedDbCache</definition>
        <argsstring>(const ArgsManager &amp;args) noexcept</argsstring>
        <name>LogOversizedDbCache</name>
        <qualifiedname>node::LogOversizedDbCache</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/caches.cpp" line="55" column="6" bodyfile="src/node/caches.cpp" bodystart="55" bodyend="64" declfile="src/node/caches.h" declline="36" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a4c30a66b5de0d011291e6530ddb04375" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool ShouldWarnOversizedDbCache</definition>
        <argsstring>(size_t dbcache, size_t total_ram) noexcept</argsstring>
        <name>ShouldWarnOversizedDbCache</name>
        <qualifiedname>node::ShouldWarnOversizedDbCache</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>dbcache</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>total_ram</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/caches.h" line="30" column="16" bodyfile="src/node/caches.h" bodystart="30" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a20cc5dbc53f5e1b87abf4727ec17cb46" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacenode_1a32a0f7eb760387e8c7bb445014017062" kindref="member">ChainstateLoadResult</ref></type>
        <definition>static ChainstateLoadResult CompleteChainstateInitialization</definition>
        <argsstring>(ChainstateManager &amp;chainman, const ChainstateLoadOptions &amp;options) EXCLUSIVE_LOCKS_REQUIRED(</argsstring>
        <name>CompleteChainstateInitialization</name>
        <qualifiedname>node::CompleteChainstateInitialization</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type>const <ref refid="structnode_1_1_chainstate_load_options" kindref="compound">ChainstateLoadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstate.cpp" line="34" column="29" bodyfile="src/node/chainstate.cpp" bodystart="34" bodyend="142"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a2d650cf978844ae65f6667c85fc53ede" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacenode_1a32a0f7eb760387e8c7bb445014017062" kindref="member">ChainstateLoadResult</ref></type>
        <definition>ChainstateLoadResult LoadChainstate</definition>
        <argsstring>(ChainstateManager &amp;chainman, const CacheSizes &amp;cache_sizes, const ChainstateLoadOptions &amp;options)</argsstring>
        <name>LoadChainstate</name>
        <qualifiedname>node::LoadChainstate</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type>const <ref refid="struct_cache_sizes" kindref="compound">CacheSizes</ref> &amp;</type>
          <declname>cache_sizes</declname>
        </param>
        <param>
          <type>const <ref refid="structnode_1_1_chainstate_load_options" kindref="compound">ChainstateLoadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstate.cpp" line="144" column="22" bodyfile="src/node/chainstate.cpp" bodystart="144" bodyend="231"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1aa25a7902215e7a3de72f3b19a4372167" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacenode_1a32a0f7eb760387e8c7bb445014017062" kindref="member">ChainstateLoadResult</ref></type>
        <definition>ChainstateLoadResult VerifyLoadedChainstate</definition>
        <argsstring>(ChainstateManager &amp;chainman, const ChainstateLoadOptions &amp;options)</argsstring>
        <name>VerifyLoadedChainstate</name>
        <qualifiedname>node::VerifyLoadedChainstate</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type>const <ref refid="structnode_1_1_chainstate_load_options" kindref="compound">ChainstateLoadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstate.cpp" line="233" column="22" bodyfile="src/node/chainstate.cpp" bodystart="233" bodyend="272" declfile="src/node/chainstate.h" declline="71" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a2dbdeed288a3645a5ebb91335a1a86d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacenode_1a32a0f7eb760387e8c7bb445014017062" kindref="member">ChainstateLoadResult</ref></type>
        <definition>ChainstateLoadResult LoadChainstate</definition>
        <argsstring>(ChainstateManager &amp;chainman, const kernel::CacheSizes &amp;cache_sizes, const ChainstateLoadOptions &amp;options)</argsstring>
        <name>LoadChainstate</name>
        <qualifiedname>node::LoadChainstate</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type>const <ref refid="structkernel_1_1_cache_sizes" kindref="compound">kernel::CacheSizes</ref> &amp;</type>
          <declname>cache_sizes</declname>
        </param>
        <param>
          <type>const <ref refid="structnode_1_1_chainstate_load_options" kindref="compound">ChainstateLoadOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This sequence can have 4 types of outcomes:</para>
<para><orderedlist>
<listitem><para>Success</para>
</listitem><listitem><para>Shutdown requested<itemizedlist>
<listitem><para>nothing failed but a shutdown was triggered in the middle of the sequence</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Soft failure<itemizedlist>
<listitem><para>a failure that might be recovered from with a reindex</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Hard failure<itemizedlist>
<listitem><para>a failure that definitively cannot be recovered from with a reindex</para>
</listitem></itemizedlist>
</para>
</listitem></orderedlist>
</para>
<para>LoadChainstate returns a (status code, error string) tuple. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstate.h" line="69" column="22" declfile="src/node/chainstate.h" declline="69" declcolumn="22"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a862701ebfab8fe9ffae6b0106682fa81" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classutil_1_1_result" kindref="compound">util::Result</ref>&lt; void &gt;</type>
        <definition>util::Result&lt; void &gt; ApplyArgsManOptions</definition>
        <argsstring>(const ArgsManager &amp;args, ChainstateManager::Options &amp;opts)</argsstring>
        <name>ApplyArgsManOptions</name>
        <qualifiedname>node::ApplyArgsManOptions</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type><ref refid="class_chainstate_manager_1a66bc0ee7102eaf1cbd62d3a9d7087e52" kindref="member">ChainstateManager::Options</ref> &amp;</type>
          <declname>opts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/chainstatemanager_args.cpp" line="25" column="14" bodyfile="src/node/chainstatemanager_args.cpp" bodystart="25" bodyend="73" declfile="src/node/chainstatemanager_args.h" declline="17" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a7cbf0dd47c6f8c068e7604434f8e0457" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void FindCoins</definition>
        <argsstring>(const NodeContext &amp;node, std::map&lt; COutPoint, Coin &gt; &amp;coins)</argsstring>
        <name>FindCoins</name>
        <qualifiedname>node::FindCoins</qualifiedname>
        <param>
          <type>const <ref refid="structnode_1_1_node_context" kindref="compound">node::NodeContext</ref> &amp;</type>
          <declname>node</declname>
        </param>
        <param>
          <type>std::map&lt; <ref refid="class_c_out_point" kindref="compound">COutPoint</ref>, <ref refid="class_coin" kindref="compound">Coin</ref> &gt; &amp;</type>
          <declname>coins</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Look up unspent output information. Returns coins in the mempool and in the current chain UTXO set. Iterates through all the keys in the map and populates the values.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>The node context to use for lookup </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">coins</parametername>
</parameternamelist>
<parameterdescription>
<para>map to fill </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/coin.cpp" line="12" column="6" bodyfile="src/node/coin.cpp" bodystart="12" bodyend="26" declfile="src/node/coin.h" declline="24" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ab60165720176200b11a590d7f740dcaa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ReadCoinsViewArgs</definition>
        <argsstring>(const ArgsManager &amp;args, CoinsViewOptions &amp;options)</argsstring>
        <name>ReadCoinsViewArgs</name>
        <qualifiedname>node::ReadCoinsViewArgs</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type><ref refid="struct_coins_view_options" kindref="compound">CoinsViewOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/coins_view_args.cpp" line="11" column="6" bodyfile="src/node/coins_view_args.cpp" bodystart="11" bodyend="15" declfile="src/node/coins_view_args.h" declline="12" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a44ea8e2133a215e8a67a087fa4ab90e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ReadDatabaseArgs</definition>
        <argsstring>(const ArgsManager &amp;args, DBOptions &amp;options)</argsstring>
        <name>ReadDatabaseArgs</name>
        <qualifiedname>node::ReadDatabaseArgs</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type><ref refid="struct_d_b_options" kindref="compound">DBOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/database_args.cpp" line="11" column="6" bodyfile="src/node/database_args.cpp" bodystart="11" bodyend="17" declfile="src/node/database_args.h" declline="12" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1acd82a235461d5587ce350b06c7fa3011" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ReadNotificationArgs</definition>
        <argsstring>(const ArgsManager &amp;args, KernelNotifications &amp;notifications)</argsstring>
        <name>ReadNotificationArgs</name>
        <qualifiedname>node::ReadNotificationArgs</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type><ref refid="class_kernel_notifications" kindref="compound">KernelNotifications</ref> &amp;</type>
          <declname>notifications</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/kernel_notifications.cpp" line="110" column="6" bodyfile="src/node/kernel_notifications.cpp" bodystart="110" bodyend="113" declfile="src/node/kernel_notifications.h" declline="72" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ab2381316504e955ba03329e6eae581cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool LoadMempool</definition>
        <argsstring>(CTxMemPool &amp;pool, const fs::path &amp;load_path, Chainstate &amp;active_chainstate, ImportMempoolOptions &amp;&amp;opts)</argsstring>
        <name>LoadMempool</name>
        <qualifiedname>node::LoadMempool</qualifiedname>
        <param>
          <type><ref refid="class_c_tx_mem_pool" kindref="compound">CTxMemPool</ref> &amp;</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref> &amp;</type>
          <declname>load_path</declname>
        </param>
        <param>
          <type><ref refid="class_chainstate" kindref="compound">Chainstate</ref> &amp;</type>
          <declname>active_chainstate</declname>
        </param>
        <param>
          <type><ref refid="structnode_1_1_import_mempool_options" kindref="compound">ImportMempoolOptions</ref> &amp;&amp;</type>
          <declname>opts</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Import the file and attempt to add its contents to the mempool. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist.cpp" line="43" column="6" bodyfile="src/node/mempool_persist.cpp" bodystart="43" bodyend="151" declfile="src/node/mempool_persist.h" declline="27" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ab50998edc0bcd4e1b0990d891b7ee90b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool DumpMempool</definition>
        <argsstring>(const CTxMemPool &amp;pool, const fs::path &amp;dump_path, FopenFn mockable_fopen_function, bool skip_file_commit)</argsstring>
        <name>DumpMempool</name>
        <qualifiedname>node::DumpMempool</qualifiedname>
        <param>
          <type>const <ref refid="class_c_tx_mem_pool" kindref="compound">CTxMemPool</ref> &amp;</type>
          <declname>pool</declname>
        </param>
        <param>
          <type>const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref> &amp;</type>
          <declname>dump_path</declname>
        </param>
        <param>
          <type><ref refid="namespacefsbridge_1a37b0fd82fe2a81c8cf4ecedc6f083cd5" kindref="member">fsbridge::FopenFn</ref></type>
          <declname>mockable_fopen_function</declname>
          <defval><ref refid="namespacefsbridge_1a52093f6db7ef176f21e89f9e46367ded" kindref="member">fsbridge::fopen</ref></defval>
        </param>
        <param>
          <type>bool</type>
          <declname>skip_file_commit</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Dump the mempool to a file. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist.cpp" line="153" column="6" bodyfile="src/node/mempool_persist.cpp" bodystart="153" bodyend="231" declfile="src/node/mempool_persist.h" declline="16" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a2ca33310929752f44f32a912fc1634ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool ShouldPersistMempool</definition>
        <argsstring>(const ArgsManager &amp;argsman)</argsstring>
        <name>ShouldPersistMempool</name>
        <qualifiedname>node::ShouldPersistMempool</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>argsman</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist_args.cpp" line="13" column="6" bodyfile="src/node/mempool_persist_args.cpp" bodystart="13" bodyend="16" declfile="src/node/mempool_persist_args.h" declline="20" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a33310f5279d28a2f9fcc1b3a51cf53ff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classfs_1_1path" kindref="compound">fs::path</ref></type>
        <definition>fs::path MempoolPath</definition>
        <argsstring>(const ArgsManager &amp;argsman)</argsstring>
        <name>MempoolPath</name>
        <qualifiedname>node::MempoolPath</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>argsman</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/mempool_persist_args.cpp" line="18" column="10" bodyfile="src/node/mempool_persist_args.cpp" bodystart="18" bodyend="21" declfile="src/node/mempool_persist_args.h" declline="21" declcolumn="10"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ab0a9f566c87d8e762f84ad2ccc060177" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t GetMinimumTime</definition>
        <argsstring>(const CBlockIndex *pindexPrev, const int64_t difficulty_adjustment_interval)</argsstring>
        <name>GetMinimumTime</name>
        <qualifiedname>node::GetMinimumTime</qualifiedname>
        <param>
          <type>const <ref refid="class_c_block_index" kindref="compound">CBlockIndex</ref> *</type>
          <declname>pindexPrev</declname>
        </param>
        <param>
          <type>const int64_t</type>
          <declname>difficulty_adjustment_interval</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the minimum time a miner should use in the next block. This always accounts for the BIP94 timewarp rule, so does not necessarily reflect the consensus limit. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="36" column="9" bodyfile="src/node/miner.cpp" bodystart="36" bodyend="47" declfile="src/node/miner.h" declline="126" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a9c09903c7d6401b5405db02af064179c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t UpdateTime</definition>
        <argsstring>(CBlockHeader *pblock, const Consensus::Params &amp;consensusParams, const CBlockIndex *pindexPrev)</argsstring>
        <name>UpdateTime</name>
        <qualifiedname>node::UpdateTime</qualifiedname>
        <param>
          <type><ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref> *</type>
          <declname>pblock</declname>
        </param>
        <param>
          <type>const <ref refid="struct_consensus_1_1_params" kindref="compound">Consensus::Params</ref> &amp;</type>
          <declname>consensusParams</declname>
        </param>
        <param>
          <type>const <ref refid="class_c_block_index" kindref="compound">CBlockIndex</ref> *</type>
          <declname>pindexPrev</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="49" column="9" bodyfile="src/node/miner.cpp" bodystart="49" bodyend="65" declfile="src/node/miner.h" declline="128" declcolumn="9"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ad7d81a8f20e10a0889027618f1ca7c96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void RegenerateCommitments</definition>
        <argsstring>(CBlock &amp;block, ChainstateManager &amp;chainman)</argsstring>
        <name>RegenerateCommitments</name>
        <qualifiedname>node::RegenerateCommitments</qualifiedname>
        <param>
          <type><ref refid="class_c_block" kindref="compound">CBlock</ref> &amp;</type>
          <declname>block</declname>
        </param>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="67" column="6" bodyfile="src/node/miner.cpp" bodystart="67" bodyend="77" declfile="src/node/miner.h" declline="131" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a35d39903358007a3b239d38c6f07b8c3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_block_assembler_1_1_options" kindref="compound">BlockAssembler::Options</ref></type>
        <definition>static BlockAssembler::Options ClampOptions</definition>
        <argsstring>(BlockAssembler::Options options)</argsstring>
        <name>ClampOptions</name>
        <qualifiedname>node::ClampOptions</qualifiedname>
        <param>
          <type><ref refid="struct_block_assembler_1_1_options" kindref="compound">BlockAssembler::Options</ref></type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="79" column="32" bodyfile="src/node/miner.cpp" bodystart="79" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1aa0502f4c140961e55cf2ea92ffe97616" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ApplyArgsManOptions</definition>
        <argsstring>(const ArgsManager &amp;args, BlockAssembler::Options &amp;options)</argsstring>
        <name>ApplyArgsManOptions</name>
        <qualifiedname>node::ApplyArgsManOptions</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>gArgs</declname>
        </param>
        <param>
          <type><ref refid="struct_block_assembler_1_1_options" kindref="compound">BlockAssembler::Options</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Apply -blockmintxfee and -blockmaxweight options from <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> to <ref refid="classnode_1_1_block_assembler" kindref="compound">BlockAssembler</ref> options. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="97" column="6" bodyfile="src/node/miner.cpp" bodystart="97" bodyend="106" declfile="src/node/miner.h" declline="134" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1af655b23c126974dd09b63bb8c9333438" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void AddMerkleRootAndCoinbase</definition>
        <argsstring>(CBlock &amp;block, CTransactionRef coinbase, uint32_t version, uint32_t timestamp, uint32_t nonce)</argsstring>
        <name>AddMerkleRootAndCoinbase</name>
        <qualifiedname>node::AddMerkleRootAndCoinbase</qualifiedname>
        <param>
          <type><ref refid="class_c_block" kindref="compound">CBlock</ref> &amp;</type>
          <declname>block</declname>
        </param>
        <param>
          <type><ref refid="primitives_2transaction_8h_1ae462b4b8f07705a82bf11cf361959b97" kindref="member">CTransactionRef</ref></type>
          <declname>coinbase</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>version</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>timestamp</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>nonce</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="293" column="6" bodyfile="src/node/miner.cpp" bodystart="293" bodyend="309" declfile="src/node/miner.h" declline="137" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ad9ddecf9590cc59582f576a1db0cc14c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void InterruptWait</definition>
        <argsstring>(KernelNotifications &amp;kernel_notifications, bool &amp;interrupt_wait)</argsstring>
        <name>InterruptWait</name>
        <qualifiedname>node::InterruptWait</qualifiedname>
        <param>
          <type><ref refid="class_kernel_notifications" kindref="compound">KernelNotifications</ref> &amp;</type>
          <declname>kernel_notifications</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>interrupt_wait</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="311" column="6" bodyfile="src/node/miner.cpp" bodystart="311" bodyend="316" declfile="src/node/miner.h" declline="141" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a278642046cc2f9ee283ed3e072585d69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="struct_c_block_template" kindref="compound">CBlockTemplate</ref> &gt;</type>
        <definition>std::unique_ptr&lt; CBlockTemplate &gt; WaitAndCreateNewBlock</definition>
        <argsstring>(ChainstateManager &amp;chainman, KernelNotifications &amp;kernel_notifications, CTxMemPool *mempool, const std::unique_ptr&lt; CBlockTemplate &gt; &amp;block_template, const BlockWaitOptions &amp;options, const BlockAssembler::Options &amp;assemble_options, bool &amp;interrupt_wait)</argsstring>
        <name>WaitAndCreateNewBlock</name>
        <qualifiedname>node::WaitAndCreateNewBlock</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type><ref refid="class_kernel_notifications" kindref="compound">KernelNotifications</ref> &amp;</type>
          <declname>kernel_notifications</declname>
        </param>
        <param>
          <type><ref refid="class_c_tx_mem_pool" kindref="compound">CTxMemPool</ref> *</type>
          <declname>mempool</declname>
        </param>
        <param>
          <type>const std::unique_ptr&lt; <ref refid="struct_c_block_template" kindref="compound">CBlockTemplate</ref> &gt; &amp;</type>
          <declname>block_template</declname>
        </param>
        <param>
          <type>const <ref refid="struct_block_wait_options" kindref="compound">BlockWaitOptions</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <param>
          <type>const <ref refid="struct_block_assembler_1_1_options" kindref="compound">BlockAssembler::Options</ref> &amp;</type>
          <declname>assemble_options</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>interrupt_wait</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return a new block template when fees rise to a certain threshold or after a new tip; return nullopt if timeout is reached. </para>
        </detaileddescription>
        <inbodydescription>
<para>We determine if fees increased compared to the previous template by generating a fresh template. There may be more efficient ways to determine how much (approximate) fees for the next block increased, perhaps more so after Cluster Mempool.</para>
<para>We&apos;ll also create a new template if the tip changed during this iteration.</para>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="318" column="17" bodyfile="src/node/miner.cpp" bodystart="318" bodyend="405" declfile="src/node/miner.h" declline="146" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a222c68c9ae42bc5fcea6ce1726dacfc4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="struct_block_ref" kindref="compound">BlockRef</ref> &gt;</type>
        <definition>std::optional&lt; BlockRef &gt; GetTip</definition>
        <argsstring>(ChainstateManager &amp;chainman)</argsstring>
        <name>GetTip</name>
        <qualifiedname>node::GetTip</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="407" column="15" bodyfile="src/node/miner.cpp" bodystart="407" bodyend="413" declfile="src/node/miner.h" declline="155" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1abbc69ba8422e4a527f19e2b927c28fda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="struct_block_ref" kindref="compound">BlockRef</ref> &gt;</type>
        <definition>std::optional&lt; BlockRef &gt; WaitTipChanged</definition>
        <argsstring>(ChainstateManager &amp;chainman, KernelNotifications &amp;kernel_notifications, const uint256 &amp;current_tip, MillisecondsDouble &amp;timeout)</argsstring>
        <name>WaitTipChanged</name>
        <qualifiedname>node::WaitTipChanged</qualifiedname>
        <param>
          <type><ref refid="class_chainstate_manager" kindref="compound">ChainstateManager</ref> &amp;</type>
          <declname>chainman</declname>
        </param>
        <param>
          <type><ref refid="class_kernel_notifications" kindref="compound">KernelNotifications</ref> &amp;</type>
          <declname>kernel_notifications</declname>
        </param>
        <param>
          <type>const <ref refid="classuint256" kindref="compound">uint256</ref> &amp;</type>
          <declname>current_tip</declname>
        </param>
        <param>
          <type><ref refid="util_2time_8h_1a30c9e1a2af0f5daddd2594c7082ffda0" kindref="member">MillisecondsDouble</ref> &amp;</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/miner.cpp" line="415" column="15" bodyfile="src/node/miner.cpp" bodystart="415" bodyend="442" declfile="src/node/miner.h" declline="159" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a0e12a9612fd84893b7f88efc723b7554" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Minisketch</type>
        <definition>Minisketch MakeMinisketch32</definition>
        <argsstring>(size_t capacity)</argsstring>
        <name>MakeMinisketch32</name>
        <qualifiedname>node::MakeMinisketch32</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>capacity</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="class_wrapper" kindref="compound">Wrapper</ref> around Minisketch::Minisketch(32, implementation, capacity). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/minisketchwrapper.cpp" line="70" column="12" bodyfile="src/node/minisketchwrapper.cpp" bodystart="70" bodyend="73" declfile="src/node/minisketchwrapper.h" declline="15" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a5b13cfd20c2769b7f76441f731d7f617" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>Minisketch</type>
        <definition>Minisketch MakeMinisketch32FP</definition>
        <argsstring>(size_t max_elements, uint32_t fpbits)</argsstring>
        <name>MakeMinisketch32FP</name>
        <qualifiedname>node::MakeMinisketch32FP</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>max_elements</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>fpbits</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="class_wrapper" kindref="compound">Wrapper</ref> around Minisketch::CreateFP. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/minisketchwrapper.cpp" line="75" column="12" bodyfile="src/node/minisketchwrapper.cpp" bodystart="75" bodyend="78" declfile="src/node/minisketchwrapper.h" declline="17" declcolumn="12"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a19cd2a70ea6924b1caa287e972e7ab54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ApplyArgsManOptions</definition>
        <argsstring>(const ArgsManager &amp;argsman, PeerManager::Options &amp;options)</argsstring>
        <name>ApplyArgsManOptions</name>
        <qualifiedname>node::ApplyArgsManOptions</qualifiedname>
        <param>
          <type>const <ref refid="class_args_manager" kindref="compound">ArgsManager</ref> &amp;</type>
          <declname>argsman</declname>
        </param>
        <param>
          <type><ref refid="struct_peer_manager_1_1_options" kindref="compound">PeerManager::Options</ref> &amp;</type>
          <declname>options</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/peerman_args.cpp" line="15" column="6" bodyfile="src/node/peerman_args.cpp" bodystart="15" bodyend="26" declfile="src/node/peerman_args.h" declline="13" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1af950b4118f79793a4568d7252770fc0a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_p_s_b_t_analysis" kindref="compound">PSBTAnalysis</ref></type>
        <definition>PSBTAnalysis AnalyzePSBT</definition>
        <argsstring>(PartiallySignedTransaction psbtx)</argsstring>
        <name>AnalyzePSBT</name>
        <qualifiedname>node::AnalyzePSBT</qualifiedname>
        <param>
          <type><ref refid="struct_partially_signed_transaction" kindref="compound">PartiallySignedTransaction</ref></type>
          <declname>psbtx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Provides helpful miscellaneous information about where a PSBT is in the signing workflow.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">psbtx</parametername>
</parameternamelist>
<parameterdescription>
<para>the PSBT to analyze </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A <ref refid="structnode_1_1_p_s_b_t_analysis" kindref="compound">PSBTAnalysis</ref> with information about the provided PSBT. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/psbt.cpp" line="16" column="14" bodyfile="src/node/psbt.cpp" bodystart="16" bodyend="150" declfile="src/node/psbt.h" declline="55" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a07ed6700cad892487329b181c76be195" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacenode_1a857c3bfc8da2a43cebacd0582cc867ac" kindref="member">TransactionError</ref></type>
        <definition>static TransactionError HandleATMPError</definition>
        <argsstring>(const TxValidationState &amp;state, std::string &amp;err_string_out)</argsstring>
        <name>HandleATMPError</name>
        <qualifiedname>node::HandleATMPError</qualifiedname>
        <param>
          <type>const <ref refid="class_tx_validation_state" kindref="compound">TxValidationState</ref> &amp;</type>
          <declname>state</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>err_string_out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/transaction.cpp" line="21" column="25" bodyfile="src/node/transaction.cpp" bodystart="21" bodyend="32"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a370a682ed5a80a825a4fe2e54c13357e" prot="public" static="no" nodiscard="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="namespacenode_1a857c3bfc8da2a43cebacd0582cc867ac" kindref="member">TransactionError</ref></type>
        <definition>TransactionError BroadcastTransaction</definition>
        <argsstring>(NodeContext &amp;node, const CTransactionRef tx, std::string &amp;err_string, const CAmount &amp;max_tx_fee, TxBroadcast broadcast_method, bool wait_callback)</argsstring>
        <name>BroadcastTransaction</name>
        <qualifiedname>node::BroadcastTransaction</qualifiedname>
        <param>
          <type><ref refid="struct_node_context" kindref="compound">NodeContext</ref> &amp;</type>
          <declname>node</declname>
        </param>
        <param>
          <type><ref refid="primitives_2transaction_8h_1ae462b4b8f07705a82bf11cf361959b97" kindref="member">CTransactionRef</ref></type>
          <declname>tx</declname>
        </param>
        <param>
          <type>std::string &amp;</type>
          <declname>err_string</declname>
        </param>
        <param>
          <type>const <ref refid="amount_8h_1a4eaf3a5239714d8c45b851527f7cb564" kindref="member">CAmount</ref> &amp;</type>
          <declname>max_tx_fee</declname>
        </param>
        <param>
          <type><ref refid="namespacenode_1a634bcbd7f41b10ba1c4e823cf2d0f3b0" kindref="member">TxBroadcast</ref></type>
          <declname>broadcast_method</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>wait_callback</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Submit a transaction to the mempool and (optionally) relay it to all P2P peers.</para>
<para>Mempool submission can be synchronous (will await mempool entry notification over the <ref refid="class_c_validation_interface" kindref="compound">CValidationInterface</ref>) or asynchronous (will submit and not wait for notification), depending on the value of wait_callback. wait_callback MUST NOT be set while cs_main, cs_mempool or cs_wallet are held to avoid deadlock.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">node</parametername>
</parameternamelist>
<parameterdescription>
<para>reference to node context </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">tx</parametername>
</parameternamelist>
<parameterdescription>
<para>the transaction to broadcast </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">err_string</parametername>
</parameternamelist>
<parameterdescription>
<para>reference to std::string to fill with error string if available </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_tx_fee</parametername>
</parameternamelist>
<parameterdescription>
<para>reject txs with fees higher than this (if 0, accept any fee) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">broadcast_method</parametername>
</parameternamelist>
<parameterdescription>
<para>whether to add the transaction to the mempool and how to broadcast it </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">wait_callback</parametername>
</parameternamelist>
<parameterdescription>
<para>wait until callbacks have been processed to avoid stale result due to a sequentially RPC. return error </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/transaction.cpp" line="34" column="18" bodyfile="src/node/transaction.cpp" bodystart="34" bodyend="141" declfile="src/node/transaction.h" declline="53" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a5164d41fdf8e6d77e7a7a4e94041e537" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="primitives_2transaction_8h_1ae462b4b8f07705a82bf11cf361959b97" kindref="member">CTransactionRef</ref></type>
        <definition>CTransactionRef GetTransaction</definition>
        <argsstring>(const CBlockIndex *const block_index, const CTxMemPool *const mempool, const Txid &amp;hash, const BlockManager &amp;blockman, uint256 &amp;hashBlock)</argsstring>
        <name>GetTransaction</name>
        <qualifiedname>node::GetTransaction</qualifiedname>
        <param>
          <type>const <ref refid="class_c_block_index" kindref="compound">CBlockIndex</ref> *const</type>
          <declname>block_index</declname>
        </param>
        <param>
          <type>const <ref refid="class_c_tx_mem_pool" kindref="compound">CTxMemPool</ref> *const</type>
          <declname>mempool</declname>
        </param>
        <param>
          <type>const <ref refid="transaction__identifier_8h_1ac4bb3c35b94889843d632be4de4b223c" kindref="member">Txid</ref> &amp;</type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const <ref refid="class_block_manager" kindref="compound">BlockManager</ref> &amp;</type>
          <declname>blockman</declname>
        </param>
        <param>
          <type><ref refid="classuint256" kindref="compound">uint256</ref> &amp;</type>
          <declname>hashBlock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return transaction with a given hash. If mempool is provided and block_index is not provided, check it first for the tx. If -txindex is available, check it next for the tx. Finally, if block_index is provided, check for tx by reading entire block from disk.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">block_index</parametername>
</parameternamelist>
<parameterdescription>
<para>The block to read from disk, or nullptr </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">mempool</parametername>
</parameternamelist>
<parameterdescription>
<para>If provided, check mempool for tx </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">hash</parametername>
</parameternamelist>
<parameterdescription>
<para>The txid </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">blockman</parametername>
</parameternamelist>
<parameterdescription>
<para>Used to access and read blocks from disk </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">hashBlock</parametername>
</parameternamelist>
<parameterdescription>
<para>The block hash, if the tx was found via -txindex or block_index </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The tx if found, otherwise nullptr </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/transaction.cpp" line="143" column="17" bodyfile="src/node/transaction.cpp" bodystart="143" bodyend="174" declfile="src/node/transaction.h" declline="73" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1aa4c7a71c1806142d5b1e084687b566c0" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="classnode_1_1_tx_orphanage" kindref="compound">TxOrphanage</ref> &gt;</type>
        <definition>std::unique_ptr&lt; TxOrphanage &gt; MakeTxOrphanage</definition>
        <argsstring>() noexcept</argsstring>
        <name>MakeTxOrphanage</name>
        <qualifiedname>node::MakeTxOrphanage</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a new <ref refid="classnode_1_1_tx_orphanage" kindref="compound">TxOrphanage</ref> instance </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txorphanage.cpp" line="775" column="17" bodyfile="src/node/txorphanage.cpp" bodystart="775" bodyend="778" declfile="src/node/txorphanage.h" declline="148" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ad35287c945ebc4aa30c0f8dd52bb36e7" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>std::unique_ptr&lt; <ref refid="classnode_1_1_tx_orphanage" kindref="compound">TxOrphanage</ref> &gt;</type>
        <definition>std::unique_ptr&lt; TxOrphanage &gt; MakeTxOrphanage</definition>
        <argsstring>(TxOrphanage::Count max_global_latency_score, TxOrphanage::Usage reserved_peer_usage) noexcept</argsstring>
        <name>MakeTxOrphanage</name>
        <qualifiedname>node::MakeTxOrphanage</qualifiedname>
        <param>
          <type><ref refid="classnode_1_1_tx_orphanage_1ae64c746440a24b397929dabe92a05f2a" kindref="member">TxOrphanage::Count</ref></type>
          <declname>max_global_latency_score</declname>
        </param>
        <param>
          <type><ref refid="classnode_1_1_tx_orphanage_1a9ecb794ec69428768c604c35c07d363c" kindref="member">TxOrphanage::Usage</ref></type>
          <declname>reserved_peer_usage</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/txorphanage.cpp" line="779" column="17" bodyfile="src/node/txorphanage.cpp" bodystart="779" bodyend="782" declfile="src/node/txorphanage.h" declline="149" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1aa28134e14a9f1ba865d7ca064e0486dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool WriteSnapshotBaseBlockhash</definition>
        <argsstring>(Chainstate &amp;snapshot_chainstate)</argsstring>
        <name>WriteSnapshotBaseBlockhash</name>
        <qualifiedname>node::WriteSnapshotBaseBlockhash</qualifiedname>
        <param>
          <type><ref refid="class_chainstate" kindref="compound">Chainstate</ref> &amp;</type>
          <declname>snapshot_chainstate</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/utxo_snapshot.cpp" line="23" column="6" bodyfile="src/node/utxo_snapshot.cpp" bodystart="23" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a4d2cd11f67bcd44c8e56621eeee89695" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classuint256" kindref="compound">uint256</ref> &gt;</type>
        <definition>std::optional&lt; uint256 &gt; ReadSnapshotBaseBlockhash</definition>
        <argsstring>(fs::path chaindir)</argsstring>
        <name>ReadSnapshotBaseBlockhash</name>
        <qualifiedname>node::ReadSnapshotBaseBlockhash</qualifiedname>
        <param>
          <type><ref refid="classfs_1_1path" kindref="compound">fs::path</ref></type>
          <declname>chaindir</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/utxo_snapshot.cpp" line="49" column="15" bodyfile="src/node/utxo_snapshot.cpp" bodystart="49" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1a5b64fe45690872d3bd11de86a157c931" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="classfs_1_1path" kindref="compound">fs::path</ref> &gt;</type>
        <definition>std::optional&lt; fs::path &gt; FindAssumeutxoChainstateDir</definition>
        <argsstring>(const fs::path &amp;data_dir)</argsstring>
        <name>FindAssumeutxoChainstateDir</name>
        <qualifiedname>node::FindAssumeutxoChainstateDir</qualifiedname>
        <param>
          <type>const <ref refid="classfs_1_1path" kindref="compound">fs::path</ref> &amp;</type>
          <declname>data_dir</declname>
        </param>
        <briefdescription>
<para>Return a path to the snapshot-based chainstate dir, if one exists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/utxo_snapshot.cpp" line="84" column="15" bodyfile="src/node/utxo_snapshot.cpp" bodystart="84" bodyend="93" declfile="src/node/utxo_snapshot.h" declline="132" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespacenode_1ace8af9650a423663c58e95ef395a37a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_uni_value" kindref="compound">UniValue</ref></type>
        <definition>UniValue GetWarningsForRpc</definition>
        <argsstring>(const Warnings &amp;warnings, bool use_deprecated)</argsstring>
        <name>GetWarningsForRpc</name>
        <qualifiedname>node::GetWarningsForRpc</qualifiedname>
        <param>
          <type>const <ref refid="classnode_1_1_warnings" kindref="compound">Warnings</ref> &amp;</type>
          <declname>warnings</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>use_deprecated</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>RPC helper function that wraps warnings.GetMessages().</para>
<para>Returns a <ref refid="class_uni_value_1a28a778aedb7441c6b9755e1882b58dc9ad7eb819329aa2eae7e825f6f7a8f4efc" kindref="member">UniValue::VSTR</ref> with the latest warning if use_deprecated is set to true, or a <ref refid="class_uni_value_1a28a778aedb7441c6b9755e1882b58dc9a29e09364a716e7f1500adfc15d206e78" kindref="member">UniValue::VARR</ref> with all warnings otherwise. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/node/warnings.cpp" line="54" column="10" bodyfile="src/node/warnings.cpp" bodystart="54" bodyend="66" declfile="src/node/warnings.h" declline="87" declcolumn="10"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/common/messages.h" line="21" column="1"/>
  </compounddef>
</doxygen>
