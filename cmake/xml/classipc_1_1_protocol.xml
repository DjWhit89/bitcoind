<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classipc_1_1_protocol" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>ipc::Protocol</compoundname>
    <includes refid="ipc_2protocol_8h" local="no">protocol.h</includes>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classipc_1_1_protocol_1ae8dff142c91e726e5e1ca3abff872adf" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual ~Protocol</definition>
        <argsstring>()=default</argsstring>
        <name>~Protocol</name>
        <qualifiedname>ipc::Protocol::~Protocol</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="24" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classipc_1_1_protocol_1a098584fc42adacc9ecfd5dc910fea66f" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::unique_ptr&lt; <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> &gt;</type>
        <definition>virtual std::unique_ptr&lt; interfaces::Init &gt; connect</definition>
        <argsstring>(int fd, const char *exe_name)=0</argsstring>
        <name>connect</name>
        <qualifiedname>ipc::Protocol::connect</qualifiedname>
        <param>
          <type>int</type>
          <declname>fd</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return <ref refid="class_init" kindref="compound">Init</ref> interface that forwards requests over given socket descriptor. Socket communication is handled on a background thread.</para>
<para><simplesect kind="note"><para>It could be potentially useful in the future to add std::function&lt;void()&gt; on_disconnect callback argument here. But there isn&apos;t an immediate need, because the protocol implementation can clean up its own state (calling ProxyServer destructors, etc) on disconnect, and any client calls will just throw <ref refid="classipc_1_1_exception" kindref="compound">ipc::Exception</ref> errors after a disconnect. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="35" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classipc_1_1_protocol_1aefda533b5b61d4d7c1e4aa513ee94aa9" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void listen</definition>
        <argsstring>(int listen_fd, const char *exe_name, interfaces::Init &amp;init)=0</argsstring>
        <name>listen</name>
        <qualifiedname>ipc::Protocol::listen</qualifiedname>
        <param>
          <type>int</type>
          <declname>listen_fd</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <param>
          <type><ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Listen for connections on provided socket descriptor, accept them, and handle requests on accepted connections. This method doesn&apos;t block, and performs I/O on a background thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="40" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classipc_1_1_protocol_1a5249513dbbca3afe53c192be98ac7504" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void serve</definition>
        <argsstring>(int fd, const char *exe_name, interfaces::Init &amp;init, const std::function&lt; void()&gt; &amp;ready_fn={})=0</argsstring>
        <name>serve</name>
        <qualifiedname>ipc::Protocol::serve</qualifiedname>
        <param>
          <type>int</type>
          <declname>fd</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <param>
          <type><ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>const std::function&lt; void()&gt; &amp;</type>
          <declname>ready_fn</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Handle requests on provided socket descriptor, forwarding them to the provided <ref refid="class_init" kindref="compound">Init</ref> interface. Socket communication is handled on the current thread, and this call blocks until the socket is closed.</para>
<para><simplesect kind="note"><para>: If this method is called, it needs be called before <ref refid="classipc_1_1_protocol_1a098584fc42adacc9ecfd5dc910fea66f" kindref="member">connect()</ref> or <ref refid="classipc_1_1_protocol_1aefda533b5b61d4d7c1e4aa513ee94aa9" kindref="member">listen()</ref> methods, because for ease of implementation it&apos;s inflexible and always runs the event loop in the foreground thread. It can share its event loop with the other methods but can&apos;t share an event loop that was created by them. This isn&apos;t really a problem because <ref refid="classipc_1_1_protocol_1a5249513dbbca3afe53c192be98ac7504" kindref="member">serve()</ref> is only called by spawned child processes that call it immediately to communicate back with parent processes.</para>
</simplesect>
The optional <computeroutput>ready_fn</computeroutput> callback will be called after the event loop is created but before it is started. This can be useful in tests to trigger client connections from another thread as soon as the event loop is available, but should not be necessary in normal code which starts clients and servers independently. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="59" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classipc_1_1_protocol_1a45306c63b743375d0db4f613d2de7300" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void disconnectIncoming</definition>
        <argsstring>()=0</argsstring>
        <name>disconnectIncoming</name>
        <qualifiedname>ipc::Protocol::disconnectIncoming</qualifiedname>
        <briefdescription>
<para>Disconnect any incoming connections that are still connected. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="62" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classipc_1_1_protocol_1ab752d262895c2173617749fea06bcba1" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void addCleanup</definition>
        <argsstring>(std::type_index type, void *iface, std::function&lt; void()&gt; cleanup)=0</argsstring>
        <name>addCleanup</name>
        <qualifiedname>ipc::Protocol::addCleanup</qualifiedname>
        <param>
          <type>std::type_index</type>
          <declname>type</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>iface</declname>
        </param>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <declname>cleanup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add cleanup callback to interface that will run when the interface is deleted. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="66" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classipc_1_1_protocol_1a4b2af83137ac1ea8dd7afb875940b3cb" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="structipc_1_1_context" kindref="compound">Context</ref> &amp;</type>
        <definition>virtual Context &amp; context</definition>
        <argsstring>()=0</argsstring>
        <name>context</name>
        <qualifiedname>ipc::Protocol::context</qualifiedname>
        <briefdescription>
<para><ref refid="structipc_1_1_context" kindref="compound">Context</ref> accessor. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/protocol.h" line="69" column="21"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>IPC protocol interface for calling IPC methods over sockets.</para>
<para>There may be different implementations of this interface for different IPC protocols (e.g. Cap&apos;n Proto, gRPC, JSON-RPC, or custom protocols). </para>
    </detaileddescription>
    <location file="src/ipc/protocol.h" line="21" column="1" bodyfile="src/ipc/protocol.h" bodystart="22" bodyend="70"/>
    <listofallmembers>
      <member refid="classipc_1_1_protocol_1ab752d262895c2173617749fea06bcba1" prot="public" virt="pure-virtual"><scope>ipc::Protocol</scope><name>addCleanup</name></member>
      <member refid="classipc_1_1_protocol_1a098584fc42adacc9ecfd5dc910fea66f" prot="public" virt="pure-virtual"><scope>ipc::Protocol</scope><name>connect</name></member>
      <member refid="classipc_1_1_protocol_1a4b2af83137ac1ea8dd7afb875940b3cb" prot="public" virt="pure-virtual"><scope>ipc::Protocol</scope><name>context</name></member>
      <member refid="classipc_1_1_protocol_1a45306c63b743375d0db4f613d2de7300" prot="public" virt="pure-virtual"><scope>ipc::Protocol</scope><name>disconnectIncoming</name></member>
      <member refid="classipc_1_1_protocol_1aefda533b5b61d4d7c1e4aa513ee94aa9" prot="public" virt="pure-virtual"><scope>ipc::Protocol</scope><name>listen</name></member>
      <member refid="classipc_1_1_protocol_1a5249513dbbca3afe53c192be98ac7504" prot="public" virt="pure-virtual"><scope>ipc::Protocol</scope><name>serve</name></member>
      <member refid="classipc_1_1_protocol_1ae8dff142c91e726e5e1ca3abff872adf" prot="public" virt="virtual"><scope>ipc::Protocol</scope><name>~Protocol</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
