<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_headers_sync_state" kind="class" language="C++" prot="public">
    <compoundname>HeadersSyncState</compoundname>
    <derivedcompoundref refid="class_fuzzed_headers_sync_state" prot="public" virt="non-virtual">FuzzedHeadersSyncState</derivedcompoundref>
    <includes refid="headerssync_8h" local="no">headerssync.h</includes>
    <innerclass refid="struct_headers_sync_state_1_1_processing_result" prot="public">HeadersSyncState::ProcessingResult</innerclass>
    <sectiondef kind="public-type">
      <memberdef kind="enum" id="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8" prot="public" static="no" strong="yes">
        <type></type>
        <name>State</name>
        <qualifiedname>HeadersSyncState::State</qualifiedname>
        <enumvalue id="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8ac7b4faed4767142023121f8faacef9fa" prot="public">
          <name>PRESYNC</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>PRESYNC means the peer has not yet demonstrated their chain has sufficient work and we&apos;re only building commitments to the chain they serve us. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8acc314a5a286af9c5faefcdd8fa5f8a1f" prot="public">
          <name>REDOWNLOAD</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>REDOWNLOAD means the peer has given us a high-enough-work chain, and now we&apos;re redownloading the headers we saw before and trying to accept them </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8a6c8361dc2036c0559376fe4957699f69" prot="public">
          <name>FINAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>We&apos;re done syncing with this peer and can discard any remaining state </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="105" column="5" bodyfile="src/headerssync.h" bodystart="105" bodyend="116"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="class_headers_sync_state_1a840e4da6e13976dfabe46b044e3b1738" prot="protected" static="no" mutable="no">
        <type>const size_t</type>
        <definition>const size_t m_commit_offset</definition>
        <argsstring></argsstring>
        <name>m_commit_offset</name>
        <qualifiedname>HeadersSyncState::m_commit_offset</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The (secret) offset on the heights for which to create commitments.</para>
<para>m_header_commitments entries are created at any height h for which (h % m_params.commitment_period) == m_commit_offset. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="184" column="18" bodyfile="src/headerssync.h" bodystart="184" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_headers_sync_state_1a3fd2bd87699e7aed6dee14d46832fe9f" prot="private" static="no" mutable="no">
        <type>const <ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref></type>
        <definition>const NodeId m_id</definition>
        <argsstring></argsstring>
        <name>m_id</name>
        <qualifiedname>HeadersSyncState::m_id</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref> of the peer (used for log messages) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="213" column="18" bodyfile="src/headerssync.h" bodystart="213" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a23255258fd76d30a2e501dd2635fa971" prot="private" static="no" mutable="no">
        <type>const <ref refid="struct_consensus_1_1_params" kindref="compound">Consensus::Params</ref> &amp;</type>
        <definition>const Consensus::Params&amp; m_consensus_params</definition>
        <argsstring></argsstring>
        <name>m_consensus_params</name>
        <qualifiedname>HeadersSyncState::m_consensus_params</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>We use the consensus params in our anti-DoS calculations </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="216" column="29" bodyfile="src/headerssync.h" bodystart="216" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a70efa3a01a97822c16032d0d924aaaa3" prot="private" static="no" mutable="no">
        <type>const <ref refid="struct_headers_sync_params" kindref="compound">HeadersSyncParams</ref></type>
        <definition>const HeadersSyncParams m_params</definition>
        <argsstring></argsstring>
        <name>m_params</name>
        <qualifiedname>HeadersSyncState::m_params</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parameters that impact memory usage for a given chain, especially when attacked. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="219" column="29" bodyfile="src/headerssync.h" bodystart="219" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a360acbf1850f46c0ba8e272818d11291" prot="private" static="no" mutable="no">
        <type>const <ref refid="class_c_block_index" kindref="compound">CBlockIndex</ref> *</type>
        <definition>const CBlockIndex* m_chain_start</definition>
        <argsstring></argsstring>
        <name>m_chain_start</name>
        <qualifiedname>HeadersSyncState::m_chain_start</qualifiedname>
        <initializer>{nullptr}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Store the last block in our block index that the peer&apos;s chain builds from </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="222" column="23" bodyfile="src/headerssync.h" bodystart="222" bodyend="222"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a76195b4072d7f0c1dd75d08095300a90" prot="private" static="no" mutable="no">
        <type>const <ref refid="classarith__uint256" kindref="compound">arith_uint256</ref></type>
        <definition>const arith_uint256 m_minimum_required_work</definition>
        <argsstring></argsstring>
        <name>m_minimum_required_work</name>
        <qualifiedname>HeadersSyncState::m_minimum_required_work</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Minimum work that we&apos;re looking for on this chain. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="225" column="25" bodyfile="src/headerssync.h" bodystart="225" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1ab16eb9ad5673f2af729f8a0b2607ff95" prot="private" static="no" mutable="no">
        <type><ref refid="classarith__uint256" kindref="compound">arith_uint256</ref></type>
        <definition>arith_uint256 m_current_chain_work</definition>
        <argsstring></argsstring>
        <name>m_current_chain_work</name>
        <qualifiedname>HeadersSyncState::m_current_chain_work</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Work that we&apos;ve seen so far on the peer&apos;s chain </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="228" column="19" bodyfile="src/headerssync.h" bodystart="228" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a56e78ab99b5cb5425c1aa9872e403b88" prot="private" static="no" mutable="no">
        <type>const <ref refid="class_salted_uint256_hasher" kindref="compound">SaltedUint256Hasher</ref></type>
        <definition>const SaltedUint256Hasher m_hasher</definition>
        <argsstring></argsstring>
        <name>m_hasher</name>
        <qualifiedname>HeadersSyncState::m_hasher</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>m_hasher is a salted hasher for making our 1-bit commitments to headers we&apos;ve seen. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="231" column="31" bodyfile="src/headerssync.h" bodystart="231" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1aaa8a19f8097da313c938b84a9e34d8e7" prot="private" static="no" mutable="no">
        <type><ref refid="classbitdeque" kindref="compound">bitdeque</ref></type>
        <definition>bitdeque m_header_commitments</definition>
        <argsstring></argsstring>
        <name>m_header_commitments</name>
        <qualifiedname>HeadersSyncState::m_header_commitments</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A queue of commitment bits, created during the 1st phase, and verified during the 2nd. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="234" column="6" bodyfile="src/headerssync.h" bodystart="234" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a3f43afd39a1491aee2abf05ac9a7d94d" prot="private" static="no" mutable="no">
        <type>uint64_t</type>
        <definition>uint64_t m_max_commitments</definition>
        <argsstring></argsstring>
        <name>m_max_commitments</name>
        <qualifiedname>HeadersSyncState::m_max_commitments</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>m_max_commitments is a bound we calculate on how long an honest peer&apos;s chain could be, given the MTP rule.</para>
<para>Any peer giving us more headers than this will have its sync aborted. This serves as a memory bound on m_header_commitments. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="241" column="14" bodyfile="src/headerssync.h" bodystart="241" bodyend="241"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a82dd9be3428f0017fad3d1d3058f89bf" prot="private" static="no" mutable="no">
        <type><ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref></type>
        <definition>CBlockHeader m_last_header_received</definition>
        <argsstring></argsstring>
        <name>m_last_header_received</name>
        <qualifiedname>HeadersSyncState::m_last_header_received</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Store the latest header received while in PRESYNC (initialized to m_chain_start) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="244" column="18" bodyfile="src/headerssync.h" bodystart="244" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1aa27ccb01ea5af50b6849b563d188c2d5" prot="private" static="no" mutable="no">
        <type>int64_t</type>
        <definition>int64_t m_current_height</definition>
        <argsstring></argsstring>
        <name>m_current_height</name>
        <qualifiedname>HeadersSyncState::m_current_height</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Height of m_last_header_received </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="247" column="13" bodyfile="src/headerssync.h" bodystart="247" bodyend="247"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a159f762fb185c8e154b5dc3d67fe22a1" prot="private" static="no" mutable="no">
        <type>std::deque&lt; <ref refid="struct_compressed_header" kindref="compound">CompressedHeader</ref> &gt;</type>
        <definition>std::deque&lt;CompressedHeader&gt; m_redownloaded_headers</definition>
        <argsstring></argsstring>
        <name>m_redownloaded_headers</name>
        <qualifiedname>HeadersSyncState::m_redownloaded_headers</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>During phase 2 (REDOWNLOAD), we buffer redownloaded headers in memory until enough commitments have been verified; those are stored in m_redownloaded_headers </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="252" column="16" bodyfile="src/headerssync.h" bodystart="252" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1aa716c9d136876c7ce2d5bf27a99bbef4" prot="private" static="no" mutable="no">
        <type>int64_t</type>
        <definition>int64_t m_redownload_buffer_last_height</definition>
        <argsstring></argsstring>
        <name>m_redownload_buffer_last_height</name>
        <qualifiedname>HeadersSyncState::m_redownload_buffer_last_height</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Height of last header in m_redownloaded_headers </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="255" column="13" bodyfile="src/headerssync.h" bodystart="255" bodyend="255"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1af4c0ca7d9aeb474acb50cef4e735d50f" prot="private" static="no" mutable="no">
        <type><ref refid="classuint256" kindref="compound">uint256</ref></type>
        <definition>uint256 m_redownload_buffer_last_hash</definition>
        <argsstring></argsstring>
        <name>m_redownload_buffer_last_hash</name>
        <qualifiedname>HeadersSyncState::m_redownload_buffer_last_hash</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Hash of last header in m_redownloaded_headers (initialized to m_chain_start). We have to cache it because we don&apos;t have hashPrevBlock available in a <ref refid="struct_compressed_header" kindref="compound">CompressedHeader</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="261" column="13" bodyfile="src/headerssync.h" bodystart="261" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a2969af8d1b880dfc7145c8750ff91c12" prot="private" static="no" mutable="no">
        <type><ref refid="classuint256" kindref="compound">uint256</ref></type>
        <definition>uint256 m_redownload_buffer_first_prev_hash</definition>
        <argsstring></argsstring>
        <name>m_redownload_buffer_first_prev_hash</name>
        <qualifiedname>HeadersSyncState::m_redownload_buffer_first_prev_hash</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The hashPrevBlock entry for the first header in m_redownloaded_headers We need this to reconstruct the full header when it&apos;s time for processing. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="267" column="13" bodyfile="src/headerssync.h" bodystart="267" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1aa4410e9f0ab301067f218a95d103d245" prot="private" static="no" mutable="no">
        <type><ref refid="classarith__uint256" kindref="compound">arith_uint256</ref></type>
        <definition>arith_uint256 m_redownload_chain_work</definition>
        <argsstring></argsstring>
        <name>m_redownload_chain_work</name>
        <qualifiedname>HeadersSyncState::m_redownload_chain_work</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The accumulated work on the redownloaded chain. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="270" column="19" bodyfile="src/headerssync.h" bodystart="270" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1a89afb6711c637991dd786e422a1dffd0" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool m_process_all_remaining_headers</definition>
        <argsstring></argsstring>
        <name>m_process_all_remaining_headers</name>
        <qualifiedname>HeadersSyncState::m_process_all_remaining_headers</qualifiedname>
        <initializer>{false}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set this to true once we encounter the target blockheader during phase 2 (REDOWNLOAD). At this point, we can process and store all remaining headers still in m_redownloaded_headers. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="276" column="10" bodyfile="src/headerssync.h" bodystart="276" bodyend="276"/>
      </memberdef>
      <memberdef kind="variable" id="class_headers_sync_state_1ac4b68bdff4bae06f773abbe57617b313" prot="private" static="no" mutable="no">
        <type><ref refid="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8" kindref="member">State</ref></type>
        <definition>State m_download_state</definition>
        <argsstring></argsstring>
        <name>m_download_state</name>
        <qualifiedname>HeadersSyncState::m_download_state</qualifiedname>
        <initializer>{State::PRESYNC}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Current state of our headers sync. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="279" column="11" bodyfile="src/headerssync.h" bodystart="279" bodyend="279"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_headers_sync_state_1aead457f323e9312e44673a1837abf705" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~HeadersSyncState</definition>
        <argsstring>()=default</argsstring>
        <name>~HeadersSyncState</name>
        <qualifiedname>HeadersSyncState::~HeadersSyncState</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="103" column="5"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1affcd8c8b4f9cd82f29ce903bee82d622" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8" kindref="member">State</ref></type>
        <definition>State GetState</definition>
        <argsstring>() const</argsstring>
        <name>GetState</name>
        <qualifiedname>HeadersSyncState::GetState</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the current state of our download </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="119" column="11" bodyfile="src/headerssync.h" bodystart="119" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a57884de72372d959f39a3110123e419f" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>int64_t</type>
        <definition>int64_t GetPresyncHeight</definition>
        <argsstring>() const</argsstring>
        <name>GetPresyncHeight</name>
        <qualifiedname>HeadersSyncState::GetPresyncHeight</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the height reached during the PRESYNC phase </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="122" column="13" bodyfile="src/headerssync.h" bodystart="122" bodyend="122"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1ae696375936b0658e352ebcb824b91ae5" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t GetPresyncTime</definition>
        <argsstring>() const</argsstring>
        <name>GetPresyncTime</name>
        <qualifiedname>HeadersSyncState::GetPresyncTime</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the block timestamp of the last header received during the PRESYNC phase. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="125" column="14" bodyfile="src/headerssync.h" bodystart="125" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a1bcb794b07d97b08d45420e40589e5b4" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classarith__uint256" kindref="compound">arith_uint256</ref></type>
        <definition>arith_uint256 GetPresyncWork</definition>
        <argsstring>() const</argsstring>
        <name>GetPresyncWork</name>
        <qualifiedname>HeadersSyncState::GetPresyncWork</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the amount of work in the chain received during the PRESYNC phase. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="128" column="19" bodyfile="src/headerssync.h" bodystart="128" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a9ef34f87a3e2aa8d73b928fa9f3b1911" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>HeadersSyncState</definition>
        <argsstring>(NodeId id, const Consensus::Params &amp;consensus_params, const HeadersSyncParams &amp;params, const CBlockIndex *chain_start, const arith_uint256 &amp;minimum_required_work)</argsstring>
        <name>HeadersSyncState</name>
        <qualifiedname>HeadersSyncState::HeadersSyncState</qualifiedname>
        <param>
          <type><ref refid="net_8h_1aa637b11e18b77724b35db2229cd12788" kindref="member">NodeId</ref></type>
          <declname>id</declname>
        </param>
        <param>
          <type>const <ref refid="struct_consensus_1_1_params" kindref="compound">Consensus::Params</ref> &amp;</type>
          <declname>consensus_params</declname>
        </param>
        <param>
          <type>const <ref refid="struct_headers_sync_params" kindref="compound">HeadersSyncParams</ref> &amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>const <ref refid="class_c_block_index" kindref="compound">CBlockIndex</ref> *</type>
          <declname>chain_start</declname>
        </param>
        <param>
          <type>const <ref refid="classarith__uint256" kindref="compound">arith_uint256</ref> &amp;</type>
          <declname>minimum_required_work</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct a <ref refid="class_headers_sync_state" kindref="compound">HeadersSyncState</ref> object representing a headers sync via this download-twice mechanism).</para>
<para>id: node id (for logging) consensus_params: parameters needed for difficulty adjustment validation chain_start: best known fork point that the peer&apos;s headers branch from minimum_required_work: amount of chain work required to accept the chain </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="138" column="5" bodyfile="src/headerssync.cpp" bodystart="17" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a0e12375af6318f0729742c2fde2e7294" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_headers_sync_state_1_1_processing_result" kindref="compound">ProcessingResult</ref></type>
        <definition>HeadersSyncState::ProcessingResult ProcessNextHeaders</definition>
        <argsstring>(std::span&lt; const CBlockHeader &gt; received_headers, bool full_headers_message)</argsstring>
        <name>ProcessNextHeaders</name>
        <qualifiedname>HeadersSyncState::ProcessNextHeaders</qualifiedname>
        <param>
          <type>std::span&lt; const <ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref> &gt;</type>
          <declname>received_headers</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>full_headers_message</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Process a batch of headers, once a sync via this mechanism has started</para>
<para>received_headers: headers that were received over the network for processing. Assumes the caller has already verified the headers are continuous, and has checked that each header satisfies the proof-of-work target included in the header (but not necessarily verified that the proof-of-work target is correct and passes consensus rules). full_headers_message: true if the message was at max capacity, indicating more headers may be available <ref refid="struct_headers_sync_state_1_1_processing_result_1a9c35a329ec17ebcbece028b7cc1e9d1e" kindref="member">ProcessingResult.pow_validated_headers</ref>: will be filled in with any headers that the caller can fully process and validate now (because these returned headers are on a chain with sufficient work) <ref refid="struct_headers_sync_state_1_1_processing_result_1a7960f9c558f9ee2c3d4a8fdea096fb56" kindref="member">ProcessingResult.success</ref>: set to false if an error is detected and the sync is aborted; true otherwise. <ref refid="struct_headers_sync_state_1_1_processing_result_1a360c8f164bde96ae04a0106b65ab4a3f" kindref="member">ProcessingResult.request_more</ref>: if true, the caller is suggested to call NextHeadersRequestLocator and send a getheaders message using it.</para>
<para>Process the next batch of headers received from our peer. Validate and store commitments, and compare total chainwork to our target to see if we can switch to REDOWNLOAD mode. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="169" column="22" bodyfile="src/headerssync.cpp" bodystart="65" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1ac7f7cda8eb56d220ef54951c6cebcb2e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_c_block_locator" kindref="compound">CBlockLocator</ref></type>
        <definition>CBlockLocator NextHeadersRequestLocator</definition>
        <argsstring>() const</argsstring>
        <name>NextHeadersRequestLocator</name>
        <qualifiedname>HeadersSyncState::NextHeadersRequestLocator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Issue the next GETHEADERS message to our peer.</para>
<para>This will return a locator appropriate for the current sync object, to continue the synchronization phase it is in. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="177" column="19" bodyfile="src/headerssync.cpp" bodystart="293" bodyend="314"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_headers_sync_state_1a8fee61d7a783cade1a3d07fe86284d27" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Finalize</definition>
        <argsstring>()</argsstring>
        <name>Finalize</name>
        <qualifiedname>HeadersSyncState::Finalize</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Clear out all download state that might be in progress (freeing any used memory), and mark this object as no longer usable.</para>
<para>Free any memory in use, and mark this object as no longer usable. This is required to guarantee that we won&apos;t reuse this object with the same <ref refid="class_salted_uint256_hasher" kindref="compound">SaltedUint256Hasher</ref> for another sync. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="190" column="10" bodyfile="src/headerssync.cpp" bodystart="48" bodyend="60"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a8675e244287fdb061499143939796a70" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool ValidateAndStoreHeadersCommitments</definition>
        <argsstring>(std::span&lt; const CBlockHeader &gt; headers)</argsstring>
        <name>ValidateAndStoreHeadersCommitments</name>
        <qualifiedname>HeadersSyncState::ValidateAndStoreHeadersCommitments</qualifiedname>
        <param>
          <type>std::span&lt; const <ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref> &gt;</type>
          <declname>headers</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Only called in PRESYNC. Validate the work on the headers we received from the network, and store commitments for later. Update overall state with successfully processed headers. On failure, this invokes Finalize() and returns false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="199" column="10" bodyfile="src/headerssync.cpp" bodystart="136" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a67a47ee04e7d9148c62828bdf26cbd87" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool ValidateAndProcessSingleHeader</definition>
        <argsstring>(const CBlockHeader &amp;current)</argsstring>
        <name>ValidateAndProcessSingleHeader</name>
        <qualifiedname>HeadersSyncState::ValidateAndProcessSingleHeader</qualifiedname>
        <param>
          <type>const <ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref> &amp;</type>
          <declname>current</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>In PRESYNC, process and update state for a single header </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="202" column="10" bodyfile="src/headerssync.cpp" bodystart="174" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a3a19759fa297387e2651eaf0c4c83492" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool ValidateAndStoreRedownloadedHeader</definition>
        <argsstring>(const CBlockHeader &amp;header)</argsstring>
        <name>ValidateAndStoreRedownloadedHeader</name>
        <qualifiedname>HeadersSyncState::ValidateAndStoreRedownloadedHeader</qualifiedname>
        <param>
          <type>const <ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref> &amp;</type>
          <declname>header</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>In REDOWNLOAD, check a header&apos;s commitment (if applicable) and add to buffer for later processing </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="206" column="10" bodyfile="src/headerssync.cpp" bodystart="212" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="class_headers_sync_state_1a9983ea7a6f1465bc2bd3f05b87a09f6e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="class_c_block_header" kindref="compound">CBlockHeader</ref> &gt;</type>
        <definition>std::vector&lt; CBlockHeader &gt; PopHeadersReadyForAcceptance</definition>
        <argsstring>()</argsstring>
        <name>PopHeadersReadyForAcceptance</name>
        <qualifiedname>HeadersSyncState::PopHeadersReadyForAcceptance</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return a set of headers that satisfy our proof-of-work threshold </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/headerssync.h" line="209" column="17" bodyfile="src/headerssync.cpp" bodystart="277" bodyend="291"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><ref refid="class_headers_sync_state" kindref="compound">HeadersSyncState</ref>:</para>
<para>We wish to download a peer&apos;s headers chain in a DoS-resistant way.</para>
<para>The Bitcoin protocol does not offer an easy way to determine the work on a peer&apos;s chain. Currently, we can query a peer&apos;s headers by using a GETHEADERS message, and our peer can return a set of up to 2000 headers that connect to something we know. If a peer&apos;s chain has more than 2000 blocks, then we need a way to verify that the chain actually has enough work on it to be useful to us <ndash/> by being above our anti-DoS minimum-chain-work threshold <ndash/> before we commit to storing those headers in memory. Otherwise, it would be cheap for an attacker to waste all our memory by serving us low-work headers (particularly for a new node coming online for the first time).</para>
<para>To prevent memory-DoS with low-work headers, while still always being able to reorg to whatever the most-work chain is, we require that a chain meet a work threshold before committing it to memory. We can do this by downloading a peer&apos;s headers twice, whenever we are not sure that the chain has sufficient work:</para>
<para><itemizedlist>
<listitem><para>In the first download phase, called pre-synchronization, we can calculate the work on the chain as we go (just by checking the nBits value on each header, and validating the proof-of-work).</para>
</listitem><listitem><para>Once we have reached a header where the cumulative chain work is sufficient, we switch to downloading the headers a second time, this time processing them fully, and possibly storing them in memory.</para>
</listitem></itemizedlist>
</para>
<para>To prevent an attacker from using (eg) the honest chain to convince us that they have a high-work chain, but then feeding us an alternate set of low-difficulty headers in the second phase, we store commitments to the chain we see in the first download phase that we check in the second phase, as follows:</para>
<para><itemizedlist>
<listitem><para>In phase 1 (presync), store 1 bit (using a salted hash function) for every N headers that we see. With a reasonable choice of N, this uses relatively little memory even for a very long chain.</para>
</listitem><listitem><para>In phase 2 (redownload), keep a lookahead buffer and only accept headers from that buffer into the block index (permanent memory usage) once they have some target number of verified commitments on top of them. With this parametrization, we can achieve a given security target for potential permanent memory usage, while choosing N to minimize memory use during the sync (temporary, per-peer storage). </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>FuzzedHeadersSyncState</label>
        <link refid="class_fuzzed_headers_sync_state"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>HeadersSyncState</label>
        <link refid="class_headers_sync_state"/>
      </node>
    </inheritancegraph>
    <location file="src/headerssync.h" line="101" column="1" bodyfile="src/headerssync.h" bodystart="101" bodyend="280"/>
    <listofallmembers>
      <member refid="class_headers_sync_state_1a8fee61d7a783cade1a3d07fe86284d27" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>Finalize</name></member>
      <member refid="class_headers_sync_state_1a57884de72372d959f39a3110123e419f" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>GetPresyncHeight</name></member>
      <member refid="class_headers_sync_state_1ae696375936b0658e352ebcb824b91ae5" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>GetPresyncTime</name></member>
      <member refid="class_headers_sync_state_1a1bcb794b07d97b08d45420e40589e5b4" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>GetPresyncWork</name></member>
      <member refid="class_headers_sync_state_1affcd8c8b4f9cd82f29ce903bee82d622" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>GetState</name></member>
      <member refid="class_headers_sync_state_1a9ef34f87a3e2aa8d73b928fa9f3b1911" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>HeadersSyncState</name></member>
      <member refid="class_headers_sync_state_1a360acbf1850f46c0ba8e272818d11291" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_chain_start</name></member>
      <member refid="class_headers_sync_state_1a840e4da6e13976dfabe46b044e3b1738" prot="protected" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_commit_offset</name></member>
      <member refid="class_headers_sync_state_1a23255258fd76d30a2e501dd2635fa971" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_consensus_params</name></member>
      <member refid="class_headers_sync_state_1ab16eb9ad5673f2af729f8a0b2607ff95" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_current_chain_work</name></member>
      <member refid="class_headers_sync_state_1aa27ccb01ea5af50b6849b563d188c2d5" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_current_height</name></member>
      <member refid="class_headers_sync_state_1ac4b68bdff4bae06f773abbe57617b313" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_download_state</name></member>
      <member refid="class_headers_sync_state_1a56e78ab99b5cb5425c1aa9872e403b88" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_hasher</name></member>
      <member refid="class_headers_sync_state_1aaa8a19f8097da313c938b84a9e34d8e7" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_header_commitments</name></member>
      <member refid="class_headers_sync_state_1a3fd2bd87699e7aed6dee14d46832fe9f" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_id</name></member>
      <member refid="class_headers_sync_state_1a82dd9be3428f0017fad3d1d3058f89bf" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_last_header_received</name></member>
      <member refid="class_headers_sync_state_1a3f43afd39a1491aee2abf05ac9a7d94d" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_max_commitments</name></member>
      <member refid="class_headers_sync_state_1a76195b4072d7f0c1dd75d08095300a90" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_minimum_required_work</name></member>
      <member refid="class_headers_sync_state_1a70efa3a01a97822c16032d0d924aaaa3" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_params</name></member>
      <member refid="class_headers_sync_state_1a89afb6711c637991dd786e422a1dffd0" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_process_all_remaining_headers</name></member>
      <member refid="class_headers_sync_state_1a2969af8d1b880dfc7145c8750ff91c12" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_redownload_buffer_first_prev_hash</name></member>
      <member refid="class_headers_sync_state_1af4c0ca7d9aeb474acb50cef4e735d50f" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_redownload_buffer_last_hash</name></member>
      <member refid="class_headers_sync_state_1aa716c9d136876c7ce2d5bf27a99bbef4" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_redownload_buffer_last_height</name></member>
      <member refid="class_headers_sync_state_1aa4410e9f0ab301067f218a95d103d245" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_redownload_chain_work</name></member>
      <member refid="class_headers_sync_state_1a159f762fb185c8e154b5dc3d67fe22a1" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>m_redownloaded_headers</name></member>
      <member refid="class_headers_sync_state_1ac7f7cda8eb56d220ef54951c6cebcb2e" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>NextHeadersRequestLocator</name></member>
      <member refid="class_headers_sync_state_1a9983ea7a6f1465bc2bd3f05b87a09f6e" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>PopHeadersReadyForAcceptance</name></member>
      <member refid="class_headers_sync_state_1a0e12375af6318f0729742c2fde2e7294" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>ProcessNextHeaders</name></member>
      <member refid="class_headers_sync_state_1a5d74787dedbc4e11c1ab15bf487e61f8" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>State</name></member>
      <member refid="class_headers_sync_state_1a67a47ee04e7d9148c62828bdf26cbd87" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>ValidateAndProcessSingleHeader</name></member>
      <member refid="class_headers_sync_state_1a8675e244287fdb061499143939796a70" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>ValidateAndStoreHeadersCommitments</name></member>
      <member refid="class_headers_sync_state_1a3a19759fa297387e2651eaf0c4c83492" prot="private" virt="non-virtual"><scope>HeadersSyncState</scope><name>ValidateAndStoreRedownloadedHeader</name></member>
      <member refid="class_headers_sync_state_1aead457f323e9312e44673a1837abf705" prot="public" virt="non-virtual"><scope>HeadersSyncState</scope><name>~HeadersSyncState</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
