<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="namespacecluster__linearize" kind="namespace" language="C++">
    <compoundname>cluster_linearize</compoundname>
    <innerclass refid="classcluster__linearize_1_1_dep_graph" prot="public">cluster_linearize::DepGraph</innerclass>
    <innerclass refid="structcluster__linearize_1_1_set_info" prot="public">cluster_linearize::SetInfo</innerclass>
    <innerclass refid="classcluster__linearize_1_1_spanning_forest_state" prot="public">cluster_linearize::SpanningForestState</innerclass>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" prot="public" static="no">
        <type>uint32_t</type>
        <definition>using DepGraphIndex =  uint32_t</definition>
        <argsstring></argsstring>
        <name>DepGraphIndex</name>
        <qualifiedname>cluster_linearize::DepGraphIndex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Data type to represent transaction indices in DepGraphs and the clusters they represent. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="24" column="1" bodyfile="src/cluster_linearize.h" bodystart="24" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespacecluster__linearize_1a30f9a354e247428df47e59a11e2a098f" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename SetType</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="structcluster__linearize_1_1_set_info" kindref="compound">SetInfo</ref>&lt; SetType &gt; &gt;</type>
        <definition>std::vector&lt; SetInfo&lt; SetType &gt; &gt; ChunkLinearizationInfo</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph, std::span&lt; const DepGraphIndex &gt; linearization) noexcept</argsstring>
        <name>ChunkLinearizationInfo</name>
        <qualifiedname>cluster_linearize::ChunkLinearizationInfo</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <param>
          <type>std::span&lt; const <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
          <declname>linearization</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compute the chunks of linearization as SetInfos. </para>
        </detaileddescription>
        <inbodydescription>
<para>The new chunk to be added, initially a singleton.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="427" column="13" bodyfile="src/cluster_linearize.h" bodystart="427" bodyend="442"/>
      </memberdef>
      <memberdef kind="function" id="namespacecluster__linearize_1a8efd6c0d9203d9d942b0c8b9baf81e87" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename SetType</type>
          </param>
        </templateparamlist>
        <type>std::vector&lt; <ref refid="struct_fee_frac" kindref="compound">FeeFrac</ref> &gt;</type>
        <definition>std::vector&lt; FeeFrac &gt; ChunkLinearization</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph, std::span&lt; const DepGraphIndex &gt; linearization) noexcept</argsstring>
        <name>ChunkLinearization</name>
        <qualifiedname>cluster_linearize::ChunkLinearization</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <param>
          <type>std::span&lt; const <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
          <declname>linearization</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compute the feerates of the chunks of linearization. Identical to ChunkLinearizationInfo, but only returns the chunk feerates, not the corresponding transaction sets. </para>
        </detaileddescription>
        <inbodydescription>
<para>The new chunk to be added, initially a singleton.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="447" column="13" bodyfile="src/cluster_linearize.h" bodystart="447" bodyend="462"/>
      </memberdef>
      <memberdef kind="function" id="namespacecluster__linearize_1ad7fec78514892bfc4213dec2180ea5fa" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename SetType</type>
          </param>
        </templateparamlist>
        <type>std::tuple&lt; std::vector&lt; <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;, bool, uint64_t &gt;</type>
        <definition>std::tuple&lt; std::vector&lt; DepGraphIndex &gt;, bool, uint64_t &gt; Linearize</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph, uint64_t max_iterations, uint64_t rng_seed, std::span&lt; const DepGraphIndex &gt; old_linearization={}) noexcept</argsstring>
        <name>Linearize</name>
        <qualifiedname>cluster_linearize::Linearize</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>max_iterations</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>rng_seed</declname>
        </param>
        <param>
          <type>std::span&lt; const <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
          <declname>old_linearization</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Find or improve a linearization for a cluster.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">depgraph</parametername>
</parameternamelist>
<parameterdescription>
<para>Dependency graph of the cluster to be linearized. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_iterations</parametername>
</parameternamelist>
<parameterdescription>
<para>Upper bound on the amount of work that will be done. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">rng_seed</parametername>
</parameternamelist>
<parameterdescription>
<para>A random number seed to control search order. This prevents peers from predicting exactly which clusters would be hard for us to linearize. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">old_linearization</parametername>
</parameternamelist>
<parameterdescription>
<para>An existing linearization for the cluster (which must be topologically valid), or empty. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A tuple of:<itemizedlist>
<listitem><para>The resulting linearization. It is guaranteed to be at least as good (in the feerate diagram sense) as old_linearization.</para>
</listitem><listitem><para>A boolean indicating whether the result is guaranteed to be optimal.</para>
</listitem><listitem><para>How many optimization steps were actually performed. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
<para>Initialize a spanning forest data structure for this cluster.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1351" column="12" bodyfile="src/cluster_linearize.h" bodystart="1351" bodyend="1373"/>
      </memberdef>
      <memberdef kind="function" id="namespacecluster__linearize_1ab4dfb7a53e485a4f5eac2219e4176a91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename SetType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void PostLinearize</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph, std::span&lt; DepGraphIndex &gt; linearization)</argsstring>
        <name>PostLinearize</name>
        <qualifiedname>cluster_linearize::PostLinearize</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <param>
          <type>std::span&lt; <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
          <declname>linearization</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Improve a given linearization.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">depgraph</parametername>
</parameternamelist>
<parameterdescription>
<para>Dependency graph of the cluster being linearized. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">linearization</parametername>
</parameternamelist>
<parameterdescription>
<para>On input, an existing linearization for depgraph. On output, a potentially better linearization for the same graph.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Postlinearization guarantees:<itemizedlist>
<listitem><para>The resulting chunks are connected.</para>
</listitem><listitem><para>If the input has a tree shape (either all transactions have at most one child, or all transactions have at most one parent), the result is optimal.</para>
</listitem><listitem><para>Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end, optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least as good as L1. This means that replacing transactions with same-size higher-fee transactions will not worsen linearizations through a &quot;drop conflicts, append new transactions,
  postlinearize&quot; process. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
<para>Index of the sentinel in the entries array below.</para>
<para>Indicator that a group has no previous transaction.</para>
<para>Data structure per transaction entry.</para>
<para>The index of the previous transaction in this group; NO_PREV_TX if this is the first entry of a group.</para>
<para>Index of the first transaction in this group, possibly itself.</para>
<para>Index of the last transaction in the previous group. The first group (the sentinel) points back to the last group here, making it a singly-linked circular list.</para>
<para>All transactions in the group. Empty for the sentinel.</para>
<para>All dependencies of the group (descendants in even passes; ancestors in odd ones).</para>
<para>The combined fee/size of transactions in the group. Fee is negated in even passes.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1392" column="6" bodyfile="src/cluster_linearize.h" bodystart="1392" bodyend="1574"/>
      </memberdef>
      <memberdef kind="function" id="namespacecluster__linearize_1a2d8e8c7af3c1fd9b4bbd67716b358430" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename SetType</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void FixLinearization</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph, std::span&lt; DepGraphIndex &gt; linearization) noexcept</argsstring>
        <name>FixLinearization</name>
        <qualifiedname>cluster_linearize::FixLinearization</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <param>
          <type>std::span&lt; <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
          <declname>linearization</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make linearization topological, retaining its ordering where possible. </para>
        </detaileddescription>
        <inbodydescription>
<para>The element at that position.</para>
<para>j represents how far from the back of the linearization elem should be placed.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1578" column="6" bodyfile="src/cluster_linearize.h" bodystart="1578" bodyend="1606"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/cluster_linearize.h" line="21" column="1"/>
  </compounddef>
</doxygen>
