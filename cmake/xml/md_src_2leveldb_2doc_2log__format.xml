<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="md_src_2leveldb_2doc_2log__format" kind="page">
    <compoundname>md_src_2leveldb_2doc_2log__format</compoundname>
    <title>leveldb Log format</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>The log file contents are a sequence of 32KB blocks. The only exception is that the tail of the file may contain a partial block.</para>
<para>Each block consists of a sequence of records: <verbatim>block := record* trailer?
record :=
  checksum: uint32     // crc32c of type and data[] ; little-endian
  length: uint16       // little-endian
  type: uint8          // One of FULL, FIRST, MIDDLE, LAST
  data: uint8[length]
</verbatim></para>
<para>A record never starts within the last six bytes of a block (since it won&apos;t fit). Any leftover bytes here form the trailer, which must consist entirely of zero bytes and must be skipped by readers.</para>
<para>Aside: if exactly seven bytes are left in the current block, and a new non-zero length record is added, the writer must emit a FIRST record (which contains zero bytes of user data) to fill up the trailing seven bytes of the block and then emit all of the user data in subsequent blocks.</para>
<para>More types may be added in the future. Some Readers may skip record types they do not understand, others may report that some data was skipped. <verbatim>FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4
</verbatim></para>
<para>The FULL record contains the contents of an entire user record.</para>
<para>FIRST, MIDDLE, LAST are types used for user records that have been split into multiple fragments (typically because of block boundaries). FIRST is the type of the first fragment of a user record, LAST is the type of the last fragment of a user record, and MIDDLE is the type of all interior fragments of a user record.</para>
<para>Example: consider a sequence of user records: <verbatim>A: length 1000
B: length 97270
C: length 8000
</verbatim></para>
<para><bold>A</bold> will be stored as a FULL record in the first block.</para>
<para><bold>B</bold> will be split into three fragments: first fragment occupies the rest of the first block, second fragment occupies the entirety of the second block, and the third fragment occupies a prefix of the third block. This will leave six bytes free in the third block, which will be left empty as the trailer.</para>
<para><bold>C</bold> will be stored as a FULL record in the fourth block.</para>
<para><hruler/>
</para>
<sect1 id="md_src_2leveldb_2doc_2log__format_1autotoc_md65">
<title>Some benefits over the recordio format:</title><para><orderedlist>
<listitem><para>We do not need any heuristics for resyncing - just go to next block boundary and scan. If there is a corruption, skip to the next block. As a side-benefit, we do not get confused when part of the contents of one log file are embedded as a record inside another log file.</para>
</listitem><listitem><para>Splitting at approximate boundaries (e.g., for mapreduce) is simple: find the next block boundary and skip records until we hit a FULL or FIRST record.</para>
</listitem><listitem><para>We do not need extra buffering for large records.</para>
</listitem></orderedlist>
</para>
</sect1>
<sect1 id="md_src_2leveldb_2doc_2log__format_1autotoc_md66">
<title>Some downsides compared to recordio format:</title><para><orderedlist>
<listitem><para>No packing of tiny records. This could be fixed by adding a new record type, so it is a shortcoming of the current implementation, not necessarily the format.</para>
</listitem><listitem><para>No compression. Again, this could be fixed by adding new record types. </para>
</listitem></orderedlist>
</para>
</sect1>
    </detaileddescription>
    <location file="src/leveldb/doc/log_format.md"/>
  </compounddef>
</doxygen>
