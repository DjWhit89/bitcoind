<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="index_8md" kind="file" language="Markdown">
    <compoundname>index.md</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">leveldb</highlight></codeline>
<codeline><highlight class="normal">=======</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">_Jeff<sp/>Dean,<sp/>Sanjay<sp/>Ghemawat_</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>leveldb<sp/>library<sp/>provides<sp/>a<sp/>persistent<sp/>key<sp/>value<sp/>store.<sp/>Keys<sp/>and<sp/>values<sp/>are</highlight></codeline>
<codeline><highlight class="normal">arbitrary<sp/>byte<sp/>arrays.<sp/><sp/>The<sp/>keys<sp/>are<sp/>ordered<sp/>within<sp/>the<sp/>key<sp/>value<sp/>store</highlight></codeline>
<codeline><highlight class="normal">according<sp/>to<sp/>a<sp/>user-specified<sp/>comparator<sp/>function.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Opening<sp/>A<sp/>Database</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>leveldb<sp/>database<sp/>has<sp/>a<sp/>name<sp/>which<sp/>corresponds<sp/>to<sp/>a<sp/>file<sp/>system<sp/>directory.<sp/>All</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>contents<sp/>of<sp/>database<sp/>are<sp/>stored<sp/>in<sp/>this<sp/>directory.<sp/>The<sp/>following<sp/>example</highlight></codeline>
<codeline><highlight class="normal">shows<sp/>how<sp/>to<sp/>open<sp/>a<sp/>database,<sp/>creating<sp/>it<sp/>if<sp/>necessary:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;cassert&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;leveldb/db.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">leveldb::DB*<sp/>db;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.create_if_missing<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Status<sp/>status<sp/>=<sp/>leveldb::DB::Open(options,<sp/>&quot;/tmp/testdb&quot;,<sp/>&amp;db);</highlight></codeline>
<codeline><highlight class="normal">assert(status.ok());</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>want<sp/>to<sp/>raise<sp/>an<sp/>error<sp/>if<sp/>the<sp/>database<sp/>already<sp/>exists,<sp/>add<sp/>the<sp/>following</highlight></codeline>
<codeline><highlight class="normal">line<sp/>before<sp/>the<sp/>`leveldb::DB::Open`<sp/>call:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">options.error_if_exists<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Status</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>may<sp/>have<sp/>noticed<sp/>the<sp/>`leveldb::Status`<sp/>type<sp/>above.<sp/>Values<sp/>of<sp/>this<sp/>type<sp/>are</highlight></codeline>
<codeline><highlight class="normal">returned<sp/>by<sp/>most<sp/>functions<sp/>in<sp/>leveldb<sp/>that<sp/>may<sp/>encounter<sp/>an<sp/>error.<sp/>You<sp/>can<sp/>check</highlight></codeline>
<codeline><highlight class="normal">if<sp/>such<sp/>a<sp/>result<sp/>is<sp/>ok,<sp/>and<sp/>also<sp/>print<sp/>an<sp/>associated<sp/>error<sp/>message:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Status<sp/>s<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(!s.ok())<sp/>cerr<sp/>&lt;&lt;<sp/>s.ToString()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Closing<sp/>A<sp/>Database</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>you<sp/>are<sp/>done<sp/>with<sp/>a<sp/>database,<sp/>just<sp/>delete<sp/>the<sp/>database<sp/>object.<sp/>Example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">...<sp/>open<sp/>the<sp/>db<sp/>as<sp/>described<sp/>above<sp/>...</highlight></codeline>
<codeline><highlight class="normal">...<sp/>do<sp/>something<sp/>with<sp/>db<sp/>...</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>db;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Reads<sp/>And<sp/>Writes</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>database<sp/>provides<sp/>Put,<sp/>Delete,<sp/>and<sp/>Get<sp/>methods<sp/>to<sp/>modify/query<sp/>the<sp/>database.</highlight></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>the<sp/>following<sp/>code<sp/>moves<sp/>the<sp/>value<sp/>stored<sp/>under<sp/>key1<sp/>to<sp/>key2.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>value;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Status<sp/>s<sp/>=<sp/>db-&gt;Get(leveldb::ReadOptions(),<sp/>key1,<sp/>&amp;value);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(s.ok())<sp/>s<sp/>=<sp/>db-&gt;Put(leveldb::WriteOptions(),<sp/>key2,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(s.ok())<sp/>s<sp/>=<sp/>db-&gt;Delete(leveldb::WriteOptions(),<sp/>key1);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Atomic<sp/>Updates</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>if<sp/>the<sp/>process<sp/>dies<sp/>after<sp/>the<sp/>Put<sp/>of<sp/>key2<sp/>but<sp/>before<sp/>the<sp/>delete<sp/>of</highlight></codeline>
<codeline><highlight class="normal">key1,<sp/>the<sp/>same<sp/>value<sp/>may<sp/>be<sp/>left<sp/>stored<sp/>under<sp/>multiple<sp/>keys.<sp/>Such<sp/>problems<sp/>can</highlight></codeline>
<codeline><highlight class="normal">be<sp/>avoided<sp/>by<sp/>using<sp/>the<sp/>`WriteBatch`<sp/>class<sp/>to<sp/>atomically<sp/>apply<sp/>a<sp/>set<sp/>of<sp/>updates:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;leveldb/write_batch.h&quot;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>value;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Status<sp/>s<sp/>=<sp/>db-&gt;Get(leveldb::ReadOptions(),<sp/>key1,<sp/>&amp;value);</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(s.ok())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>leveldb::WriteBatch<sp/>batch;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>batch.Delete(key1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>batch.Put(key2,<sp/>value);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>s<sp/>=<sp/>db-&gt;Write(leveldb::WriteOptions(),<sp/>&amp;batch);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>`WriteBatch`<sp/>holds<sp/>a<sp/>sequence<sp/>of<sp/>edits<sp/>to<sp/>be<sp/>made<sp/>to<sp/>the<sp/>database,<sp/>and<sp/>these</highlight></codeline>
<codeline><highlight class="normal">edits<sp/>within<sp/>the<sp/>batch<sp/>are<sp/>applied<sp/>in<sp/>order.<sp/>Note<sp/>that<sp/>we<sp/>called<sp/>Delete<sp/>before</highlight></codeline>
<codeline><highlight class="normal">Put<sp/>so<sp/>that<sp/>if<sp/>key1<sp/>is<sp/>identical<sp/>to<sp/>key2,<sp/>we<sp/>do<sp/>not<sp/>end<sp/>up<sp/>erroneously<sp/>dropping</highlight></codeline>
<codeline><highlight class="normal">the<sp/>value<sp/>entirely.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Apart<sp/>from<sp/>its<sp/>atomicity<sp/>benefits,<sp/>`WriteBatch`<sp/>may<sp/>also<sp/>be<sp/>used<sp/>to<sp/>speed<sp/>up</highlight></codeline>
<codeline><highlight class="normal">bulk<sp/>updates<sp/>by<sp/>placing<sp/>lots<sp/>of<sp/>individual<sp/>mutations<sp/>into<sp/>the<sp/>same<sp/>batch.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Synchronous<sp/>Writes</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">By<sp/>default,<sp/>each<sp/>write<sp/>to<sp/>leveldb<sp/>is<sp/>asynchronous:<sp/>it<sp/>returns<sp/>after<sp/>pushing<sp/>the</highlight></codeline>
<codeline><highlight class="normal">write<sp/>from<sp/>the<sp/>process<sp/>into<sp/>the<sp/>operating<sp/>system.<sp/>The<sp/>transfer<sp/>from<sp/>operating</highlight></codeline>
<codeline><highlight class="normal">system<sp/>memory<sp/>to<sp/>the<sp/>underlying<sp/>persistent<sp/>storage<sp/>happens<sp/>asynchronously.<sp/>The</highlight></codeline>
<codeline><highlight class="normal">sync<sp/>flag<sp/>can<sp/>be<sp/>turned<sp/>on<sp/>for<sp/>a<sp/>particular<sp/>write<sp/>to<sp/>make<sp/>the<sp/>write<sp/>operation</highlight></codeline>
<codeline><highlight class="normal">not<sp/>return<sp/>until<sp/>the<sp/>data<sp/>being<sp/>written<sp/>has<sp/>been<sp/>pushed<sp/>all<sp/>the<sp/>way<sp/>to</highlight></codeline>
<codeline><highlight class="normal">persistent<sp/>storage.<sp/>(On<sp/>Posix<sp/>systems,<sp/>this<sp/>is<sp/>implemented<sp/>by<sp/>calling<sp/>either</highlight></codeline>
<codeline><highlight class="normal">`fsync(...)`<sp/>or<sp/>`fdatasync(...)`<sp/>or<sp/>`msync(...,<sp/>MS_SYNC)`<sp/>before<sp/>the<sp/>write</highlight></codeline>
<codeline><highlight class="normal">operation<sp/>returns.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::WriteOptions<sp/>write_options;</highlight></codeline>
<codeline><highlight class="normal">write_options.sync<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">db-&gt;Put(write_options,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Asynchronous<sp/>writes<sp/>are<sp/>often<sp/>more<sp/>than<sp/>a<sp/>thousand<sp/>times<sp/>as<sp/>fast<sp/>as<sp/>synchronous</highlight></codeline>
<codeline><highlight class="normal">writes.<sp/>The<sp/>downside<sp/>of<sp/>asynchronous<sp/>writes<sp/>is<sp/>that<sp/>a<sp/>crash<sp/>of<sp/>the<sp/>machine<sp/>may</highlight></codeline>
<codeline><highlight class="normal">cause<sp/>the<sp/>last<sp/>few<sp/>updates<sp/>to<sp/>be<sp/>lost.<sp/>Note<sp/>that<sp/>a<sp/>crash<sp/>of<sp/>just<sp/>the<sp/>writing</highlight></codeline>
<codeline><highlight class="normal">process<sp/>(i.e.,<sp/>not<sp/>a<sp/>reboot)<sp/>will<sp/>not<sp/>cause<sp/>any<sp/>loss<sp/>since<sp/>even<sp/>when<sp/>sync<sp/>is</highlight></codeline>
<codeline><highlight class="normal">false,<sp/>an<sp/>update<sp/>is<sp/>pushed<sp/>from<sp/>the<sp/>process<sp/>memory<sp/>into<sp/>the<sp/>operating<sp/>system</highlight></codeline>
<codeline><highlight class="normal">before<sp/>it<sp/>is<sp/>considered<sp/>done.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Asynchronous<sp/>writes<sp/>can<sp/>often<sp/>be<sp/>used<sp/>safely.<sp/>For<sp/>example,<sp/>when<sp/>loading<sp/>a<sp/>large</highlight></codeline>
<codeline><highlight class="normal">amount<sp/>of<sp/>data<sp/>into<sp/>the<sp/>database<sp/>you<sp/>can<sp/>handle<sp/>lost<sp/>updates<sp/>by<sp/>restarting<sp/>the</highlight></codeline>
<codeline><highlight class="normal">bulk<sp/>load<sp/>after<sp/>a<sp/>crash.<sp/>A<sp/>hybrid<sp/>scheme<sp/>is<sp/>also<sp/>possible<sp/>where<sp/>every<sp/>Nth<sp/>write</highlight></codeline>
<codeline><highlight class="normal">is<sp/>synchronous,<sp/>and<sp/>in<sp/>the<sp/>event<sp/>of<sp/>a<sp/>crash,<sp/>the<sp/>bulk<sp/>load<sp/>is<sp/>restarted<sp/>just</highlight></codeline>
<codeline><highlight class="normal">after<sp/>the<sp/>last<sp/>synchronous<sp/>write<sp/>finished<sp/>by<sp/>the<sp/>previous<sp/>run.<sp/>(The<sp/>synchronous</highlight></codeline>
<codeline><highlight class="normal">write<sp/>can<sp/>update<sp/>a<sp/>marker<sp/>that<sp/>describes<sp/>where<sp/>to<sp/>restart<sp/>on<sp/>a<sp/>crash.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`WriteBatch`<sp/>provides<sp/>an<sp/>alternative<sp/>to<sp/>asynchronous<sp/>writes.<sp/>Multiple<sp/>updates</highlight></codeline>
<codeline><highlight class="normal">may<sp/>be<sp/>placed<sp/>in<sp/>the<sp/>same<sp/>WriteBatch<sp/>and<sp/>applied<sp/>together<sp/>using<sp/>a<sp/>synchronous</highlight></codeline>
<codeline><highlight class="normal">write<sp/>(i.e.,<sp/>`write_options.sync`<sp/>is<sp/>set<sp/>to<sp/>true).<sp/>The<sp/>extra<sp/>cost<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">synchronous<sp/>write<sp/>will<sp/>be<sp/>amortized<sp/>across<sp/>all<sp/>of<sp/>the<sp/>writes<sp/>in<sp/>the<sp/>batch.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Concurrency</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>database<sp/>may<sp/>only<sp/>be<sp/>opened<sp/>by<sp/>one<sp/>process<sp/>at<sp/>a<sp/>time.<sp/>The<sp/>leveldb</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>acquires<sp/>a<sp/>lock<sp/>from<sp/>the<sp/>operating<sp/>system<sp/>to<sp/>prevent<sp/>misuse.</highlight></codeline>
<codeline><highlight class="normal">Within<sp/>a<sp/>single<sp/>process,<sp/>the<sp/>same<sp/>`leveldb::DB`<sp/>object<sp/>may<sp/>be<sp/>safely<sp/>shared<sp/>by</highlight></codeline>
<codeline><highlight class="normal">multiple<sp/>concurrent<sp/>threads.<sp/>I.e.,<sp/>different<sp/>threads<sp/>may<sp/>write<sp/>into<sp/>or<sp/>fetch</highlight></codeline>
<codeline><highlight class="normal">iterators<sp/>or<sp/>call<sp/>Get<sp/>on<sp/>the<sp/>same<sp/>database<sp/>without<sp/>any<sp/>external<sp/>synchronization</highlight></codeline>
<codeline><highlight class="normal">(the<sp/>leveldb<sp/>implementation<sp/>will<sp/>automatically<sp/>do<sp/>the<sp/>required<sp/>synchronization).</highlight></codeline>
<codeline><highlight class="normal">However<sp/>other<sp/>objects<sp/>(like<sp/>Iterator<sp/>and<sp/>`WriteBatch`)<sp/>may<sp/>require<sp/>external</highlight></codeline>
<codeline><highlight class="normal">synchronization.<sp/>If<sp/>two<sp/>threads<sp/>share<sp/>such<sp/>an<sp/>object,<sp/>they<sp/>must<sp/>protect<sp/>access</highlight></codeline>
<codeline><highlight class="normal">to<sp/>it<sp/>using<sp/>their<sp/>own<sp/>locking<sp/>protocol.<sp/>More<sp/>details<sp/>are<sp/>available<sp/>in<sp/>the<sp/>public</highlight></codeline>
<codeline><highlight class="normal">header<sp/>files.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Iteration</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>following<sp/>example<sp/>demonstrates<sp/>how<sp/>to<sp/>print<sp/>all<sp/>key,value<sp/>pairs<sp/>in<sp/>a</highlight></codeline>
<codeline><highlight class="normal">database.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Iterator*<sp/>it<sp/>=<sp/>db-&gt;NewIterator(leveldb::ReadOptions());</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(it-&gt;SeekToFirst();<sp/>it-&gt;Valid();<sp/>it-&gt;Next())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cout<sp/>&lt;&lt;<sp/>it-&gt;key().ToString()<sp/>&lt;&lt;<sp/>&quot;:<sp/>&quot;<sp/><sp/>&lt;&lt;<sp/>it-&gt;value().ToString()<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">assert(it-&gt;status().ok());<sp/><sp/>//<sp/>Check<sp/>for<sp/>any<sp/>errors<sp/>found<sp/>during<sp/>the<sp/>scan</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>it;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>following<sp/>variation<sp/>shows<sp/>how<sp/>to<sp/>process<sp/>just<sp/>the<sp/>keys<sp/>in<sp/>the<sp/>range</highlight></codeline>
<codeline><highlight class="normal">[start,limit):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(it-&gt;Seek(start);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>it-&gt;Valid()<sp/>&amp;&amp;<sp/>it-&gt;key().ToString()<sp/>&lt;<sp/>limit;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>it-&gt;Next())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>also<sp/>process<sp/>entries<sp/>in<sp/>reverse<sp/>order.<sp/>(Caveat:<sp/>reverse<sp/>iteration<sp/>may<sp/>be</highlight></codeline>
<codeline><highlight class="normal">somewhat<sp/>slower<sp/>than<sp/>forward<sp/>iteration.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(it-&gt;SeekToLast();<sp/>it-&gt;Valid();<sp/>it-&gt;Prev())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Snapshots</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Snapshots<sp/>provide<sp/>consistent<sp/>read-only<sp/>views<sp/>over<sp/>the<sp/>entire<sp/>state<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">key-value<sp/>store.<sp/><sp/>`ReadOptions::snapshot`<sp/>may<sp/>be<sp/>non-NULL<sp/>to<sp/>indicate<sp/>that<sp/>a</highlight></codeline>
<codeline><highlight class="normal">read<sp/>should<sp/>operate<sp/>on<sp/>a<sp/>particular<sp/>version<sp/>of<sp/>the<sp/>DB<sp/>state.<sp/>If</highlight></codeline>
<codeline><highlight class="normal">`ReadOptions::snapshot`<sp/>is<sp/>NULL,<sp/>the<sp/>read<sp/>will<sp/>operate<sp/>on<sp/>an<sp/>implicit<sp/>snapshot</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>current<sp/>state.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Snapshots<sp/>are<sp/>created<sp/>by<sp/>the<sp/>`DB::GetSnapshot()`<sp/>method:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::ReadOptions<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.snapshot<sp/>=<sp/>db-&gt;GetSnapshot();</highlight></codeline>
<codeline><highlight class="normal">...<sp/>apply<sp/>some<sp/>updates<sp/>to<sp/>db<sp/>...</highlight></codeline>
<codeline><highlight class="normal">leveldb::Iterator*<sp/>iter<sp/>=<sp/>db-&gt;NewIterator(options);</highlight></codeline>
<codeline><highlight class="normal">...<sp/>read<sp/>using<sp/>iter<sp/>to<sp/>view<sp/>the<sp/>state<sp/>when<sp/>the<sp/>snapshot<sp/>was<sp/>created<sp/>...</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>iter;</highlight></codeline>
<codeline><highlight class="normal">db-&gt;ReleaseSnapshot(options.snapshot);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>when<sp/>a<sp/>snapshot<sp/>is<sp/>no<sp/>longer<sp/>needed,<sp/>it<sp/>should<sp/>be<sp/>released<sp/>using<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`DB::ReleaseSnapshot`<sp/>interface.<sp/>This<sp/>allows<sp/>the<sp/>implementation<sp/>to<sp/>get<sp/>rid<sp/>of</highlight></codeline>
<codeline><highlight class="normal">state<sp/>that<sp/>was<sp/>being<sp/>maintained<sp/>just<sp/>to<sp/>support<sp/>reading<sp/>as<sp/>of<sp/>that<sp/>snapshot.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Slice</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>return<sp/>value<sp/>of<sp/>the<sp/>`it-&gt;key()`<sp/>and<sp/>`it-&gt;value()`<sp/>calls<sp/>above<sp/>are<sp/>instances</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>`leveldb::Slice`<sp/>type.<sp/>Slice<sp/>is<sp/>a<sp/>simple<sp/>structure<sp/>that<sp/>contains<sp/>a<sp/>length</highlight></codeline>
<codeline><highlight class="normal">and<sp/>a<sp/>pointer<sp/>to<sp/>an<sp/>external<sp/>byte<sp/>array.<sp/>Returning<sp/>a<sp/>Slice<sp/>is<sp/>a<sp/>cheaper</highlight></codeline>
<codeline><highlight class="normal">alternative<sp/>to<sp/>returning<sp/>a<sp/>`std::string`<sp/>since<sp/>we<sp/>do<sp/>not<sp/>need<sp/>to<sp/>copy</highlight></codeline>
<codeline><highlight class="normal">potentially<sp/>large<sp/>keys<sp/>and<sp/>values.<sp/>In<sp/>addition,<sp/>leveldb<sp/>methods<sp/>do<sp/>not<sp/>return</highlight></codeline>
<codeline><highlight class="normal">null-terminated<sp/>C-style<sp/>strings<sp/>since<sp/>leveldb<sp/>keys<sp/>and<sp/>values<sp/>are<sp/>allowed<sp/>to</highlight></codeline>
<codeline><highlight class="normal">contain<sp/>`&apos;\0&apos;`<sp/>bytes.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">C++<sp/>strings<sp/>and<sp/>null-terminated<sp/>C-style<sp/>strings<sp/>can<sp/>be<sp/>easily<sp/>converted<sp/>to<sp/>a</highlight></codeline>
<codeline><highlight class="normal">Slice:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Slice<sp/>s1<sp/>=<sp/>&quot;hello&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">std::string<sp/>str(&quot;world&quot;);</highlight></codeline>
<codeline><highlight class="normal">leveldb::Slice<sp/>s2<sp/>=<sp/>str;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">A<sp/>Slice<sp/>can<sp/>be<sp/>easily<sp/>converted<sp/>back<sp/>to<sp/>a<sp/>C++<sp/>string:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>str<sp/>=<sp/>s1.ToString();</highlight></codeline>
<codeline><highlight class="normal">assert(str<sp/>==<sp/>std::string(&quot;hello&quot;));</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Be<sp/>careful<sp/>when<sp/>using<sp/>Slices<sp/>since<sp/>it<sp/>is<sp/>up<sp/>to<sp/>the<sp/>caller<sp/>to<sp/>ensure<sp/>that<sp/>the</highlight></codeline>
<codeline><highlight class="normal">external<sp/>byte<sp/>array<sp/>into<sp/>which<sp/>the<sp/>Slice<sp/>points<sp/>remains<sp/>live<sp/>while<sp/>the<sp/>Slice<sp/>is</highlight></codeline>
<codeline><highlight class="normal">in<sp/>use.<sp/>For<sp/>example,<sp/>the<sp/>following<sp/>is<sp/>buggy:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Slice<sp/>slice;</highlight></codeline>
<codeline><highlight class="normal">if<sp/>(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::string<sp/>str<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>slice<sp/>=<sp/>str;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">Use(slice);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>the<sp/>if<sp/>statement<sp/>goes<sp/>out<sp/>of<sp/>scope,<sp/>str<sp/>will<sp/>be<sp/>destroyed<sp/>and<sp/>the<sp/>backing</highlight></codeline>
<codeline><highlight class="normal">storage<sp/>for<sp/>slice<sp/>will<sp/>disappear.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Comparators</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>preceding<sp/>examples<sp/>used<sp/>the<sp/>default<sp/>ordering<sp/>function<sp/>for<sp/>key,<sp/>which<sp/>orders</highlight></codeline>
<codeline><highlight class="normal">bytes<sp/>lexicographically.<sp/>You<sp/>can<sp/>however<sp/>supply<sp/>a<sp/>custom<sp/>comparator<sp/>when<sp/>opening</highlight></codeline>
<codeline><highlight class="normal">a<sp/>database.<sp/><sp/>For<sp/>example,<sp/>suppose<sp/>each<sp/>database<sp/>key<sp/>consists<sp/>of<sp/>two<sp/>numbers<sp/>and</highlight></codeline>
<codeline><highlight class="normal">we<sp/>should<sp/>sort<sp/>by<sp/>the<sp/>first<sp/>number,<sp/>breaking<sp/>ties<sp/>by<sp/>the<sp/>second<sp/>number.<sp/>First,</highlight></codeline>
<codeline><highlight class="normal">define<sp/>a<sp/>proper<sp/>subclass<sp/>of<sp/>`leveldb::Comparator`<sp/>that<sp/>expresses<sp/>these<sp/>rules:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">class<sp/>TwoPartComparator<sp/>:<sp/>public<sp/>leveldb::Comparator<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Three-way<sp/>comparison<sp/>function:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>if<sp/>a<sp/>&lt;<sp/>b:<sp/>negative<sp/>result</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>if<sp/>a<sp/>&gt;<sp/>b:<sp/>positive<sp/>result</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/><sp/><sp/>else:<sp/>zero<sp/>result</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>Compare(const<sp/>leveldb::Slice&amp;<sp/>a,<sp/>const<sp/>leveldb::Slice&amp;<sp/>b)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>int<sp/>a1,<sp/>a2,<sp/>b1,<sp/>b2;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ParseKey(a,<sp/>&amp;a1,<sp/>&amp;a2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ParseKey(b,<sp/>&amp;b1,<sp/>&amp;b2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(a1<sp/>&lt;<sp/>b1)<sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(a1<sp/>&gt;<sp/>b1)<sp/>return<sp/>+1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(a2<sp/>&lt;<sp/>b2)<sp/>return<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(a2<sp/>&gt;<sp/>b2)<sp/>return<sp/>+1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Ignore<sp/>the<sp/>following<sp/>methods<sp/>for<sp/>now:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>char*<sp/>Name()<sp/>const<sp/>{<sp/>return<sp/>&quot;TwoPartComparator&quot;;<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FindShortestSeparator(std::string*,<sp/>const<sp/>leveldb::Slice&amp;)<sp/>const<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>FindShortSuccessor(std::string*)<sp/>const<sp/>{}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Now<sp/>create<sp/>a<sp/>database<sp/>using<sp/>this<sp/>custom<sp/>comparator:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">TwoPartComparator<sp/>cmp;</highlight></codeline>
<codeline><highlight class="normal">leveldb::DB*<sp/>db;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.create_if_missing<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal">options.comparator<sp/>=<sp/>&amp;cmp;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Status<sp/>status<sp/>=<sp/>leveldb::DB::Open(options,<sp/>&quot;/tmp/testdb&quot;,<sp/>&amp;db);</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Backwards<sp/>compatibility</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>result<sp/>of<sp/>the<sp/>comparator&apos;s<sp/>Name<sp/>method<sp/>is<sp/>attached<sp/>to<sp/>the<sp/>database<sp/>when<sp/>it</highlight></codeline>
<codeline><highlight class="normal">is<sp/>created,<sp/>and<sp/>is<sp/>checked<sp/>on<sp/>every<sp/>subsequent<sp/>database<sp/>open.<sp/>If<sp/>the<sp/>name</highlight></codeline>
<codeline><highlight class="normal">changes,<sp/>the<sp/>`leveldb::DB::Open`<sp/>call<sp/>will<sp/>fail.<sp/>Therefore,<sp/>change<sp/>the<sp/>name<sp/>if</highlight></codeline>
<codeline><highlight class="normal">and<sp/>only<sp/>if<sp/>the<sp/>new<sp/>key<sp/>format<sp/>and<sp/>comparison<sp/>function<sp/>are<sp/>incompatible<sp/>with</highlight></codeline>
<codeline><highlight class="normal">existing<sp/>databases,<sp/>and<sp/>it<sp/>is<sp/>ok<sp/>to<sp/>discard<sp/>the<sp/>contents<sp/>of<sp/>all<sp/>existing</highlight></codeline>
<codeline><highlight class="normal">databases.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">You<sp/>can<sp/>however<sp/>still<sp/>gradually<sp/>evolve<sp/>your<sp/>key<sp/>format<sp/>over<sp/>time<sp/>with<sp/>a<sp/>little</highlight></codeline>
<codeline><highlight class="normal">bit<sp/>of<sp/>pre-planning.<sp/>For<sp/>example,<sp/>you<sp/>could<sp/>store<sp/>a<sp/>version<sp/>number<sp/>at<sp/>the<sp/>end<sp/>of</highlight></codeline>
<codeline><highlight class="normal">each<sp/>key<sp/>(one<sp/>byte<sp/>should<sp/>suffice<sp/>for<sp/>most<sp/>uses).<sp/>When<sp/>you<sp/>wish<sp/>to<sp/>switch<sp/>to<sp/>a</highlight></codeline>
<codeline><highlight class="normal">new<sp/>key<sp/>format<sp/>(e.g.,<sp/>adding<sp/>an<sp/>optional<sp/>third<sp/>part<sp/>to<sp/>the<sp/>keys<sp/>processed<sp/>by</highlight></codeline>
<codeline><highlight class="normal">`TwoPartComparator`),<sp/>(a)<sp/>keep<sp/>the<sp/>same<sp/>comparator<sp/>name<sp/>(b)<sp/>increment<sp/>the</highlight></codeline>
<codeline><highlight class="normal">version<sp/>number<sp/>for<sp/>new<sp/>keys<sp/>(c)<sp/>change<sp/>the<sp/>comparator<sp/>function<sp/>so<sp/>it<sp/>uses<sp/>the</highlight></codeline>
<codeline><highlight class="normal">version<sp/>numbers<sp/>found<sp/>in<sp/>the<sp/>keys<sp/>to<sp/>decide<sp/>how<sp/>to<sp/>interpret<sp/>them.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Performance</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Performance<sp/>can<sp/>be<sp/>tuned<sp/>by<sp/>changing<sp/>the<sp/>default<sp/>values<sp/>of<sp/>the<sp/>types<sp/>defined<sp/>in</highlight></codeline>
<codeline><highlight class="normal">`include/options.h`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Block<sp/>size</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">leveldb<sp/>groups<sp/>adjacent<sp/>keys<sp/>together<sp/>into<sp/>the<sp/>same<sp/>block<sp/>and<sp/>such<sp/>a<sp/>block<sp/>is</highlight></codeline>
<codeline><highlight class="normal">the<sp/>unit<sp/>of<sp/>transfer<sp/>to<sp/>and<sp/>from<sp/>persistent<sp/>storage.<sp/>The<sp/>default<sp/>block<sp/>size<sp/>is</highlight></codeline>
<codeline><highlight class="normal">approximately<sp/>4096<sp/>uncompressed<sp/>bytes.<sp/><sp/>Applications<sp/>that<sp/>mostly<sp/>do<sp/>bulk<sp/>scans</highlight></codeline>
<codeline><highlight class="normal">over<sp/>the<sp/>contents<sp/>of<sp/>the<sp/>database<sp/>may<sp/>wish<sp/>to<sp/>increase<sp/>this<sp/>size.<sp/>Applications</highlight></codeline>
<codeline><highlight class="normal">that<sp/>do<sp/>a<sp/>lot<sp/>of<sp/>point<sp/>reads<sp/>of<sp/>small<sp/>values<sp/>may<sp/>wish<sp/>to<sp/>switch<sp/>to<sp/>a<sp/>smaller</highlight></codeline>
<codeline><highlight class="normal">block<sp/>size<sp/>if<sp/>performance<sp/>measurements<sp/>indicate<sp/>an<sp/>improvement.<sp/>There<sp/>isn&apos;t<sp/>much</highlight></codeline>
<codeline><highlight class="normal">benefit<sp/>in<sp/>using<sp/>blocks<sp/>smaller<sp/>than<sp/>one<sp/>kilobyte,<sp/>or<sp/>larger<sp/>than<sp/>a<sp/>few</highlight></codeline>
<codeline><highlight class="normal">megabytes.<sp/>Also<sp/>note<sp/>that<sp/>compression<sp/>will<sp/>be<sp/>more<sp/>effective<sp/>with<sp/>larger<sp/>block</highlight></codeline>
<codeline><highlight class="normal">sizes.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Compression</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Each<sp/>block<sp/>is<sp/>individually<sp/>compressed<sp/>before<sp/>being<sp/>written<sp/>to<sp/>persistent</highlight></codeline>
<codeline><highlight class="normal">storage.<sp/>Compression<sp/>is<sp/>on<sp/>by<sp/>default<sp/>since<sp/>the<sp/>default<sp/>compression<sp/>method<sp/>is</highlight></codeline>
<codeline><highlight class="normal">very<sp/>fast,<sp/>and<sp/>is<sp/>automatically<sp/>disabled<sp/>for<sp/>incompressible<sp/>data.<sp/>In<sp/>rare<sp/>cases,</highlight></codeline>
<codeline><highlight class="normal">applications<sp/>may<sp/>want<sp/>to<sp/>disable<sp/>compression<sp/>entirely,<sp/>but<sp/>should<sp/>only<sp/>do<sp/>so<sp/>if</highlight></codeline>
<codeline><highlight class="normal">benchmarks<sp/>show<sp/>a<sp/>performance<sp/>improvement:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.compression<sp/>=<sp/>leveldb::kNoCompression;</highlight></codeline>
<codeline><highlight class="normal">...<sp/>leveldb::DB::Open(options,<sp/>name,<sp/>...)<sp/>....</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Cache</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>contents<sp/>of<sp/>the<sp/>database<sp/>are<sp/>stored<sp/>in<sp/>a<sp/>set<sp/>of<sp/>files<sp/>in<sp/>the<sp/>filesystem<sp/>and</highlight></codeline>
<codeline><highlight class="normal">each<sp/>file<sp/>stores<sp/>a<sp/>sequence<sp/>of<sp/>compressed<sp/>blocks.<sp/>If<sp/>options.block_cache<sp/>is</highlight></codeline>
<codeline><highlight class="normal">non-NULL,<sp/>it<sp/>is<sp/>used<sp/>to<sp/>cache<sp/>frequently<sp/>used<sp/>uncompressed<sp/>block<sp/>contents.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;leveldb/cache.h&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">leveldb::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.block_cache<sp/>=<sp/>leveldb::NewLRUCache(100<sp/>*<sp/>1048576);<sp/><sp/>//<sp/>100MB<sp/>cache</highlight></codeline>
<codeline><highlight class="normal">leveldb::DB*<sp/>db;</highlight></codeline>
<codeline><highlight class="normal">leveldb::DB::Open(options,<sp/>name,<sp/>&amp;db);</highlight></codeline>
<codeline><highlight class="normal">...<sp/>use<sp/>the<sp/>db<sp/>...</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>db</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>options.block_cache;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>cache<sp/>holds<sp/>uncompressed<sp/>data,<sp/>and<sp/>therefore<sp/>it<sp/>should<sp/>be<sp/>sized</highlight></codeline>
<codeline><highlight class="normal">according<sp/>to<sp/>application<sp/>level<sp/>data<sp/>sizes,<sp/>without<sp/>any<sp/>reduction<sp/>from</highlight></codeline>
<codeline><highlight class="normal">compression.<sp/>(Caching<sp/>of<sp/>compressed<sp/>blocks<sp/>is<sp/>left<sp/>to<sp/>the<sp/>operating<sp/>system</highlight></codeline>
<codeline><highlight class="normal">buffer<sp/>cache,<sp/>or<sp/>any<sp/>custom<sp/>Env<sp/>implementation<sp/>provided<sp/>by<sp/>the<sp/>client.)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">When<sp/>performing<sp/>a<sp/>bulk<sp/>read,<sp/>the<sp/>application<sp/>may<sp/>wish<sp/>to<sp/>disable<sp/>caching<sp/>so<sp/>that</highlight></codeline>
<codeline><highlight class="normal">the<sp/>data<sp/>processed<sp/>by<sp/>the<sp/>bulk<sp/>read<sp/>does<sp/>not<sp/>end<sp/>up<sp/>displacing<sp/>most<sp/>of<sp/>the</highlight></codeline>
<codeline><highlight class="normal">cached<sp/>contents.<sp/>A<sp/>per-iterator<sp/>option<sp/>can<sp/>be<sp/>used<sp/>to<sp/>achieve<sp/>this:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::ReadOptions<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.fill_cache<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Iterator*<sp/>it<sp/>=<sp/>db-&gt;NewIterator(options);</highlight></codeline>
<codeline><highlight class="normal">for<sp/>(it-&gt;SeekToFirst();<sp/>it-&gt;Valid();<sp/>it-&gt;Next())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Key<sp/>Layout</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Note<sp/>that<sp/>the<sp/>unit<sp/>of<sp/>disk<sp/>transfer<sp/>and<sp/>caching<sp/>is<sp/>a<sp/>block.<sp/>Adjacent<sp/>keys</highlight></codeline>
<codeline><highlight class="normal">(according<sp/>to<sp/>the<sp/>database<sp/>sort<sp/>order)<sp/>will<sp/>usually<sp/>be<sp/>placed<sp/>in<sp/>the<sp/>same<sp/>block.</highlight></codeline>
<codeline><highlight class="normal">Therefore<sp/>the<sp/>application<sp/>can<sp/>improve<sp/>its<sp/>performance<sp/>by<sp/>placing<sp/>keys<sp/>that<sp/>are</highlight></codeline>
<codeline><highlight class="normal">accessed<sp/>together<sp/>near<sp/>each<sp/>other<sp/>and<sp/>placing<sp/>infrequently<sp/>used<sp/>keys<sp/>in<sp/>a</highlight></codeline>
<codeline><highlight class="normal">separate<sp/>region<sp/>of<sp/>the<sp/>key<sp/>space.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>suppose<sp/>we<sp/>are<sp/>implementing<sp/>a<sp/>simple<sp/>file<sp/>system<sp/>on<sp/>top<sp/>of<sp/>leveldb.</highlight></codeline>
<codeline><highlight class="normal">The<sp/>types<sp/>of<sp/>entries<sp/>we<sp/>might<sp/>wish<sp/>to<sp/>store<sp/>are:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>filename<sp/>-&gt;<sp/>permission-bits,<sp/>length,<sp/>list<sp/>of<sp/>file_block_ids</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>file_block_id<sp/>-&gt;<sp/>data</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">We<sp/>might<sp/>want<sp/>to<sp/>prefix<sp/>filename<sp/>keys<sp/>with<sp/>one<sp/>letter<sp/>(say<sp/>&apos;/&apos;)<sp/>and<sp/>the</highlight></codeline>
<codeline><highlight class="normal">`file_block_id`<sp/>keys<sp/>with<sp/>a<sp/>different<sp/>letter<sp/>(say<sp/>&apos;0&apos;)<sp/>so<sp/>that<sp/>scans<sp/>over<sp/>just</highlight></codeline>
<codeline><highlight class="normal">the<sp/>metadata<sp/>do<sp/>not<sp/>force<sp/>us<sp/>to<sp/>fetch<sp/>and<sp/>cache<sp/>bulky<sp/>file<sp/>contents.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">###<sp/>Filters</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Because<sp/>of<sp/>the<sp/>way<sp/>leveldb<sp/>data<sp/>is<sp/>organized<sp/>on<sp/>disk,<sp/>a<sp/>single<sp/>`Get()`<sp/>call<sp/>may</highlight></codeline>
<codeline><highlight class="normal">involve<sp/>multiple<sp/>reads<sp/>from<sp/>disk.<sp/>The<sp/>optional<sp/>FilterPolicy<sp/>mechanism<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal">used<sp/>to<sp/>reduce<sp/>the<sp/>number<sp/>of<sp/>disk<sp/>reads<sp/>substantially.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.filter_policy<sp/>=<sp/>NewBloomFilterPolicy(10);</highlight></codeline>
<codeline><highlight class="normal">leveldb::DB*<sp/>db;</highlight></codeline>
<codeline><highlight class="normal">leveldb::DB::Open(options,<sp/>&quot;/tmp/testdb&quot;,<sp/>&amp;db);</highlight></codeline>
<codeline><highlight class="normal">...<sp/>use<sp/>the<sp/>database<sp/>...</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>db;</highlight></codeline>
<codeline><highlight class="normal">delete<sp/>options.filter_policy;</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>preceding<sp/>code<sp/>associates<sp/>a<sp/>Bloom<sp/>filter<sp/>based<sp/>filtering<sp/>policy<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal">database.<sp/><sp/>Bloom<sp/>filter<sp/>based<sp/>filtering<sp/>relies<sp/>on<sp/>keeping<sp/>some<sp/>number<sp/>of<sp/>bits<sp/>of</highlight></codeline>
<codeline><highlight class="normal">data<sp/>in<sp/>memory<sp/>per<sp/>key<sp/>(in<sp/>this<sp/>case<sp/>10<sp/>bits<sp/>per<sp/>key<sp/>since<sp/>that<sp/>is<sp/>the<sp/>argument</highlight></codeline>
<codeline><highlight class="normal">we<sp/>passed<sp/>to<sp/>`NewBloomFilterPolicy`).<sp/>This<sp/>filter<sp/>will<sp/>reduce<sp/>the<sp/>number<sp/>of</highlight></codeline>
<codeline><highlight class="normal">unnecessary<sp/>disk<sp/>reads<sp/>needed<sp/>for<sp/>Get()<sp/>calls<sp/>by<sp/>a<sp/>factor<sp/>of<sp/>approximately</highlight></codeline>
<codeline><highlight class="normal">a<sp/>100.<sp/>Increasing<sp/>the<sp/>bits<sp/>per<sp/>key<sp/>will<sp/>lead<sp/>to<sp/>a<sp/>larger<sp/>reduction<sp/>at<sp/>the<sp/>cost</highlight></codeline>
<codeline><highlight class="normal">of<sp/>more<sp/>memory<sp/>usage.<sp/>We<sp/>recommend<sp/>that<sp/>applications<sp/>whose<sp/>working<sp/>set<sp/>does<sp/>not</highlight></codeline>
<codeline><highlight class="normal">fit<sp/>in<sp/>memory<sp/>and<sp/>that<sp/>do<sp/>a<sp/>lot<sp/>of<sp/>random<sp/>reads<sp/>set<sp/>a<sp/>filter<sp/>policy.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>you<sp/>are<sp/>using<sp/>a<sp/>custom<sp/>comparator,<sp/>you<sp/>should<sp/>ensure<sp/>that<sp/>the<sp/>filter<sp/>policy</highlight></codeline>
<codeline><highlight class="normal">you<sp/>are<sp/>using<sp/>is<sp/>compatible<sp/>with<sp/>your<sp/>comparator.<sp/>For<sp/>example,<sp/>consider<sp/>a</highlight></codeline>
<codeline><highlight class="normal">comparator<sp/>that<sp/>ignores<sp/>trailing<sp/>spaces<sp/>when<sp/>comparing<sp/>keys.</highlight></codeline>
<codeline><highlight class="normal">`NewBloomFilterPolicy`<sp/>must<sp/>not<sp/>be<sp/>used<sp/>with<sp/>such<sp/>a<sp/>comparator.<sp/>Instead,<sp/>the</highlight></codeline>
<codeline><highlight class="normal">application<sp/>should<sp/>provide<sp/>a<sp/>custom<sp/>filter<sp/>policy<sp/>that<sp/>also<sp/>ignores<sp/>trailing</highlight></codeline>
<codeline><highlight class="normal">spaces.<sp/>For<sp/>example:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">class<sp/>CustomFilterPolicy<sp/>:<sp/>public<sp/>leveldb::FilterPolicy<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>private:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>FilterPolicy*<sp/>builtin_policy_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CustomFilterPolicy()<sp/>:<sp/>builtin_policy_(NewBloomFilterPolicy(10))<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>~CustomFilterPolicy()<sp/>{<sp/>delete<sp/>builtin_policy_;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>char*<sp/>Name()<sp/>const<sp/>{<sp/>return<sp/>&quot;IgnoreTrailingSpacesFilter&quot;;<sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>void<sp/>CreateFilter(const<sp/>Slice*<sp/>keys,<sp/>int<sp/>n,<sp/>std::string*<sp/>dst)<sp/>const<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Use<sp/>builtin<sp/>bloom<sp/>filter<sp/>code<sp/>after<sp/>removing<sp/>trailing<sp/>spaces</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Slice&gt;<sp/>trimmed(n);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>trimmed[i]<sp/>=<sp/>RemoveTrailingSpaces(keys[i]);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>builtin_policy_-&gt;CreateFilter(&amp;trimmed[i],<sp/>n,<sp/>dst);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Advanced<sp/>applications<sp/>may<sp/>provide<sp/>a<sp/>filter<sp/>policy<sp/>that<sp/>does<sp/>not<sp/>use<sp/>a<sp/>bloom</highlight></codeline>
<codeline><highlight class="normal">filter<sp/>but<sp/>uses<sp/>some<sp/>other<sp/>mechanism<sp/>for<sp/>summarizing<sp/>a<sp/>set<sp/>of<sp/>keys.<sp/>See</highlight></codeline>
<codeline><highlight class="normal">`leveldb/filter_policy.h`<sp/>for<sp/>detail.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Checksums</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">leveldb<sp/>associates<sp/>checksums<sp/>with<sp/>all<sp/>data<sp/>it<sp/>stores<sp/>in<sp/>the<sp/>file<sp/>system.<sp/>There</highlight></codeline>
<codeline><highlight class="normal">are<sp/>two<sp/>separate<sp/>controls<sp/>provided<sp/>over<sp/>how<sp/>aggressively<sp/>these<sp/>checksums<sp/>are</highlight></codeline>
<codeline><highlight class="normal">verified:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`ReadOptions::verify_checksums`<sp/>may<sp/>be<sp/>set<sp/>to<sp/>true<sp/>to<sp/>force<sp/>checksum</highlight></codeline>
<codeline><highlight class="normal">verification<sp/>of<sp/>all<sp/>data<sp/>that<sp/>is<sp/>read<sp/>from<sp/>the<sp/>file<sp/>system<sp/>on<sp/>behalf<sp/>of<sp/>a</highlight></codeline>
<codeline><highlight class="normal">particular<sp/>read.<sp/><sp/>By<sp/>default,<sp/>no<sp/>such<sp/>verification<sp/>is<sp/>done.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">`Options::paranoid_checks`<sp/>may<sp/>be<sp/>set<sp/>to<sp/>true<sp/>before<sp/>opening<sp/>a<sp/>database<sp/>to<sp/>make</highlight></codeline>
<codeline><highlight class="normal">the<sp/>database<sp/>implementation<sp/>raise<sp/>an<sp/>error<sp/>as<sp/>soon<sp/>as<sp/>it<sp/>detects<sp/>an<sp/>internal</highlight></codeline>
<codeline><highlight class="normal">corruption.<sp/>Depending<sp/>on<sp/>which<sp/>portion<sp/>of<sp/>the<sp/>database<sp/>has<sp/>been<sp/>corrupted,<sp/>the</highlight></codeline>
<codeline><highlight class="normal">error<sp/>may<sp/>be<sp/>raised<sp/>when<sp/>the<sp/>database<sp/>is<sp/>opened,<sp/>or<sp/>later<sp/>by<sp/>another<sp/>database</highlight></codeline>
<codeline><highlight class="normal">operation.<sp/>By<sp/>default,<sp/>paranoid<sp/>checking<sp/>is<sp/>off<sp/>so<sp/>that<sp/>the<sp/>database<sp/>can<sp/>be<sp/>used</highlight></codeline>
<codeline><highlight class="normal">even<sp/>if<sp/>parts<sp/>of<sp/>its<sp/>persistent<sp/>storage<sp/>have<sp/>been<sp/>corrupted.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">If<sp/>a<sp/>database<sp/>is<sp/>corrupted<sp/>(perhaps<sp/>it<sp/>cannot<sp/>be<sp/>opened<sp/>when<sp/>paranoid<sp/>checking</highlight></codeline>
<codeline><highlight class="normal">is<sp/>turned<sp/>on),<sp/>the<sp/>`leveldb::RepairDB`<sp/>function<sp/>may<sp/>be<sp/>used<sp/>to<sp/>recover<sp/>as<sp/>much</highlight></codeline>
<codeline><highlight class="normal">of<sp/>the<sp/>data<sp/>as<sp/>possible</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Approximate<sp/>Sizes</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>`GetApproximateSizes`<sp/>method<sp/>can<sp/>used<sp/>to<sp/>get<sp/>the<sp/>approximate<sp/>number<sp/>of<sp/>bytes</highlight></codeline>
<codeline><highlight class="normal">of<sp/>file<sp/>system<sp/>space<sp/>used<sp/>by<sp/>one<sp/>or<sp/>more<sp/>key<sp/>ranges.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">leveldb::Range<sp/>ranges[2];</highlight></codeline>
<codeline><highlight class="normal">ranges[0]<sp/>=<sp/>leveldb::Range(&quot;a&quot;,<sp/>&quot;c&quot;);</highlight></codeline>
<codeline><highlight class="normal">ranges[1]<sp/>=<sp/>leveldb::Range(&quot;x&quot;,<sp/>&quot;z&quot;);</highlight></codeline>
<codeline><highlight class="normal">uint64_t<sp/>sizes[2];</highlight></codeline>
<codeline><highlight class="normal">leveldb::Status<sp/>s<sp/>=<sp/>db-&gt;GetApproximateSizes(ranges,<sp/>2,<sp/>sizes);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">The<sp/>preceding<sp/>call<sp/>will<sp/>set<sp/>`sizes[0]`<sp/>to<sp/>the<sp/>approximate<sp/>number<sp/>of<sp/>bytes<sp/>of</highlight></codeline>
<codeline><highlight class="normal">file<sp/>system<sp/>space<sp/>used<sp/>by<sp/>the<sp/>key<sp/>range<sp/>`[a..c)`<sp/>and<sp/>`sizes[1]`<sp/>to<sp/>the</highlight></codeline>
<codeline><highlight class="normal">approximate<sp/>number<sp/>of<sp/>bytes<sp/>used<sp/>by<sp/>the<sp/>key<sp/>range<sp/>`[x..z)`.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Environment</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">All<sp/>file<sp/>operations<sp/>(and<sp/>other<sp/>operating<sp/>system<sp/>calls)<sp/>issued<sp/>by<sp/>the<sp/>leveldb</highlight></codeline>
<codeline><highlight class="normal">implementation<sp/>are<sp/>routed<sp/>through<sp/>a<sp/>`leveldb::Env`<sp/>object.<sp/>Sophisticated<sp/>clients</highlight></codeline>
<codeline><highlight class="normal">may<sp/>wish<sp/>to<sp/>provide<sp/>their<sp/>own<sp/>Env<sp/>implementation<sp/>to<sp/>get<sp/>better<sp/>control.</highlight></codeline>
<codeline><highlight class="normal">For<sp/>example,<sp/>an<sp/>application<sp/>may<sp/>introduce<sp/>artificial<sp/>delays<sp/>in<sp/>the<sp/>file<sp/>IO</highlight></codeline>
<codeline><highlight class="normal">paths<sp/>to<sp/>limit<sp/>the<sp/>impact<sp/>of<sp/>leveldb<sp/>on<sp/>other<sp/>activities<sp/>in<sp/>the<sp/>system.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">```c++</highlight></codeline>
<codeline><highlight class="normal">class<sp/>SlowEnv<sp/>:<sp/>public<sp/>leveldb::Env<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...<sp/>implementation<sp/>of<sp/>the<sp/>Env<sp/>interface<sp/>...</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">SlowEnv<sp/>env;</highlight></codeline>
<codeline><highlight class="normal">leveldb::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.env<sp/>=<sp/>&amp;env;</highlight></codeline>
<codeline><highlight class="normal">Status<sp/>s<sp/>=<sp/>leveldb::DB::Open(options,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Porting</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">leveldb<sp/>may<sp/>be<sp/>ported<sp/>to<sp/>a<sp/>new<sp/>platform<sp/>by<sp/>providing<sp/>platform<sp/>specific</highlight></codeline>
<codeline><highlight class="normal">implementations<sp/>of<sp/>the<sp/>types/methods/functions<sp/>exported<sp/>by</highlight></codeline>
<codeline><highlight class="normal">`leveldb/port/port.h`.<sp/><sp/>See<sp/>`leveldb/port/port_example.h`<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">In<sp/>addition,<sp/>the<sp/>new<sp/>platform<sp/>may<sp/>need<sp/>a<sp/>new<sp/>default<sp/>`leveldb::Env`</highlight></codeline>
<codeline><highlight class="normal">implementation.<sp/><sp/>See<sp/>`leveldb/util/env_posix.h`<sp/>for<sp/>an<sp/>example.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">##<sp/>Other<sp/>Information</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Details<sp/>about<sp/>the<sp/>leveldb<sp/>implementation<sp/>may<sp/>be<sp/>found<sp/>in<sp/>the<sp/>following</highlight></codeline>
<codeline><highlight class="normal">documents:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">1.<sp/>[Implementation<sp/>notes](impl.md)</highlight></codeline>
<codeline><highlight class="normal">2.<sp/>[Format<sp/>of<sp/>an<sp/>immutable<sp/>Table<sp/>file](table_format.md)</highlight></codeline>
<codeline><highlight class="normal">3.<sp/>[Format<sp/>of<sp/>a<sp/>log<sp/>file](log_format.md)</highlight></codeline>
    </programlisting>
    <location file="src/leveldb/doc/index.md"/>
  </compounddef>
</doxygen>
