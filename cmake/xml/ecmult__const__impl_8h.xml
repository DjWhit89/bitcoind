<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="ecmult__const__impl_8h" kind="file" language="C++">
    <compoundname>ecmult_const_impl.h</compoundname>
    <includes refid="scalar_8h" local="yes">scalar.h</includes>
    <includes refid="group_8h" local="yes">group.h</includes>
    <includes refid="ecmult__const_8h" local="yes">ecmult_const.h</includes>
    <includes refid="ecmult__impl_8h" local="yes">ecmult_impl.h</includes>
    <includedby refid="ecdh_2main__impl_8h" local="yes">src/secp256k1/src/modules/ecdh/main_impl.h</includedby>
    <includedby refid="secp256k1_8c" local="yes">src/secp256k1/src/secp256k1.c</includedby>
    <incdepgraph>
      <node id="4">
        <label>../include/secp256k1.h</label>
        <link refid="secp256k1_8h"/>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>checkmem.h</label>
        <link refid="checkmem_8h"/>
      </node>
      <node id="32">
        <label>ecmult.h</label>
        <link refid="ecmult_8h"/>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="33" relation="include">
        </childnode>
      </node>
      <node id="30">
        <label>ecmult_const.h</label>
        <link refid="ecmult__const_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/secp256k1/src/ecmult_const_impl.h</label>
        <link refid="ecmult__const__impl_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="31" relation="include">
        </childnode>
      </node>
      <node id="31">
        <label>ecmult_impl.h</label>
        <link refid="ecmult__impl_8h"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
      </node>
      <node id="28">
        <label>field.h</label>
        <link refid="field_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="29">
        <label>field_5x52.h</label>
        <link refid="field__5x52_8h"/>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="27">
        <label>group.h</label>
        <link refid="group_8h"/>
        <childnode refid="28" relation="include">
        </childnode>
      </node>
      <node id="34">
        <label>precomputed_ecmult.h</label>
        <link refid="precomputed__ecmult_8h"/>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>scalar.h</label>
        <link refid="scalar_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
      </node>
      <node id="26">
        <label>scalar_4x64.h</label>
        <link refid="scalar__4x64_8h"/>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="33">
        <label>scratch.h</label>
        <link refid="scratch_8h"/>
      </node>
      <node id="3">
        <label>util.h</label>
        <link refid="secp256k1_2src_2util_8h"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="22" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
      </node>
      <node id="35">
        <label>util_local_visibility.h</label>
        <link refid="util__local__visibility_8h"/>
      </node>
      <node id="8">
        <label>span.h</label>
        <link refid="span_8h"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>string.h</label>
        <link refid="string_8h"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>array</label>
      </node>
      <node id="9">
        <label>cassert</label>
      </node>
      <node id="10">
        <label>cstddef</label>
      </node>
      <node id="15">
        <label>cstdint</label>
      </node>
      <node id="16">
        <label>cstring</label>
      </node>
      <node id="25">
        <label>limits.h</label>
      </node>
      <node id="17">
        <label>locale</label>
      </node>
      <node id="11">
        <label>span</label>
      </node>
      <node id="18">
        <label>sstream</label>
      </node>
      <node id="5">
        <label>stddef.h</label>
      </node>
      <node id="23">
        <label>stdint.h</label>
      </node>
      <node id="24">
        <label>stdio.h</label>
      </node>
      <node id="22">
        <label>stdlib.h</label>
      </node>
      <node id="19">
        <label>string</label>
      </node>
      <node id="20">
        <label>string_view</label>
      </node>
      <node id="12">
        <label>type_traits</label>
      </node>
      <node id="13">
        <label>utility</label>
      </node>
      <node id="21">
        <label>vector</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="4">
        <label>src/secp256k1/src/bench_ecmult.c</label>
        <link refid="bench__ecmult_8c"/>
      </node>
      <node id="5">
        <label>src/secp256k1/src/bench_internal.c</label>
        <link refid="bench__internal_8c"/>
      </node>
      <node id="1">
        <label>src/secp256k1/src/ecmult_const_impl.h</label>
        <link refid="ecmult__const__impl_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>src/secp256k1/src/modules/ecdh/main_impl.h</label>
        <link refid="ecdh_2main__impl_8h"/>
      </node>
      <node id="3">
        <label>src/secp256k1/src/secp256k1.c</label>
        <link refid="secp256k1_8c"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>src/secp256k1/src/tests.c</label>
        <link refid="tests_8c"/>
      </node>
      <node id="7">
        <label>src/secp256k1/src/tests_exhaustive.c</label>
        <link refid="tests__exhaustive_8c"/>
      </node>
    </invincdepgraph>
    <sectiondef kind="define">
      <memberdef kind="define" id="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" prot="public" static="no">
        <name>ECMULT_CONST_GROUP_SIZE</name>
        <initializer>5</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="30" column="11" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="30" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" prot="public" static="no">
        <name>ECMULT_CONST_TABLE_SIZE</name>
        <initializer>(1L &lt;&lt; (<ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref> - 1))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="33" column="9" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ecmult__const__impl_8h_1ae7062079987fc5243b359cd49335e6f3" prot="public" static="no">
        <name>ECMULT_CONST_GROUPS</name>
        <initializer>((129 + <ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref> - 1) / <ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="34" column="9" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ecmult__const__impl_8h_1af2037d3f314af9fccad6f061dbb0745b" prot="public" static="no">
        <name>ECMULT_CONST_BITS</name>
        <initializer>(<ref refid="ecmult__const__impl_8h_1ae7062079987fc5243b359cd49335e6f3" kindref="member">ECMULT_CONST_GROUPS</ref> * <ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="35" column="9" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ecmult__const__impl_8h_1ab6d58eec4c00b5b20c607d7b95c5d583" prot="public" static="no">
        <name>ECMULT_CONST_TABLE_GET_GE</name>
        <param><defname>r</defname></param>
        <param><defname>pre</defname></param>
        <param><defname>n</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="83" column="9" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="61" bodyend="81"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="ecmult__const__impl_8h_1a78a98cc89560295a2fd786fbf3e4b060" prot="public" static="yes" mutable="no">
        <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref></type>
        <definition>const secp256k1_scalar secp256k1_ecmult_const_K</definition>
        <argsstring></argsstring>
        <name>secp256k1_ecmult_const_K</name>
        <initializer>= <ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0xa4e88a7dul, 0xcb13034eul, 0xc2bdd6bful, 0x7c118d6bul, 0x589ae848ul, 0x26ba29e4ul, 0xb5c2c1dcul, 0xde9798d9ul)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="94" column="31" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="94" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="ecmult__const__impl_8h_1a4cc0d96bc221943d18602a91d6b5c2c1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_ecmult_const_odd_multiples_table_globalz</definition>
        <argsstring>(secp256k1_ge *pre, secp256k1_fe *globalz, const secp256k1_gej *a)</argsstring>
        <name>secp256k1_ecmult_const_odd_multiples_table_globalz</name>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>pre</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref> *</type>
          <declname>globalz</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref> *</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Fill a table &apos;pre&apos; with precomputed odd multiples of a.</para>
<para>The resulting point set is brought to a single constant Z denominator, stores the X and Y coordinates as ge points in pre, and stores the global Z in globalz.</para>
<para>&apos;pre&apos; must be an array of size ECMULT_CONST_TABLE_SIZE. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="44" column="13" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="44" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="ecmult__const__impl_8h_1a91d964b6d73b3bc6dbb913b4b2307288" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_ecmult_const</definition>
        <argsstring>(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q)</argsstring>
        <name>secp256k1_ecmult_const</name>
        <param>
          <type><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>q</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="102" column="13" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="102" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="ecmult__const__impl_8h_1a094fb53e0f752f58e49cba6ea167a779" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_ecmult_const_xonly</definition>
        <argsstring>(secp256k1_fe *r, const secp256k1_fe *n, const secp256k1_fe *d, const secp256k1_scalar *q, int known_on_curve)</argsstring>
        <name>secp256k1_ecmult_const_xonly</name>
        <param>
          <type><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref> *</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref> *</type>
          <declname>d</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>q</declname>
        </param>
        <param>
          <type>int</type>
          <declname>known_on_curve</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/src/ecmult_const_impl.h" line="248" column="12" bodyfile="src/secp256k1/src/ecmult_const_impl.h" bodystart="248" bodyend="377"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/***********************************************************************</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2015,<sp/>2022<sp/>Pieter<sp/>Wuille,<sp/>Andrew<sp/>Poelstra<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>Distributed<sp/>under<sp/>the<sp/>MIT<sp/>software<sp/>license,<sp/>see<sp/>the<sp/>accompanying<sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>file<sp/>COPYING<sp/>or<sp/>https://www.opensource.org/licenses/mit-license.php.*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>***********************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>SECP256K1_ECMULT_CONST_IMPL_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SECP256K1_ECMULT_CONST_IMPL_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="scalar_8h" kindref="compound">scalar.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="group_8h" kindref="compound">group.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__const_8h" kindref="compound">ecmult_const.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__impl_8h" kindref="compound">ecmult_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(EXHAUSTIVE_TEST_ORDER)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>We<sp/>need<sp/>2^ECMULT_CONST_GROUP_SIZE<sp/>-<sp/>1<sp/>to<sp/>be<sp/>less<sp/>than<sp/>EXHAUSTIVE_TEST_ORDER,<sp/>because</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*<sp/>the<sp/>tables<sp/>cannot<sp/>have<sp/>infinities<sp/>in<sp/>them<sp/>(this<sp/>breaks<sp/>the<sp/>effective-affine<sp/>technique&apos;s</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/>z-ratio<sp/>tracking)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>if<sp/>EXHAUSTIVE_TEST_ORDER<sp/>==<sp/>199</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/><sp/><sp/>define<sp/>ECMULT_CONST_GROUP_SIZE<sp/>4</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>elif<sp/>EXHAUSTIVE_TEST_ORDER<sp/>==<sp/>13</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/><sp/><sp/>define<sp/>ECMULT_CONST_GROUP_SIZE<sp/>3</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>elif<sp/>EXHAUSTIVE_TEST_ORDER<sp/>==<sp/>7</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/><sp/><sp/>define<sp/>ECMULT_CONST_GROUP_SIZE<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/><sp/><sp/>error<sp/>&quot;Unknown<sp/>EXHAUSTIVE_TEST_ORDER&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Group<sp/>size<sp/>4<sp/>or<sp/>5<sp/>appears<sp/>optimal.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30" refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>define<sp/>ECMULT_CONST_GROUP_SIZE<sp/>5</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight></codeline>
<codeline lineno="33" refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ECMULT_CONST_TABLE_SIZE<sp/>(1L<sp/>&lt;&lt;<sp/>(ECMULT_CONST_GROUP_SIZE<sp/>-<sp/>1))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="34" refid="ecmult__const__impl_8h_1ae7062079987fc5243b359cd49335e6f3" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ECMULT_CONST_GROUPS<sp/>((129<sp/>+<sp/>ECMULT_CONST_GROUP_SIZE<sp/>-<sp/>1)<sp/>/<sp/>ECMULT_CONST_GROUP_SIZE)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35" refid="ecmult__const__impl_8h_1af2037d3f314af9fccad6f061dbb0745b" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ECMULT_CONST_BITS<sp/>(ECMULT_CONST_GROUPS<sp/>*<sp/>ECMULT_CONST_GROUP_SIZE)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_ecmult_const_odd_multiples_table_globalz(<ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*pre,<sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>*globalz,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>*a)<sp/>{</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>zr[<ref refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" kindref="member">ECMULT_CONST_TABLE_SIZE</ref>];</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_odd_multiples_table(<ref refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" kindref="member">ECMULT_CONST_TABLE_SIZE</ref>,<sp/>pre,<sp/>zr,<sp/>globalz,<sp/>a);</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_table_set_globalz(<ref refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" kindref="member">ECMULT_CONST_TABLE_SIZE</ref>,<sp/>pre,<sp/>zr);</highlight></codeline>
<codeline lineno="49"><highlight class="normal">}</highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Given<sp/>a<sp/>table<sp/>&apos;pre&apos;<sp/>with<sp/>odd<sp/>multiples<sp/>of<sp/>a<sp/>point,<sp/>put<sp/>in<sp/>r<sp/>the<sp/>signed-bit<sp/>multiplication<sp/>of<sp/>n<sp/>with<sp/>that<sp/>point.</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="53"><highlight class="comment"><sp/>*<sp/>For<sp/>example,<sp/>if<sp/>ECMULT_CONST_GROUP_SIZE<sp/>is<sp/>4,<sp/>then<sp/>pre<sp/>is<sp/>expected<sp/>to<sp/>contain<sp/>8<sp/>entries:</highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>*<sp/>[1*P,<sp/>3*P,<sp/>5*P,<sp/>7*P,<sp/>9*P,<sp/>11*P,<sp/>13*P,<sp/>15*P].<sp/>n<sp/>is<sp/>then<sp/>expected<sp/>to<sp/>be<sp/>a<sp/>4-bit<sp/>integer<sp/>(range<sp/>0-15),<sp/>and<sp/>its</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/>*<sp/>bits<sp/>are<sp/>interpreted<sp/>as<sp/>signs<sp/>of<sp/>powers<sp/>of<sp/>two<sp/>to<sp/>look<sp/>up.</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/>*<sp/>For<sp/>example,<sp/>if<sp/>n=4,<sp/>which<sp/>is<sp/>0100<sp/>in<sp/>binary,<sp/>which<sp/>is<sp/>interpreted<sp/>as<sp/>[-<sp/>+<sp/>-<sp/>-],<sp/>so<sp/>the<sp/>looked<sp/>up<sp/>value<sp/>is</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/>*<sp/>[<sp/>-(2^3)<sp/>+<sp/>(2^2)<sp/>-<sp/>(2^1)<sp/>-<sp/>(2^0)<sp/>]*P<sp/>=<sp/>-7*P.<sp/>Every<sp/>valid<sp/>n<sp/>translates<sp/>to<sp/>an<sp/>odd<sp/>number<sp/>in<sp/>range<sp/>[-15,15],</highlight></codeline>
<codeline lineno="59"><highlight class="comment"><sp/>*<sp/>which<sp/>means<sp/>we<sp/>just<sp/>need<sp/>to<sp/>look<sp/>up<sp/>one<sp/>of<sp/>the<sp/>precomputed<sp/>values,<sp/>and<sp/>optionally<sp/>negate<sp/>it.</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61" refid="ecmult__const__impl_8h_1ab6d58eec4c00b5b20c607d7b95c5d583" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ECMULT_CONST_TABLE_GET_GE(r,pre,n)<sp/>do<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="62"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>m<sp/>=<sp/>0;<sp/>\</highlight></codeline>
<codeline lineno="63"><highlight class="preprocessor"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>If<sp/>the<sp/>top<sp/>bit<sp/>of<sp/>n<sp/>is<sp/>0,<sp/>we<sp/>want<sp/>the<sp/>negation.<sp/>*/</highlight><highlight class="preprocessor"><sp/>\</highlight></codeline>
<codeline lineno="64"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>volatile<sp/>unsigned<sp/>int<sp/>negative<sp/>=<sp/>((n)<sp/>&gt;&gt;<sp/>(ECMULT_CONST_GROUP_SIZE<sp/>-<sp/>1))<sp/>^<sp/>1;<sp/>\</highlight></codeline>
<codeline lineno="65"><highlight class="preprocessor"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Let<sp/>n[i]<sp/>be<sp/>the<sp/>i-th<sp/>bit<sp/>of<sp/>n,<sp/>then<sp/>the<sp/>index<sp/>is</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>sum(cnot(n[i])<sp/>*<sp/>2^i,<sp/>i=0..l-2)</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>where<sp/>cnot(b)<sp/>=<sp/>b<sp/>if<sp/>n[l-1]<sp/>=<sp/>1<sp/>and<sp/>1<sp/>-<sp/>b<sp/>otherwise.</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>For<sp/>example,<sp/>if<sp/>n<sp/>=<sp/>4,<sp/>in<sp/>binary<sp/>0100,<sp/>the<sp/>index<sp/>is<sp/>3,<sp/>in<sp/>binary<sp/>011.</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Proof:</highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>Let</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>x<sp/>=<sp/>sum((2*n[i]<sp/>-<sp/>1)*2^i,<sp/>i=0..l-1)</highlight></codeline>
<codeline lineno="73"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>2*sum(n[i]<sp/>*<sp/>2^i,<sp/>i=0..l-1)<sp/>-<sp/>2^l<sp/>+<sp/>1</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>be<sp/>the<sp/>value<sp/>represented<sp/>by<sp/>n.</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>The<sp/>index<sp/>is<sp/>(x<sp/>-<sp/>1)/2<sp/>if<sp/>x<sp/>&gt;<sp/>0<sp/>and<sp/>-(x<sp/>+<sp/>1)/2<sp/>otherwise.</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>Case<sp/>x<sp/>&gt;<sp/>0:</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n[l-1]<sp/>=<sp/>1</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>sum(n[i]<sp/>*<sp/>2^i,<sp/>i=0..l-1)<sp/>-<sp/>2^(l-1)</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>sum(n[i]<sp/>*<sp/>2^i,<sp/>i=0..l-2)</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>Case<sp/>x<sp/>&lt;=<sp/>0:</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>n[l-1]<sp/>=<sp/>0</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>-(2*sum(n[i]<sp/>*<sp/>2^i,<sp/>i=0..l-1)<sp/>-<sp/>2^l<sp/>+<sp/>2)/2</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>2^(l-1)<sp/>-<sp/>1<sp/>-<sp/>sum(n[i]<sp/>*<sp/>2^i,<sp/>i=0..l-1)</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>sum((1<sp/>-<sp/>n[i])<sp/>*<sp/>2^i,<sp/>i=0..l-2)</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="preprocessor"><sp/>\</highlight></codeline>
<codeline lineno="86"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>index<sp/>=<sp/>((unsigned<sp/>int)(-negative)<sp/>^<sp/>n)<sp/>&amp;<sp/>((1U<sp/>&lt;&lt;<sp/>(ECMULT_CONST_GROUP_SIZE<sp/>-<sp/>1))<sp/>-<sp/>1U);<sp/>\</highlight></codeline>
<codeline lineno="87"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>secp256k1_fe<sp/>neg_y;<sp/>\</highlight></codeline>
<codeline lineno="88"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>VERIFY_CHECK((n)<sp/>&lt;<sp/>(1U<sp/>&lt;&lt;<sp/>ECMULT_CONST_GROUP_SIZE));<sp/>\</highlight></codeline>
<codeline lineno="89"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>VERIFY_CHECK(index<sp/>&lt;<sp/>(1U<sp/>&lt;&lt;<sp/>(ECMULT_CONST_GROUP_SIZE<sp/>-<sp/>1)));<sp/>\</highlight></codeline>
<codeline lineno="90"><highlight class="preprocessor"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Unconditionally<sp/>set<sp/>r-&gt;x<sp/>=<sp/>(pre)[m].x.<sp/>r-&gt;y<sp/>=<sp/>(pre)[m].y.<sp/>because<sp/>it&apos;s<sp/>either<sp/>the<sp/>correct<sp/>one</highlight></codeline>
<codeline lineno="91"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>or<sp/>will<sp/>get<sp/>replaced<sp/>in<sp/>the<sp/>later<sp/>iterations,<sp/>this<sp/>is<sp/>needed<sp/>to<sp/>make<sp/>sure<sp/>`r`<sp/>is<sp/>initialized.<sp/>*/</highlight><highlight class="preprocessor"><sp/>\</highlight></codeline>
<codeline lineno="92"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>(r)-&gt;x<sp/>=<sp/>(pre)[m].x;<sp/>\</highlight></codeline>
<codeline lineno="93"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>(r)-&gt;y<sp/>=<sp/>(pre)[m].y;<sp/>\</highlight></codeline>
<codeline lineno="94"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>for<sp/>(m<sp/>=<sp/>1;<sp/>m<sp/>&lt;<sp/>ECMULT_CONST_TABLE_SIZE;<sp/>m++)<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="95"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>This<sp/>loop<sp/>is<sp/>used<sp/>to<sp/>avoid<sp/>secret<sp/>data<sp/>in<sp/>array<sp/>indices.<sp/>See</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>comment<sp/>in<sp/>ecmult_gen_impl.h<sp/>for<sp/>rationale.<sp/>*/</highlight><highlight class="preprocessor"><sp/>\</highlight></codeline>
<codeline lineno="97"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_cmov(&amp;(r)-&gt;x,<sp/>&amp;(pre)[m].x,<sp/>m<sp/>==<sp/>index);<sp/>\</highlight></codeline>
<codeline lineno="98"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_cmov(&amp;(r)-&gt;y,<sp/>&amp;(pre)[m].y,<sp/>m<sp/>==<sp/>index);<sp/>\</highlight></codeline>
<codeline lineno="99"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>}<sp/>\</highlight></codeline>
<codeline lineno="100"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>(r)-&gt;infinity<sp/>=<sp/>0;<sp/>\</highlight></codeline>
<codeline lineno="101"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>secp256k1_fe_negate(&amp;neg_y,<sp/>&amp;(r)-&gt;y,<sp/>1);<sp/>\</highlight></codeline>
<codeline lineno="102"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>secp256k1_fe_cmov(&amp;(r)-&gt;y,<sp/>&amp;neg_y,<sp/>negative);<sp/>\</highlight></codeline>
<codeline lineno="103"><highlight class="preprocessor">}<sp/>while(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>For<sp/>K<sp/>as<sp/>defined<sp/>in<sp/>the<sp/>comment<sp/>of<sp/>secp256k1_ecmult_const,<sp/>we<sp/>have<sp/>several<sp/>precomputed</highlight></codeline>
<codeline lineno="106"><highlight class="comment"><sp/>*<sp/>formulas/constants.</highlight></codeline>
<codeline lineno="107"><highlight class="comment"><sp/>*<sp/>-<sp/>in<sp/>exhaustive<sp/>test<sp/>mode,<sp/>we<sp/>give<sp/>an<sp/>explicit<sp/>expression<sp/>to<sp/>compute<sp/>it<sp/>at<sp/>compile<sp/>time:<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>EXHAUSTIVE_TEST_ORDER</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>secp256k1_ecmult_const_K<sp/>=<sp/>((<ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0,<sp/>0,<sp/>0,<sp/>(1U<sp/>&lt;&lt;<sp/>(<ref refid="ecmult__const__impl_8h_1af2037d3f314af9fccad6f061dbb0745b" kindref="member">ECMULT_CONST_BITS</ref><sp/>-<sp/>128))<sp/>-<sp/>2U,<sp/>0,<sp/>0,<sp/>0,<sp/>0)<sp/>+<sp/><ref refid="tests__exhaustive_8c_1aef79eeed489f1f87f86dbbef6f0cb41b" kindref="member">EXHAUSTIVE_TEST_ORDER</ref><sp/>-<sp/>1U)<sp/>*<sp/>(1U<sp/>+<sp/>EXHAUSTIVE_TEST_LAMBDA))<sp/>%<sp/><ref refid="tests__exhaustive_8c_1aef79eeed489f1f87f86dbbef6f0cb41b" kindref="member">EXHAUSTIVE_TEST_ORDER</ref>;</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>-<sp/>for<sp/>the<sp/>real<sp/>secp256k1<sp/>group<sp/>we<sp/>have<sp/>constants<sp/>for<sp/>various<sp/>ECMULT_CONST_BITS<sp/>values.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>ECMULT_CONST_BITS<sp/>==<sp/>129</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>For<sp/>GROUP_SIZE<sp/>=<sp/>1,3.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>secp256k1_ecmult_const_K<sp/>=<sp/><ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0xac9c52b3ul,<sp/>0x3fa3cf1ful,<sp/>0x5ad9e3fdul,<sp/>0x77ed9ba4ul,<sp/>0xa880b9fcul,<sp/>0x8ec739c2ul,<sp/>0xe0cfc810ul,<sp/>0xb51283ceul);</highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>ECMULT_CONST_BITS<sp/>==<sp/>130</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>For<sp/>GROUP_SIZE<sp/>=<sp/>2,5.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>secp256k1_ecmult_const_K<sp/>=<sp/><ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0xa4e88a7dul,<sp/>0xcb13034eul,<sp/>0xc2bdd6bful,<sp/>0x7c118d6bul,<sp/>0x589ae848ul,<sp/>0x26ba29e4ul,<sp/>0xb5c2c1dcul,<sp/>0xde9798d9ul);</highlight></codeline>
<codeline lineno="117"><highlight class="normal"></highlight><highlight class="preprocessor">#elif<sp/>ECMULT_CONST_BITS<sp/>==<sp/>132</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>For<sp/>GROUP_SIZE<sp/>=<sp/>4,6<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>secp256k1_ecmult_const_K<sp/>=<sp/><ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0x76b1d93dul,<sp/>0x0fae3c6bul,<sp/>0x3215874bul,<sp/>0x94e93813ul,<sp/>0x7937fe0dul,<sp/>0xb66bcaaful,<sp/>0xb3749ca5ul,<sp/>0xd7b6171bul);</highlight></codeline>
<codeline lineno="120"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/>error<sp/>&quot;Unknown<sp/>ECMULT_CONST_BITS&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_ecmult_const(<ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>*r,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*a,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>*q)<sp/>{</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>approach<sp/>below<sp/>combines<sp/>the<sp/>signed-digit<sp/>logic<sp/>from<sp/>Mike<sp/>Hamburg&apos;s</highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&quot;Fast<sp/>and<sp/>compact<sp/>elliptic-curve<sp/>cryptography&quot;<sp/>(https://eprint.iacr.org/2012/309)</highlight></codeline>
<codeline lineno="127"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Section<sp/>3.3,<sp/>with<sp/>the<sp/>GLV<sp/>endomorphism.</highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="129"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>The<sp/>idea<sp/>there<sp/>is<sp/>to<sp/>interpret<sp/>the<sp/>bits<sp/>of<sp/>a<sp/>scalar<sp/>as<sp/>signs<sp/>(1<sp/>=<sp/>+,<sp/>0<sp/>=<sp/>-),<sp/>and<sp/>compute<sp/>a</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>point<sp/>multiplication<sp/>in<sp/>that<sp/>fashion.<sp/>Let<sp/>v<sp/>be<sp/>an<sp/>n-bit<sp/>non-negative<sp/>integer<sp/>(0<sp/>&lt;=<sp/>v<sp/>&lt;<sp/>2^n),</highlight></codeline>
<codeline lineno="131"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>and<sp/>v[i]<sp/>its<sp/>i&apos;th<sp/>bit<sp/>(so<sp/>v<sp/>=<sp/>sum(v[i]<sp/>*<sp/>2^i,<sp/>i=0..n-1)).<sp/>Then<sp/>define:</highlight></codeline>
<codeline lineno="132"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="133"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>C_l(v,<sp/>A)<sp/>=<sp/>sum((2*v[i]<sp/>-<sp/>1)<sp/>*<sp/>2^i*A,<sp/>i=0..l-1)</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Then<sp/>it<sp/>holds<sp/>that<sp/>C_l(v,<sp/>A)<sp/>=<sp/>sum((2*v[i]<sp/>-<sp/>1)<sp/>*<sp/>2^i*A,<sp/>i=0..l-1)</highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(2*sum(v[i]<sp/>*<sp/>2^i,<sp/>i=0..l-1)<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>A</highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>(2*v<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>A</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Thus,<sp/>one<sp/>can<sp/>compute<sp/>q*A<sp/>as<sp/>C_256((q<sp/>+<sp/>2^256<sp/>-<sp/>1)<sp/>/<sp/>2,<sp/>A).<sp/>This<sp/>is<sp/>the<sp/>basis<sp/>for<sp/>the</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>paper&apos;s<sp/>signed-digit<sp/>multi-comb<sp/>algorithm<sp/>for<sp/>multiplication<sp/>using<sp/>a<sp/>precomputed<sp/>table.</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>It<sp/>is<sp/>appealing<sp/>to<sp/>try<sp/>to<sp/>combine<sp/>this<sp/>with<sp/>the<sp/>GLV<sp/>optimization:<sp/>the<sp/>idea<sp/>that<sp/>a<sp/>scalar</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>s<sp/>can<sp/>be<sp/>written<sp/>as<sp/>s1<sp/>+<sp/>lambda*s2,<sp/>where<sp/>lambda<sp/>is<sp/>a<sp/>curve-specific<sp/>constant<sp/>such<sp/>that</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>lambda*A<sp/>is<sp/>easy<sp/>to<sp/>compute,<sp/>and<sp/>where<sp/>s1<sp/>and<sp/>s2<sp/>are<sp/>small.<sp/>In<sp/>particular<sp/>we<sp/>have<sp/>the</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>secp256k1_scalar_split_lambda<sp/>function<sp/>which<sp/>performs<sp/>such<sp/>a<sp/>split<sp/>with<sp/>the<sp/>resulting<sp/>s1</highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>and<sp/>s2<sp/>in<sp/>range<sp/>(-2^128,<sp/>2^128)<sp/>mod<sp/>n.<sp/>This<sp/>does<sp/>work,<sp/>but<sp/>is<sp/>uninteresting:</highlight></codeline>
<codeline lineno="147"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>To<sp/>compute<sp/>q*A:</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>s1,<sp/>s2<sp/>=<sp/>split_lambda(q)</highlight></codeline>
<codeline lineno="150"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>R1<sp/>=<sp/>C_256((s1<sp/>+<sp/>2^256<sp/>-<sp/>1)<sp/>/<sp/>2,<sp/>A)</highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>R2<sp/>=<sp/>C_256((s2<sp/>+<sp/>2^256<sp/>-<sp/>1)<sp/>/<sp/>2,<sp/>lambda*A)</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Return<sp/>R1<sp/>+<sp/>R2</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>The<sp/>issue<sp/>is<sp/>that<sp/>while<sp/>s1<sp/>and<sp/>s2<sp/>are<sp/>small-range<sp/>numbers,<sp/>(s1<sp/>+<sp/>2^256<sp/>-<sp/>1)<sp/>/<sp/>2<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="155"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>and<sp/>(s2<sp/>+<sp/>2^256<sp/>-<sp/>1)<sp/>/<sp/>2<sp/>(mod<sp/>n)<sp/>are<sp/>not,<sp/>undoing<sp/>the<sp/>benefit<sp/>of<sp/>the<sp/>splitting.</highlight></codeline>
<codeline lineno="156"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="157"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>To<sp/>make<sp/>it<sp/>work,<sp/>we<sp/>want<sp/>to<sp/>modify<sp/>the<sp/>input<sp/>scalar<sp/>q<sp/>first,<sp/>before<sp/>splitting,<sp/>and<sp/>then<sp/>only</highlight></codeline>
<codeline lineno="158"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>add<sp/>a<sp/>2^128<sp/>offset<sp/>of<sp/>the<sp/>split<sp/>results<sp/>(so<sp/>that<sp/>they<sp/>end<sp/>up<sp/>in<sp/>the<sp/>single<sp/>129-bit<sp/>range</highlight></codeline>
<codeline lineno="159"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>[0,2^129]).<sp/>A<sp/>slightly<sp/>smaller<sp/>offset<sp/>would<sp/>work<sp/>due<sp/>to<sp/>the<sp/>bounds<sp/>on<sp/>the<sp/>split,<sp/>but<sp/>we<sp/>pick</highlight></codeline>
<codeline lineno="160"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>2^128<sp/>for<sp/>simplicity.<sp/>Let<sp/>s<sp/>be<sp/>the<sp/>scalar<sp/>fed<sp/>to<sp/>split_lambda,<sp/>and<sp/>f(q)<sp/>the<sp/>function<sp/>to</highlight></codeline>
<codeline lineno="161"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>compute<sp/>it<sp/>from<sp/>q:</highlight></codeline>
<codeline lineno="162"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="163"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>To<sp/>compute<sp/>q*A:</highlight></codeline>
<codeline lineno="164"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Compute<sp/>s<sp/>=<sp/>f(q)</highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>s1,<sp/>s2<sp/>=<sp/>split_lambda(s)</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>v1<sp/>=<sp/>s1<sp/>+<sp/>2^128<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>v2<sp/>=<sp/>s2<sp/>+<sp/>2^128<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>R1<sp/>=<sp/>C_l(v1,<sp/>A)</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Let<sp/>R2<sp/>=<sp/>C_l(v2,<sp/>lambda*A)</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>-<sp/>Return<sp/>R1<sp/>+<sp/>R2</highlight></codeline>
<codeline lineno="171"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="172"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>l<sp/>will<sp/>thus<sp/>need<sp/>to<sp/>be<sp/>at<sp/>least<sp/>129,<sp/>but<sp/>we<sp/>may<sp/>overshoot<sp/>by<sp/>a<sp/>few<sp/>bits<sp/>(see</highlight></codeline>
<codeline lineno="173"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>further),<sp/>so<sp/>keep<sp/>it<sp/>as<sp/>a<sp/>variable.</highlight></codeline>
<codeline lineno="174"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="175"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>To<sp/>solve<sp/>for<sp/>s,<sp/>we<sp/>reason:</highlight></codeline>
<codeline lineno="176"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>q*A<sp/><sp/>=<sp/>R1<sp/>+<sp/>R2</highlight></codeline>
<codeline lineno="177"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>q*A<sp/><sp/>=<sp/>C_l(s1<sp/>+<sp/>2^128,<sp/>A)<sp/>+<sp/>C_l(s2<sp/>+<sp/>2^128,<sp/>lambda*A)</highlight></codeline>
<codeline lineno="178"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>q*A<sp/><sp/>=<sp/>(2*(s1<sp/>+<sp/>2^128)<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>A<sp/>+<sp/>(2*(s2<sp/>+<sp/>2^128)<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>lambda*A</highlight></codeline>
<codeline lineno="179"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>q*A<sp/><sp/>=<sp/>(2*(s1<sp/>+<sp/>s2*lambda)<sp/>+<sp/>(2^129<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>(1<sp/>+<sp/>lambda))<sp/>*<sp/>A</highlight></codeline>
<codeline lineno="180"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>q<sp/><sp/><sp/><sp/>=<sp/>2*(s1<sp/>+<sp/>s2*lambda)<sp/>+<sp/>(2^129<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>(1<sp/>+<sp/>lambda)<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>q<sp/><sp/><sp/><sp/>=<sp/>2*s<sp/>+<sp/>(2^129<sp/>+<sp/>1<sp/>-<sp/>2^l)<sp/>*<sp/>(1<sp/>+<sp/>lambda)<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>s<sp/><sp/><sp/><sp/>=<sp/>(q<sp/>+<sp/>(2^l<sp/>-<sp/>2^129<sp/>-<sp/>1)<sp/>*<sp/>(1<sp/>+<sp/>lambda))<sp/>/<sp/>2<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="183"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>f(q)<sp/>=<sp/>(q<sp/>+<sp/>K)<sp/>/<sp/>2<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="184"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>where<sp/>K<sp/>=<sp/>(2^l<sp/>-<sp/>2^129<sp/>-<sp/>1)*(1<sp/>+<sp/>lambda)<sp/>(mod<sp/>n)</highlight></codeline>
<codeline lineno="185"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="186"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>We<sp/>will<sp/>process<sp/>the<sp/>computation<sp/>of<sp/>C_l(v1,<sp/>A)<sp/>and<sp/>C_l(v2,<sp/>lambda*A)<sp/>in<sp/>groups<sp/>of</highlight></codeline>
<codeline lineno="187"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>ECMULT_CONST_GROUP_SIZE,<sp/>so<sp/>we<sp/>set<sp/>l<sp/>to<sp/>the<sp/>smallest<sp/>multiple<sp/>of<sp/>ECMULT_CONST_GROUP_SIZE</highlight></codeline>
<codeline lineno="188"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>that<sp/>is<sp/>not<sp/>less<sp/>than<sp/>129;<sp/>this<sp/>equals<sp/>ECMULT_CONST_BITS.</highlight></codeline>
<codeline lineno="189"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>offset<sp/>to<sp/>add<sp/>to<sp/>s1<sp/>and<sp/>s2<sp/>to<sp/>make<sp/>them<sp/>non-negative.<sp/>Equal<sp/>to<sp/>2^128.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>S_OFFSET<sp/>=<sp/><ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0,<sp/>0,<sp/>0,<sp/>1,<sp/>0,<sp/>0,<sp/>0,<sp/>0);</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>s,<sp/>v1,<sp/>v2;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>pre_a[<ref refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" kindref="member">ECMULT_CONST_TABLE_SIZE</ref>];</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>pre_a_lam[<ref refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" kindref="member">ECMULT_CONST_TABLE_SIZE</ref>];</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>global_z;</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>group,<sp/>i;</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We&apos;re<sp/>allowed<sp/>to<sp/>be<sp/>non-constant<sp/>time<sp/>in<sp/>the<sp/>point,<sp/>and<sp/>the<sp/>code<sp/>below<sp/>(in<sp/>particular,</highlight></codeline>
<codeline lineno="200"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>secp256k1_ecmult_const_odd_multiples_table_globalz)<sp/>cannot<sp/>deal<sp/>with<sp/>infinity<sp/>in<sp/>a</highlight></codeline>
<codeline lineno="201"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>constant-time<sp/>manner<sp/>anyway.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_ge_is_infinity(a))<sp/>{</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_set_infinity(r);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>v1<sp/>and<sp/>v2.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_add(&amp;s,<sp/>q,<sp/>&amp;secp256k1_ecmult_const_K);</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_half(&amp;s,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_split_lambda(&amp;v1,<sp/>&amp;v2,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_add(&amp;v1,<sp/>&amp;v1,<sp/>&amp;S_OFFSET);</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_add(&amp;v2,<sp/>&amp;v2,<sp/>&amp;S_OFFSET);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>VERIFY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Verify<sp/>that<sp/>v1<sp/>and<sp/>v2<sp/>are<sp/>in<sp/>range<sp/>[0,<sp/>2^129-1].<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>129;<sp/>i<sp/>&lt;<sp/>256;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(secp256k1_scalar_get_bits_limb32(&amp;v1,<sp/>i,<sp/>1)<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(secp256k1_scalar_get_bits_limb32(&amp;v2,<sp/>i,<sp/>1)<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Calculate<sp/>odd<sp/>multiples<sp/>of<sp/>A<sp/>and<sp/>A*lambda.</highlight></codeline>
<codeline lineno="223"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>All<sp/>multiples<sp/>are<sp/>brought<sp/>to<sp/>the<sp/>same<sp/>Z<sp/>&apos;denominator&apos;,<sp/>which<sp/>is<sp/>stored</highlight></codeline>
<codeline lineno="224"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>in<sp/>global_z.<sp/>Due<sp/>to<sp/>secp256k1&apos;<sp/>isomorphism<sp/>we<sp/>can<sp/>do<sp/>all<sp/>operations<sp/>pretending</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>that<sp/>the<sp/>Z<sp/>coordinate<sp/>was<sp/>1,<sp/>use<sp/>affine<sp/>addition<sp/>formulae,<sp/>and<sp/>correct</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>Z<sp/>coordinate<sp/>of<sp/>the<sp/>result<sp/>once<sp/>at<sp/>the<sp/>end.</highlight></codeline>
<codeline lineno="227"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_gej_set_ge(r,<sp/>a);</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_const_odd_multiples_table_globalz(pre_a,<sp/>&amp;global_z,<sp/>r);</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/><ref refid="ecmult__const__impl_8h_1ab836af3cd15c7e154d4c6306ebf8c636" kindref="member">ECMULT_CONST_TABLE_SIZE</ref>;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ge_mul_lambda(&amp;pre_a_lam[i],<sp/>&amp;pre_a[i]);</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Next,<sp/>we<sp/>compute<sp/>r<sp/>=<sp/>C_l(v1,<sp/>A)<sp/>+<sp/>C_l(v2,<sp/>lambda*A).</highlight></codeline>
<codeline lineno="235"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="236"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>We<sp/>proceed<sp/>in<sp/>groups<sp/>of<sp/>ECMULT_CONST_GROUP_SIZE<sp/>bits,<sp/>operating<sp/>on<sp/>that<sp/>many<sp/>bits</highlight></codeline>
<codeline lineno="237"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>at<sp/>a<sp/>time,<sp/>from<sp/>high<sp/>in<sp/>v1,<sp/>v2<sp/>to<sp/>low.<sp/>Call<sp/>these<sp/>bits1<sp/>(from<sp/>v1)<sp/>and<sp/>bits2<sp/>(from<sp/>v2).</highlight></codeline>
<codeline lineno="238"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="239"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Now<sp/>note<sp/>that<sp/>ECMULT_CONST_TABLE_GET_GE(&amp;t,<sp/>pre_a,<sp/>bits1)<sp/>loads<sp/>into<sp/>t<sp/>a<sp/>point<sp/>equal</highlight></codeline>
<codeline lineno="240"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>to<sp/>C_{ECMULT_CONST_GROUP_SIZE}(bits1,<sp/>A),<sp/>and<sp/>analogously<sp/>for<sp/>pre_lam_a<sp/>/<sp/>bits2.</highlight></codeline>
<codeline lineno="241"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>This<sp/>means<sp/>that<sp/>all<sp/>we<sp/>need<sp/>to<sp/>do<sp/>is<sp/>add<sp/>these<sp/>looked<sp/>up<sp/>values<sp/>together,<sp/>multiplied</highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>by<sp/>2^(ECMULT_GROUP_SIZE<sp/>*<sp/>group).</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(group<sp/>=<sp/><ref refid="ecmult__const__impl_8h_1ae7062079987fc5243b359cd49335e6f3" kindref="member">ECMULT_CONST_GROUPS</ref><sp/>-<sp/>1;<sp/><ref refid="namespacetests__wycheproof__generate__ecdsa_1a0f9123af540f084d1c0421dccc31e1dd" kindref="member">group</ref><sp/>&gt;=<sp/>0;<sp/>--<ref refid="namespacetests__wycheproof__generate__ecdsa_1a0f9123af540f084d1c0421dccc31e1dd" kindref="member">group</ref>)<sp/>{</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Using<sp/>the<sp/>_var<sp/>get_bits<sp/>function<sp/>is<sp/>ok<sp/>here,<sp/>since<sp/>it&apos;s<sp/>only<sp/>variable<sp/>in<sp/>offset<sp/>and<sp/>count,<sp/>not<sp/>in<sp/>the<sp/>scalar.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bits1<sp/>=<sp/>secp256k1_scalar_get_bits_var(&amp;v1,<sp/>group<sp/>*<sp/><ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>,<sp/><ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>bits2<sp/>=<sp/>secp256k1_scalar_get_bits_var(&amp;v2,<sp/>group<sp/>*<sp/><ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>,<sp/><ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>);</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/><ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e" kindref="member">t</ref>;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j;</highlight></codeline>
<codeline lineno="250"><highlight class="normal"></highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="ecmult__const__impl_8h_1ab6d58eec4c00b5b20c607d7b95c5d583" kindref="member">ECMULT_CONST_TABLE_GET_GE</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e" kindref="member">t</ref>,<sp/>pre_a,<sp/>bits1);</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(group<sp/>==<sp/><ref refid="ecmult__const__impl_8h_1ae7062079987fc5243b359cd49335e6f3" kindref="member">ECMULT_CONST_GROUPS</ref><sp/>-<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Directly<sp/>set<sp/>r<sp/>in<sp/>the<sp/>first<sp/>iteration.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_set_ge(r,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e" kindref="member">t</ref>);</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Shift<sp/>the<sp/>result<sp/>so<sp/>far<sp/>up.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/><ref refid="ecmult__const__impl_8h_1a78bc41ab5f3fc5e2475c41631a645c41" kindref="member">ECMULT_CONST_GROUP_SIZE</ref>;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_double(r,<sp/>r);</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_add_ge(r,<sp/>r,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e" kindref="member">t</ref>);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="ecmult__const__impl_8h_1ab6d58eec4c00b5b20c607d7b95c5d583" kindref="member">ECMULT_CONST_TABLE_GET_GE</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e" kindref="member">t</ref>,<sp/>pre_a_lam,<sp/>bits2);</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_add_ge(r,<sp/>r,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e" kindref="member">t</ref>);</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Map<sp/>the<sp/>result<sp/>back<sp/>to<sp/>the<sp/>secp256k1<sp/>curve<sp/>from<sp/>the<sp/>isomorphic<sp/>curve.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;r-&gt;<ref refid="structsecp256k1__gej_1a761e4ae44d26ee28461beeaf09a26218" kindref="member">z</ref>,<sp/>&amp;r-&gt;<ref refid="structsecp256k1__gej_1a761e4ae44d26ee28461beeaf09a26218" kindref="member">z</ref>,<sp/>&amp;global_z);</highlight></codeline>
<codeline lineno="268"><highlight class="normal">}</highlight></codeline>
<codeline lineno="269"><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_ecmult_const_xonly(<ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref>*<sp/>r,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>*n,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>*d,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>*q,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>known_on_curve)<sp/>{</highlight></codeline>
<codeline lineno="271"><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>This<sp/>algorithm<sp/>is<sp/>a<sp/>generalization<sp/>of<sp/>Peter<sp/>Dettman&apos;s<sp/>technique<sp/>for</highlight></codeline>
<codeline lineno="273"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>avoiding<sp/>the<sp/>square<sp/>root<sp/>in<sp/>a<sp/>random-basepoint<sp/>x-only<sp/>multiplication</highlight></codeline>
<codeline lineno="274"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>on<sp/>a<sp/>Weierstrass<sp/>curve:</highlight></codeline>
<codeline lineno="275"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>https://mailarchive.ietf.org/arch/msg/cfrg/7DyYY6gg32wDgHAhgSb6XxMDlJA/</highlight></codeline>
<codeline lineno="276"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="277"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="278"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>===<sp/>Background:<sp/>the<sp/>effective<sp/>affine<sp/>technique<sp/>===</highlight></codeline>
<codeline lineno="279"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="280"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Let<sp/>phi_u<sp/>be<sp/>the<sp/>isomorphism<sp/>that<sp/>maps<sp/>(x,<sp/>y)<sp/>on<sp/>secp256k1<sp/>curve<sp/>y^2<sp/>=<sp/>x^3<sp/>+<sp/>7<sp/>to</highlight></codeline>
<codeline lineno="281"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>x&apos;<sp/>=<sp/>u^2*x,<sp/>y&apos;<sp/>=<sp/>u^3*y<sp/>on<sp/>curve<sp/>y&apos;^2<sp/>=<sp/>x&apos;^3<sp/>+<sp/>u^6*7.<sp/>This<sp/>new<sp/>curve<sp/>has<sp/>the<sp/>same<sp/>order<sp/>as</highlight></codeline>
<codeline lineno="282"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>original<sp/>(it<sp/>is<sp/>isomorphic),<sp/>but<sp/>moreover,<sp/>has<sp/>the<sp/>same<sp/>addition/doubling<sp/>formulas,<sp/>as</highlight></codeline>
<codeline lineno="283"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>curve<sp/>b=7<sp/>coefficient<sp/>does<sp/>not<sp/>appear<sp/>in<sp/>those<sp/>formulas<sp/>(or<sp/>at<sp/>least<sp/>does<sp/>not<sp/>appear<sp/>in</highlight></codeline>
<codeline lineno="284"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>formulas<sp/>implemented<sp/>in<sp/>this<sp/>codebase,<sp/>both<sp/>affine<sp/>and<sp/>Jacobian).<sp/>See<sp/>also<sp/>Example<sp/>9.5.2</highlight></codeline>
<codeline lineno="285"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>in<sp/>https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch9.pdf.</highlight></codeline>
<codeline lineno="286"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="287"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>This<sp/>means<sp/>any<sp/>linear<sp/>combination<sp/>of<sp/>secp256k1<sp/>points<sp/>can<sp/>be<sp/>computed<sp/>by<sp/>applying<sp/>phi_u</highlight></codeline>
<codeline lineno="288"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>(with<sp/>non-zero<sp/>u)<sp/>on<sp/>all<sp/>input<sp/>points<sp/>(including<sp/>the<sp/>generator,<sp/>if<sp/>used),<sp/>computing<sp/>the</highlight></codeline>
<codeline lineno="289"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>linear<sp/>combination<sp/>on<sp/>the<sp/>isomorphic<sp/>curve<sp/>(using<sp/>the<sp/>same<sp/>group<sp/>laws),<sp/>and<sp/>then<sp/>applying</highlight></codeline>
<codeline lineno="290"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>phi_u^{-1}<sp/>to<sp/>get<sp/>back<sp/>to<sp/>secp256k1.</highlight></codeline>
<codeline lineno="291"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="292"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Switching<sp/>to<sp/>Jacobian<sp/>coordinates,<sp/>note<sp/>that<sp/>phi_u<sp/>applied<sp/>to<sp/>(X,<sp/>Y,<sp/>Z)<sp/>is<sp/>simply</highlight></codeline>
<codeline lineno="293"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>(X,<sp/>Y,<sp/>Z/u).<sp/>Thus,<sp/>if<sp/>we<sp/>want<sp/>to<sp/>compute<sp/>(X1,<sp/>Y1,<sp/>Z)<sp/>+<sp/>(X2,<sp/>Y2,<sp/>Z),<sp/>with<sp/>identical<sp/>Z</highlight></codeline>
<codeline lineno="294"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>coordinates,<sp/>we<sp/>can<sp/>use<sp/>phi_Z<sp/>to<sp/>transform<sp/>it<sp/>to<sp/>(X1,<sp/>Y1,<sp/>1)<sp/>+<sp/>(X2,<sp/>Y2,<sp/>1)<sp/>on<sp/>an<sp/>isomorphic</highlight></codeline>
<codeline lineno="295"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>curve<sp/>where<sp/>the<sp/>affine<sp/>addition<sp/>formula<sp/>can<sp/>be<sp/>used<sp/>instead.</highlight></codeline>
<codeline lineno="296"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>If<sp/>(X3,<sp/>Y3,<sp/>Z3)<sp/>=<sp/>(X1,<sp/>Y1)<sp/>+<sp/>(X2,<sp/>Y2)<sp/>on<sp/>that<sp/>curve,<sp/>then<sp/>our<sp/>answer<sp/>on<sp/>secp256k1<sp/>is</highlight></codeline>
<codeline lineno="297"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>(X3,<sp/>Y3,<sp/>Z3*Z).</highlight></codeline>
<codeline lineno="298"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="299"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>This<sp/>is<sp/>the<sp/>effective<sp/>affine<sp/>technique:<sp/>if<sp/>we<sp/>have<sp/>a<sp/>linear<sp/>combination<sp/>of<sp/>group<sp/>elements</highlight></codeline>
<codeline lineno="300"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>to<sp/>compute,<sp/>and<sp/>all<sp/>those<sp/>group<sp/>elements<sp/>have<sp/>the<sp/>same<sp/>Z<sp/>coordinate,<sp/>we<sp/>can<sp/>simply<sp/>pretend</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>that<sp/>all<sp/>those<sp/>Z<sp/>coordinates<sp/>are<sp/>1,<sp/>perform<sp/>the<sp/>computation<sp/>that<sp/>way,<sp/>and<sp/>then<sp/>multiply<sp/>the</highlight></codeline>
<codeline lineno="302"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>original<sp/>Z<sp/>coordinate<sp/>back<sp/>in.</highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>The<sp/>technique<sp/>works<sp/>on<sp/>any<sp/>a=0<sp/>short<sp/>Weierstrass<sp/>curve.<sp/>It<sp/>is<sp/>possible<sp/>to<sp/>generalize<sp/>it<sp/>to</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>other<sp/>curves<sp/>too,<sp/>but<sp/>there<sp/>the<sp/>isomorphic<sp/>curves<sp/>will<sp/>have<sp/>different<sp/>&apos;a&apos;<sp/>coefficients,</highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>which<sp/>typically<sp/>does<sp/>affect<sp/>the<sp/>group<sp/>laws.</highlight></codeline>
<codeline lineno="307"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="309"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>===<sp/>Avoiding<sp/>the<sp/>square<sp/>root<sp/>for<sp/>x-only<sp/>point<sp/>multiplication<sp/>===</highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="311"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>In<sp/>this<sp/>function,<sp/>we<sp/>want<sp/>to<sp/>compute<sp/>the<sp/>X<sp/>coordinate<sp/>of<sp/>q*(n/d,<sp/>y),<sp/>for</highlight></codeline>
<codeline lineno="312"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>y<sp/>=<sp/>sqrt((n/d)^3<sp/>+<sp/>7).<sp/>Its<sp/>negation<sp/>would<sp/>also<sp/>be<sp/>a<sp/>valid<sp/>Y<sp/>coordinate,<sp/>but<sp/>by<sp/>convention</highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>we<sp/>pick<sp/>whatever<sp/>sqrt<sp/>returns<sp/>(which<sp/>we<sp/>assume<sp/>to<sp/>be<sp/>a<sp/>deterministic<sp/>function).</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="315"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Let<sp/>g<sp/>=<sp/>y^2*d^3<sp/>=<sp/>n^3<sp/>+<sp/>7*d^3.<sp/>This<sp/>also<sp/>means<sp/>y<sp/>=<sp/>sqrt(g/d^3).</highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Further<sp/>let<sp/>v<sp/>=<sp/>sqrt(d*g),<sp/>which<sp/>must<sp/>exist<sp/>as<sp/>d*g<sp/>=<sp/>y^2*d^4<sp/>=<sp/>(y*d^2)^2.</highlight></codeline>
<codeline lineno="317"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="318"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>The<sp/>input<sp/>point<sp/>(n/d,<sp/>y)<sp/>also<sp/>has<sp/>Jacobian<sp/>coordinates:</highlight></codeline>
<codeline lineno="319"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="320"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>(n/d,<sp/>y,<sp/>1)</highlight></codeline>
<codeline lineno="321"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>=<sp/>(n/d<sp/>*<sp/>v^2,<sp/>y<sp/>*<sp/>v^3,<sp/>v)</highlight></codeline>
<codeline lineno="322"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>=<sp/>(n/d<sp/>*<sp/>d*g,<sp/>y<sp/>*<sp/>sqrt(d^3*g^3),<sp/>v)</highlight></codeline>
<codeline lineno="323"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>=<sp/>(n/d<sp/>*<sp/>d*g,<sp/>sqrt(y^2<sp/>*<sp/>d^3*g^3),<sp/>v)</highlight></codeline>
<codeline lineno="324"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>=<sp/>(n*g,<sp/>sqrt(g/d^3<sp/>*<sp/>d^3*g^3),<sp/>v)</highlight></codeline>
<codeline lineno="325"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>=<sp/>(n*g,<sp/>sqrt(g^4),<sp/>v)</highlight></codeline>
<codeline lineno="326"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/>=<sp/>(n*g,<sp/>g^2,<sp/>v)</highlight></codeline>
<codeline lineno="327"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="328"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>It<sp/>is<sp/>easy<sp/>to<sp/>verify<sp/>that<sp/>both<sp/>(n*g,<sp/>g^2,<sp/>v)<sp/>and<sp/>its<sp/>negation<sp/>(n*g,<sp/>-g^2,<sp/>v)<sp/>have<sp/>affine<sp/>X</highlight></codeline>
<codeline lineno="329"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>coordinate<sp/>n/d,<sp/>and<sp/>this<sp/>holds<sp/>even<sp/>when<sp/>the<sp/>square<sp/>root<sp/>function<sp/>doesn&apos;t<sp/>have<sp/>a</highlight></codeline>
<codeline lineno="330"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>deterministic<sp/>sign.<sp/>We<sp/>choose<sp/>the<sp/>(n*g,<sp/>g^2,<sp/>v)<sp/>version.</highlight></codeline>
<codeline lineno="331"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="332"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Now<sp/>switch<sp/>to<sp/>the<sp/>effective<sp/>affine<sp/>curve<sp/>using<sp/>phi_v,<sp/>where<sp/>the<sp/>input<sp/>point<sp/>has<sp/>coordinates</highlight></codeline>
<codeline lineno="333"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>(n*g,<sp/>g^2).<sp/>Compute<sp/>(X,<sp/>Y,<sp/>Z)<sp/>=<sp/>q<sp/>*<sp/>(n*g,<sp/>g^2)<sp/>there.</highlight></codeline>
<codeline lineno="334"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="335"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Back<sp/>on<sp/>secp256k1,<sp/>that<sp/>means<sp/>q<sp/>*<sp/>(n*g,<sp/>g^2,<sp/>v)<sp/>=<sp/>(X,<sp/>Y,<sp/>v*Z).<sp/>This<sp/>last<sp/>point<sp/>has<sp/>affine<sp/>X</highlight></codeline>
<codeline lineno="336"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>coordinate<sp/>X<sp/>/<sp/>(v^2*Z^2)<sp/>=<sp/>X<sp/>/<sp/>(d*g*Z^2).<sp/>Determining<sp/>the<sp/>affine<sp/>Y<sp/>coordinate<sp/>would<sp/>involve</highlight></codeline>
<codeline lineno="337"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>a<sp/>square<sp/>root,<sp/>but<sp/>as<sp/>long<sp/>as<sp/>we<sp/>only<sp/>care<sp/>about<sp/>the<sp/>resulting<sp/>X<sp/>coordinate,<sp/>no<sp/>square<sp/>root</highlight></codeline>
<codeline lineno="338"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>is<sp/>needed<sp/>anywhere<sp/>in<sp/>this<sp/>computation.</highlight></codeline>
<codeline lineno="339"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="340"><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/><ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>i;</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>rj;</highlight></codeline>
<codeline lineno="344"><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>g<sp/>=<sp/>(n^3<sp/>+<sp/>B*d^3).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1ad9dea8392967835e0e925f808c0e563f" kindref="member">secp256k1_fe_sqr</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>n);</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>n);</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d)<sp/>{</highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>b;</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(!<ref refid="field_8h_1ad12797531a53ba4d5d5a613ae4bfa980" kindref="member">secp256k1_fe_normalizes_to_zero</ref>(d));</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="field_8h_1ad9dea8392967835e0e925f808c0e563f" kindref="member">secp256k1_fe_sqr</ref>(&amp;b,<sp/>d);</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(<ref refid="group__impl_8h_1a6ac7906b0db18f65df2909faefce2416" kindref="member">SECP256K1_B</ref><sp/>&lt;=<sp/>8);<sp/></highlight><highlight class="comment">/*<sp/>magnitude<sp/>of<sp/>b<sp/>will<sp/>be<sp/>&lt;=<sp/>8<sp/>after<sp/>the<sp/>next<sp/>call<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="field_8h_1a1b53120e78e87f77227520c8a8d15245" kindref="member">secp256k1_fe_mul_int</ref>(&amp;b,<sp/><ref refid="group__impl_8h_1a6ac7906b0db18f65df2909faefce2416" kindref="member">SECP256K1_B</ref>);</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;b,<sp/>&amp;b,<sp/>d);</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="field_8h_1a781758016240ae593998306356388ab0" kindref="member">secp256k1_fe_add</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>&amp;b);</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!known_on_curve)<sp/>{</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>need<sp/>to<sp/>determine<sp/>whether<sp/>(n/d)^3<sp/>+<sp/>7<sp/>is<sp/>square.</highlight></codeline>
<codeline lineno="358"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="359"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/><sp/><sp/><sp/>is_square((n/d)^3<sp/>+<sp/>7)</highlight></codeline>
<codeline lineno="360"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>is_square(((n/d)^3<sp/>+<sp/>7)<sp/>*<sp/>d^4)</highlight></codeline>
<codeline lineno="361"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>is_square((n^3<sp/>+<sp/>7*d^3)<sp/>*<sp/>d)</highlight></codeline>
<codeline lineno="362"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>&lt;=&gt;<sp/>is_square(g<sp/>*<sp/>d)</highlight></codeline>
<codeline lineno="363"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>c;</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;c,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>d);</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="field_8h_1ab4f8ed33ded868148c61ae3f0027e807" kindref="member">secp256k1_fe_is_square_var</ref>(&amp;c))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="field_8h_1af1125dec014cc84f3f62cbed8be95fc8" kindref="member">secp256k1_fe_add_int</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/><ref refid="group__impl_8h_1a6ac7906b0db18f65df2909faefce2416" kindref="member">SECP256K1_B</ref>);</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!known_on_curve)<sp/>{</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>g<sp/>at<sp/>this<sp/>point<sp/>equals<sp/>x^3<sp/>+<sp/>7.<sp/>Test<sp/>if<sp/>it<sp/>is<sp/>square.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!<ref refid="field_8h_1ab4f8ed33ded868148c61ae3f0027e807" kindref="member">secp256k1_fe_is_square_var</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="375"><highlight class="normal"></highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1a5e5856d39a6132445e39d6b8db2e6c20" kindref="member">SECP256K1_FE_VERIFY_MAGNITUDE</ref>(&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>2);</highlight></codeline>
<codeline lineno="377"><highlight class="normal"></highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>base<sp/>point<sp/>P<sp/>=<sp/>(n*g,<sp/>g^2),<sp/>the<sp/>effective<sp/>affine<sp/>version<sp/>of<sp/>(n*g,<sp/>g^2,<sp/>v),<sp/>which<sp/>has</highlight></codeline>
<codeline lineno="379"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>corresponding<sp/>affine<sp/>X<sp/>coordinate<sp/>n/d.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;p.<ref refid="structsecp256k1__ge_1af089d748d95dc12c1185adae8e11972d" kindref="member">x</ref>,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>,<sp/>n);</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1ad9dea8392967835e0e925f808c0e563f" kindref="member">secp256k1_fe_sqr</ref>(&amp;p.<ref refid="structsecp256k1__ge_1a8ab8d07fa557181528b86bd1c9bb2b92" kindref="member">y</ref>,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>);</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/>p.<ref refid="structsecp256k1__ge_1a652f88fb6bac77f1882023c1410e84d3" kindref="member">infinity</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="383"><highlight class="normal"></highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Perform<sp/>x-only<sp/>EC<sp/>multiplication<sp/>of<sp/>P<sp/>with<sp/>q.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(!secp256k1_scalar_is_zero(q));</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_const(&amp;rj,<sp/>&amp;p,<sp/>q);</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(!secp256k1_gej_is_infinity(&amp;rj));</highlight></codeline>
<codeline lineno="388"><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>resulting<sp/>(X,<sp/>Y,<sp/>Z)<sp/>point<sp/>on<sp/>the<sp/>effective-affine<sp/>isomorphic<sp/>curve<sp/>corresponds<sp/>to</highlight></codeline>
<codeline lineno="390"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>(X,<sp/>Y,<sp/>Z*v)<sp/>on<sp/>the<sp/>secp256k1<sp/>curve.<sp/>The<sp/>affine<sp/>version<sp/>of<sp/>that<sp/>has<sp/>X<sp/>coordinate</highlight></codeline>
<codeline lineno="391"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>(X<sp/>/<sp/>(Z^2*d*g)).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1ad9dea8392967835e0e925f808c0e563f" kindref="member">secp256k1_fe_sqr</ref>(&amp;i,<sp/>&amp;rj.<ref refid="structsecp256k1__gej_1a761e4ae44d26ee28461beeaf09a26218" kindref="member">z</ref>);</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;i,<sp/>&amp;i,<sp/>&amp;<ref refid="strencodings_8h_1a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d" kindref="member">g</ref>);</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d)<sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(&amp;i,<sp/>&amp;i,<sp/>d);</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1ad5bf02734f048dcf570404d8a16eadcd" kindref="member">secp256k1_fe_inv</ref>(&amp;i,<sp/>&amp;i);</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="field_8h_1a60271f91746f3029ea2cac2ec2e37b36" kindref="member">secp256k1_fe_mul</ref>(r,<sp/>&amp;rj.<ref refid="structsecp256k1__gej_1af089d748d95dc12c1185adae8e11972d" kindref="member">x</ref>,<sp/>&amp;i);</highlight></codeline>
<codeline lineno="397"><highlight class="normal"></highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="399"><highlight class="normal">}</highlight></codeline>
<codeline lineno="400"><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>SECP256K1_ECMULT_CONST_IMPL_H<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="src/secp256k1/src/ecmult_const_impl.h"/>
  </compounddef>
</doxygen>
