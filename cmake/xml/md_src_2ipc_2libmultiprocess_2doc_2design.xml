<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="md_src_2ipc_2libmultiprocess_2doc_2design" kind="page">
    <compoundname>md_src_2ipc_2libmultiprocess_2doc_2design</compoundname>
    <title>libmultiprocess Design</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><anchor id="md_src_2ipc_2libmultiprocess_2doc_2design_1autotoc_md14"/></para>
<para>Given an interface description of an object with one or more methods, libmultiprocess generates:</para>
<para><itemizedlist>
<listitem><para>A C++ <computeroutput>ProxyClient</computeroutput> class template specialization with an implementation of each interface method that sends a request over a socket, waits for a response, and returns the result.</para>
</listitem><listitem><para>A C++ <computeroutput>ProxyServer</computeroutput> class template specialization that listens for requests over a socket and calls a wrapped C++ object implementing the same interface to actually execute the requests.</para>
</listitem></itemizedlist>
</para>
<para>The function call â‡† request translation supports input and output arguments, standard types like <computeroutput>unique_ptr</computeroutput>, <computeroutput>vector</computeroutput>, <computeroutput>map</computeroutput>, and <computeroutput>optional</computeroutput>, and bidirectional calls between processes through interface pointer and <computeroutput>std::function</computeroutput> arguments.</para>
<para>If the wrapped C++ object inherits from an abstract base class declaring virtual methods, the generated <computeroutput>ProxyClient</computeroutput> objects can inherit from the same class, allowing interprocess calls to replace local calls without changes to existing code.</para>
<para>There is also optional support for thread mapping, so each thread making interprocess calls can have a dedicated thread processing requests from it, and callbacks from processing threads are executed on corresponding request threads (so recursive mutexes and thread names function as expected in callbacks).</para>
<para>Libmultiprocess acts as a pure wrapper or layer over the underlying protocol. Clients and servers written in other languages, but using a shared capnproto schema can communicate with interprocess counterparties using libmultiprocess without having to use libmultiprocess themselves or having to know about the implementation details of libmultiprocess.</para>
<sect1 id="md_src_2ipc_2libmultiprocess_2doc_2design_1autotoc_md15_1s1"><sect2 id="md_src_2ipc_2libmultiprocess_2doc_2design_1autotoc_md15">
<title>Internals</title><para>The <computeroutput>ProxyClient</computeroutput> and <computeroutput>ProxyServer</computeroutput> generated classes are not directly exposed to the user, as described in <ref refid="md_src_2ipc_2libmultiprocess_2doc_2usage" kindref="compound">usage.md</ref>. Instead, they wrap C++ interfaces and appear to the user as pointers to an interface. They are first instantiated when calling <computeroutput>ConnectStream</computeroutput> and <computeroutput>ServeStream</computeroutput> respectively for creating the <computeroutput>InitInterface</computeroutput>. These methods establish connections through sockets, internally creating <computeroutput>Connection</computeroutput> objects wrapping a <computeroutput>capnp::RpcSystem</computeroutput> configured for client and server mode respectively.</para>
<para>The <computeroutput>InitInterface</computeroutput> interface will typically have methods which return other interfaces, giving the connecting process the ability to call other functions in the serving process. Interfaces can also have methods accepting other interfaces as parameters, giving serving processes the ability to call back and invoke functions in connecting processes. Creating new interfaces does not create new connections, and typically many interface objects will share the same connection.</para>
<para>Both <computeroutput>ConnectStream</computeroutput> and <computeroutput>ServeStream</computeroutput> also require an instantiation of the <computeroutput>EventLoop</computeroutput>. The <computeroutput>EventLoop</computeroutput> owns pending requests, notifies on request dispatch, allows clients from multiple threads to make synchronous calls, and handles some cleanup routines on exit. It must be run in a separate thread so it is always active and can process incoming requests from local clients and remote connections.</para>
<para>When a generated method on the <computeroutput>ProxyClient</computeroutput> is called, it calls <computeroutput>clientInvoke</computeroutput> with the capnp-translated types. <computeroutput>clientInvoke</computeroutput> creates a self-executing promise (<computeroutput>kj::TaskSet</computeroutput>) that drives the execution of the request and gives ownership of it to the <computeroutput>EventLoop</computeroutput>. <computeroutput>clientInvoke</computeroutput> blocks until a response is received, or until there is a call from the server that needs to run on the same client thread, using a <computeroutput>Waiter</computeroutput> object.</para>
<para>On the server side, the <computeroutput>capnp::RpcSystem</computeroutput> receives the capnp request and invokes the corresponding C++ method through the corresponding <computeroutput>ProxyServer</computeroutput> and the heavily templated <computeroutput>serverInvoke</computeroutput> triggering a <computeroutput>ServerCall</computeroutput>. The return values from the actual C++ methods are copied into capnp responses by <computeroutput>ServerRet</computeroutput> and exceptions are caught and copied by <computeroutput>ServerExcept</computeroutput>. The two are connected through <computeroutput>ServerField</computeroutput>. The main method driving execution of a request is <computeroutput>PassField</computeroutput>, which is invoked through <computeroutput>ServerField</computeroutput>. Instantiated interfaces, or capabilities in capnp speak, are tracked and owned by the server&apos;s <computeroutput>capnp::RpcSystem</computeroutput>.</para>
</sect2></sect1>
<sect1 id="md_src_2ipc_2libmultiprocess_2doc_2design_1autotoc_md16">
<title>Interface descriptions</title><para>As explained in the <ref refid="md_src_2ipc_2libmultiprocess_2doc_2usage" kindref="compound">usage</ref> document, interface descriptions need to be consumed both by the <emphasis>libmultiprocess</emphasis> code generator, and by C++ code that calls and implements the interfaces. The C++ code only needs to know about C++ arguments and return types, while the code generator only needs to know about capnp arguments and return types, but both need to know class and method names, so the corresponding <computeroutput>.h</computeroutput> and <computeroutput>.capnp</computeroutput> source files contain some of the same information, and have to be kept in sync manually when methods or parameters change. Despite the redundancy, reconciling the interface definitions is designed to be <emphasis>straightforward</emphasis> and <emphasis>safe</emphasis>. <emphasis>Straightforward</emphasis> because there is no need to write manual serialization code or use awkward intermediate types like <ulink url="https://github.com/bitcoin/bitcoin/blob/master/src/univalue/include/univalue.h"><computeroutput>UniValue</computeroutput></ulink> instead of native types. <emphasis>Safe</emphasis> because if there are any inconsistencies between API and data definitions (even minor ones like using a narrow int data type for a wider int API input), there are errors at build time instead of errors or bugs at runtime.</para>
<para>In the future, it would be possible to combine API and data definitions together using <ulink url="https://en.cppreference.com/w/cpp/language/attributes">C++ attributes</ulink>. To do this we would add attributes to the API definition files, and then generate the data definitions from the API definitions and attributes. I didn&apos;t take this approach mostly because it would be extra work, but also because until C++ standardizes reflection, this would require either hooking into compiler APIs like <ulink url="https://github.com/RosettaCommons/binder">https://github.com/RosettaCommons/binder</ulink>, or parsing C++ code manually like <ulink url="http://www.swig.org/">http://www.swig.org/</ulink>.</para>
</sect1>
<sect1 id="md_src_2ipc_2libmultiprocess_2doc_2design_1autotoc_md17">
<title>What is <computeroutput>kj</computeroutput>?</title><para>KJ is a concurrency framework <ulink url="https://capnproto.org/cxxrpc.html#kj-concurrency-framework">bundled with capnproto</ulink>; it is used as a basis in this library to construct the event-loop necessary to service IPC requests.</para>
</sect1>
<sect1 id="md_src_2ipc_2libmultiprocess_2doc_2design_1autotoc_md18">
<title>Future directions</title><para><emphasis>libmultiprocess</emphasis> uses the <ulink url="https://capnproto.org">Cap&apos;n Proto</ulink> interface description language and protocol, but it could be extended or changed to use a different IDL/protocol like <ulink url="https://grpc.io">gRPC</ulink>. The nice thing about <emphasis>Cap&apos;n Proto</emphasis> compared to <emphasis>gRPC</emphasis> and most other lower level protocols is that it allows interface pointers (<emphasis>Services</emphasis> in gRPC parlance) to be passed as method arguments and return values, so object references and bidirectional requests work out of the box. Supporting a lower-level protocol would require adding maps and tracking code to proxy objects.</para>
<para><emphasis>libmultiprocess</emphasis> is currently compatible with sandboxing but could add platform-specific sandboxing support or integration with a sandboxing library like <ulink url="https://github.com/google/sandboxed-api">SAPI</ulink>. </para>
</sect1>
    </detaileddescription>
    <location file="src/ipc/libmultiprocess/doc/design.md"/>
  </compounddef>
</doxygen>
