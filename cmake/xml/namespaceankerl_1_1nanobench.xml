<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="namespaceankerl_1_1nanobench" kind="namespace" language="C++">
    <compoundname>ankerl::nanobench</compoundname>
    <innerclass refid="structankerl_1_1nanobench_1_1_config" prot="public">ankerl::nanobench::Config</innerclass>
    <innerclass refid="classankerl_1_1nanobench_1_1_result" prot="public">ankerl::nanobench::Result</innerclass>
    <innerclass refid="classankerl_1_1nanobench_1_1_rng" prot="public">ankerl::nanobench::Rng</innerclass>
    <innerclass refid="classankerl_1_1nanobench_1_1_bench" prot="public">ankerl::nanobench::Bench</innerclass>
    <innerclass refid="classankerl_1_1nanobench_1_1_big_o" prot="public">ankerl::nanobench::BigO</innerclass>
    <innernamespace refid="namespaceankerl_1_1nanobench_1_1templates">ankerl::nanobench::templates</innernamespace>
    <innernamespace refid="namespaceankerl_1_1nanobench_1_1detail">ankerl::nanobench::detail</innernamespace>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespaceankerl_1_1nanobench_1a75c517a490cc337babc53b6c5008cdb5" prot="public" static="no">
        <type>std::conditional&lt; std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock, std::chrono::steady_clock &gt;::type</type>
        <definition>using Clock =  std::conditional&lt;std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock,
                               std::chrono::steady_clock&gt;::type</definition>
        <argsstring></argsstring>
        <name>Clock</name>
        <qualifiedname>ankerl::nanobench::Clock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="132" column="1" bodyfile="src/bench/nanobench.h" bodystart="132" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1aa8b83321afa5228fa13d67157ad8657e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void render</definition>
        <argsstring>(char const *mustacheTemplate, Bench const &amp;bench, std::ostream &amp;out)</argsstring>
        <name>render</name>
        <qualifiedname>ankerl::nanobench::render</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>mustacheTemplate</declname>
        </param>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_bench" kindref="compound">Bench</ref> const &amp;</type>
          <declname>bench</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
<para>Renders output from a mustache-like template and benchmark results. </para>
        </briefdescription>
        <detaileddescription>
<para>The templating facility here is heavily inspired by <ulink url="https://mustache.github.io/">mustache - logic-less templates</ulink>. It adds a few more features that are necessary to get all of the captured data out of nanobench. Please read the excellent <ulink url="https://mustache.github.io/mustache.5.html">mustache manual</ulink> to see what this is all about.</para>
<para>nanobench output has two nested layers, <emphasis>result</emphasis> and <emphasis>measurement</emphasis>. Here is a hierarchy of the allowed tags:</para>
<para><itemizedlist>
<listitem><para><computeroutput>{{#result}}</computeroutput> Marks the begin of the result layer. Whatever comes after this will be instantiated as often as a benchmark result is available. Within it, you can use these tags:<itemizedlist>
<listitem><para><computeroutput>{{title}}</computeroutput> See <ref refid="classankerl_1_1nanobench_1_1_bench_1a4e7209cd88a09e1e2278f0d506dd3aa3" kindref="member">Bench::title</ref>.</para>
</listitem><listitem><para><computeroutput>{{<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>}}</computeroutput> Benchmark name, usually directly provided with <ref refid="classankerl_1_1nanobench_1_1_bench_1ae0f1d3ec977f3733d457b759b1f08e9e" kindref="member">Bench::run</ref>, but can also be set with <ref refid="classankerl_1_1nanobench_1_1_bench_1a8a87b6c0978c4d69179ee249beb86c0c" kindref="member">Bench::name</ref>.</para>
</listitem><listitem><para><computeroutput>{{unit}}</computeroutput> Unit, e.g. <computeroutput>byte</computeroutput>. Defaults to <computeroutput>op</computeroutput>, see <ref refid="classankerl_1_1nanobench_1_1_bench_1a7fada6f805f9af86b8508e8ef028d936" kindref="member">Bench::unit</ref>.</para>
</listitem><listitem><para><computeroutput>{{batch}}</computeroutput> Batch size, see <ref refid="classankerl_1_1nanobench_1_1_bench_1a37d376bc0b00680fc13656e4761f8168" kindref="member">Bench::batch</ref>.</para>
</listitem><listitem><para><computeroutput>{{complexityN}}</computeroutput> Value used for asymptotic complexity calculation. See <ref refid="classankerl_1_1nanobench_1_1_bench_1a4c2fa1375c3a79a88cfb8532b4017f69" kindref="member">Bench::complexityN</ref>.</para>
</listitem><listitem><para><computeroutput>{{epochs}}</computeroutput> Number of epochs, see <ref refid="classankerl_1_1nanobench_1_1_bench_1a2aace9b04e1962c6490d7b2bbcbf0269" kindref="member">Bench::epochs</ref>.</para>
</listitem><listitem><para><computeroutput>{{clockResolution}}</computeroutput> Accuracy of the clock, i.e. what&apos;s the smallest time possible to measure with the clock. For modern systems, this can be around 20 ns. This value is automatically determined by nanobench at the first benchmark that is run, and used as a static variable throughout the application&apos;s runtime.</para>
</listitem><listitem><para><computeroutput>{{clockResolutionMultiple}}</computeroutput> Configuration multiplier for <computeroutput>clockResolution</computeroutput>. See <ref refid="classankerl_1_1nanobench_1_1_bench_1a92b3a1e3050c61c1e24e42a116b92a87" kindref="member">Bench::clockResolutionMultiple</ref>. This is the target runtime for each measurement (epoch). That means the more accurate your clock is, the faster will be the benchmark. Basing the measurement&apos;s runtime on the clock resolution is the main reason why nanobench is so fast.</para>
</listitem><listitem><para><computeroutput>{{maxEpochTime}}</computeroutput> Configuration for a maximum time each measurement (epoch) is allowed to take. Note that at least a single iteration will be performed, even when that takes longer than maxEpochTime. See <ref refid="classankerl_1_1nanobench_1_1_bench_1abb7e4067323a8d7569e9867b03a35b39" kindref="member">Bench::maxEpochTime</ref>.</para>
</listitem><listitem><para><computeroutput>{{minEpochTime}}</computeroutput> Minimum epoch time, defaults to 1ms. See <ref refid="classankerl_1_1nanobench_1_1_bench_1aa6b15573e7e0c48f1290e1842fd21edf" kindref="member">Bench::minEpochTime</ref>.</para>
</listitem><listitem><para><computeroutput>{{minEpochIterations}}</computeroutput> See <ref refid="classankerl_1_1nanobench_1_1_bench_1aab73759486903f243d9664e3c3208034" kindref="member">Bench::minEpochIterations</ref>.</para>
</listitem><listitem><para><computeroutput>{{epochIterations}}</computeroutput> See <ref refid="classankerl_1_1nanobench_1_1_bench_1ae084f501a2a3c61c1d128a519d4a38ae" kindref="member">Bench::epochIterations</ref>.</para>
</listitem><listitem><para><computeroutput>{{warmup}}</computeroutput> Number of iterations used before measuring starts. See <ref refid="classankerl_1_1nanobench_1_1_bench_1ae48156567cac1e76706ac0ce076894b7" kindref="member">Bench::warmup</ref>.</para>
</listitem><listitem><para><computeroutput>{{relative}}</computeroutput> True or false, depending on the setting you have used. See <ref refid="classankerl_1_1nanobench_1_1_bench_1a2b35462c62dcf9e55bf31618dd8008e0" kindref="member">Bench::relative</ref>.</para>
</listitem><listitem><para><computeroutput>{{context(variableName)}}</computeroutput> See <ref refid="classankerl_1_1nanobench_1_1_bench_1a6c5c13becb6edb48ef7d02cc8caab1bb" kindref="member">Bench::context</ref>.</para>
</listitem></itemizedlist>
</para>
<para>Apart from these tags, it is also possible to use some mathematical operations on the measurement data. The operations are of the form <computeroutput>{{<ref refid="bitcoin-wallet_8cpp_1a64b0c5844a38fc862dcb5b4e30b1ca49" kindref="member">command(name)</ref>}}</computeroutput>. Currently <computeroutput><ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref></computeroutput> can be one of <computeroutput>elapsed</computeroutput>, <computeroutput>iterations</computeroutput>. If performance counters are available (currently only on current Linux systems), you also have <computeroutput>pagefaults</computeroutput>, <computeroutput>cpucycles</computeroutput>, <computeroutput>contextswitches</computeroutput>, <computeroutput>instructions</computeroutput>, <computeroutput>branchinstructions</computeroutput>, and <computeroutput>branchmisses</computeroutput>. All the measures (except <computeroutput>iterations</computeroutput>) are provided for a single iteration (so <computeroutput>elapsed</computeroutput> is the time a single iteration took). The following tags are available:<itemizedlist>
<listitem><para><computeroutput>{{median(&lt;<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>&gt;)}}</computeroutput> Calculate median of a measurement data set, e.g. <computeroutput>{{median(elapsed)}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{average(&lt;<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>&gt;)}}</computeroutput> Average (mean) calculation.</para>
</listitem><listitem><para><computeroutput>{{medianAbsolutePercentError(&lt;<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>&gt;)}}</computeroutput> Calculates MdAPE, the Median Absolute Percentage Error. The MdAPE is an excellent metric for the variation of measurements. It is more robust to outliers than the <ulink url="https://en.wikipedia.org/wiki/Mean_absolute_percentage_error">Mean absolute percentage error (M-APE)</ulink>.   <formula id="0">\[      \mathrm{MdAPE}(e) = \mathrm{med}\{| \frac{e_i - \mathrm{med}\{e\}}{e_i}| \}
\]</formula> E.g. for <emphasis>elapsed</emphasis>: First, <formula id="1">$ \mathrm{med}\{e\} $</formula> calculates the median by sorting and then taking the middle element of all <emphasis>elapsed</emphasis> measurements. This is used to calculate the absolute percentage error to this median for each measurement, as in <formula id="2">$ | \frac{e_i - \mathrm{med}\{e\}}{e_i}| $</formula>. All these results are sorted, and the middle value is chosen as the median absolute percent error.</para>
<para>This measurement is a bit hard to interpret, but it is very robust against outliers. E.g. a value of 5% means that half of the measurements deviate less than 5% from the median, and the other deviate more than 5% from the median.</para>
</listitem><listitem><para><computeroutput>{{<ref refid="examples_8cpp_1a936f4b586a8f869a9d0d197cc5110653" kindref="member">sum</ref>(&lt;<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>&gt;)}}</computeroutput> Sum of all the measurements. E.g. <computeroutput>{{<ref refid="examples_8cpp_1a936f4b586a8f869a9d0d197cc5110653" kindref="member">sum(iterations)</ref>}}</computeroutput> will give you the total number of iterations measured in this benchmark.</para>
</listitem><listitem><para><computeroutput>{{minimum(&lt;<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>&gt;)}}</computeroutput> Minimum of all measurements.</para>
</listitem><listitem><para><computeroutput>{{maximum(&lt;<ref refid="rest_8cpp_1a8f8f80d37794cde9472343e4487ba3eb" kindref="member">name</ref>&gt;)}}</computeroutput> Maximum of all measurements.</para>
</listitem><listitem><para><computeroutput>{{sumProduct(&lt;first&gt;, &lt;second&gt;)}}</computeroutput> Calculates the sum of the products of corresponding measures:   <formula id="3">\[         \mathrm{sumProduct}(a,b) = \sum_{i=1}^{n}a_i\cdot b_i
\]</formula> E.g. to calculate total runtime of the benchmark, you multiply iterations with elapsed time for each measurement, and sum these results up: <computeroutput>{{sumProduct(iterations, elapsed)}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{#measurement}}</computeroutput> To access individual measurement results, open the begin tag for measurements.<itemizedlist>
<listitem><para><computeroutput>{{elapsed}}</computeroutput> Average elapsed wall clock time per iteration, in seconds.</para>
</listitem><listitem><para><computeroutput>{{iterations}}</computeroutput> Number of iterations in the measurement. The number of iterations will fluctuate due to some applied randomness, to enhance accuracy.</para>
</listitem><listitem><para><computeroutput>{{pagefaults}}</computeroutput> Average number of pagefaults per iteration.</para>
</listitem><listitem><para><computeroutput>{{cpucycles}}</computeroutput> Average number of CPU cycles processed per iteration.</para>
</listitem><listitem><para><computeroutput>{{contextswitches}}</computeroutput> Average number of context switches per iteration.</para>
</listitem><listitem><para><computeroutput>{{instructions}}</computeroutput> Average number of retired instructions per iteration.</para>
</listitem><listitem><para><computeroutput>{{branchinstructions}}</computeroutput> Average number of branches executed per iteration.</para>
</listitem><listitem><para><computeroutput>{{branchmisses}}</computeroutput> Average number of branches that were missed per iteration.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>{{/measurement}}</computeroutput> Ends the measurement tag.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>{{/result}}</computeroutput> Marks the end of the result layer. This is the end marker for the template part that will be instantiated for each benchmark result.</para>
<para>For the layer tags <emphasis>result</emphasis> and <emphasis>measurement</emphasis> you additionally can use these special markers:<itemizedlist>
<listitem><para><computeroutput>{{#-first}}</computeroutput> - Begin marker of a template that will be instantiated <emphasis>only for the first</emphasis> entry in the layer. Use is only allowed between the begin and end marker of the layer. So between <computeroutput>{{#result}}</computeroutput> and <computeroutput>{{/result}}</computeroutput>, or between <computeroutput>{{#measurement}}</computeroutput> and <computeroutput>{{/measurement}}</computeroutput>. Finish the template with <computeroutput>{{/-first}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{^-first}}</computeroutput> - Begin marker of a template that will be instantiated <emphasis>for each except the first</emphasis> entry in the layer. This, this is basically the inversion of <computeroutput>{{#-first}}</computeroutput>. Use is only allowed between the begin and end marker of the layer. So between <computeroutput>{{#result}}</computeroutput> and <computeroutput>{{/result}}</computeroutput>, or between <computeroutput>{{#measurement}}</computeroutput> and <computeroutput>{{/measurement}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{/-first}}</computeroutput> - End marker for either <computeroutput>{{#-first}}</computeroutput> or <computeroutput>{{^-first}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{#-last}}</computeroutput> - Begin marker of a template that will be instantiated <emphasis>only for the last</emphasis> entry in the layer. Use is only allowed between the begin and end marker of the layer. So between <computeroutput>{{#result}}</computeroutput> and <computeroutput>{{/result}}</computeroutput>, or between <computeroutput>{{#measurement}}</computeroutput> and <computeroutput>{{/measurement}}</computeroutput>. Finish the template with <computeroutput>{{/-last}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{^-last}}</computeroutput> - Begin marker of a template that will be instantiated <emphasis>for each except the last</emphasis> entry in the layer. This, this is basically the inversion of <computeroutput>{{#-last}}</computeroutput>. Use is only allowed between the begin and end marker of the layer. So between <computeroutput>{{#result}}</computeroutput> and <computeroutput>{{/result}}</computeroutput>, or between <computeroutput>{{#measurement}}</computeroutput> and <computeroutput>{{/measurement}}</computeroutput>.</para>
</listitem><listitem><para><computeroutput>{{/-last}}</computeroutput> - End marker for either <computeroutput>{{#-last}}</computeroutput> or <computeroutput>{{^-last}}</computeroutput>.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><verbatim>embed:rst

For an overview of all the possible data you can get out of nanobench, please see the tutorial at :ref:`tutorial-template-json`.

The templates that ship with nanobench are:

* :cpp:func:`templates::csv() &lt;ankerl::nanobench::templates::csv()&gt;`
* :cpp:func:`templates::json() &lt;ankerl::nanobench::templates::json()&gt;`
* :cpp:func:`templates::htmlBoxplot() &lt;ankerl::nanobench::templates::htmlBoxplot()&gt;`
* :cpp:func:`templates::pyperf() &lt;ankerl::nanobench::templates::pyperf()&gt;`
</verbatim></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mustacheTemplate</parametername>
</parameternamelist>
<parameterdescription>
<para>The template. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bench</parametername>
</parameternamelist>
<parameterdescription>
<para>Benchmark, containing all the results. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>Output for the generated output. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="290" column="6" declfile="src/bench/nanobench.h" declline="290" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1aa1dec992ac1ca3b7f809b19f80731e5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void render</definition>
        <argsstring>(std::string const &amp;mustacheTemplate, Bench const &amp;bench, std::ostream &amp;out)</argsstring>
        <name>render</name>
        <qualifiedname>ankerl::nanobench::render</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>mustacheTemplate</declname>
        </param>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_bench" kindref="compound">Bench</ref> const &amp;</type>
          <declname>bench</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="291" column="6" declfile="src/bench/nanobench.h" declline="291" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1a2ceb04bb3be4bfefdb350794d870c601" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void render</definition>
        <argsstring>(char const *mustacheTemplate, std::vector&lt; Result &gt; const &amp;results, std::ostream &amp;out)</argsstring>
        <name>render</name>
        <qualifiedname>ankerl::nanobench::render</qualifiedname>
        <param>
          <type>char const *</type>
          <declname>mustacheTemplate</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classankerl_1_1nanobench_1_1_result" kindref="compound">Result</ref> &gt; const &amp;</type>
          <declname>results</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as <ref refid="namespaceankerl_1_1nanobench_1aa8b83321afa5228fa13d67157ad8657e" kindref="member">render(char const* mustacheTemplate, Bench const&amp; bench, std::ostream&amp; out)</ref>, but for when you only have results available.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mustacheTemplate</parametername>
</parameternamelist>
<parameterdescription>
<para>The template. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>results</parametername>
</parameternamelist>
<parameterdescription>
<para>All the results to be used for rendering. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out</parametername>
</parameternamelist>
<parameterdescription>
<para>Output for the generated output. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="301" column="6" declfile="src/bench/nanobench.h" declline="301" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1a01eed06f15c6b472a066041a45bf5ce8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void render</definition>
        <argsstring>(std::string const &amp;mustacheTemplate, std::vector&lt; Result &gt; const &amp;results, std::ostream &amp;out)</argsstring>
        <name>render</name>
        <qualifiedname>ankerl::nanobench::render</qualifiedname>
        <param>
          <type>std::string const &amp;</type>
          <declname>mustacheTemplate</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classankerl_1_1nanobench_1_1_result" kindref="compound">Result</ref> &gt; const &amp;</type>
          <declname>results</declname>
        </param>
        <param>
          <type>std::ostream &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="302" column="6" declfile="src/bench/nanobench.h" declline="302" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1a3212d2fb3075373651a84b10c6e27f5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Arg</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void doNotOptimizeAway</definition>
        <argsstring>(Arg &amp;&amp;arg)</argsstring>
        <name>doNotOptimizeAway</name>
        <qualifiedname>ankerl::nanobench::doNotOptimizeAway</qualifiedname>
        <param>
          <type>Arg &amp;&amp;</type>
          <declname>arg</declname>
        </param>
        <briefdescription>
<para>Makes sure none of the given arguments are optimized away by the compiler. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Type of the argument that shouldn&apos;t be optimized away. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>The input that we mark as being used, even though we don&apos;t do anything with it. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1279" column="6" bodyfile="src/bench/nanobench.h" bodystart="1279" bodyend="1281" declfile="src/bench/nanobench.h" declline="1023" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1ac6dfa99fbb0ccc7e9057b5fccef501d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, BigO const &amp;bigO)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>ankerl::nanobench::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_big_o" kindref="compound">BigO</ref> const &amp;</type>
          <declname>bigO</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1145" column="1" declfile="src/bench/nanobench.h" declline="1145" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="namespaceankerl_1_1nanobench_1a3f1e3dca5735b98bda904a5bb78fff2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, std::vector&lt; ankerl::nanobench::BigO &gt; const &amp;bigOs)</argsstring>
        <name>operator&lt;&lt;</name>
        <qualifiedname>ankerl::nanobench::operator&lt;&lt;</qualifiedname>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="classankerl_1_1nanobench_1_1_big_o" kindref="compound">ankerl::nanobench::BigO</ref> &gt; const &amp;</type>
          <declname>bigOs</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="1146" column="1" declfile="src/bench/nanobench.h" declline="1146" declcolumn="1"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/bench/nanobench.h" line="130" column="1"/>
  </compounddef>
</doxygen>
