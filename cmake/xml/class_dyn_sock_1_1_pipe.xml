<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_dyn_sock_1_1_pipe" kind="class" language="C++" prot="public">
    <compoundname>DynSock::Pipe</compoundname>
    <includes refid="test_2util_2net_8h" local="no">net.h</includes>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_dyn_sock_1_1_pipe_1a71aaf23d91d7b7a5611738c4f06e3577" prot="private" static="no" mutable="no">
        <type><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref></type>
        <definition>Mutex m_mutex</definition>
        <argsstring></argsstring>
        <name>m_mutex</name>
        <qualifiedname>DynSock::Pipe::m_mutex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="282" column="15" bodyfile="src/test/util/net.h" bodystart="282" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_dyn_sock_1_1_pipe_1a76964a5982cf430a1d7e7b4466dc11eb" prot="private" static="no" mutable="no">
        <type>std::condition_variable</type>
        <definition>std::condition_variable m_cond</definition>
        <argsstring></argsstring>
        <name>m_cond</name>
        <qualifiedname>DynSock::Pipe::m_cond</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="283" column="33" bodyfile="src/test/util/net.h" bodystart="283" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1abd101ceb3b30109dad0280139fa5afa2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ssize_t</type>
        <definition>ssize_t GetBytes</definition>
        <argsstring>(void *buf, size_t len, int flags=0) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>GetBytes</name>
        <qualifiedname>DynSock::Pipe::GetBytes</qualifiedname>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get bytes and remove them from the pipe. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">buf</parametername>
</parameternamelist>
<parameterdescription>
<para>Destination to write bytes to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">len</parametername>
</parameternamelist>
<parameterdescription>
<para>Write up to this number of bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">flags</parametername>
</parameternamelist>
<parameterdescription>
<para>Same as the flags of <computeroutput>recv(2)</computeroutput>. Just <computeroutput>MSG_PEEK</computeroutput> is honored. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The number of bytes written to <computeroutput>buf</computeroutput>. <computeroutput>0</computeroutput> if <computeroutput><ref refid="class_dyn_sock_1_1_pipe_1a1f4d4e97fdc6b20d7da01cea65f3fa6c" kindref="member">Eof()</ref></computeroutput> has been called. If no bytes are available then <computeroutput>-1</computeroutput> is returned and <computeroutput>errno</computeroutput> is set to <computeroutput>EAGAIN</computeroutput>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="250" column="17" bodyfile="src/test/util/net.cpp" bodystart="256" bodyend="276"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1a45a40d959c432aec9fe9702d18b0af05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="class_c_net_message" kindref="compound">CNetMessage</ref> &gt;</type>
        <definition>std::optional&lt; CNetMessage &gt; GetNetMsg</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>GetNetMsg</name>
        <qualifiedname>DynSock::Pipe::GetNetMsg</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deserialize a <computeroutput><ref refid="class_c_net_message" kindref="compound">CNetMessage</ref></computeroutput> and remove it from the pipe. If not enough bytes are available then the function will wait. If parsing fails or EOF is signaled to the pipe, then <computeroutput>std::nullopt</computeroutput> is returned. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="257" column="23" bodyfile="src/test/util/net.cpp" bodystart="278" bodyend="314"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1a2764431e2e0ea25b35beabcc1dab0ca1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void PushBytes</definition>
        <argsstring>(const void *buf, size_t len) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>PushBytes</name>
        <qualifiedname>DynSock::Pipe::PushBytes</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Push bytes to the pipe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="262" column="14" bodyfile="src/test/util/net.cpp" bodystart="316" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1afb25e44054f943a7cbffeed3ba336ec5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void PushNetMsg</definition>
        <argsstring>(const std::string &amp;type, Args &amp;&amp;... payload) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>PushNetMsg</name>
        <qualifiedname>DynSock::Pipe::PushNetMsg</qualifiedname>
        <param>
          <type>const std::string &amp;</type>
          <declname>type</declname>
        </param>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>payload</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct and push <ref refid="class_c_net_message" kindref="compound">CNetMessage</ref> to the pipe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="268" column="14" bodyfile="src/test/util/net.h" bodystart="358" bodyend="378"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1a1f4d4e97fdc6b20d7da01cea65f3fa6c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Eof</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)</argsstring>
        <name>Eof</name>
        <qualifiedname>DynSock::Pipe::Eof</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Signal end-of-file on the receiving end (<computeroutput><ref refid="class_dyn_sock_1_1_pipe_1abd101ceb3b30109dad0280139fa5afa2" kindref="member">GetBytes()</ref></computeroutput> or <computeroutput><ref refid="class_dyn_sock_1_1_pipe_1a45a40d959c432aec9fe9702d18b0af05" kindref="member">GetNetMsg()</ref></computeroutput>). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="273" column="14" bodyfile="src/test/util/net.cpp" bodystart="324" bodyend="329"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1a8a151fcf099957ab189d691e779d67a0" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void WaitForDataOrEof</definition>
        <argsstring>(UniqueLock&lt; Mutex &gt; &amp;lock) EXCLUSIVE_LOCKS_REQUIRED(m_mutex)</argsstring>
        <name>WaitForDataOrEof</name>
        <qualifiedname>DynSock::Pipe::WaitForDataOrEof</qualifiedname>
        <param>
          <type><ref refid="class_unique_lock" kindref="compound">UniqueLock</ref>&lt; <ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref> &gt; &amp;</type>
          <declname>lock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return when there is some data to read or EOF has been signaled. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">lock</parametername>
</parameternamelist>
<parameterdescription>
<para>Unique lock that must have been derived from <computeroutput>m_mutex</computeroutput> by <computeroutput><ref refid="sync_8h_1a05166a687f0bfba57b8ea332c7dd57e0" kindref="member">WAIT_LOCK(m_mutex, lock)</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="280" column="14" bodyfile="src/test/util/net.cpp" bodystart="331" bodyend="339"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1a4596c220946b0650c454912c9488ddb8" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; uint8_t &gt; m_data</type>
        <definition>std::vector&lt; uint8_t &gt; m_data GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>DynSock::Pipe::GUARDED_BY</qualifiedname>
        <param>
          <type>m_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="284" column="28"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1_1_pipe_1a4fccefae961d428794131aa590f703d9" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool m_eof</type>
        <definition>bool m_eof GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>DynSock::Pipe::GUARDED_BY</qualifiedname>
        <param>
          <type>m_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="285" column="20" bodyfile="src/test/util/net.h" bodystart="285" bodyend="285"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Unidirectional bytes or <ref refid="class_c_net_message" kindref="compound">CNetMessage</ref> queue (FIFO). </para>
    </detaileddescription>
    <location file="src/test/util/net.h" line="239" column="5" bodyfile="src/test/util/net.h" bodystart="240" bodyend="286"/>
    <listofallmembers>
      <member refid="class_dyn_sock_1_1_pipe_1a1f4d4e97fdc6b20d7da01cea65f3fa6c" prot="public" virt="non-virtual"><scope>DynSock::Pipe</scope><name>Eof</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1abd101ceb3b30109dad0280139fa5afa2" prot="public" virt="non-virtual"><scope>DynSock::Pipe</scope><name>GetBytes</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a45a40d959c432aec9fe9702d18b0af05" prot="public" virt="non-virtual"><scope>DynSock::Pipe</scope><name>GetNetMsg</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a4596c220946b0650c454912c9488ddb8" prot="private" virt="non-virtual"><scope>DynSock::Pipe</scope><name>GUARDED_BY</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a4fccefae961d428794131aa590f703d9" prot="private" virt="non-virtual"><scope>DynSock::Pipe</scope><name>GUARDED_BY</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a76964a5982cf430a1d7e7b4466dc11eb" prot="private" virt="non-virtual"><scope>DynSock::Pipe</scope><name>m_cond</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a71aaf23d91d7b7a5611738c4f06e3577" prot="private" virt="non-virtual"><scope>DynSock::Pipe</scope><name>m_mutex</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a2764431e2e0ea25b35beabcc1dab0ca1" prot="public" virt="non-virtual"><scope>DynSock::Pipe</scope><name>PushBytes</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1afb25e44054f943a7cbffeed3ba336ec5" prot="public" virt="non-virtual"><scope>DynSock::Pipe</scope><name>PushNetMsg</name></member>
      <member refid="class_dyn_sock_1_1_pipe_1a8a151fcf099957ab189d691e779d67a0" prot="private" virt="non-virtual"><scope>DynSock::Pipe</scope><name>WaitForDataOrEof</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
