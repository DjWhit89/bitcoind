<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_dyn_sock" kind="class" language="C++" prot="public">
    <compoundname>DynSock</compoundname>
    <basecompoundref refid="class_zero_sock" prot="public" virt="non-virtual">ZeroSock</basecompoundref>
    <includes refid="test_2util_2net_8h" local="no">net.h</includes>
    <innerclass refid="class_dyn_sock_1_1_pipe" prot="public">DynSock::Pipe</innerclass>
    <innerclass refid="struct_dyn_sock_1_1_pipes" prot="public">DynSock::Pipes</innerclass>
    <innerclass refid="class_dyn_sock_1_1_queue" prot="public">DynSock::Queue</innerclass>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_dyn_sock_1ac8d17b7d19e7c8f85c1d1d933f0cbc61" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="struct_dyn_sock_1_1_pipes" kindref="compound">Pipes</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Pipes&gt; m_pipes</definition>
        <argsstring></argsstring>
        <name>m_pipes</name>
        <qualifiedname>DynSock::m_pipes</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="353" column="21" bodyfile="src/test/util/net.h" bodystart="353" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_dyn_sock_1a7cc9441622ec9a64cdf86d3b425dbcc0" prot="private" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="class_dyn_sock_1_1_queue" kindref="compound">Queue</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Queue&gt; m_accept_sockets</definition>
        <argsstring></argsstring>
        <name>m_accept_sockets</name>
        <qualifiedname>DynSock::m_accept_sockets</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="354" column="21" bodyfile="src/test/util/net.h" bodystart="354" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_dyn_sock_1a4eb9d1799da10d0a13739c7b98b62559" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>DynSock</definition>
        <argsstring>(std::shared_ptr&lt; Pipes &gt; pipes, std::shared_ptr&lt; Queue &gt; accept_sockets)</argsstring>
        <name>DynSock</name>
        <qualifiedname>DynSock::DynSock</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="struct_dyn_sock_1_1_pipes" kindref="compound">Pipes</ref> &gt;</type>
          <declname>pipes</declname>
        </param>
        <param>
          <type>std::shared_ptr&lt; <ref refid="class_dyn_sock_1_1_queue" kindref="compound">Queue</ref> &gt;</type>
          <declname>accept_sockets</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a new mocked sock. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">pipes</parametername>
</parameternamelist>
<parameterdescription>
<para>Send/recv pipes used by the <ref refid="class_dyn_sock_1a91f43a08763aa3988637e9242bc1219f" kindref="member">Send()</ref> and <ref refid="class_dyn_sock_1acc57da900d09bf26675b155ff9f4ac89" kindref="member">Recv()</ref> methods. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">accept_sockets</parametername>
</parameternamelist>
<parameterdescription>
<para>Sockets to return by the <ref refid="class_dyn_sock_1a36b4abe351193181c883d465020aa101" kindref="member">Accept()</ref> method. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="334" column="14" bodyfile="src/test/util/net.cpp" bodystart="341" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1add4890d12ff2543da388315428c23f7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~DynSock</definition>
        <argsstring>()</argsstring>
        <name>~DynSock</name>
        <qualifiedname>DynSock::~DynSock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="336" column="5" bodyfile="src/test/util/net.cpp" bodystart="346" bodyend="349"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1acc57da900d09bf26675b155ff9f4ac89" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>ssize_t</type>
        <definition>ssize_t Recv</definition>
        <argsstring>(void *buf, size_t len, int flags) const override</argsstring>
        <name>Recv</name>
        <qualifiedname>DynSock::Recv</qualifiedname>
        <reimplements refid="class_sock_1ad5d478226aba69810d73757744e13317">Recv</reimplements>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>recv(2) wrapper. Equivalent to <computeroutput>recv(m_socket, buf, len, flags);</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="338" column="13" bodyfile="src/test/util/net.cpp" bodystart="351" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1a91f43a08763aa3988637e9242bc1219f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>ssize_t</type>
        <definition>ssize_t Send</definition>
        <argsstring>(const void *buf, size_t len, int) const override</argsstring>
        <name>Send</name>
        <qualifiedname>DynSock::Send</qualifiedname>
        <reimplements refid="class_sock_1ad50f4b43d2b968d64162193e9254d6b5">Send</reimplements>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>send(2) wrapper. Equivalent to <computeroutput>send(m_socket, data, len, flags);</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="340" column="13" bodyfile="src/test/util/net.cpp" bodystart="356" bodyend="360"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1a36b4abe351193181c883d465020aa101" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::unique_ptr&lt; <ref refid="class_sock" kindref="compound">Sock</ref> &gt;</type>
        <definition>std::unique_ptr&lt; Sock &gt; Accept</definition>
        <argsstring>(sockaddr *addr, socklen_t *addr_len) const override</argsstring>
        <name>Accept</name>
        <qualifiedname>DynSock::Accept</qualifiedname>
        <reimplements refid="class_sock_1a0478fe1f85686563dafce68f30878fa6">Accept</reimplements>
        <param>
          <type>sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>accept(2) wrapper. Equivalent to <computeroutput>std::make_unique&lt;<ref refid="class_sock" kindref="compound">Sock</ref>&gt;(accept(m_socket, addr, addr_len))</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. The returned unique_ptr is empty if <computeroutput>accept()</computeroutput> failed in which case errno will be set. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="342" column="21" bodyfile="src/test/util/net.cpp" bodystart="362" bodyend="366"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1aa9d44903b57505d9f8765404cb04f35f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool Wait</definition>
        <argsstring>(std::chrono::milliseconds timeout, Event requested, Event *occurred=nullptr) const override</argsstring>
        <name>Wait</name>
        <qualifiedname>DynSock::Wait</qualifiedname>
        <reimplements refid="class_sock_1a851a09613d347a157da032137020065a">Wait</reimplements>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref></type>
          <declname>requested</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref> *</type>
          <declname>occurred</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Wait for readiness for input (recv) or output (send). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait this much for at least one of the requested events to occur. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">requested</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait for those events, bitwise-or of <computeroutput><ref refid="class_sock_1ae15d539512bccb6583fc75310b0d2f86" kindref="member">RECV</ref></computeroutput> and <computeroutput><ref refid="class_sock_1ac739f9398eaa67718961a5ac331fba4a" kindref="member">SEND</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">occurred</parametername>
</parameternamelist>
<parameterdescription>
<para>If not nullptr and the function returns <computeroutput>true</computeroutput>, then this indicates which of the requested events occurred (<computeroutput><ref refid="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" kindref="member">ERR</ref></computeroutput> will be added, even if not requested, if an exceptional event occurs on the socket). A timeout is indicated by return value of <computeroutput>true</computeroutput> and <computeroutput>occurred</computeroutput> being set to 0. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success (or timeout, if <computeroutput>occurred</computeroutput> of 0 is returned), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="344" column="10" bodyfile="src/test/util/net.cpp" bodystart="368" bodyend="379"/>
      </memberdef>
      <memberdef kind="function" id="class_dyn_sock_1af35a7663942bba32c947f387114bc068" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool WaitMany</definition>
        <argsstring>(std::chrono::milliseconds timeout, EventsPerSock &amp;events_per_sock) const override</argsstring>
        <name>WaitMany</name>
        <qualifiedname>DynSock::WaitMany</qualifiedname>
        <reimplements refid="class_sock_1a6ec7a34cbf87594ed9b7eac590cf965f">WaitMany</reimplements>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" kindref="member">EventsPerSock</ref> &amp;</type>
          <declname>events_per_sock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as <computeroutput><ref refid="class_dyn_sock_1aa9d44903b57505d9f8765404cb04f35f" kindref="member">Wait()</ref></computeroutput>, but wait on many sockets within the same timeout. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait this long for at least one of the requested events to occur. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">events_per_sock</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait for the requested events on these sockets and set <computeroutput>occurred</computeroutput> for the events that actually occurred. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success (or timeout, if all <computeroutput>what[].occurred</computeroutput> are returned as 0), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="348" column="10" bodyfile="src/test/util/net.cpp" bodystart="381" bodyend="413"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_dyn_sock_1a813c68af975a142f7da1907426ace386" prot="private" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="class_dyn_sock" kindref="compound">DynSock</ref> &amp;</type>
        <definition>DynSock &amp; operator=</definition>
        <argsstring>(Sock &amp;&amp;) override</argsstring>
        <name>operator=</name>
        <qualifiedname>DynSock::operator=</qualifiedname>
        <reimplements refid="class_sock_1aed8298a36ba25760ceb8d1207a39f8db">operator=</reimplements>
        <param>
          <type><ref refid="class_sock" kindref="compound">Sock</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move assignment operator, grab the socket from another object and close ours (if set). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/test/util/net.h" line="351" column="13" bodyfile="src/test/util/net.cpp" bodystart="415" bodyend="419"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>A mocked <ref refid="class_sock" kindref="compound">Sock</ref> alternative that allows providing the data to be returned by <ref refid="class_dyn_sock_1acc57da900d09bf26675b155ff9f4ac89" kindref="member">Recv()</ref> and inspecting the data that has been supplied to <ref refid="class_dyn_sock_1a91f43a08763aa3988637e9242bc1219f" kindref="member">Send()</ref>. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>DynSock</label>
        <link refid="class_dyn_sock"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>Sock</label>
        <link refid="class_sock"/>
      </node>
      <node id="2">
        <label>ZeroSock</label>
        <link refid="class_zero_sock"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>DynSock</label>
        <link refid="class_dyn_sock"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>Sock</label>
        <link refid="class_sock"/>
      </node>
      <node id="2">
        <label>ZeroSock</label>
        <link refid="class_zero_sock"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="src/test/util/net.h" line="233" column="1" bodyfile="src/test/util/net.h" bodystart="234" bodyend="355"/>
    <listofallmembers>
      <member refid="class_dyn_sock_1a36b4abe351193181c883d465020aa101" prot="public" virt="virtual"><scope>DynSock</scope><name>Accept</name></member>
      <member refid="class_zero_sock_1ab8f4fedff95b14573fabc05c019f9f8e" prot="public" virt="virtual"><scope>DynSock</scope><name>Bind</name></member>
      <member refid="class_zero_sock_1a2a2d42283320a5a051f301933328ad09" prot="public" virt="virtual"><scope>DynSock</scope><name>Connect</name></member>
      <member refid="class_dyn_sock_1a4eb9d1799da10d0a13739c7b98b62559" prot="public" virt="non-virtual"><scope>DynSock</scope><name>DynSock</name></member>
      <member refid="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" prot="public" virt="non-virtual"><scope>DynSock</scope><name>ERR</name></member>
      <member refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" prot="public" virt="non-virtual"><scope>DynSock</scope><name>Event</name></member>
      <member refid="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" prot="public" virt="non-virtual"><scope>DynSock</scope><name>EventsPerSock</name></member>
      <member refid="class_zero_sock_1a16930ee6ded3a8fe47a7adaf178affff" prot="public" virt="virtual"><scope>DynSock</scope><name>GetSockName</name></member>
      <member refid="class_zero_sock_1a5b5845e5aca634a6f79c82afecbc37fd" prot="public" virt="virtual"><scope>DynSock</scope><name>GetSockOpt</name></member>
      <member refid="class_sock_1a395f618148d26468dc12324ffcddbd4a" prot="public" virt="virtual"><scope>DynSock</scope><name>IsConnected</name></member>
      <member refid="class_zero_sock_1a598fdcc705deaa438fba72650d51fe20" prot="public" virt="virtual"><scope>DynSock</scope><name>IsSelectable</name></member>
      <member refid="class_zero_sock_1a172d2ef5e777674d5445aac1387bab41" prot="public" virt="virtual"><scope>DynSock</scope><name>Listen</name></member>
      <member refid="class_dyn_sock_1a7cc9441622ec9a64cdf86d3b425dbcc0" prot="private" virt="non-virtual"><scope>DynSock</scope><name>m_accept_sockets</name></member>
      <member refid="class_dyn_sock_1ac8d17b7d19e7c8f85c1d1d933f0cbc61" prot="private" virt="non-virtual"><scope>DynSock</scope><name>m_pipes</name></member>
      <member refid="class_sock_1a453ef0b211974cc0b3f59651f2759a85" prot="protected" virt="non-virtual"><scope>DynSock</scope><name>m_socket</name></member>
      <member refid="class_dyn_sock_1a813c68af975a142f7da1907426ace386" prot="private" virt="virtual"><scope>DynSock</scope><name>operator=</name></member>
      <member refid="class_sock_1a4c90c4a9a6886cb68a9ee851522afff1" prot="public" virt="non-virtual" ambiguityscope="Sock::"><scope>DynSock</scope><name>operator=</name></member>
      <member refid="class_sock_1a0e4e0f6358b1a1c9d549037d265cc729" prot="public" virt="non-virtual"><scope>DynSock</scope><name>operator==</name></member>
      <member refid="class_sock_1ae15d539512bccb6583fc75310b0d2f86" prot="public" virt="non-virtual"><scope>DynSock</scope><name>RECV</name></member>
      <member refid="class_dyn_sock_1acc57da900d09bf26675b155ff9f4ac89" prot="public" virt="virtual"><scope>DynSock</scope><name>Recv</name></member>
      <member refid="class_sock_1a27107f318fb56aa730ab7572ac613479" prot="public" virt="virtual"><scope>DynSock</scope><name>RecvUntilTerminator</name></member>
      <member refid="class_sock_1ac739f9398eaa67718961a5ac331fba4a" prot="public" virt="non-virtual"><scope>DynSock</scope><name>SEND</name></member>
      <member refid="class_dyn_sock_1a91f43a08763aa3988637e9242bc1219f" prot="public" virt="virtual"><scope>DynSock</scope><name>Send</name></member>
      <member refid="class_sock_1a43f09a43a02f01718f04fd139c2a5ed4" prot="public" virt="virtual"><scope>DynSock</scope><name>SendComplete</name></member>
      <member refid="class_sock_1a885ca2c5b4d6185c0393595967115e6d" prot="public" virt="virtual"><scope>DynSock</scope><name>SendComplete</name></member>
      <member refid="class_zero_sock_1a8a6517d31b9c4c9a895c1cbb83387c86" prot="public" virt="virtual"><scope>DynSock</scope><name>SetNonBlocking</name></member>
      <member refid="class_zero_sock_1a94f895afc687c06525ac15ccb10ce2b0" prot="public" virt="virtual"><scope>DynSock</scope><name>SetSockOpt</name></member>
      <member refid="class_sock_1aa514692e524d2d55d80976eac6456d12" prot="public" virt="non-virtual"><scope>DynSock</scope><name>Sock</name></member>
      <member refid="class_sock_1a76264c08d7dff8a6c0521733d5bd850c" prot="public" virt="non-virtual"><scope>DynSock</scope><name>Sock</name></member>
      <member refid="class_sock_1a000e1d0f0c23801b9a15043312d90b15" prot="public" virt="non-virtual"><scope>DynSock</scope><name>Sock</name></member>
      <member refid="class_sock_1a014eef261ec754e8e3586d5d11f260fb" prot="public" virt="non-virtual"><scope>DynSock</scope><name>Sock</name></member>
      <member refid="class_dyn_sock_1aa9d44903b57505d9f8765404cb04f35f" prot="public" virt="virtual"><scope>DynSock</scope><name>Wait</name></member>
      <member refid="class_dyn_sock_1af35a7663942bba32c947f387114bc068" prot="public" virt="virtual"><scope>DynSock</scope><name>WaitMany</name></member>
      <member refid="class_zero_sock_1aefa860e8fb68c2d8a73ec71f10b27895" prot="public" virt="non-virtual"><scope>DynSock</scope><name>ZeroSock</name></member>
      <member refid="class_dyn_sock_1add4890d12ff2543da388315428c23f7f" prot="public" virt="non-virtual"><scope>DynSock</scope><name>~DynSock</name></member>
      <member refid="class_sock_1a6c6d5559856121d4b1a18465e2901c94" prot="public" virt="virtual"><scope>DynSock</scope><name>~Sock</name></member>
      <member refid="class_zero_sock_1af2fee29bcc7448c2d5d3acc995be6bd8" prot="public" virt="non-virtual"><scope>DynSock</scope><name>~ZeroSock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
