<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classinterfaces_1_1_ipc" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>interfaces::Ipc</compoundname>
    <includes refid="ipc_8h" local="no">ipc.h</includes>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1a901cfb7417e9511e9890c137eb556c18" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual ~Ipc</definition>
        <argsstring>()=default</argsstring>
        <name>~Ipc</name>
        <qualifiedname>interfaces::Ipc::~Ipc</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="52" column="13"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1adac82dc623fa04500dcc1c4eee94760b" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::unique_ptr&lt; <ref refid="class_init" kindref="compound">Init</ref> &gt;</type>
        <definition>virtual std::unique_ptr&lt; Init &gt; spawnProcess</definition>
        <argsstring>(const char *exe_name)=0</argsstring>
        <name>spawnProcess</name>
        <qualifiedname>interfaces::Ipc::spawnProcess</qualifiedname>
        <param>
          <type>const char *</type>
          <declname>exe_name</declname>
        </param>
        <briefdescription>
<para>Spawn a child process returning pointer to its <ref refid="classinterfaces_1_1_init" kindref="compound">Init</ref> interface. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="55" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1a5e302c6524dd19f78c2efe9a55abd057" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>bool</type>
        <definition>virtual bool startSpawnedProcess</definition>
        <argsstring>(int argc, char *argv[], int &amp;exit_status)=0</argsstring>
        <name>startSpawnedProcess</name>
        <qualifiedname>interfaces::Ipc::startSpawnedProcess</qualifiedname>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>argv</declname>
          <array>[]</array>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>exit_status</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If this is a spawned process, block and handle requests from the parent process by forwarding them to this process&apos;s <ref refid="classinterfaces_1_1_init" kindref="compound">Init</ref> interface, then return true. If this is not a spawned child process, return false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="60" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1a8f4b6624f88179cc8e91b0eec3698b45" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>std::unique_ptr&lt; <ref refid="class_init" kindref="compound">Init</ref> &gt;</type>
        <definition>virtual std::unique_ptr&lt; Init &gt; connectAddress</definition>
        <argsstring>(std::string &amp;address)=0</argsstring>
        <name>connectAddress</name>
        <qualifiedname>interfaces::Ipc::connectAddress</qualifiedname>
        <param>
          <type>std::string &amp;</type>
          <declname>address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Connect to a socket address and return a pointer to its <ref refid="classinterfaces_1_1_init" kindref="compound">Init</ref> interface. Returns a non-null pointer if the connection was established, returns null if address is empty (&quot;&quot;) or disabled (&quot;0&quot;) or if a connection was refused but not required (&quot;auto&quot;), and throws an exception if there was an unexpected error. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="67" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1a9c3d57bf43d3d20ace3a4249e6a797b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void listenAddress</definition>
        <argsstring>(std::string &amp;address)=0</argsstring>
        <name>listenAddress</name>
        <qualifiedname>interfaces::Ipc::listenAddress</qualifiedname>
        <param>
          <type>std::string &amp;</type>
          <declname>address</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Listen on a socket address exposing this process&apos;s init interface to clients. Throws an exception if there was an error. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="71" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1a45306c63b743375d0db4f613d2de7300" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void disconnectIncoming</definition>
        <argsstring>()=0</argsstring>
        <name>disconnectIncoming</name>
        <qualifiedname>interfaces::Ipc::disconnectIncoming</qualifiedname>
        <briefdescription>
<para>Disconnect any incoming connections that are still connected. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="74" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1adc17e7ae36bce773070d934e22ab97d7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Interface</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void addCleanup</definition>
        <argsstring>(Interface &amp;iface, std::function&lt; void()&gt; cleanup)</argsstring>
        <name>addCleanup</name>
        <qualifiedname>interfaces::Ipc::addCleanup</qualifiedname>
        <param>
          <type>Interface &amp;</type>
          <declname>iface</declname>
        </param>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <declname>cleanup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add cleanup callback to remote interface that will run when the interface is deleted. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="79" column="10" bodyfile="src/interfaces/ipc.h" bodystart="79" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1aadeee9466f33f2396a7ad52831083f8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type><ref refid="structipc_1_1_context" kindref="compound">ipc::Context</ref> &amp;</type>
        <definition>virtual ipc::Context &amp; context</definition>
        <argsstring>()=0</argsstring>
        <name>context</name>
        <qualifiedname>interfaces::Ipc::context</qualifiedname>
        <briefdescription>
<para>IPC context struct accessor (see struct definition for more description). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="85" column="26"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-func">
      <memberdef kind="function" id="classinterfaces_1_1_ipc_1ab752d262895c2173617749fea06bcba1" prot="protected" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void addCleanup</definition>
        <argsstring>(std::type_index type, void *iface, std::function&lt; void()&gt; cleanup)=0</argsstring>
        <name>addCleanup</name>
        <qualifiedname>interfaces::Ipc::addCleanup</qualifiedname>
        <param>
          <type>std::type_index</type>
          <declname>type</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>iface</declname>
        </param>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <declname>cleanup</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Internal implementation of public addCleanup method (above) as a type-erased virtual function, since template functions can&apos;t be virtual. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/interfaces/ipc.h" line="90" column="18"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Interface providing access to interprocess-communication (IPC) functionality. The IPC implementation is responsible for establishing connections between a controlling process and a process being controlled. When a connection is established, the process being controlled returns an <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> pointer to the controlling process, which the controlling process can use to get access to other interfaces and functionality.</para>
<para>When spawning a new process, the steps are:</para>
<para><orderedlist>
<listitem><para>The controlling process calls <ref refid="classinterfaces_1_1_ipc_1adac82dc623fa04500dcc1c4eee94760b" kindref="member">interfaces::Ipc::spawnProcess()</ref>, which calls <ref refid="classipc_1_1_process_1a75aaa60d46ba19dacf4a926911a4069d" kindref="member">ipc::Process::spawn()</ref>, which spawns a new process and returns a socketpair file descriptor for communicating with it. <ref refid="classinterfaces_1_1_ipc_1adac82dc623fa04500dcc1c4eee94760b" kindref="member">interfaces::Ipc::spawnProcess()</ref> then calls <ref refid="classipc_1_1_protocol_1a098584fc42adacc9ecfd5dc910fea66f" kindref="member">ipc::Protocol::connect()</ref> passing the socketpair descriptor, which returns a local proxy <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> implementation calling remote <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> methods.</para>
</listitem><listitem><para>The spawned process calls interfaces::Ipc::startSpawnProcess(), which calls <ref refid="classipc_1_1_process_1ae29d81a1df3ef04d9031ed37834db893" kindref="member">ipc::Process::checkSpawned()</ref> to read command line arguments and determine whether it is a spawned process and what socketpair file descriptor it should use. It then calls <ref refid="classipc_1_1_protocol_1a5249513dbbca3afe53c192be98ac7504" kindref="member">ipc::Protocol::serve()</ref> to handle incoming requests from the socketpair and invoke <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> interface methods, and exit when the socket is closed.</para>
</listitem><listitem><para>The controlling process calls local proxy <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> object methods to make other proxy objects calling other remote interfaces. It can also destroy the initial <ref refid="classinterfaces_1_1_init" kindref="compound">interfaces::Init</ref> object to close the connection and shut down the spawned process.</para>
</listitem></orderedlist>
</para>
<para>When connecting to an existing process, the steps are similar to spawning a new process, except a socket is created instead of a socketpair, and destroying an <ref refid="classinterfaces_1_1_init" kindref="compound">Init</ref> interface doesn&apos;t end the process, since there can be multiple connections. </para>
    </detaileddescription>
    <location file="src/interfaces/ipc.h" line="49" column="1" bodyfile="src/interfaces/ipc.h" bodystart="50" bodyend="91"/>
    <listofallmembers>
      <member refid="classinterfaces_1_1_ipc_1adc17e7ae36bce773070d934e22ab97d7" prot="public" virt="non-virtual"><scope>interfaces::Ipc</scope><name>addCleanup</name></member>
      <member refid="classinterfaces_1_1_ipc_1ab752d262895c2173617749fea06bcba1" prot="protected" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>addCleanup</name></member>
      <member refid="classinterfaces_1_1_ipc_1a8f4b6624f88179cc8e91b0eec3698b45" prot="public" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>connectAddress</name></member>
      <member refid="classinterfaces_1_1_ipc_1aadeee9466f33f2396a7ad52831083f8a" prot="public" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>context</name></member>
      <member refid="classinterfaces_1_1_ipc_1a45306c63b743375d0db4f613d2de7300" prot="public" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>disconnectIncoming</name></member>
      <member refid="classinterfaces_1_1_ipc_1a9c3d57bf43d3d20ace3a4249e6a797b5" prot="public" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>listenAddress</name></member>
      <member refid="classinterfaces_1_1_ipc_1adac82dc623fa04500dcc1c4eee94760b" prot="public" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>spawnProcess</name></member>
      <member refid="classinterfaces_1_1_ipc_1a5e302c6524dd19f78c2efe9a55abd057" prot="public" virt="pure-virtual"><scope>interfaces::Ipc</scope><name>startSpawnedProcess</name></member>
      <member refid="classinterfaces_1_1_ipc_1a901cfb7417e9511e9890c137eb556c18" prot="public" virt="virtual"><scope>interfaces::Ipc</scope><name>~Ipc</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
