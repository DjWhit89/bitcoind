<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classankerl_1_1nanobench_1_1_rng" kind="class" language="C++" prot="public" final="yes">
    <compoundname>ankerl::nanobench::Rng</compoundname>
    <includes refid="nanobench_8h" local="no">nanobench.h</includes>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classankerl_1_1nanobench_1_1_rng_1ae09bda5b21273560a98edf490a2a1172" prot="public" static="no">
        <type>uint64_t</type>
        <definition>using result_type =  uint64_t</definition>
        <argsstring></argsstring>
        <name>result_type</name>
        <qualifiedname>ankerl::nanobench::Rng::result_type</qualifiedname>
        <briefdescription>
<para>This RNG provides 64bit randomness. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="493" column="5" bodyfile="src/bench/nanobench.h" bodystart="493" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classankerl_1_1nanobench_1_1_rng_1a93412c916897640add780dab73f60c0e" prot="private" static="no" mutable="no">
        <type>uint64_t</type>
        <definition>uint64_t mX</definition>
        <argsstring></argsstring>
        <name>mX</name>
        <qualifiedname>ankerl::nanobench::Rng::mX</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="608" column="14" bodyfile="src/bench/nanobench.h" bodystart="608" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classankerl_1_1nanobench_1_1_rng_1a5011b26e77f021ea07bff34c8af56140" prot="private" static="no" mutable="no">
        <type>uint64_t</type>
        <definition>uint64_t mY</definition>
        <argsstring></argsstring>
        <name>mY</name>
        <qualifiedname>ankerl::nanobench::Rng::mY</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="609" column="14" bodyfile="src/bench/nanobench.h" bodystart="609" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a1f7b8e49e5d1e5dbc26ec3440312c373" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t min</definition>
        <argsstring>()</argsstring>
        <name>min</name>
        <qualifiedname>ankerl::nanobench::Rng::min</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="495" column="22" bodyfile="src/bench/nanobench.h" bodystart="1156" bodyend="1158"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1ad9793b70696830eb34deaf0acdf55126" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t max</definition>
        <argsstring>()</argsstring>
        <name>max</name>
        <qualifiedname>ankerl::nanobench::Rng::max</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="496" column="22" bodyfile="src/bench/nanobench.h" bodystart="1160" bodyend="1162"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Rng</definition>
        <argsstring>(Rng const &amp;)=delete</argsstring>
        <name>Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::Rng</qualifiedname>
        <param>
          <type>Rng const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>As a safety precaution, we don&apos;t allow copying. Copying a PRNG would mean you would have two random generators that produce the same sequence, which is generally not what one wants. Instead create a new rng with the default constructor <ref refid="classankerl_1_1nanobench_1_1_rng_1a86f83b16aa4240810ebd8142c2bd984c" kindref="member">Rng()</ref>, which is automatically seeded from <computeroutput>std::random_device</computeroutput>. If you really need a copy, use <computeroutput>copy()</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="503" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a7949f4d69fee86ad2fc555447f2d54bd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" kindref="member">Rng</ref> &amp;</type>
        <definition>Rng &amp; operator=</definition>
        <argsstring>(Rng const &amp;)=delete</argsstring>
        <name>operator=</name>
        <qualifiedname>ankerl::nanobench::Rng::operator=</qualifiedname>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" kindref="member">Rng</ref> const &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as <ref refid="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" kindref="member">Rng(Rng const&amp;)</ref>, we don&apos;t allow assignment. If you need a new <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref> create one with the default constructor <ref refid="classankerl_1_1nanobench_1_1_rng_1a86f83b16aa4240810ebd8142c2bd984c" kindref="member">Rng()</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="508" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a4dd1c2f4418bca511ebd3e0f737ddef6" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>Rng</definition>
        <argsstring>(Rng &amp;&amp;) noexcept=default</argsstring>
        <name>Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::Rng</qualifiedname>
        <param>
          <type>Rng &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="511" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a37cba82ca15ef6a85a942c5c21e15d88" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type><ref refid="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" kindref="member">Rng</ref> &amp;</type>
        <definition>Rng &amp; operator=</definition>
        <argsstring>(Rng &amp;&amp;) noexcept=default</argsstring>
        <name>operator=</name>
        <qualifiedname>ankerl::nanobench::Rng::operator=</qualifiedname>
        <param>
          <type><ref refid="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" kindref="member">Rng</ref> &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="512" column="9"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a77dfb47bddc83f5127f45ac593b111c2" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>~Rng</definition>
        <argsstring>() noexcept=default</argsstring>
        <name>~Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::~Rng</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="513" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a86f83b16aa4240810ebd8142c2bd984c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Rng</definition>
        <argsstring>()</argsstring>
        <name>Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::Rng</qualifiedname>
        <briefdescription>
<para>Creates a new Random generator with random seed. </para>
        </briefdescription>
        <detaileddescription>
<para>Instead of a default seed (as the random generators from the STD), this properly seeds the random generator from <computeroutput>std::random_device</computeroutput>. It guarantees correct seeding. Note that seeding can be relatively slow, depending on the source of randomness used. So it is best to create a <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref> once and use it for all your randomness purposes. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="522" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1aa975b23f442b880e0464b983cbfaa913" prot="public" static="no" const="no" explicit="yes" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>Rng</definition>
        <argsstring>(uint64_t seed) noexcept</argsstring>
        <name>Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::Rng</qualifiedname>
        <param>
          <type>uint64_t</type>
          <declname>seed</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a new <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref> that is seeded with a specific seed. Each <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref> created from the same seed will produce the same randomness sequence. This can be useful for deterministic behavior.</para>
<para><verbatim>embed:rst
.. note::

   The random algorithm might change between nanobench releases. Whenever a faster and/or better random
   generator becomes available, I will switch the implementation.
</verbatim></para>
<para>As per the Romu paper, this seeds the <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref> with splitMix64 algorithm and performs 10 initial rounds for further mixing up of the internal state.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>seed</parametername>
</parameternamelist>
<parameterdescription>
<para>The 64bit seed. All values are allowed, even 0. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="540" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1ae23864321191c777758e0054e5c81038" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>Rng</definition>
        <argsstring>(uint64_t x, uint64_t y) noexcept</argsstring>
        <name>Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::Rng</qualifiedname>
        <param>
          <type>uint64_t</type>
          <declname>x</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>y</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="541" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a377e53f0579d0c9742d3a8e5b458b5e7" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>Rng</definition>
        <argsstring>(std::vector&lt; uint64_t &gt; const &amp;data)</argsstring>
        <name>Rng</name>
        <qualifiedname>ankerl::nanobench::Rng::Rng</qualifiedname>
        <param>
          <type>std::vector&lt; uint64_t &gt; const &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="542" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1ade63acbfc2122333ce5b5d070c036a38" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>ANKERL_NANOBENCH</definition>
        <argsstring>(NODISCARD) Rng copy() const noexcept</argsstring>
        <name>ANKERL_NANOBENCH</name>
        <qualifiedname>ankerl::nanobench::Rng::ANKERL_NANOBENCH</qualifiedname>
        <param>
          <type>NODISCARD</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a copy of the <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref>, thus the copy provides exactly the same random sequence as the original. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="547" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1aa25a7475df9e61004f5c8dc7a950a6a2" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t operator()</definition>
        <argsstring>() noexcept</argsstring>
        <name>operator()</name>
        <qualifiedname>ankerl::nanobench::Rng::operator()</qualifiedname>
        <briefdescription>
<para>Produces a 64bit random value. This should be very fast, thus it is marked as inline. In my benchmark, this is ~46 times faster than <computeroutput>std::default_random_engine</computeroutput> for producing 64bit random values. It seems that the fastest std contender is <computeroutput>std::mt19937_64</computeroutput>. Still, this RNG is 2-3 times as fast. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>uint64_t The next 64 bit random value. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="556" column="21" bodyfile="src/bench/nanobench.h" bodystart="1165" bodyend="1172"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a017c38492f5151d4f5a8566909ca236c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t bounded</definition>
        <argsstring>(uint32_t range) noexcept</argsstring>
        <name>bounded</name>
        <qualifiedname>ankerl::nanobench::Rng::bounded</qualifiedname>
        <param>
          <type>uint32_t</type>
          <declname>range</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Generates a random number between 0 and range (excluding range).</para>
<para>The algorithm only produces 32bit numbers, and is slightly biased. The effect is quite small unless your range is close to the maximum value of an integer. It is possible to correct the bias with rejection sampling (see <ulink url="https://lemire.me/blog/2016/06/30/fast-random-shuffling/">here</ulink>, but this is most likely irrelevant in practices for the purposes of this <ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref>.</para>
<para>See Daniel Lemire&apos;s blog post <ulink url="https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/">A fast alternative to the modulo reduction</ulink></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>range</parametername>
</parameternamelist>
<parameterdescription>
<para>Upper exclusive range. E.g a value of 3 will generate random numbers 0, 1, 2. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>uint32_t Generated random values in range [0, range(. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="574" column="21" bodyfile="src/bench/nanobench.h" bodystart="1175" bodyend="1179"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a7b7654f256407efb2c3ca964fb1c6d45" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>double</type>
        <definition>double uniform01</definition>
        <argsstring>() noexcept</argsstring>
        <name>uniform01</name>
        <qualifiedname>ankerl::nanobench::Rng::uniform01</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Provides a random uniform double value between 0 and 1. This uses the method described in <ulink url="http://prng.di.unimi.it/">Generating uniform doubles in the unit interval</ulink>, and is extremely fast.</para>
<para><simplesect kind="return"><para>double Uniformly distributed double value in range [0,1(, excluding 1. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="585" column="19" bodyfile="src/bench/nanobench.h" bodystart="1181" bodyend="1188"/>
      </memberdef>
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1a2dce85d19b09e36c22400ac47a38ce54" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Container</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void shuffle</definition>
        <argsstring>(Container &amp;container) noexcept</argsstring>
        <name>shuffle</name>
        <qualifiedname>ankerl::nanobench::Rng::shuffle</qualifiedname>
        <param>
          <type>Container &amp;</type>
          <declname>container</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Shuffles all entries in the given container. Although this has a slight bias due to the implementation of <ref refid="classankerl_1_1nanobench_1_1_rng_1a017c38492f5151d4f5a8566909ca236c" kindref="member">bounded()</ref>, this is preferable to <computeroutput>std::shuffle</computeroutput> because it is over 5 times faster. See Daniel Lemire&apos;s blog post <ulink url="https://lemire.me/blog/2016/06/30/fast-random-shuffling/">Fast random shuffling</ulink>.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>container</parametername>
</parameternamelist>
<parameterdescription>
<para>The whole container will be shuffled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="595" column="10" bodyfile="src/bench/nanobench.h" bodystart="1191" bodyend="1203"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-static-func">
      <memberdef kind="function" id="classankerl_1_1nanobench_1_1_rng_1abfb6747614a67e3565d0646b1c833ec4" prot="private" static="yes" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t rotl</definition>
        <argsstring>(uint64_t x, unsigned k) noexcept</argsstring>
        <name>rotl</name>
        <qualifiedname>ankerl::nanobench::Rng::rotl</qualifiedname>
        <param>
          <type>uint64_t</type>
          <declname>x</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>k</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Extracts the full state of the generator, e.g. for serialization. For this RNG this is just 2 values, but to stay API compatible with future implementations that potentially use more state, we use a vector.</para>
<para><simplesect kind="return"><para>Vector containing the full state: </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/bench/nanobench.h" line="606" column="31" bodyfile="src/bench/nanobench.h" bodystart="1206" bodyend="1208"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>An extremely fast random generator. Currently, this implements <emphasis>RomuDuoJr</emphasis>, developed by Mark Overton. Source: <ulink url="http://www.romu-random.org/">http://www.romu-random.org/</ulink></para>
<para>RomuDuoJr is extremely fast and provides reasonable good randomness. Not enough for large jobs, but definitely good enough for a benchmarking framework.</para>
<para><itemizedlist>
<listitem><para>Estimated capacity: <formula id="4">$ 2^{51} $</formula> bytes</para>
</listitem><listitem><para>Register pressure: 4</para>
</listitem><listitem><para><ref refid="headers__sync__chainwork__tests_8cpp_1ae883f65c4951396ab945f766e09e3c94" kindref="member">State</ref> size: 128 bits</para>
</listitem></itemizedlist>
</para>
<para>This random generator is a drop-in replacement for the generators supplied by <computeroutput>&lt;random&gt;</computeroutput>. It is not cryptographically secure. It&apos;s intended purpose is to be very fast so that benchmarks that make use of randomness are not distorted too much by the random generator.</para>
<para><ref refid="classankerl_1_1nanobench_1_1_rng" kindref="compound">Rng</ref> also provides a few non-standard helpers, optimized for speed. </para>
    </detaileddescription>
    <location file="src/bench/nanobench.h" line="488" column="1" bodyfile="src/bench/nanobench.h" bodystart="488" bodyend="610"/>
    <listofallmembers>
      <member refid="classankerl_1_1nanobench_1_1_rng_1ade63acbfc2122333ce5b5d070c036a38" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>ANKERL_NANOBENCH</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a017c38492f5151d4f5a8566909ca236c" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>bounded</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1ad9793b70696830eb34deaf0acdf55126" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>max</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a1f7b8e49e5d1e5dbc26ec3440312c373" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>min</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a93412c916897640add780dab73f60c0e" prot="private" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>mX</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a5011b26e77f021ea07bff34c8af56140" prot="private" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>mY</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1aa25a7475df9e61004f5c8dc7a950a6a2" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>operator()</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a7949f4d69fee86ad2fc555447f2d54bd" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>operator=</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a37cba82ca15ef6a85a942c5c21e15d88" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>operator=</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1ae09bda5b21273560a98edf490a2a1172" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>result_type</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a4f9307a675ebaa03bf39e53f471c4c5b" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>Rng</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a4dd1c2f4418bca511ebd3e0f737ddef6" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>Rng</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a86f83b16aa4240810ebd8142c2bd984c" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>Rng</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1aa975b23f442b880e0464b983cbfaa913" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>Rng</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1ae23864321191c777758e0054e5c81038" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>Rng</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a377e53f0579d0c9742d3a8e5b458b5e7" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>Rng</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1abfb6747614a67e3565d0646b1c833ec4" prot="private" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>rotl</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a2dce85d19b09e36c22400ac47a38ce54" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>shuffle</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a7b7654f256407efb2c3ca964fb1c6d45" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>uniform01</name></member>
      <member refid="classankerl_1_1nanobench_1_1_rng_1a77dfb47bddc83f5127f45ac593b111c2" prot="public" virt="non-virtual"><scope>ankerl::nanobench::Rng</scope><name>~Rng</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
