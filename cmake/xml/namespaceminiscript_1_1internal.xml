<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="namespaceminiscript_1_1internal" kind="namespace" language="C++">
    <compoundname>miniscript::internal</compoundname>
    <innerclass refid="structminiscript_1_1internal_1_1_input_stack" prot="public">miniscript::internal::InputStack</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_input_result" prot="public">miniscript::internal::InputResult</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_max_int" prot="public">miniscript::internal::MaxInt</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_ops" prot="public">miniscript::internal::Ops</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_sat_info" prot="public">miniscript::internal::SatInfo</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_stack_size" prot="public">miniscript::internal::StackSize</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_witness_size" prot="public">miniscript::internal::WitnessSize</innerclass>
    <innerclass refid="structminiscript_1_1internal_1_1_no_dup_check" prot="public">miniscript::internal::NoDupCheck</innerclass>
    <sectiondef kind="enum">
      <memberdef kind="enum" id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797" prot="public" static="no" strong="yes">
        <type></type>
        <name>ParseContext</name>
        <qualifiedname>miniscript::internal::ParseContext</qualifiedname>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797affdbf66764570d272af5ad31f0b40c14" prot="public">
          <name>WRAPPED_EXPR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>An expression which may be begin with wrappers followed by a colon. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797ab0cd8af157ed30eaa1980da18b07a38d" prot="public">
          <name>EXPR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>A miniscript expression which does not begin with wrappers. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a46fc23bc4e4d57e5469a39658a6dd3e8" prot="public">
          <name>SWAP</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>SWAP wraps the top constructed node with s: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797adfbfc9cc7a235560f04cb1a5faf1ec3e" prot="public">
          <name>ALT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ALT wraps the top constructed node with a: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a8c46d8d9d3402788403e2f6911153089" prot="public">
          <name>CHECK</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>CHECK wraps the top constructed node with c: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a9362f0ff4871b693667ba2e4732c02da" prot="public">
          <name>DUP_IF</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>DUP_IF wraps the top constructed node with d: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a0b4c12d7e0a73840c1c4f148fda3b037" prot="public">
          <name>VERIFY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>VERIFY wraps the top constructed node with v: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797ab565263de845e66aad41844b7f3c4946" prot="public">
          <name>NON_ZERO</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>NON_ZERO wraps the top constructed node with j: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797ab531e0f2f7d3b2585765c1fcb46462e5" prot="public">
          <name>ZERO_NOTEQUAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ZERO_NOTEQUAL wraps the top constructed node with n: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797af77bef471d90e08efe428179052325ee" prot="public">
          <name>WRAP_U</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>WRAP_U will construct an or_i(X,0) node from the top constructed node. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797ab7432d88778de12539fbb0b52e51cb3c" prot="public">
          <name>WRAP_T</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>WRAP_T will construct an and_v(X,1) node from the top constructed node. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a2cfc97e25f98c2a4c4d7502e282d0339" prot="public">
          <name>AND_N</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>AND_N will construct an andor(X,Y,0) node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a7a76c8357af82c1900d6308d7855220a" prot="public">
          <name>AND_V</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>AND_V will construct an and_v node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797acac3917c66dfcb0b806a572de3534a11" prot="public">
          <name>AND_B</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>AND_B will construct an and_b node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a477cb9f7a7b9acbe7f0fe8e68e42baec" prot="public">
          <name>ANDOR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ANDOR will construct an andor node from the last three constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a1f1d97cb213675b7c8a6254f9870aa1b" prot="public">
          <name>OR_B</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_B will construct an or_b node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a9b76909336a0f900ad3ed00af720918f" prot="public">
          <name>OR_C</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_C will construct an or_c node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797ac50198187f55e66b8b20e3dcee6e0d38" prot="public">
          <name>OR_D</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_D will construct an or_d node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a00d71ec48b4f106004f0d1e2b521da37" prot="public">
          <name>OR_I</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_I will construct an or_i node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a486f207345522dfc69492f029d832ee8" prot="public">
          <name>THRESH</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>THRESH will read a wrapped expression, and then look for a COMMA. If no comma follows, it will construct a thresh node from the appropriate number of constructed children. Otherwise, it will recurse with another THRESH. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a4d9b3e9fc12849d060371eb65154c751" prot="public">
          <name>COMMA</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>COMMA expects the next element to be &apos;,&apos; and fails if not. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a818d8c9fb081152823a5b0c172a24797a260494f9a3c7deb9951abcb79b25d9cd" prot="public">
          <name>CLOSE_BRACKET</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>CLOSE_BRACKET expects the next element to be &apos;)&apos; and fails if not. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="1693" column="1" bodyfile="src/script/miniscript.h" bodystart="1693" bodyend="1745"/>
      </memberdef>
      <memberdef kind="enum" id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120" prot="public" static="no" strong="yes">
        <type></type>
        <name>DecodeContext</name>
        <qualifiedname>miniscript::internal::DecodeContext</qualifiedname>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a0bb08feb8e58dee36b47e7f69dbdd071" prot="public">
          <name>SINGLE_BKV_EXPR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>A single expression of type B, K, or V. Specifically, this can&apos;t be an and_v or an expression of type W (a: and s: wrappers). </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a283aa64734688ae72214a692b743e135" prot="public">
          <name>BKV_EXPR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>Potentially multiple SINGLE_BKV_EXPRs as children of (potentially multiple) and_v expressions. Syntactic sugar for MAYBE_AND_V + SINGLE_BKV_EXPR. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a501b4566de4741021ed321a1312b8911" prot="public">
          <name>W_EXPR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>An expression of type W (a: or s: wrappers). </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a46fc23bc4e4d57e5469a39658a6dd3e8" prot="public">
          <name>SWAP</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>SWAP expects the next element to be OP_SWAP (inside a W-type expression that didn&apos;t end with FROMALTSTACK), and wraps the top of the constructed stack with s: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120adfbfc9cc7a235560f04cb1a5faf1ec3e" prot="public">
          <name>ALT</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ALT expects the next element to be TOALTSTACK (we must have already read a FROMALTSTACK earlier), and wraps the top of the constructed stack with a: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a8c46d8d9d3402788403e2f6911153089" prot="public">
          <name>CHECK</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>CHECK wraps the top constructed node with c: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a9362f0ff4871b693667ba2e4732c02da" prot="public">
          <name>DUP_IF</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>DUP_IF wraps the top constructed node with d: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a0b4c12d7e0a73840c1c4f148fda3b037" prot="public">
          <name>VERIFY</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>VERIFY wraps the top constructed node with v: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120ab565263de845e66aad41844b7f3c4946" prot="public">
          <name>NON_ZERO</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>NON_ZERO wraps the top constructed node with j: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120ab531e0f2f7d3b2585765c1fcb46462e5" prot="public">
          <name>ZERO_NOTEQUAL</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ZERO_NOTEQUAL wraps the top constructed node with n: </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a399cf171174343d572acc28659acd09e" prot="public">
          <name>MAYBE_AND_V</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>MAYBE_AND_V will check if the next part of the script could be a valid miniscript sub-expression, and if so it will push AND_V and SINGLE_BKV_EXPR to decode it and construct the and_v node. This is recursive, to deal with multiple and_v nodes inside each other. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a7a76c8357af82c1900d6308d7855220a" prot="public">
          <name>AND_V</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>AND_V will construct an and_v node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120acac3917c66dfcb0b806a572de3534a11" prot="public">
          <name>AND_B</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>AND_B will construct an and_b node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a477cb9f7a7b9acbe7f0fe8e68e42baec" prot="public">
          <name>ANDOR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ANDOR will construct an andor node from the last three constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a1f1d97cb213675b7c8a6254f9870aa1b" prot="public">
          <name>OR_B</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_B will construct an or_b node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a9b76909336a0f900ad3ed00af720918f" prot="public">
          <name>OR_C</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_C will construct an or_c node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120ac50198187f55e66b8b20e3dcee6e0d38" prot="public">
          <name>OR_D</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>OR_D will construct an or_d node from the last two constructed nodes. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120ae3f116998858d227c947a282e13cd48c" prot="public">
          <name>THRESH_W</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>In a thresh expression, all sub-expressions other than the first are W-type, and end in OP_ADD. THRESH_W will check for this OP_ADD and either push a W_EXPR or a SINGLE_BKV_EXPR and jump to THRESH_E accordingly. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a813c9a61374c1fd0ee094cad52707059" prot="public">
          <name>THRESH_E</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>THRESH_E constructs a thresh node from the appropriate number of constructed children. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120aa7edf885402c37993bf4581db4a4615c" prot="public">
          <name>ENDIF</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>ENDIF signals that we are inside some sort of OP_IF structure, which could be or_d, or_c, or_i, andor, d:, or j: wrapper, depending on what follows. We read a BKV_EXPR and then deal with the next opcode case-by-case. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a21b3adcdd2d9ae386725d2ad703bcc62" prot="public">
          <name>ENDIF_NOTIF</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>If, inside an ENDIF context, we find an OP_NOTIF before finding an OP_ELSE, we could either be in an or_d or an or_c node. We then check for IFDUP to distinguish these cases. </para>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespaceminiscript_1_1internal_1a662e0956f5f3efaa37e9d39516998120a3589f9f38556db84215ee9037f5cf84c" prot="public">
          <name>ENDIF_ELSE</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
<para>If, inside an ENDIF context, we find an OP_ELSE, then we could be in either an or_i or an andor node. Read the next BKV_EXPR and find either an OP_IF or an OP_NOTIF. </para>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="2182" column="1" bodyfile="src/script/miniscript.h" bodystart="2182" bodyend="2248"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1ae625a420ca4c6f94e474ab10411847b4" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t MAX_TAPMINISCRIPT_STACK_ELEM_SIZE</definition>
        <argsstring></argsstring>
        <name>MAX_TAPMINISCRIPT_STACK_ELEM_SIZE</name>
        <qualifiedname>miniscript::internal::MAX_TAPMINISCRIPT_STACK_ELEM_SIZE</qualifiedname>
        <initializer>{65}</initializer>
        <briefdescription>
<para>The maximum size of a witness item for a Miniscript under Tapscript context. (A BIP340 signature with a sighash type byte.). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="257" column="27" bodyfile="src/script/miniscript.h" bodystart="257" bodyend="257"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1a65e769dad36af5863e82900834035fd8" prot="public" static="no" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t TX_OVERHEAD</definition>
        <argsstring></argsstring>
        <name>TX_OVERHEAD</name>
        <qualifiedname>miniscript::internal::TX_OVERHEAD</qualifiedname>
        <initializer>{4 + 4}</initializer>
        <briefdescription>
<para>version + nLockTime </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="260" column="20" bodyfile="src/script/miniscript.h" bodystart="260" bodyend="260"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1acf16aac084d691145181a6a43004e92c" prot="public" static="no" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t TXIN_BYTES_NO_WITNESS</definition>
        <argsstring></argsstring>
        <name>TXIN_BYTES_NO_WITNESS</name>
        <qualifiedname>miniscript::internal::TXIN_BYTES_NO_WITNESS</qualifiedname>
        <initializer>{36 + 4 + 1}</initializer>
        <briefdescription>
<para>prevout + nSequence + scriptSig </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="262" column="20" bodyfile="src/script/miniscript.h" bodystart="262" bodyend="262"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1aa85394e8d5ea4494250ed2fb6599817c" prot="public" static="no" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t P2WSH_TXOUT_BYTES</definition>
        <argsstring></argsstring>
        <name>P2WSH_TXOUT_BYTES</name>
        <qualifiedname>miniscript::internal::P2WSH_TXOUT_BYTES</qualifiedname>
        <initializer>{8 + 1 + 1 + 33}</initializer>
        <briefdescription>
<para>nValue + script len + OP_0 + pushdata 32. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="264" column="20" bodyfile="src/script/miniscript.h" bodystart="264" bodyend="264"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1aa9b8628beb4eac08bad4c6bdd679f881" prot="public" static="no" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t TX_BODY_LEEWAY_WEIGHT</definition>
        <argsstring></argsstring>
        <name>TX_BODY_LEEWAY_WEIGHT</name>
        <qualifiedname>miniscript::internal::TX_BODY_LEEWAY_WEIGHT</qualifiedname>
        <initializer>{(<ref refid="namespaceminiscript_1_1internal_1a65e769dad36af5863e82900834035fd8" kindref="member">TX_OVERHEAD</ref> + <ref refid="serialize_8h_1a10a4e43c0ccd0b8a271c2722eb19d6cf" kindref="member">GetSizeOfCompactSize</ref>(1) + <ref refid="namespaceminiscript_1_1internal_1acf16aac084d691145181a6a43004e92c" kindref="member">TXIN_BYTES_NO_WITNESS</ref> + <ref refid="serialize_8h_1a10a4e43c0ccd0b8a271c2722eb19d6cf" kindref="member">GetSizeOfCompactSize</ref>(1) + <ref refid="namespaceminiscript_1_1internal_1aa85394e8d5ea4494250ed2fb6599817c" kindref="member">P2WSH_TXOUT_BYTES</ref>) * WITNESS_SCALE_FACTOR + 2}</initializer>
        <briefdescription>
<para>Data other than the witness in a transaction. Overhead + vin count + one vin + vout count + one vout + segwit marker. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="266" column="20" bodyfile="src/script/miniscript.h" bodystart="266" bodyend="266"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1aa226c9e93b1157c353529298a3bd527e" prot="public" static="no" constexpr="yes" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t MAX_TAPSCRIPT_SAT_SIZE</definition>
        <argsstring></argsstring>
        <name>MAX_TAPSCRIPT_SAT_SIZE</name>
        <qualifiedname>miniscript::internal::MAX_TAPSCRIPT_SAT_SIZE</qualifiedname>
        <initializer>{<ref refid="serialize_8h_1a10a4e43c0ccd0b8a271c2722eb19d6cf" kindref="member">GetSizeOfCompactSize</ref>(MAX_STACK_SIZE) + (<ref refid="serialize_8h_1a10a4e43c0ccd0b8a271c2722eb19d6cf" kindref="member">GetSizeOfCompactSize</ref>(MAX_TAPMINISCRIPT_STACK_ELEM_SIZE) + MAX_TAPMINISCRIPT_STACK_ELEM_SIZE) * MAX_STACK_SIZE + <ref refid="serialize_8h_1a10a4e43c0ccd0b8a271c2722eb19d6cf" kindref="member">GetSizeOfCompactSize</ref>(TAPROOT_CONTROL_MAX_SIZE) + TAPROOT_CONTROL_MAX_SIZE}</initializer>
        <briefdescription>
<para>Maximum possible stack size to spend a Taproot output (excluding the script itself). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="268" column="20" bodyfile="src/script/miniscript.h" bodystart="268" bodyend="268"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1add42cb69a3f099b3eabe1018d05e9587" prot="public" static="yes" mutable="no">
        <type>const auto</type>
        <definition>const auto ZERO</definition>
        <argsstring></argsstring>
        <name>ZERO</name>
        <qualifiedname>miniscript::internal::ZERO</qualifiedname>
        <initializer>= <ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref>(std::vector&lt;unsigned char&gt;())</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A stack consisting of a single zero-length element (interpreted as 0 by the script interpreter in numeric context). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="331" column="19" bodyfile="src/script/miniscript.h" bodystart="331" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1a4097374bec9db43d48df40b9fe6b218a" prot="public" static="yes" mutable="no">
        <type>const auto</type>
        <definition>const auto ZERO32</definition>
        <argsstring></argsstring>
        <name>ZERO32</name>
        <qualifiedname>miniscript::internal::ZERO32</qualifiedname>
        <initializer>= <ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref>(std::vector&lt;unsigned char&gt;(32, 0)).SetMalleable()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A stack consisting of a single malleable 32-byte 0x0000...0000 element (for dissatisfying hash challenges). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="333" column="19" bodyfile="src/script/miniscript.h" bodystart="333" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1a0a36b8db74ed0a8d9a73db66eea95e2d" prot="public" static="yes" mutable="no">
        <type>const auto</type>
        <definition>const auto ONE</definition>
        <argsstring></argsstring>
        <name>ONE</name>
        <qualifiedname>miniscript::internal::ONE</qualifiedname>
        <initializer>= <ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref>(<ref refid="vector_8h_1a99cbb5fac6b713705162f5c56079defb" kindref="member">Vector</ref>((unsigned char)1))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A stack consisting of a single 0x01 element (interpreted as 1 by the script interpreted in numeric context). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="335" column="19" bodyfile="src/script/miniscript.h" bodystart="335" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1a148449e305260bf058b6127353fcdd3a" prot="public" static="yes" mutable="no">
        <type>const auto</type>
        <definition>const auto EMPTY</definition>
        <argsstring></argsstring>
        <name>EMPTY</name>
        <qualifiedname>miniscript::internal::EMPTY</qualifiedname>
        <initializer>= <ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref>()</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The empty stack. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="337" column="19" bodyfile="src/script/miniscript.h" bodystart="337" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespaceminiscript_1_1internal_1acd668c12962528215a17963c3ba8dfd1" prot="public" static="yes" mutable="no">
        <type>const auto</type>
        <definition>const auto INVALID</definition>
        <argsstring></argsstring>
        <name>INVALID</name>
        <qualifiedname>miniscript::internal::INVALID</qualifiedname>
        <initializer>= <ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref>().SetAvailable(<ref refid="namespaceminiscript_1adfd5523d4b709d5e28349355e79255dbac2f3f489a00553e7a01d369c103c7251" kindref="member">Availability::NO</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A stack representing the lack of any (dis)satisfactions. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="339" column="19" bodyfile="src/script/miniscript.h" bodystart="339" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a1fed685d02fc4884793f8741d0e6b7fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
        <definition>Type SanitizeType</definition>
        <argsstring>(Type x)</argsstring>
        <name>SanitizeType</name>
        <qualifiedname>miniscript::internal::SanitizeType</qualifiedname>
        <param>
          <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>A helper sanitizer/checker for the output of CalcType. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="19" column="6" bodyfile="src/script/miniscript.cpp" bodystart="19" bodyend="37" declfile="src/script/miniscript.h" declline="291" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1afd3834c03c09b76fef4206cf2ac9832a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
        <definition>Type ComputeType</definition>
        <argsstring>(Fragment fragment, Type x, Type y, Type z, const std::vector&lt; Type &gt; &amp;sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys, MiniscriptContext ms_ctx)</argsstring>
        <name>ComputeType</name>
        <qualifiedname>miniscript::internal::ComputeType</qualifiedname>
        <param>
          <type><ref refid="namespaceminiscript_1a02db2bde67db0cee6704064a541c67f8" kindref="member">Fragment</ref></type>
          <declname>fragment</declname>
        </param>
        <param>
          <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
          <declname>y</declname>
        </param>
        <param>
          <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
          <declname>z</declname>
        </param>
        <param>
          <type>const std::vector&lt; <ref refid="classminiscript_1_1_type" kindref="compound">Type</ref> &gt; &amp;</type>
          <declname>sub_types</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>k</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>data_size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n_subs</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n_keys</declname>
        </param>
        <param>
          <type><ref refid="namespaceminiscript_1a2bd485f92f346bb2c8cb4189d22e1530" kindref="member">MiniscriptContext</ref></type>
          <declname>ms_ctx</declname>
        </param>
        <briefdescription>
<para>Helper function for Node::CalcType. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="39" column="6" bodyfile="src/script/miniscript.cpp" bodystart="39" bodyend="262" declfile="src/script/miniscript.h" declline="285" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1ae9c0cb5830356826ee6c21d660a0b2d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t ComputeScriptLen</definition>
        <argsstring>(Fragment fragment, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys, MiniscriptContext ms_ctx)</argsstring>
        <name>ComputeScriptLen</name>
        <qualifiedname>miniscript::internal::ComputeScriptLen</qualifiedname>
        <param>
          <type><ref refid="namespaceminiscript_1a02db2bde67db0cee6704064a541c67f8" kindref="member">Fragment</ref></type>
          <declname>fragment</declname>
        </param>
        <param>
          <type><ref refid="classminiscript_1_1_type" kindref="compound">Type</ref></type>
          <declname>sub0typ</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>subsize</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>k</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n_subs</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n_keys</declname>
        </param>
        <param>
          <type><ref refid="namespaceminiscript_1a2bd485f92f346bb2c8cb4189d22e1530" kindref="member">MiniscriptContext</ref></type>
          <declname>ms_ctx</declname>
        </param>
        <briefdescription>
<para>Helper function for Node::CalcScriptLen. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="264" column="8" bodyfile="src/script/miniscript.cpp" bodystart="264" bodyend="296" declfile="src/script/miniscript.h" declline="288" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a2527309fc564f01a8c0f44c517a70c1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref></type>
        <definition>InputStack operator+</definition>
        <argsstring>(InputStack a, InputStack b)</argsstring>
        <name>operator+</name>
        <qualifiedname>miniscript::internal::operator+</qualifiedname>
        <param>
          <type><ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="325" column="12" bodyfile="src/script/miniscript.cpp" bodystart="325" bodyend="337"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a1be38e45874ee0171f2e2348dee43224" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref></type>
        <definition>InputStack operator|</definition>
        <argsstring>(InputStack a, InputStack b)</argsstring>
        <name>operator|</name>
        <qualifiedname>miniscript::internal::operator|</qualifiedname>
        <param>
          <type><ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref></type>
          <declname>a</declname>
        </param>
        <param>
          <type><ref refid="structminiscript_1_1internal_1_1_input_stack" kindref="compound">InputStack</ref></type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="339" column="12" bodyfile="src/script/miniscript.cpp" bodystart="339" bodyend="366"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a45e054ec7e9dc5a8a4916e3d429f0a09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; std::vector&lt; <ref refid="namespaceminiscript_1ab0abbcdd9979ef4a39267be0c2d39c52" kindref="member">Opcode</ref> &gt; &gt;</type>
        <definition>std::optional&lt; std::vector&lt; Opcode &gt; &gt; DecomposeScript</definition>
        <argsstring>(const CScript &amp;script)</argsstring>
        <name>DecomposeScript</name>
        <qualifiedname>miniscript::internal::DecomposeScript</qualifiedname>
        <param>
          <type>const <ref refid="class_c_script" kindref="compound">CScript</ref> &amp;</type>
          <declname>script</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Decode a script into opcode/push pairs.</para>
<para>Construct a vector with one element per opcode in the script, in reverse order. Each element is a pair consisting of the opcode, as well as the data pushed by the opcode (including OP_n), if any. OP_CHECKSIGVERIFY, OP_CHECKMULTISIGVERIFY, OP_NUMEQUALVERIFY and OP_EQUALVERIFY are decomposed into OP_CHECKSIG, OP_CHECKMULTISIG, OP_EQUAL and OP_NUMEQUAL respectively, plus OP_VERIFY. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="368" column="15" bodyfile="src/script/miniscript.cpp" bodystart="368" bodyend="406" declfile="src/script/miniscript.h" declline="2177" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a8fd863aeff13a9b9cb1ba5f4bb80d64a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; int64_t &gt;</type>
        <definition>std::optional&lt; int64_t &gt; ParseScriptNumber</definition>
        <argsstring>(const Opcode &amp;in)</argsstring>
        <name>ParseScriptNumber</name>
        <qualifiedname>miniscript::internal::ParseScriptNumber</qualifiedname>
        <param>
          <type>const <ref refid="namespaceminiscript_1ab0abbcdd9979ef4a39267be0c2d39c52" kindref="member">Opcode</ref> &amp;</type>
          <declname>in</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determine whether the passed pair (created by DecomposeScript) is pushing a number. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="408" column="15" bodyfile="src/script/miniscript.cpp" bodystart="408" bodyend="419" declfile="src/script/miniscript.h" declline="2180" declcolumn="15"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a48c96686b2bb4f946e85ab992906df82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int FindNextChar</definition>
        <argsstring>(std::span&lt; const char &gt; sp, const char m)</argsstring>
        <name>FindNextChar</name>
        <qualifiedname>miniscript::internal::FindNextChar</qualifiedname>
        <param>
          <type>std::span&lt; const char &gt;</type>
          <declname>sp</declname>
        </param>
        <param>
          <type>const char</type>
          <declname>m</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.cpp" line="421" column="5" bodyfile="src/script/miniscript.cpp" bodystart="421" bodyend="429" declfile="src/script/miniscript.h" declline="1747" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a0f146e7f191b495aa49d8004ee6bc6c0" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t MaxScriptSize</definition>
        <argsstring>(MiniscriptContext ms_ctx)</argsstring>
        <name>MaxScriptSize</name>
        <qualifiedname>miniscript::internal::MaxScriptSize</qualifiedname>
        <param>
          <type><ref refid="namespaceminiscript_1a2bd485f92f346bb2c8cb4189d22e1530" kindref="member">MiniscriptContext</ref></type>
          <declname>ms_ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The maximum size of a script depending on the context. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="270" column="20" bodyfile="src/script/miniscript.h" bodystart="270" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a3d2bae5ee8cc452fa1bb61ba930230a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Key</type>
          </param>
          <param>
            <type>typename Ctx</type>
          </param>
        </templateparamlist>
        <type>std::optional&lt; std::pair&lt; Key, int &gt; &gt;</type>
        <definition>std::optional&lt; std::pair&lt; Key, int &gt; &gt; ParseKeyEnd</definition>
        <argsstring>(std::span&lt; const char &gt; in, const Ctx &amp;ctx)</argsstring>
        <name>ParseKeyEnd</name>
        <qualifiedname>miniscript::internal::ParseKeyEnd</qualifiedname>
        <param>
          <type>std::span&lt; const char &gt;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>const Ctx &amp;</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a key string ending at the end of the fragment&apos;s text representation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="1751" column="15" bodyfile="src/script/miniscript.h" bodystart="1751" bodyend="1758"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a3cf348a8b6d27e520e49a0650dd4293b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Ctx</type>
          </param>
        </templateparamlist>
        <type>std::optional&lt; std::pair&lt; std::vector&lt; unsigned char &gt;, int &gt; &gt;</type>
        <definition>std::optional&lt; std::pair&lt; std::vector&lt; unsigned char &gt;, int &gt; &gt; ParseHexStrEnd</definition>
        <argsstring>(std::span&lt; const char &gt; in, const size_t expected_size, const Ctx &amp;ctx)</argsstring>
        <name>ParseHexStrEnd</name>
        <qualifiedname>miniscript::internal::ParseHexStrEnd</qualifiedname>
        <param>
          <type>std::span&lt; const char &gt;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>expected_size</declname>
        </param>
        <param>
          <type>const Ctx &amp;</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a hex string ending at the end of the fragment&apos;s text representation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="1762" column="15" bodyfile="src/script/miniscript.h" bodystart="1762" bodyend="1772"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a580ea2b864383986772d0a1916961ad8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Key</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void BuildBack</definition>
        <argsstring>(const MiniscriptContext script_ctx, Fragment nt, std::vector&lt; NodeRef&lt; Key &gt; &gt; &amp;constructed, const bool reverse=false)</argsstring>
        <name>BuildBack</name>
        <qualifiedname>miniscript::internal::BuildBack</qualifiedname>
        <param>
          <type>const <ref refid="namespaceminiscript_1a2bd485f92f346bb2c8cb4189d22e1530" kindref="member">MiniscriptContext</ref></type>
          <declname>script_ctx</declname>
        </param>
        <param>
          <type><ref refid="namespaceminiscript_1a02db2bde67db0cee6704064a541c67f8" kindref="member">Fragment</ref></type>
          <declname>nt</declname>
        </param>
        <param>
          <type>std::vector&lt; <ref refid="namespaceminiscript_1a91465934fc510031f3ef3ecad7414a22" kindref="member">NodeRef</ref>&lt; Key &gt; &gt; &amp;</type>
          <declname>constructed</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>reverse</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>BuildBack pops the last two elements off <computeroutput>constructed</computeroutput> and wraps them in the specified <ref refid="namespaceminiscript_1a02db2bde67db0cee6704064a541c67f8" kindref="member">Fragment</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="1776" column="6" bodyfile="src/script/miniscript.h" bodystart="1776" bodyend="1785"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1acd3fd7352ca25025425ba3750883d99b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Key</type>
          </param>
          <param>
            <type>typename Ctx</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceminiscript_1a91465934fc510031f3ef3ecad7414a22" kindref="member">NodeRef</ref>&lt; Key &gt;</type>
        <definition>NodeRef&lt; Key &gt; Parse</definition>
        <argsstring>(std::span&lt; const char &gt; in, const Ctx &amp;ctx)</argsstring>
        <name>Parse</name>
        <qualifiedname>miniscript::internal::Parse</qualifiedname>
        <param>
          <type>std::span&lt; const char &gt;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>const Ctx &amp;</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a miniscript from its textual descriptor form. This does not check whether the script is valid, let alone sane. The caller is expected to use the <computeroutput>IsValidTopLevel()</computeroutput> and <computeroutput>IsSaneTopLevel()</computeroutput> to check for these properties on the node. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="1793" column="16" bodyfile="src/script/miniscript.h" bodystart="1793" bodyend="2167"/>
      </memberdef>
      <memberdef kind="function" id="namespaceminiscript_1_1internal_1a19befff2813793a5dd5dbc5a2d691888" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Key</type>
          </param>
          <param>
            <type>typename Ctx</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
        </templateparamlist>
        <type><ref refid="namespaceminiscript_1a91465934fc510031f3ef3ecad7414a22" kindref="member">NodeRef</ref>&lt; Key &gt;</type>
        <definition>NodeRef&lt; Key &gt; DecodeScript</definition>
        <argsstring>(I &amp;in, I last, const Ctx &amp;ctx)</argsstring>
        <name>DecodeScript</name>
        <qualifiedname>miniscript::internal::DecodeScript</qualifiedname>
        <param>
          <type>I &amp;</type>
          <declname>in</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>const Ctx &amp;</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Parse a miniscript from a bitcoin script. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>In the following wrappers, we only need to push SINGLE_BKV_EXPR rather than BKV_EXPR, because and_v commutes with these wrappers. For example, c:and_v(X,Y) produces the same script as and_v(X,c:Y).</para>
<para>In and_b and or_b nodes, we only look for SINGLE_BKV_EXPR, because or_b(and_v(X,Y),Z) has script [X] [Y] [Z] OP_BOOLOR, the same as and_v(X,or_b(Y,Z)). In this example, the former of these is invalid as miniscript, while the latter is valid. So we leave the and_v &quot;outside&quot; while decoding.</para>
        </inbodydescription>
        <location file="src/script/miniscript.h" line="2252" column="16" bodyfile="src/script/miniscript.h" bodystart="2252" bodyend="2636"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/script/miniscript.cpp" line="17" column="1"/>
  </compounddef>
</doxygen>
