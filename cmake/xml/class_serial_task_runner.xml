<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_serial_task_runner" kind="class" language="C++" prot="public">
    <compoundname>SerialTaskRunner</compoundname>
    <basecompoundref refid="classutil_1_1_task_runner_interface" prot="public" virt="non-virtual">TaskRunnerInterface</basecompoundref>
    <includes refid="scheduler_8h" local="no">scheduler.h</includes>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_serial_task_runner_1a1ad32372359918eff1fc3e087219996a" prot="private" static="no" mutable="no">
        <type><ref refid="class_c_scheduler" kindref="compound">CScheduler</ref> &amp;</type>
        <definition>CScheduler&amp; m_scheduler</definition>
        <argsstring></argsstring>
        <name>m_scheduler</name>
        <qualifiedname>SerialTaskRunner::m_scheduler</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="127" column="16" bodyfile="src/scheduler.h" bodystart="127" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_serial_task_runner_1a93eeeb2d35600448a4d1a04723438696" prot="private" static="no" mutable="no">
        <type><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref></type>
        <definition>Mutex m_callbacks_mutex</definition>
        <argsstring></argsstring>
        <name>m_callbacks_mutex</name>
        <qualifiedname>SerialTaskRunner::m_callbacks_mutex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="129" column="11" bodyfile="src/scheduler.h" bodystart="129" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_serial_task_runner_1a845b5605047acc23859ef57c3bf2df6d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::list&lt; std::function&lt; void()&gt; &gt; m_callbacks_pending</type>
        <definition>std::list&lt; std::function&lt; void()&gt; &gt; m_callbacks_pending GUARDED_BY</definition>
        <argsstring>(m_callbacks_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>SerialTaskRunner::GUARDED_BY</qualifiedname>
        <param>
          <type>m_callbacks_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="134" column="35"/>
      </memberdef>
      <memberdef kind="function" id="class_serial_task_runner_1a94975456cefd7a65eb7bff1b0b901de6" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool m_are_callbacks_running</type>
        <definition>bool m_are_callbacks_running GUARDED_BY</definition>
        <argsstring>(m_callbacks_mutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>SerialTaskRunner::GUARDED_BY</qualifiedname>
        <param>
          <type>m_callbacks_mutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="135" column="34"/>
      </memberdef>
      <memberdef kind="function" id="class_serial_task_runner_1ad6eff83f04de6db68b647af27ba0bda1" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void MaybeScheduleProcessQueue</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!m_callbacks_mutex)</argsstring>
        <name>MaybeScheduleProcessQueue</name>
        <qualifiedname>SerialTaskRunner::MaybeScheduleProcessQueue</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="137" column="10" bodyfile="src/scheduler.cpp" bodystart="132" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="class_serial_task_runner_1ad08e73e427a7b47ddb633a7e8338d521" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ProcessQueue</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!m_callbacks_mutex)</argsstring>
        <name>ProcessQueue</name>
        <qualifiedname>SerialTaskRunner::ProcessQueue</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="138" column="10" bodyfile="src/scheduler.cpp" bodystart="145" bodyend="174"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_serial_task_runner_1af7f45abc57e073f1878e92f83067e6e8" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>SerialTaskRunner</definition>
        <argsstring>(CScheduler &amp;scheduler LIFETIMEBOUND)</argsstring>
        <name>SerialTaskRunner</name>
        <qualifiedname>SerialTaskRunner::SerialTaskRunner</qualifiedname>
        <param>
          <type><ref refid="class_c_scheduler" kindref="compound">CScheduler</ref> &amp;scheduler</type>
          <declname>LIFETIMEBOUND</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="141" column="14" bodyfile="src/scheduler.h" bodystart="141" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="class_serial_task_runner_1a24b3cba006ccdd9bfa1ea82e55126688" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void insert</definition>
        <argsstring>(std::function&lt; void()&gt; func) override EXCLUSIVE_LOCKS_REQUIRED(!m_callbacks_mutex)</argsstring>
        <name>insert</name>
        <qualifiedname>SerialTaskRunner::insert</qualifiedname>
        <reimplements refid="classutil_1_1_task_runner_interface_1a6eb0f1e7bed3d6832bf23c68138c6956">insert</reimplements>
        <param>
          <type>std::function&lt; void()&gt;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a callback to be executed. Callbacks are executed serially and memory is release-acquire consistent between callback executions. Practically, this means that callbacks can behave as if they are executed in order by a single thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="149" column="10" bodyfile="src/scheduler.cpp" bodystart="176" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="class_serial_task_runner_1a12bf766b6af12f2b5b0b8c689428477b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void flush</definition>
        <argsstring>() override EXCLUSIVE_LOCKS_REQUIRED(!m_callbacks_mutex)</argsstring>
        <name>flush</name>
        <qualifiedname>SerialTaskRunner::flush</qualifiedname>
        <reimplements refid="classutil_1_1_task_runner_interface_1a50ab71f4bc571f6e246b20db4b3dd131">flush</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Processes all remaining queue members on the calling thread, blocking until queue is empty Must be called after the <ref refid="class_c_scheduler" kindref="compound">CScheduler</ref> has no remaining processing threads! </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="155" column="10" bodyfile="src/scheduler.cpp" bodystart="185" bodyend="194"/>
      </memberdef>
      <memberdef kind="function" id="class_serial_task_runner_1afb6c687105362d1ec6906d7834cccf8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>size_t size</definition>
        <argsstring>() override EXCLUSIVE_LOCKS_REQUIRED(!m_callbacks_mutex)</argsstring>
        <name>size</name>
        <qualifiedname>SerialTaskRunner::size</qualifiedname>
        <reimplements refid="classutil_1_1_task_runner_interface_1a56d807462b9d24ed3ac7ff22a5418953">size</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the number of currently pending events. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="157" column="12" bodyfile="src/scheduler.cpp" bodystart="196" bodyend="200"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Class used by <ref refid="class_c_scheduler" kindref="compound">CScheduler</ref> clients which may schedule multiple jobs which are required to be run serially. Jobs may not be run on the same thread, but no two jobs will be executed at the same time and memory will be release-acquire consistent (the scheduler will internally do an acquire before invoking a callback as well as a release at the end). In practice this means that a callback <ref refid="util__tests_8cpp_1a111da81ae5883147168bbb8366377b10" kindref="member">B()</ref> will be able to observe all of the effects of callback A() which executed before it. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>SerialTaskRunner</label>
        <link refid="class_serial_task_runner"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>TaskRunnerInterface</label>
        <link refid="classutil_1_1_task_runner_interface"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="1">
        <label>SerialTaskRunner</label>
        <link refid="class_serial_task_runner"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>TaskRunnerInterface</label>
        <link refid="classutil_1_1_task_runner_interface"/>
      </node>
    </collaborationgraph>
    <location file="src/scheduler.h" line="124" column="1" bodyfile="src/scheduler.h" bodystart="125" bodyend="158"/>
    <listofallmembers>
      <member refid="class_serial_task_runner_1a12bf766b6af12f2b5b0b8c689428477b" prot="public" virt="virtual"><scope>SerialTaskRunner</scope><name>flush</name></member>
      <member refid="class_serial_task_runner_1a845b5605047acc23859ef57c3bf2df6d" prot="private" virt="non-virtual"><scope>SerialTaskRunner</scope><name>GUARDED_BY</name></member>
      <member refid="class_serial_task_runner_1a94975456cefd7a65eb7bff1b0b901de6" prot="private" virt="non-virtual"><scope>SerialTaskRunner</scope><name>GUARDED_BY</name></member>
      <member refid="class_serial_task_runner_1a24b3cba006ccdd9bfa1ea82e55126688" prot="public" virt="virtual"><scope>SerialTaskRunner</scope><name>insert</name></member>
      <member refid="class_serial_task_runner_1a93eeeb2d35600448a4d1a04723438696" prot="private" virt="non-virtual"><scope>SerialTaskRunner</scope><name>m_callbacks_mutex</name></member>
      <member refid="class_serial_task_runner_1a1ad32372359918eff1fc3e087219996a" prot="private" virt="non-virtual"><scope>SerialTaskRunner</scope><name>m_scheduler</name></member>
      <member refid="class_serial_task_runner_1ad6eff83f04de6db68b647af27ba0bda1" prot="private" virt="non-virtual"><scope>SerialTaskRunner</scope><name>MaybeScheduleProcessQueue</name></member>
      <member refid="class_serial_task_runner_1ad08e73e427a7b47ddb633a7e8338d521" prot="private" virt="non-virtual"><scope>SerialTaskRunner</scope><name>ProcessQueue</name></member>
      <member refid="class_serial_task_runner_1af7f45abc57e073f1878e92f83067e6e8" prot="public" virt="non-virtual"><scope>SerialTaskRunner</scope><name>SerialTaskRunner</name></member>
      <member refid="class_serial_task_runner_1afb6c687105362d1ec6906d7834cccf8f" prot="public" virt="virtual"><scope>SerialTaskRunner</scope><name>size</name></member>
      <member refid="classutil_1_1_task_runner_interface_1aff8f57e0f902bcda2f2de5f0f1d7a375" prot="public" virt="virtual"><scope>SerialTaskRunner</scope><name>~TaskRunnerInterface</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
