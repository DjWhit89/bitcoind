<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="structmp_1_1_proxy_client_3_01_thread_01_4" kind="struct" language="C++" prot="public">
    <compoundname>mp::ProxyClient&lt; Thread &gt;</compoundname>
    <basecompoundref refid="classmp_1_1_proxy_client_base" prot="public" virt="non-virtual">ProxyClientBase&lt; Thread, ::capnp::Void &gt;</basecompoundref>
    <includes refid="proxy-io_8h" local="no">proxy-io.h</includes>
    <templateparamlist>
    </templateparamlist>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structmp_1_1_proxy_client_3_01_thread_01_4_1a36bc04dbcc8122bc405076c2bd588f7a" prot="public" static="no" mutable="no">
        <type>std::optional&lt; <ref refid="namespacemp_1a5922c1e79ba82f5eb46c5cd0bfc69966" kindref="member">CleanupIt</ref> &gt;</type>
        <definition>std::optional&lt;CleanupIt&gt; m_disconnect_cb</definition>
        <argsstring></argsstring>
        <name>m_disconnect_cb</name>
        <qualifiedname>mp::ProxyClient&lt; Thread &gt;::m_disconnect_cb</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Reference to callback function that is run if there is a sudden disconnect and the <ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> object is destroyed before this <ref refid="structmp_1_1_proxy_client_3_01_thread_01_4" kindref="compound">ProxyClient&lt;Thread&gt;</ref> object. The callback will destroy this object and remove its entry from the thread&apos;s request_threads or callback_threads map. It will also reset m_disconnect_cb so the destructor does not access it. In the normal case where there is no sudden disconnect, the destructor will unregister m_disconnect_cb so the callback is never run. Since this variable is accessed from multiple threads, accesses should be guarded with the associated <ref refid="structmp_1_1_waiter_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">Waiter::m_mutex</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="78" column="19" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="78" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="structmp_1_1_proxy_client_3_01_thread_01_4_1acdc11ed333f47511007a0554f529e05b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ProxyClient</definition>
        <argsstring>(const ProxyClient &amp;)=delete</argsstring>
        <name>ProxyClient</name>
        <qualifiedname>mp::ProxyClient&lt; Thread &gt;::ProxyClient</qualifiedname>
        <param>
          <type>const ProxyClient &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="66" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_proxy_client_3_01_thread_01_4_1a20e57d0d84ee9d0282a79764462d5568" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~ProxyClient</definition>
        <argsstring>()</argsstring>
        <name>~ProxyClient</name>
        <qualifiedname>mp::ProxyClient&lt; Thread &gt;::~ProxyClient</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="67" column="5" bodyfile="src/ipc/libmultiprocess/src/mp/proxy.cpp" bodystart="347" bodyend="363"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_proxy_client_3_01_thread_01_4_1a32f6c2ed2bf7fd1668e2d5c3e5256682" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ProxyClientBase</definition>
        <argsstring>(typename Interface::Client client, Connection *connection, bool destroy_connection)</argsstring>
        <name>ProxyClientBase</name>
        <qualifiedname>mp::ProxyClient&lt; Thread &gt;::ProxyClientBase</qualifiedname>
        <param>
          <type>typename Interface::Client</type>
          <declname>client</declname>
        </param>
        <param>
          <type><ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> *</type>
          <declname>connection</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>destroy_connection</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct libmultiprocess client object wrapping Cap&apos;n Proto client object with a reference to the associated <ref refid="classmp_1_1_connection" kindref="compound">mp::Connection</ref> object.</para>
<para>The destroy_connection option determines whether destroying this client object closes the connection. It is set to true for the ProxyClient&lt;InitInterface&gt; object returned by ConnectStream, to let IPC clients close the connection by freeing the object. It is false for other client objects so they can be destroyed without affecting the connection. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="64" column="5" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="454" bodyend="511"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>ProxyClient&lt; Thread &gt;</label>
        <link refid="structmp_1_1_proxy_client_3_01_thread_01_4"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>Void</label>
      </node>
      <node id="2">
        <label>ProxyClientBase&lt; Thread, ::capnp::Void &gt;</label>
        <link refid="classmp_1_1_proxy_client_base"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="8">
        <label>AnnotatedMixin&lt; std::mutex &gt;</label>
        <link refid="class_annotated_mixin"/>
        <childnode refid="9" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>ProxyClient&lt; Thread &gt;</label>
        <link refid="structmp_1_1_proxy_client_3_01_thread_01_4"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>Void</label>
      </node>
      <node id="11">
        <label>ErrorHandler</label>
      </node>
      <node id="5">
        <label>Connection</label>
        <link refid="classmp_1_1_connection"/>
        <childnode refid="6" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
        <childnode refid="10" relation="usage">
          <edgelabel>m_error_handler</edgelabel>
        </childnode>
      </node>
      <node id="7">
        <label>EventLoop</label>
        <link refid="classmp_1_1_event_loop"/>
        <childnode refid="8" relation="usage">
          <edgelabel>m_mutex</edgelabel>
        </childnode>
        <childnode refid="10" relation="usage">
          <edgelabel>m_error_handler</edgelabel>
        </childnode>
        <childnode refid="12" relation="usage">
          <edgelabel>m_log_opts</edgelabel>
        </childnode>
      </node>
      <node id="6">
        <label>EventLoopRef</label>
        <link refid="classmp_1_1_event_loop_ref"/>
        <childnode refid="7" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
        <childnode refid="13" relation="usage">
          <edgelabel>m_lock</edgelabel>
        </childnode>
      </node>
      <node id="13">
        <label>Lock</label>
        <link refid="classmp_1_1_lock"/>
      </node>
      <node id="12">
        <label>LogOptions</label>
        <link refid="structmp_1_1_log_options"/>
      </node>
      <node id="10">
        <label>LoggingErrorHandler</label>
        <link refid="classmp_1_1_logging_error_handler"/>
        <childnode refid="11" relation="public-inheritance">
        </childnode>
        <childnode refid="7" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
      </node>
      <node id="2">
        <label>ProxyClientBase&lt; Thread, ::capnp::Void &gt;</label>
        <link refid="classmp_1_1_proxy_client_base"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
        <childnode refid="4" relation="usage">
          <edgelabel>m_context</edgelabel>
        </childnode>
      </node>
      <node id="4">
        <label>ProxyContext</label>
        <link refid="structmp_1_1_proxy_context"/>
        <childnode refid="5" relation="usage">
          <edgelabel>connection</edgelabel>
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>loop</edgelabel>
        </childnode>
      </node>
      <node id="9">
        <label>mutex</label>
      </node>
    </collaborationgraph>
    <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="62" column="1" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="63" bodyend="79"/>
    <listofallmembers>
      <member refid="classmp_1_1_proxy_client_base_1a18e911ce47f7b556cfbf6a3728952071" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>construct</name></member>
      <member refid="classmp_1_1_proxy_client_base_1adb322a9b900118b6eeda9c7d1bd98c83" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>destroy</name></member>
      <member refid="classmp_1_1_proxy_client_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>Impl</name></member>
      <member refid="classmp_1_1_proxy_client_base_1ac56f24b044e98752160b4a0a14514e76" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>Interface</name></member>
      <member refid="classmp_1_1_proxy_client_base_1a6869135fcb798da5312514f9663bb2b0" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>m_client</name></member>
      <member refid="classmp_1_1_proxy_client_base_1af910ca1c8fc9a191f85d16b71819c033" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>m_context</name></member>
      <member refid="structmp_1_1_proxy_client_3_01_thread_01_4_1a36bc04dbcc8122bc405076c2bd588f7a" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>m_disconnect_cb</name></member>
      <member refid="structmp_1_1_proxy_client_3_01_thread_01_4_1acdc11ed333f47511007a0554f529e05b" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>ProxyClient</name></member>
      <member refid="structmp_1_1_proxy_client_3_01_thread_01_4_1a32f6c2ed2bf7fd1668e2d5c3e5256682" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>ProxyClientBase</name></member>
      <member refid="classmp_1_1_proxy_client_base_1a90cfc8f560844fa5b07d2a91f50faac3" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>Sub</name></member>
      <member refid="classmp_1_1_proxy_client_base_1ab856cf84ab94afac4d38a770a8ef93d4" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>Super</name></member>
      <member refid="structmp_1_1_proxy_client_3_01_thread_01_4_1a20e57d0d84ee9d0282a79764462d5568" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>~ProxyClient</name></member>
      <member refid="classmp_1_1_proxy_client_base_1a0f6d5e2adea8c123189c2f263d0153ee" prot="public" virt="non-virtual"><scope>mp::ProxyClient&lt; Thread &gt;</scope><name>~ProxyClientBase</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
