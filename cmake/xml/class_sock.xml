<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_sock" kind="class" language="C++" prot="public">
    <compoundname>Sock</compoundname>
    <derivedcompoundref refid="class_fuzzed_sock" prot="public" virt="non-virtual">FuzzedSock</derivedcompoundref>
    <derivedcompoundref refid="class_p_c_p_test_sock" prot="public" virt="non-virtual">PCPTestSock</derivedcompoundref>
    <derivedcompoundref refid="class_zero_sock" prot="public" virt="non-virtual">ZeroSock</derivedcompoundref>
    <includes refid="sock_8h" local="no">sock.h</includes>
    <innerclass refid="struct_sock_1_1_events" prot="public">Sock::Events</innerclass>
    <innerclass refid="struct_sock_1_1_hash_shared_ptr_sock" prot="public">Sock::HashSharedPtrSock</innerclass>
    <innerclass refid="struct_sock_1_1_equal_shared_ptr_sock" prot="public">Sock::EqualSharedPtrSock</innerclass>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" prot="public" static="no">
        <type>uint8_t</type>
        <definition>using Event =  uint8_t</definition>
        <argsstring></argsstring>
        <name>Event</name>
        <qualifiedname>Sock::Event</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="138" column="5" bodyfile="src/util/sock.h" bodystart="138" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" prot="public" static="no">
        <type>std::unordered_map&lt; std::shared_ptr&lt; const <ref refid="class_sock" kindref="compound">Sock</ref> &gt;, <ref refid="struct_sock_1_1_events" kindref="compound">Events</ref>, <ref refid="struct_sock_1_1_hash_shared_ptr_sock" kindref="compound">HashSharedPtrSock</ref>, <ref refid="struct_sock_1_1_equal_shared_ptr_sock" kindref="compound">EqualSharedPtrSock</ref> &gt;</type>
        <definition>using EventsPerSock =  std::unordered_map&lt;std::shared_ptr&lt;const Sock&gt;, Events, HashSharedPtrSock, EqualSharedPtrSock&gt;</definition>
        <argsstring></argsstring>
        <name>EventsPerSock</name>
        <qualifiedname>Sock::EventsPerSock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>On which socket to wait for what events in <computeroutput><ref refid="class_sock_1a6ec7a34cbf87594ed9b7eac590cf965f" kindref="member">WaitMany()</ref></computeroutput>. The <computeroutput>shared_ptr</computeroutput> is copied into the map to ensure that the <computeroutput><ref refid="class_sock" kindref="compound">Sock</ref></computeroutput> object is not destroyed (its destructor would close the underlying socket). If this happens shortly before or after we call <computeroutput>poll(2)</computeroutput> and a new socket gets created under the same file descriptor number then the report from <computeroutput><ref refid="class_sock_1a6ec7a34cbf87594ed9b7eac590cf965f" kindref="member">WaitMany()</ref></computeroutput> will be bogus. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="208" column="5" bodyfile="src/util/sock.h" bodystart="208" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="class_sock_1ae15d539512bccb6583fc75310b0d2f86" prot="public" static="yes" constexpr="yes" mutable="no">
        <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref></type>
        <definition>Event RECV</definition>
        <argsstring></argsstring>
        <name>RECV</name>
        <qualifiedname>Sock::RECV</qualifiedname>
        <initializer>= 0b001</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If passed to <computeroutput><ref refid="class_sock_1a851a09613d347a157da032137020065a" kindref="member">Wait()</ref></computeroutput>, then it will wait for readiness to read from the socket. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="143" column="28" bodyfile="src/util/sock.h" bodystart="143" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_sock_1ac739f9398eaa67718961a5ac331fba4a" prot="public" static="yes" constexpr="yes" mutable="no">
        <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref></type>
        <definition>Event SEND</definition>
        <argsstring></argsstring>
        <name>SEND</name>
        <qualifiedname>Sock::SEND</qualifiedname>
        <initializer>= 0b010</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If passed to <computeroutput><ref refid="class_sock_1a851a09613d347a157da032137020065a" kindref="member">Wait()</ref></computeroutput>, then it will wait for readiness to send to the socket. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="148" column="28" bodyfile="src/util/sock.h" bodystart="148" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" prot="public" static="yes" constexpr="yes" mutable="no">
        <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref></type>
        <definition>Event ERR</definition>
        <argsstring></argsstring>
        <name>ERR</name>
        <qualifiedname>Sock::ERR</qualifiedname>
        <initializer>= 0b100</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Ignored if passed to <computeroutput><ref refid="class_sock_1a851a09613d347a157da032137020065a" kindref="member">Wait()</ref></computeroutput>, but could be set in the occurred events if an exceptional condition has occurred on the socket or if it has been disconnected. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="154" column="28" bodyfile="src/util/sock.h" bodystart="154" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="class_sock_1a453ef0b211974cc0b3f59651f2759a85" prot="protected" static="no" mutable="no">
        <type><ref refid="compat_8h_1ab8a4083c1e5d7c4172936f59e67ce798" kindref="member">SOCKET</ref></type>
        <definition>SOCKET m_socket</definition>
        <argsstring></argsstring>
        <name>m_socket</name>
        <qualifiedname>Sock::m_socket</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Contained socket. <computeroutput><ref refid="compat_8h_1a26769957ec1a2beaf223f33b66ee64ab" kindref="member">INVALID_SOCKET</ref></computeroutput> designates the object is empty. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="275" column="12" bodyfile="src/util/sock.h" bodystart="275" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_sock_1aa514692e524d2d55d80976eac6456d12" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Sock</definition>
        <argsstring>()=delete</argsstring>
        <name>Sock</name>
        <qualifiedname>Sock::Sock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="29" column="5"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a76264c08d7dff8a6c0521733d5bd850c" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>Sock</definition>
        <argsstring>(SOCKET s)</argsstring>
        <name>Sock</name>
        <qualifiedname>Sock::Sock</qualifiedname>
        <param>
          <type><ref refid="compat_8h_1ab8a4083c1e5d7c4172936f59e67ce798" kindref="member">SOCKET</ref></type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Take ownership of an existent socket. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="34" column="14" bodyfile="src/util/sock.cpp" bodystart="27" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a000e1d0f0c23801b9a15043312d90b15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Sock</definition>
        <argsstring>(const Sock &amp;)=delete</argsstring>
        <name>Sock</name>
        <qualifiedname>Sock::Sock</qualifiedname>
        <param>
          <type>const <ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy constructor, disabled because closing the same socket twice is undesirable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="39" column="5"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a014eef261ec754e8e3586d5d11f260fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Sock</definition>
        <argsstring>(Sock &amp;&amp;other)</argsstring>
        <name>Sock</name>
        <qualifiedname>Sock::Sock</qualifiedname>
        <param>
          <type><ref refid="class_sock" kindref="compound">Sock</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move constructor, grab the socket from another object and close ours (if set). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="44" column="5" bodyfile="src/util/sock.cpp" bodystart="29" bodyend="33"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a6c6d5559856121d4b1a18465e2901c94" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>~Sock</definition>
        <argsstring>()</argsstring>
        <name>~Sock</name>
        <qualifiedname>Sock::~Sock</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destructor, close the socket or do nothing if empty. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="49" column="13" bodyfile="src/util/sock.cpp" bodystart="35" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a4c90c4a9a6886cb68a9ee851522afff1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
        <definition>Sock &amp; operator=</definition>
        <argsstring>(const Sock &amp;)=delete</argsstring>
        <name>operator=</name>
        <qualifiedname>Sock::operator=</qualifiedname>
        <param>
          <type>const <ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy assignment operator, disabled because closing the same socket twice is undesirable. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="54" column="10"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1aed8298a36ba25760ceb8d1207a39f8db" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="class_sock" kindref="compound">Sock</ref> &amp;</type>
        <definition>Sock &amp; operator=</definition>
        <argsstring>(Sock &amp;&amp;other)</argsstring>
        <name>operator=</name>
        <qualifiedname>Sock::operator=</qualifiedname>
        <reimplementedby refid="class_dyn_sock_1a813c68af975a142f7da1907426ace386">operator=</reimplementedby>
        <reimplementedby refid="class_fuzzed_sock_1a3cf34ea45c3835396beb4ce77d32d120">operator=</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a9a8dd74dd909f175c3cc342c65e3e19c">operator=</reimplementedby>
        <reimplementedby refid="class_static_contents_sock_1a4d01d8b03a20005997553628e95d4365">operator=</reimplementedby>
        <reimplementedby refid="class_zero_sock_1ae1123cb010276891e0a5a9c670ba86ca">operator=</reimplementedby>
        <param>
          <type><ref refid="class_sock" kindref="compound">Sock</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Move assignment operator, grab the socket from another object and close ours (if set). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="59" column="18" bodyfile="src/util/sock.cpp" bodystart="37" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1ad50f4b43d2b968d64162193e9254d6b5" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>ssize_t</type>
        <definition>ssize_t Send</definition>
        <argsstring>(const void *data, size_t len, int flags) const</argsstring>
        <name>Send</name>
        <qualifiedname>Sock::Send</qualifiedname>
        <reimplementedby refid="class_dyn_sock_1a91f43a08763aa3988637e9242bc1219f">Send</reimplementedby>
        <reimplementedby refid="class_fuzzed_sock_1acea3de5ef4ffb5d3c9ab0529c7f31fa9">Send</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1ac2038678b0e7c9edc578bc68a5871b17">Send</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a9261d901e7024d8f9678d2fb9b0e1788">Send</reimplementedby>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>send(2) wrapper. Equivalent to <computeroutput>send(m_socket, data, len, flags);</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="65" column="22" bodyfile="src/util/sock.cpp" bodystart="45" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1ad5d478226aba69810d73757744e13317" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>ssize_t</type>
        <definition>ssize_t Recv</definition>
        <argsstring>(void *buf, size_t len, int flags) const</argsstring>
        <name>Recv</name>
        <qualifiedname>Sock::Recv</qualifiedname>
        <reimplementedby refid="class_dyn_sock_1acc57da900d09bf26675b155ff9f4ac89">Recv</reimplementedby>
        <reimplementedby refid="class_fuzzed_sock_1acc57da900d09bf26675b155ff9f4ac89">Recv</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1acc57da900d09bf26675b155ff9f4ac89">Recv</reimplementedby>
        <reimplementedby refid="class_static_contents_sock_1acc57da900d09bf26675b155ff9f4ac89">Recv</reimplementedby>
        <reimplementedby refid="class_zero_sock_1acc57da900d09bf26675b155ff9f4ac89">Recv</reimplementedby>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>len</declname>
        </param>
        <param>
          <type>int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>recv(2) wrapper. Equivalent to <computeroutput>recv(m_socket, buf, len, flags);</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="71" column="22" bodyfile="src/util/sock.cpp" bodystart="50" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a5f5be77492fb494cd6b2effd50d18435" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int Connect</definition>
        <argsstring>(const sockaddr *addr, socklen_t addr_len) const</argsstring>
        <name>Connect</name>
        <qualifiedname>Sock::Connect</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a2a2d42283320a5a051f301933328ad09">Connect</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a4c7f5777ead2f1ab3b2d80669b5b3925">Connect</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a2a2d42283320a5a051f301933328ad09">Connect</reimplementedby>
        <param>
          <type>const sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>connect(2) wrapper. Equivalent to <computeroutput>connect(m_socket, addr, addrlen)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="77" column="18" bodyfile="src/util/sock.cpp" bodystart="55" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1ae84297efb7d81f94d5c839a4b3b2abd8" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int Bind</definition>
        <argsstring>(const sockaddr *addr, socklen_t addr_len) const</argsstring>
        <name>Bind</name>
        <qualifiedname>Sock::Bind</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1ab8f4fedff95b14573fabc05c019f9f8e">Bind</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1ac775d2a939e07c034c199227da9a4f26">Bind</reimplementedby>
        <reimplementedby refid="class_zero_sock_1ab8f4fedff95b14573fabc05c019f9f8e">Bind</reimplementedby>
        <param>
          <type>const sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>bind(2) wrapper. Equivalent to <computeroutput>bind(m_socket, addr, addr_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="83" column="18" bodyfile="src/util/sock.cpp" bodystart="60" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a88c18587b3e874ee2a5fde74d6bb3cc2" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int Listen</definition>
        <argsstring>(int backlog) const</argsstring>
        <name>Listen</name>
        <qualifiedname>Sock::Listen</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1af72b3b4f4890c8c2b1b78620cfb4ae8f">Listen</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a172d2ef5e777674d5445aac1387bab41">Listen</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a172d2ef5e777674d5445aac1387bab41">Listen</reimplementedby>
        <param>
          <type>int</type>
          <declname>backlog</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>listen(2) wrapper. Equivalent to <computeroutput>listen(m_socket, backlog)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="89" column="18" bodyfile="src/util/sock.cpp" bodystart="65" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a0478fe1f85686563dafce68f30878fa6" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::unique_ptr&lt; <ref refid="class_sock" kindref="compound">Sock</ref> &gt;</type>
        <definition>std::unique_ptr&lt; Sock &gt; Accept</definition>
        <argsstring>(sockaddr *addr, socklen_t *addr_len) const</argsstring>
        <name>Accept</name>
        <qualifiedname>Sock::Accept</qualifiedname>
        <reimplementedby refid="class_dyn_sock_1a36b4abe351193181c883d465020aa101">Accept</reimplementedby>
        <reimplementedby refid="class_fuzzed_sock_1a36b4abe351193181c883d465020aa101">Accept</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a36b4abe351193181c883d465020aa101">Accept</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a36b4abe351193181c883d465020aa101">Accept</reimplementedby>
        <param>
          <type>sockaddr *</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>addr_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>accept(2) wrapper. Equivalent to <computeroutput>std::make_unique&lt;<ref refid="class_sock" kindref="compound">Sock</ref>&gt;(accept(m_socket, addr, addr_len))</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. The returned unique_ptr is empty if <computeroutput>accept()</computeroutput> failed in which case errno will be set. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="97" column="30" bodyfile="src/util/sock.cpp" bodystart="70" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a36a481d2609f5c4626a8c6136ee1f26f" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int GetSockOpt</definition>
        <argsstring>(int level, int opt_name, void *opt_val, socklen_t *opt_len) const</argsstring>
        <name>GetSockOpt</name>
        <qualifiedname>Sock::GetSockOpt</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a5b5845e5aca634a6f79c82afecbc37fd">GetSockOpt</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a5b5845e5aca634a6f79c82afecbc37fd">GetSockOpt</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a5b5845e5aca634a6f79c82afecbc37fd">GetSockOpt</reimplementedby>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int</type>
          <declname>opt_name</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>opt_val</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>opt_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>getsockopt(2) wrapper. Equivalent to <computeroutput>getsockopt(m_socket, level, opt_name, opt_val, opt_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="104" column="18" bodyfile="src/util/sock.cpp" bodystart="96" bodyend="99"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a72351052778d8f7107546f9e32159dc9" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int SetSockOpt</definition>
        <argsstring>(int level, int opt_name, const void *opt_val, socklen_t opt_len) const</argsstring>
        <name>SetSockOpt</name>
        <qualifiedname>Sock::SetSockOpt</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a1796957359313c29b05c500cd424d3a2">SetSockOpt</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a94f895afc687c06525ac15ccb10ce2b0">SetSockOpt</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a94f895afc687c06525ac15ccb10ce2b0">SetSockOpt</reimplementedby>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <param>
          <type>int</type>
          <declname>opt_name</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>opt_val</declname>
        </param>
        <param>
          <type>socklen_t</type>
          <declname>opt_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>setsockopt(2) wrapper. Equivalent to <computeroutput>setsockopt(m_socket, level, opt_name, opt_val, opt_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="114" column="18" bodyfile="src/util/sock.cpp" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a8544fa939816100e03ecba0a79fde2b1" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>int</type>
        <definition>int GetSockName</definition>
        <argsstring>(sockaddr *name, socklen_t *name_len) const</argsstring>
        <name>GetSockName</name>
        <qualifiedname>Sock::GetSockName</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a16930ee6ded3a8fe47a7adaf178affff">GetSockName</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a16930ee6ded3a8fe47a7adaf178affff">GetSockName</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a16930ee6ded3a8fe47a7adaf178affff">GetSockName</reimplementedby>
        <param>
          <type>sockaddr *</type>
          <declname>name</declname>
        </param>
        <param>
          <type>socklen_t *</type>
          <declname>name_len</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>getsockname(2) wrapper. Equivalent to <computeroutput>getsockname(m_socket, name, name_len)</computeroutput>. Code that uses this wrapper can be unit tested if this method is overridden by a mock <ref refid="class_sock" kindref="compound">Sock</ref> implementation. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="124" column="18" bodyfile="src/util/sock.cpp" bodystart="106" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a11c30b8078693d82b98b44a8b81bb71d" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool SetNonBlocking</definition>
        <argsstring>() const</argsstring>
        <name>SetNonBlocking</name>
        <qualifiedname>Sock::SetNonBlocking</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a8a6517d31b9c4c9a895c1cbb83387c86">SetNonBlocking</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a8a6517d31b9c4c9a895c1cbb83387c86">SetNonBlocking</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a8a6517d31b9c4c9a895c1cbb83387c86">SetNonBlocking</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set the non-blocking option on the socket. <simplesect kind="return"><para>true if set successfully </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="130" column="19" bodyfile="src/util/sock.cpp" bodystart="111" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a39fd9751352b6030c42c342066a1b887" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool IsSelectable</definition>
        <argsstring>() const</argsstring>
        <name>IsSelectable</name>
        <qualifiedname>Sock::IsSelectable</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a598fdcc705deaa438fba72650d51fe20">IsSelectable</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1a598fdcc705deaa438fba72650d51fe20">IsSelectable</reimplementedby>
        <reimplementedby refid="class_zero_sock_1a598fdcc705deaa438fba72650d51fe20">IsSelectable</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if the underlying socket can be used for <computeroutput>select(2)</computeroutput> (or the <computeroutput><ref refid="class_sock_1a851a09613d347a157da032137020065a" kindref="member">Wait()</ref></computeroutput> method). <simplesect kind="return"><para>true if selectable </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="136" column="19" bodyfile="src/util/sock.cpp" bodystart="130" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a851a09613d347a157da032137020065a" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool Wait</definition>
        <argsstring>(std::chrono::milliseconds timeout, Event requested, Event *occurred=nullptr) const</argsstring>
        <name>Wait</name>
        <qualifiedname>Sock::Wait</qualifiedname>
        <reimplementedby refid="class_dyn_sock_1aa9d44903b57505d9f8765404cb04f35f">Wait</reimplementedby>
        <reimplementedby refid="class_fuzzed_sock_1aa9d44903b57505d9f8765404cb04f35f">Wait</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1aa9d44903b57505d9f8765404cb04f35f">Wait</reimplementedby>
        <reimplementedby refid="class_zero_sock_1aa9d44903b57505d9f8765404cb04f35f">Wait</reimplementedby>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref></type>
          <declname>requested</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" kindref="member">Event</ref> *</type>
          <declname>occurred</declname>
          <defval>nullptr</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Wait for readiness for input (recv) or output (send). <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait this much for at least one of the requested events to occur. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">requested</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait for those events, bitwise-or of <computeroutput><ref refid="class_sock_1ae15d539512bccb6583fc75310b0d2f86" kindref="member">RECV</ref></computeroutput> and <computeroutput><ref refid="class_sock_1ac739f9398eaa67718961a5ac331fba4a" kindref="member">SEND</ref></computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">occurred</parametername>
</parameternamelist>
<parameterdescription>
<para>If not nullptr and the function returns <computeroutput>true</computeroutput>, then this indicates which of the requested events occurred (<computeroutput><ref refid="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" kindref="member">ERR</ref></computeroutput> will be added, even if not requested, if an exceptional event occurs on the socket). A timeout is indicated by return value of <computeroutput>true</computeroutput> and <computeroutput>occurred</computeroutput> being set to 0. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success (or timeout, if <computeroutput>occurred</computeroutput> of 0 is returned), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="166" column="19" bodyfile="src/util/sock.cpp" bodystart="139" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a6ec7a34cbf87594ed9b7eac590cf965f" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool WaitMany</definition>
        <argsstring>(std::chrono::milliseconds timeout, EventsPerSock &amp;events_per_sock) const</argsstring>
        <name>WaitMany</name>
        <qualifiedname>Sock::WaitMany</qualifiedname>
        <reimplementedby refid="class_dyn_sock_1af35a7663942bba32c947f387114bc068">WaitMany</reimplementedby>
        <reimplementedby refid="class_fuzzed_sock_1af35a7663942bba32c947f387114bc068">WaitMany</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1af35a7663942bba32c947f387114bc068">WaitMany</reimplementedby>
        <reimplementedby refid="class_zero_sock_1af35a7663942bba32c947f387114bc068">WaitMany</reimplementedby>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" kindref="member">EventsPerSock</ref> &amp;</type>
          <declname>events_per_sock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Same as <computeroutput><ref refid="class_sock_1a851a09613d347a157da032137020065a" kindref="member">Wait()</ref></computeroutput>, but wait on many sockets within the same timeout. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait this long for at least one of the requested events to occur. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="inout">events_per_sock</parametername>
</parameternamelist>
<parameterdescription>
<para>Wait for the requested events on these sockets and set <computeroutput>occurred</computeroutput> for the events that actually occurred. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true on success (or timeout, if all <computeroutput>what[].occurred</computeroutput> are returned as 0), false otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="218" column="19" bodyfile="src/util/sock.cpp" bodystart="159" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a43f09a43a02f01718f04fd139c2a5ed4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void SendComplete</definition>
        <argsstring>(std::span&lt; const unsigned char &gt; data, std::chrono::milliseconds timeout, CThreadInterrupt &amp;interrupt) const</argsstring>
        <name>SendComplete</name>
        <qualifiedname>Sock::SendComplete</qualifiedname>
        <param>
          <type>std::span&lt; const unsigned char &gt;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_c_thread_interrupt" kindref="compound">CThreadInterrupt</ref> &amp;</type>
          <declname>interrupt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Send the given data, retrying on transient errors. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">data</parametername>
</parameternamelist>
<parameterdescription>
<para>Data to send. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Timeout for the entire operation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">interrupt</parametername>
</parameternamelist>
<parameterdescription>
<para>If this is signaled then the operation is canceled. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if the operation cannot be completed. In this case only some of the data will be written to the socket. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="231" column="18" bodyfile="src/util/sock.cpp" bodystart="245" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a885ca2c5b4d6185c0393595967115e6d" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>void SendComplete</definition>
        <argsstring>(std::span&lt; const char &gt; data, std::chrono::milliseconds timeout, CThreadInterrupt &amp;interrupt) const</argsstring>
        <name>SendComplete</name>
        <qualifiedname>Sock::SendComplete</qualifiedname>
        <param>
          <type>std::span&lt; const char &gt;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_c_thread_interrupt" kindref="compound">CThreadInterrupt</ref> &amp;</type>
          <declname>interrupt</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convenience method, equivalent to <computeroutput>SendComplete(MakeUCharSpan(data), timeout, interrupt)</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="238" column="18" bodyfile="src/util/sock.cpp" bodystart="286" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a27107f318fb56aa730ab7572ac613479" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>std::string</type>
        <definition>std::string RecvUntilTerminator</definition>
        <argsstring>(uint8_t terminator, std::chrono::milliseconds timeout, CThreadInterrupt &amp;interrupt, size_t max_data) const</argsstring>
        <name>RecvUntilTerminator</name>
        <qualifiedname>Sock::RecvUntilTerminator</qualifiedname>
        <param>
          <type>uint8_t</type>
          <declname>terminator</declname>
        </param>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type><ref refid="class_c_thread_interrupt" kindref="compound">CThreadInterrupt</ref> &amp;</type>
          <declname>interrupt</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Read from socket until a terminator character is encountered. Will never consume bytes past the terminator from the socket. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">terminator</parametername>
</parameternamelist>
<parameterdescription>
<para>Character up to which to read from the socket. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>Timeout for the entire operation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">interrupt</parametername>
</parameternamelist>
<parameterdescription>
<para>If this is signaled then the operation is canceled. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_data</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum amount of data (in bytes) to receive. If this many bytes are received and there is still no terminator, then this method will throw an exception. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The data that has been read, without the terminating character. </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>if the operation cannot be completed. In this case some bytes may have been consumed from the socket. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="254" column="26" bodyfile="src/util/sock.cpp" bodystart="293" bodyend="374"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a395f618148d26468dc12324ffcddbd4a" prot="public" static="no" nodiscard="yes" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool IsConnected</definition>
        <argsstring>(std::string &amp;errmsg) const</argsstring>
        <name>IsConnected</name>
        <qualifiedname>Sock::IsConnected</qualifiedname>
        <reimplementedby refid="class_fuzzed_sock_1a559bd3d4e08847304e64ef6fdac33ad4">IsConnected</reimplementedby>
        <reimplementedby refid="class_p_c_p_test_sock_1aa18949f10a1aafa5498ee991e5f61fcd">IsConnected</reimplementedby>
        <reimplementedby refid="class_static_contents_sock_1aa18949f10a1aafa5498ee991e5f61fcd">IsConnected</reimplementedby>
        <param>
          <type>std::string &amp;</type>
          <declname>errmsg</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if still connected. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">errmsg</parametername>
</parameternamelist>
<parameterdescription>
<para>The error string, if the socket has been disconnected. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if connected </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="264" column="19" bodyfile="src/util/sock.cpp" bodystart="376" bodyend="399"/>
      </memberdef>
      <memberdef kind="function" id="class_sock_1a0e4e0f6358b1a1c9d549037d265cc729" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool operator==</definition>
        <argsstring>(SOCKET s) const</argsstring>
        <name>operator==</name>
        <qualifiedname>Sock::operator==</qualifiedname>
        <param>
          <type><ref refid="compat_8h_1ab8a4083c1e5d7c4172936f59e67ce798" kindref="member">SOCKET</ref></type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if the internal socket is equal to <computeroutput>s</computeroutput>. Use only in tests. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="269" column="10" bodyfile="src/util/sock.cpp" bodystart="417" bodyend="420"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_sock_1a7f7a3199c392465d0767c6506c1af5b4" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Close</definition>
        <argsstring>()</argsstring>
        <name>Close</name>
        <qualifiedname>Sock::Close</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Close <computeroutput><ref refid="class_sock_1a453ef0b211974cc0b3f59651f2759a85" kindref="member">m_socket</ref></computeroutput> if it is not <computeroutput><ref refid="compat_8h_1a26769957ec1a2beaf223f33b66ee64ab" kindref="member">INVALID_SOCKET</ref></computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/util/sock.h" line="281" column="10" bodyfile="src/util/sock.cpp" bodystart="401" bodyend="415"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>RAII helper class that manages a socket and closes it automatically when it goes out of scope. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="5">
        <label>DynSock</label>
        <link refid="class_dyn_sock"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>FuzzedSock</label>
        <link refid="class_fuzzed_sock"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>PCPTestSock</label>
        <link refid="class_p_c_p_test_sock"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>Sock</label>
        <link refid="class_sock"/>
      </node>
      <node id="6">
        <label>StaticContentsSock</label>
        <link refid="class_static_contents_sock"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>ZeroSock</label>
        <link refid="class_zero_sock"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="src/util/sock.h" line="26" column="1" bodyfile="src/util/sock.h" bodystart="27" bodyend="282"/>
    <listofallmembers>
      <member refid="class_sock_1a0478fe1f85686563dafce68f30878fa6" prot="public" virt="virtual"><scope>Sock</scope><name>Accept</name></member>
      <member refid="class_sock_1ae84297efb7d81f94d5c839a4b3b2abd8" prot="public" virt="virtual"><scope>Sock</scope><name>Bind</name></member>
      <member refid="class_sock_1a7f7a3199c392465d0767c6506c1af5b4" prot="private" virt="non-virtual"><scope>Sock</scope><name>Close</name></member>
      <member refid="class_sock_1a5f5be77492fb494cd6b2effd50d18435" prot="public" virt="virtual"><scope>Sock</scope><name>Connect</name></member>
      <member refid="class_sock_1a2d9bf7f3d9855e98e28b9224cab3920e" prot="public" virt="non-virtual"><scope>Sock</scope><name>ERR</name></member>
      <member refid="class_sock_1a4b6dc81990bf0cf4838a46f8c9729e1b" prot="public" virt="non-virtual"><scope>Sock</scope><name>Event</name></member>
      <member refid="class_sock_1a3c7a13923a7186b4d5a8ba7981729638" prot="public" virt="non-virtual"><scope>Sock</scope><name>EventsPerSock</name></member>
      <member refid="class_sock_1a8544fa939816100e03ecba0a79fde2b1" prot="public" virt="virtual"><scope>Sock</scope><name>GetSockName</name></member>
      <member refid="class_sock_1a36a481d2609f5c4626a8c6136ee1f26f" prot="public" virt="virtual"><scope>Sock</scope><name>GetSockOpt</name></member>
      <member refid="class_sock_1a395f618148d26468dc12324ffcddbd4a" prot="public" virt="virtual"><scope>Sock</scope><name>IsConnected</name></member>
      <member refid="class_sock_1a39fd9751352b6030c42c342066a1b887" prot="public" virt="virtual"><scope>Sock</scope><name>IsSelectable</name></member>
      <member refid="class_sock_1a88c18587b3e874ee2a5fde74d6bb3cc2" prot="public" virt="virtual"><scope>Sock</scope><name>Listen</name></member>
      <member refid="class_sock_1a453ef0b211974cc0b3f59651f2759a85" prot="protected" virt="non-virtual"><scope>Sock</scope><name>m_socket</name></member>
      <member refid="class_sock_1a4c90c4a9a6886cb68a9ee851522afff1" prot="public" virt="non-virtual"><scope>Sock</scope><name>operator=</name></member>
      <member refid="class_sock_1aed8298a36ba25760ceb8d1207a39f8db" prot="public" virt="virtual"><scope>Sock</scope><name>operator=</name></member>
      <member refid="class_sock_1a0e4e0f6358b1a1c9d549037d265cc729" prot="public" virt="non-virtual"><scope>Sock</scope><name>operator==</name></member>
      <member refid="class_sock_1ae15d539512bccb6583fc75310b0d2f86" prot="public" virt="non-virtual"><scope>Sock</scope><name>RECV</name></member>
      <member refid="class_sock_1ad5d478226aba69810d73757744e13317" prot="public" virt="virtual"><scope>Sock</scope><name>Recv</name></member>
      <member refid="class_sock_1a27107f318fb56aa730ab7572ac613479" prot="public" virt="virtual"><scope>Sock</scope><name>RecvUntilTerminator</name></member>
      <member refid="class_sock_1ac739f9398eaa67718961a5ac331fba4a" prot="public" virt="non-virtual"><scope>Sock</scope><name>SEND</name></member>
      <member refid="class_sock_1ad50f4b43d2b968d64162193e9254d6b5" prot="public" virt="virtual"><scope>Sock</scope><name>Send</name></member>
      <member refid="class_sock_1a43f09a43a02f01718f04fd139c2a5ed4" prot="public" virt="virtual"><scope>Sock</scope><name>SendComplete</name></member>
      <member refid="class_sock_1a885ca2c5b4d6185c0393595967115e6d" prot="public" virt="virtual"><scope>Sock</scope><name>SendComplete</name></member>
      <member refid="class_sock_1a11c30b8078693d82b98b44a8b81bb71d" prot="public" virt="virtual"><scope>Sock</scope><name>SetNonBlocking</name></member>
      <member refid="class_sock_1a72351052778d8f7107546f9e32159dc9" prot="public" virt="virtual"><scope>Sock</scope><name>SetSockOpt</name></member>
      <member refid="class_sock_1aa514692e524d2d55d80976eac6456d12" prot="public" virt="non-virtual"><scope>Sock</scope><name>Sock</name></member>
      <member refid="class_sock_1a76264c08d7dff8a6c0521733d5bd850c" prot="public" virt="non-virtual"><scope>Sock</scope><name>Sock</name></member>
      <member refid="class_sock_1a000e1d0f0c23801b9a15043312d90b15" prot="public" virt="non-virtual"><scope>Sock</scope><name>Sock</name></member>
      <member refid="class_sock_1a014eef261ec754e8e3586d5d11f260fb" prot="public" virt="non-virtual"><scope>Sock</scope><name>Sock</name></member>
      <member refid="class_sock_1a851a09613d347a157da032137020065a" prot="public" virt="virtual"><scope>Sock</scope><name>Wait</name></member>
      <member refid="class_sock_1a6ec7a34cbf87594ed9b7eac590cf965f" prot="public" virt="virtual"><scope>Sock</scope><name>WaitMany</name></member>
      <member refid="class_sock_1a6c6d5559856121d4b1a18465e2901c94" prot="public" virt="virtual"><scope>Sock</scope><name>~Sock</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
