<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_c_scheduler" kind="class" language="C++" prot="public">
    <compoundname>CScheduler</compoundname>
    <includes refid="scheduler_8h" local="no">scheduler.h</includes>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="class_c_scheduler_1a5969d318a59171fc0413b19f59434889" prot="public" static="no">
        <type>std::function&lt; void()&gt;</type>
        <definition>typedef std::function&lt;void()&gt; Function</definition>
        <argsstring></argsstring>
        <name>Function</name>
        <qualifiedname>CScheduler::Function</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="47" column="27" bodyfile="src/scheduler.h" bodystart="47" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="class_c_scheduler_1a6d839daab9225235d84cf6997c3f0ba2" prot="public" static="no" mutable="no">
        <type>std::thread</type>
        <definition>std::thread m_service_thread</definition>
        <argsstring></argsstring>
        <name>m_service_thread</name>
        <qualifiedname>CScheduler::m_service_thread</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="45" column="17" bodyfile="src/scheduler.h" bodystart="45" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_c_scheduler_1a4021f0091e793d0cece15cadaa14fb3b" prot="private" static="no" mutable="yes">
        <type><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref></type>
        <definition>Mutex newTaskMutex</definition>
        <argsstring></argsstring>
        <name>newTaskMutex</name>
        <qualifiedname>CScheduler::newTaskMutex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="105" column="19" bodyfile="src/scheduler.h" bodystart="105" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_c_scheduler_1afec5e0b03890fdc6802f45b6bfceb3d9" prot="private" static="no" mutable="no">
        <type>std::condition_variable</type>
        <definition>std::condition_variable newTaskScheduled</definition>
        <argsstring></argsstring>
        <name>newTaskScheduled</name>
        <qualifiedname>CScheduler::newTaskScheduled</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="106" column="29" bodyfile="src/scheduler.h" bodystart="106" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_c_scheduler_1a8f1d5988a71a3242aae7ebbea1ba49ac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>CScheduler</definition>
        <argsstring>()</argsstring>
        <name>CScheduler</name>
        <qualifiedname>CScheduler::CScheduler</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="42" column="5"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a4d87ed7b38f60ca287b11ec69d8e2212" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~CScheduler</definition>
        <argsstring>()</argsstring>
        <name>~CScheduler</name>
        <qualifiedname>CScheduler::~CScheduler</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="43" column="5" bodyfile="src/scheduler.cpp" bodystart="16" bodyend="20"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a243fcdfb5446405a84dffc4da757d18b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void schedule</definition>
        <argsstring>(Function f, std::chrono::steady_clock::time_point t) EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>schedule</name>
        <qualifiedname>CScheduler::schedule</qualifiedname>
        <param>
          <type><ref refid="class_c_scheduler_1a5969d318a59171fc0413b19f59434889" kindref="member">Function</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::chrono::steady_clock::time_point</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call func at/after time t </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="50" column="10" bodyfile="src/scheduler.cpp" bodystart="71" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1afdb52271200f958fa88b14b94546bb20" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void scheduleFromNow</definition>
        <argsstring>(Function f, std::chrono::milliseconds delta) EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>scheduleFromNow</name>
        <qualifiedname>CScheduler::scheduleFromNow</qualifiedname>
        <param>
          <type><ref refid="class_c_scheduler_1a5969d318a59171fc0413b19f59434889" kindref="member">Function</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>delta</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Call f once after the delta has passed </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="53" column="10" bodyfile="src/scheduler.h" bodystart="53" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1afc967db034e89889059bca31574ec485" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void scheduleEvery</definition>
        <argsstring>(Function f, std::chrono::milliseconds delta) EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>scheduleEvery</name>
        <qualifiedname>CScheduler::scheduleEvery</qualifiedname>
        <param>
          <type><ref refid="class_c_scheduler_1a5969d318a59171fc0413b19f59434889" kindref="member">Function</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::chrono::milliseconds</type>
          <declname>delta</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Repeat f until the scheduler is stopped. First run is after delta has passed once.</para>
<para>The timing is not exact: Every time f is finished, it is rescheduled to run again after delta. If you need more accurate scheduling, don&apos;t use this method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="64" column="10" bodyfile="src/scheduler.cpp" bodystart="108" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a164bd31b14643a1063d6361c9f76da3f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void MockForward</definition>
        <argsstring>(std::chrono::seconds delta_seconds) EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>MockForward</name>
        <qualifiedname>CScheduler::MockForward</qualifiedname>
        <param>
          <type>std::chrono::seconds</type>
          <declname>delta_seconds</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Mock the scheduler to fast forward in time. Iterates through items on taskQueue and reschedules them to be delta_seconds sooner. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="71" column="10" bodyfile="src/scheduler.cpp" bodystart="80" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a3c51a70f4b0106c4ee6f9dbad3f3da68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void serviceQueue</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>serviceQueue</name>
        <qualifiedname>CScheduler::serviceQueue</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Services the queue &apos;forever&apos;. Should be run in a thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="76" column="10" bodyfile="src/scheduler.cpp" bodystart="23" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1aded9b7a535edbef852c49e31f8ffa8a2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void stop</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>stop</name>
        <qualifiedname>CScheduler::stop</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tell any threads running serviceQueue to stop as soon as the current task is done </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="79" column="10" bodyfile="src/scheduler.h" bodystart="79" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a351504618ec55e33093a42e14f67e842" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void StopWhenDrained</definition>
        <argsstring>() EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>StopWhenDrained</name>
        <qualifiedname>CScheduler::StopWhenDrained</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tell any threads running serviceQueue to stop when there is no work left to be done </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="86" column="10" bodyfile="src/scheduler.h" bodystart="86" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1aff14f7f321ef504ab44a28bb8d209ac2" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t getQueueInfo</definition>
        <argsstring>(std::chrono::steady_clock::time_point &amp;first, std::chrono::steady_clock::time_point &amp;last) const EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>getQueueInfo</name>
        <qualifiedname>CScheduler::getQueueInfo</qualifiedname>
        <param>
          <type>std::chrono::steady_clock::time_point &amp;</type>
          <declname>first</declname>
        </param>
        <param>
          <type>std::chrono::steady_clock::time_point &amp;</type>
          <declname>last</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns number of tasks waiting to be serviced, and first and last task times </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="97" column="12" bodyfile="src/scheduler.cpp" bodystart="113" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a46b9b16b5ab91c682ebc937d3948775f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool AreThreadsServicingQueue</definition>
        <argsstring>() const EXCLUSIVE_LOCKS_REQUIRED(!newTaskMutex)</argsstring>
        <name>AreThreadsServicingQueue</name>
        <qualifiedname>CScheduler::AreThreadsServicingQueue</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns true if there are threads actively running in <ref refid="class_c_scheduler_1a3c51a70f4b0106c4ee6f9dbad3f3da68" kindref="member">serviceQueue()</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="102" column="10" bodyfile="src/scheduler.cpp" bodystart="125" bodyend="129"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="class_c_scheduler_1a50e8357dadadb23e24ad1126a8ee4a08" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::multimap&lt; std::chrono::steady_clock::time_point, <ref refid="class_c_scheduler_1a5969d318a59171fc0413b19f59434889" kindref="member">Function</ref> &gt; taskQueue</type>
        <definition>std::multimap&lt; std::chrono::steady_clock::time_point, Function &gt; taskQueue GUARDED_BY</definition>
        <argsstring>(newTaskMutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>CScheduler::GUARDED_BY</qualifiedname>
        <param>
          <type>newTaskMutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="107" column="29"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1a86935c99463bb08a4d4ac32f07d74cc7" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int nThreadsServicingQueue</type>
        <definition>int nThreadsServicingQueue GUARDED_BY</definition>
        <argsstring>(newTaskMutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>CScheduler::GUARDED_BY</qualifiedname>
        <param>
          <type>newTaskMutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="108" column="32" bodyfile="src/scheduler.h" bodystart="108" bodyend="108"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1af72a22d9fa7c83d323ce6f477888e23f" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool stopRequested</type>
        <definition>bool stopRequested GUARDED_BY</definition>
        <argsstring>(newTaskMutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>CScheduler::GUARDED_BY</qualifiedname>
        <param>
          <type>newTaskMutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="109" column="24" bodyfile="src/scheduler.h" bodystart="109" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1afeb7c27379d50061db893acf1ee505d3" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool stopWhenEmpty</type>
        <definition>bool stopWhenEmpty GUARDED_BY</definition>
        <argsstring>(newTaskMutex)</argsstring>
        <name>GUARDED_BY</name>
        <qualifiedname>CScheduler::GUARDED_BY</qualifiedname>
        <param>
          <type>newTaskMutex</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="110" column="24" bodyfile="src/scheduler.h" bodystart="110" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="class_c_scheduler_1ad8543a492ccbaa2c24e17220dd2bb46f" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool shouldStop</definition>
        <argsstring>() const EXCLUSIVE_LOCKS_REQUIRED(newTaskMutex)</argsstring>
        <name>shouldStop</name>
        <qualifiedname>CScheduler::shouldStop</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/scheduler.h" line="111" column="10" bodyfile="src/scheduler.h" bodystart="111" bodyend="111"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Simple class for background tasks that should be run periodically or once &quot;after a while&quot;</para>
<para>Usage:</para>
<para>CScheduler* s = new <ref refid="class_c_scheduler_1a8f1d5988a71a3242aae7ebbea1ba49ac" kindref="member">CScheduler()</ref>; s-&gt;scheduleFromNow(doSomething, std::chrono::milliseconds{11}); // Assuming a: void doSomething() { } s-&gt;scheduleFromNow([=] { this-&gt;func(argument); }, std::chrono::milliseconds{3}); std::thread* t = new std::thread([&amp;] { s-&gt;<ref refid="class_c_scheduler_1a3c51a70f4b0106c4ee6f9dbad3f3da68" kindref="member">serviceQueue()</ref>; });</para>
<para>... then at program shutdown, make sure to call <ref refid="class_c_scheduler_1aded9b7a535edbef852c49e31f8ffa8a2" kindref="member">stop()</ref> to clean up the thread(s) running serviceQueue: s-&gt;<ref refid="class_c_scheduler_1aded9b7a535edbef852c49e31f8ffa8a2" kindref="member">stop()</ref>; t-&gt;join(); delete t; delete s; // Must be done after thread is interrupted/joined. </para>
    </detaileddescription>
    <location file="src/scheduler.h" line="39" column="1" bodyfile="src/scheduler.h" bodystart="40" bodyend="112"/>
    <listofallmembers>
      <member refid="class_c_scheduler_1a46b9b16b5ab91c682ebc937d3948775f" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>AreThreadsServicingQueue</name></member>
      <member refid="class_c_scheduler_1a8f1d5988a71a3242aae7ebbea1ba49ac" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>CScheduler</name></member>
      <member refid="class_c_scheduler_1a5969d318a59171fc0413b19f59434889" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>Function</name></member>
      <member refid="class_c_scheduler_1aff14f7f321ef504ab44a28bb8d209ac2" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>getQueueInfo</name></member>
      <member refid="class_c_scheduler_1a50e8357dadadb23e24ad1126a8ee4a08" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>GUARDED_BY</name></member>
      <member refid="class_c_scheduler_1a86935c99463bb08a4d4ac32f07d74cc7" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>GUARDED_BY</name></member>
      <member refid="class_c_scheduler_1af72a22d9fa7c83d323ce6f477888e23f" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>GUARDED_BY</name></member>
      <member refid="class_c_scheduler_1afeb7c27379d50061db893acf1ee505d3" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>GUARDED_BY</name></member>
      <member refid="class_c_scheduler_1a6d839daab9225235d84cf6997c3f0ba2" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>m_service_thread</name></member>
      <member refid="class_c_scheduler_1a164bd31b14643a1063d6361c9f76da3f" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>MockForward</name></member>
      <member refid="class_c_scheduler_1a4021f0091e793d0cece15cadaa14fb3b" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>newTaskMutex</name></member>
      <member refid="class_c_scheduler_1afec5e0b03890fdc6802f45b6bfceb3d9" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>newTaskScheduled</name></member>
      <member refid="class_c_scheduler_1a243fcdfb5446405a84dffc4da757d18b" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>schedule</name></member>
      <member refid="class_c_scheduler_1afc967db034e89889059bca31574ec485" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>scheduleEvery</name></member>
      <member refid="class_c_scheduler_1afdb52271200f958fa88b14b94546bb20" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>scheduleFromNow</name></member>
      <member refid="class_c_scheduler_1a3c51a70f4b0106c4ee6f9dbad3f3da68" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>serviceQueue</name></member>
      <member refid="class_c_scheduler_1ad8543a492ccbaa2c24e17220dd2bb46f" prot="private" virt="non-virtual"><scope>CScheduler</scope><name>shouldStop</name></member>
      <member refid="class_c_scheduler_1aded9b7a535edbef852c49e31f8ffa8a2" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>stop</name></member>
      <member refid="class_c_scheduler_1a351504618ec55e33093a42e14f67e842" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>StopWhenDrained</name></member>
      <member refid="class_c_scheduler_1a4d87ed7b38f60ca287b11ec69d8e2212" prot="public" virt="non-virtual"><scope>CScheduler</scope><name>~CScheduler</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
