<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="structmp_1_1_proxy_server_base" kind="struct" language="C++" prot="public">
    <compoundname>mp::ProxyServerBase</compoundname>
    <basecompoundref prot="public" virt="virtual">Server</basecompoundref>
    <includes refid="proxy_8h" local="no">proxy.h</includes>
    <templateparamlist>
      <param>
        <type>typename Interface_</type>
      </param>
      <param>
        <type>typename Impl_</type>
      </param>
    </templateparamlist>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="structmp_1_1_proxy_server_base_1ac56f24b044e98752160b4a0a14514e76" prot="public" static="no">
        <type>Interface_</type>
        <definition>using Interface =  Interface_</definition>
        <argsstring></argsstring>
        <name>Interface</name>
        <qualifiedname>mp::ProxyServerBase::Interface</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="150" column="5" bodyfile="src/ipc/libmultiprocess/include/mp/proxy.h" bodystart="150" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="structmp_1_1_proxy_server_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" prot="public" static="no">
        <type>Impl_</type>
        <definition>using Impl =  Impl_</definition>
        <argsstring></argsstring>
        <name>Impl</name>
        <qualifiedname>mp::ProxyServerBase::Impl</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="151" column="5" bodyfile="src/ipc/libmultiprocess/include/mp/proxy.h" bodystart="151" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structmp_1_1_proxy_server_base_1a47b0d7e7413d0c7eb592ccf544a24f13" prot="public" static="no" mutable="no">
        <type>std::shared_ptr&lt; <ref refid="structmp_1_1_proxy_server_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" kindref="member">Impl</ref> &gt;</type>
        <definition>std::shared_ptr&lt;Impl&gt; m_impl</definition>
        <argsstring></argsstring>
        <name>m_impl</name>
        <qualifiedname>mp::ProxyServerBase::m_impl</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Implementation pointer that may or may not be owned and deleted when this capnp server goes out of scope. It is owned for servers created to wrap unique_ptr&lt;Impl&gt; method arguments, but unowned for servers created to wrap <ref refid="structmp_1_1_proxy_server_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" kindref="member">Impl</ref>&amp; method arguments.</para>
<para>In the case of <ref refid="structmp_1_1_proxy_server_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" kindref="member">Impl</ref>&amp; arguments, custom code is required on other side of the connection to delete the capnp client &amp; server objects since native code on that side of the connection will just be taking a plain reference rather than a pointer, so won&apos;t be able to do its own cleanup. Right now this is implemented with addCloseHook callbacks to delete clients at appropriate times depending on semantics of the particular method being wrapped. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="170" column="21" bodyfile="src/ipc/libmultiprocess/include/mp/proxy.h" bodystart="170" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structmp_1_1_proxy_server_base_1af910ca1c8fc9a191f85d16b71819c033" prot="public" static="no" mutable="no">
        <type><ref refid="structmp_1_1_proxy_context" kindref="compound">ProxyContext</ref></type>
        <definition>ProxyContext m_context</definition>
        <argsstring></argsstring>
        <name>m_context</name>
        <qualifiedname>mp::ProxyServerBase::m_context</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="171" column="18" bodyfile="src/ipc/libmultiprocess/include/mp/proxy.h" bodystart="171" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="structmp_1_1_proxy_server_base_1afe79a96d9eb6ad4ff906a7f6a5b858b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ProxyServerBase</definition>
        <argsstring>(std::shared_ptr&lt; Impl &gt; impl, Connection &amp;connection)</argsstring>
        <name>ProxyServerBase</name>
        <qualifiedname>mp::ProxyServerBase::ProxyServerBase</qualifiedname>
        <param>
          <type>std::shared_ptr&lt; <ref refid="structmp_1_1_proxy_server_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" kindref="member">Impl</ref> &gt;</type>
          <declname>impl</declname>
        </param>
        <param>
          <type><ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> &amp;</type>
          <declname>connection</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="153" column="5" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="520" bodyend="524"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_proxy_server_base_1a90a9c3ed54e1726a854d4fbf1eb1d379" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>~ProxyServerBase</definition>
        <argsstring>()</argsstring>
        <name>~ProxyServerBase</name>
        <qualifiedname>mp::ProxyServerBase::~ProxyServerBase</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> destructor, called from the <ref refid="classmp_1_1_event_loop" kindref="compound">EventLoop</ref> thread by Cap&apos;n Proto garbage collection code after there are no more references to this object. This will typically happen when the corresponding <ref refid="structmp_1_1_proxy_client" kindref="compound">ProxyClient</ref> object on the other side of the connection is destroyed. It can also happen earlier if the connection is broken or destroyed. In the latter case this destructor will typically be called inside m_rpc_system.reset() call in the ~Connection destructor while the <ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> object still exists. However, because <ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> objects are refcounted, and the <ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> object could be destroyed while asynchronous IPC calls are still in-flight, it&apos;s possible for this destructor to be called after the <ref refid="classmp_1_1_connection" kindref="compound">Connection</ref> object no longer exists, so it is NOT valid to dereference the m_context.connection pointer from this function. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="154" column="13" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="539" bodyend="567"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_proxy_server_base_1a337a3c890fad394953330b47eb4aafb2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void invokeDestroy</definition>
        <argsstring>()</argsstring>
        <name>invokeDestroy</name>
        <qualifiedname>mp::ProxyServerBase::invokeDestroy</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If the capnp interface defined a special &quot;destroy&quot; method, as described the <ref refid="classmp_1_1_proxy_client_base" kindref="compound">ProxyClientBase</ref> class, this method will be called and synchronously destroy m_impl before returning to the client.</para>
<para>If the capnp interface does not define a &quot;destroy&quot; method, this will never be called and the ~ProxyServerBase destructor will be responsible for deleting m_impl asynchronously, whenever the <ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> object gets garbage collected by Cap&apos;n Proto.</para>
<para>This method is called in the same way other proxy server methods are called, via the serverInvoke function. Basically serverInvoke just calls this as a substitute for a non-existent m_impl-&gt;destroy() method. If the destroy method has any parameters or return values they will be handled in the normal way by PassField/ReadField/BuildField functions. Particularly if a Context.thread parameter was passed, this method will run on the worker thread specified by the client. Otherwise it will run on the <ref refid="classmp_1_1_event_loop" kindref="compound">EventLoop</ref> thread, like other server methods without an assigned thread. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="155" column="10" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="587" bodyend="591"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><ref refid="class_base" kindref="compound">Base</ref> class for generated <ref refid="structmp_1_1_proxy_server" kindref="compound">ProxyServer</ref> classes that implement capnp server methods and forward calls to a wrapped c++ implementation class. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>Server</label>
      </node>
      <node id="1">
        <label>ProxyServerBase&lt; Interface_, Impl_ &gt;</label>
        <link refid="structmp_1_1_proxy_server_base"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="7">
        <label>AnnotatedMixin&lt; std::mutex &gt;</label>
        <link refid="class_annotated_mixin"/>
        <childnode refid="8" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>Server</label>
      </node>
      <node id="1">
        <label>ProxyServerBase&lt; Interface_, Impl_ &gt;</label>
        <link refid="structmp_1_1_proxy_server_base"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
        <childnode refid="3" relation="usage">
          <edgelabel>m_context</edgelabel>
        </childnode>
      </node>
      <node id="10">
        <label>ErrorHandler</label>
      </node>
      <node id="4">
        <label>Connection</label>
        <link refid="classmp_1_1_connection"/>
        <childnode refid="5" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
        <childnode refid="9" relation="usage">
          <edgelabel>m_error_handler</edgelabel>
        </childnode>
      </node>
      <node id="6">
        <label>EventLoop</label>
        <link refid="classmp_1_1_event_loop"/>
        <childnode refid="7" relation="usage">
          <edgelabel>m_mutex</edgelabel>
        </childnode>
        <childnode refid="9" relation="usage">
          <edgelabel>m_error_handler</edgelabel>
        </childnode>
        <childnode refid="11" relation="usage">
          <edgelabel>m_log_opts</edgelabel>
        </childnode>
      </node>
      <node id="5">
        <label>EventLoopRef</label>
        <link refid="classmp_1_1_event_loop_ref"/>
        <childnode refid="6" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
        <childnode refid="12" relation="usage">
          <edgelabel>m_lock</edgelabel>
        </childnode>
      </node>
      <node id="12">
        <label>Lock</label>
        <link refid="classmp_1_1_lock"/>
      </node>
      <node id="11">
        <label>LogOptions</label>
        <link refid="structmp_1_1_log_options"/>
      </node>
      <node id="9">
        <label>LoggingErrorHandler</label>
        <link refid="classmp_1_1_logging_error_handler"/>
        <childnode refid="10" relation="public-inheritance">
        </childnode>
        <childnode refid="6" relation="usage">
          <edgelabel>m_loop</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>ProxyContext</label>
        <link refid="structmp_1_1_proxy_context"/>
        <childnode refid="4" relation="usage">
          <edgelabel>connection</edgelabel>
        </childnode>
        <childnode refid="5" relation="usage">
          <edgelabel>loop</edgelabel>
        </childnode>
      </node>
      <node id="8">
        <label>mutex</label>
      </node>
    </collaborationgraph>
    <location file="src/ipc/libmultiprocess/include/mp/proxy.h" line="147" column="1" bodyfile="src/ipc/libmultiprocess/include/mp/proxy.h" bodystart="148" bodyend="172"/>
    <listofallmembers>
      <member refid="structmp_1_1_proxy_server_base_1aa5c2e2f388eaba65ab01f79b1ae9ea32" prot="public" virt="non-virtual"><scope>mp::ProxyServerBase</scope><name>Impl</name></member>
      <member refid="structmp_1_1_proxy_server_base_1ac56f24b044e98752160b4a0a14514e76" prot="public" virt="non-virtual"><scope>mp::ProxyServerBase</scope><name>Interface</name></member>
      <member refid="structmp_1_1_proxy_server_base_1a337a3c890fad394953330b47eb4aafb2" prot="public" virt="non-virtual"><scope>mp::ProxyServerBase</scope><name>invokeDestroy</name></member>
      <member refid="structmp_1_1_proxy_server_base_1af910ca1c8fc9a191f85d16b71819c033" prot="public" virt="non-virtual"><scope>mp::ProxyServerBase</scope><name>m_context</name></member>
      <member refid="structmp_1_1_proxy_server_base_1a47b0d7e7413d0c7eb592ccf544a24f13" prot="public" virt="non-virtual"><scope>mp::ProxyServerBase</scope><name>m_impl</name></member>
      <member refid="structmp_1_1_proxy_server_base_1afe79a96d9eb6ad4ff906a7f6a5b858b4" prot="public" virt="non-virtual"><scope>mp::ProxyServerBase</scope><name>ProxyServerBase</name></member>
      <member refid="structmp_1_1_proxy_server_base_1a90a9c3ed54e1726a854d4fbf1eb1d379" prot="public" virt="virtual"><scope>mp::ProxyServerBase</scope><name>~ProxyServerBase</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
