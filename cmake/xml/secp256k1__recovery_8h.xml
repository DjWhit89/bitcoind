<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="secp256k1__recovery_8h" kind="file" language="C++">
    <compoundname>secp256k1_recovery.h</compoundname>
    <includes refid="secp256k1_8h" local="yes">secp256k1.h</includes>
    <includedby refid="key_8cpp" local="no">src/key.cpp</includedby>
    <includedby refid="pubkey_8cpp" local="no">src/pubkey.cpp</includedby>
    <includedby refid="recovery_2bench__impl_8h" local="yes">src/secp256k1/src/modules/recovery/bench_impl.h</includedby>
    <includedby refid="recovery_2main__impl_8h" local="yes">src/secp256k1/src/modules/recovery/main_impl.h</includedby>
    <includedby refid="recovery_2tests__exhaustive__impl_8h" local="yes">src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h</includedby>
    <incdepgraph>
      <node id="2">
        <label>secp256k1.h</label>
        <link refid="secp256k1_8h"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/secp256k1/include/secp256k1_recovery.h</label>
        <link refid="secp256k1__recovery_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>stddef.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="2">
        <label>src/key.cpp</label>
        <link refid="key_8cpp"/>
      </node>
      <node id="3">
        <label>src/pubkey.cpp</label>
        <link refid="pubkey_8cpp"/>
      </node>
      <node id="1">
        <label>src/secp256k1/include/secp256k1_recovery.h</label>
        <link refid="secp256k1__recovery_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>src/secp256k1/src/modules/recovery/bench_impl.h</label>
        <link refid="recovery_2bench__impl_8h"/>
      </node>
      <node id="5">
        <label>src/secp256k1/src/modules/recovery/main_impl.h</label>
        <link refid="recovery_2main__impl_8h"/>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>src/secp256k1/src/modules/recovery/tests_exhaustive_impl.h</label>
        <link refid="recovery_2tests__exhaustive__impl_8h"/>
      </node>
    </invincdepgraph>
    <innerclass refid="structsecp256k1__ecdsa__recoverable__signature" prot="public">secp256k1_ecdsa_recoverable_signature</innerclass>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="secp256k1__recovery_8h_1a458eba22320a4df81ccdbd68c0a2e3c4" prot="public" static="no">
        <type>struct secp256k1_ecdsa_recoverable_signature</type>
        <definition>typedef struct secp256k1_ecdsa_recoverable_signature secp256k1_ecdsa_recoverable_signature</definition>
        <argsstring></argsstring>
        <name>secp256k1_ecdsa_recoverable_signature</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Opaque data structure that holds a parsed ECDSA signature, supporting pubkey recovery.</para>
<para>The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions. It is however guaranteed to be 65 bytes in size, and can be safely copied/moved. If you need to convert to a format suitable for storage or transmission, use the secp256k1_ecdsa_signature_serialize_* and secp256k1_ecdsa_signature_parse_* functions.</para>
<para>Furthermore, it is guaranteed that identical signatures (including their recoverability) will have identical representation, so they can be memcmp&apos;ed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/include/secp256k1_recovery.h" line="26" column="39"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="secp256k1__recovery_8h_1a6699b45dc75be70f028ac7d8ffaba46e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref> int</type>
        <definition>SECP256K1_API int secp256k1_ecdsa_recoverable_signature_parse_compact</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_recoverable_signature *sig, const unsigned char *input64, int recid) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3)</argsstring>
        <name>secp256k1_ecdsa_recoverable_signature_parse_compact</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input64</declname>
        </param>
        <param>
          <type>int</type>
          <declname>recid</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a compact ECDSA signature (64 bytes + recovery id).</para>
<para>Returns: 1 when the signature could be parsed, 0 otherwise Args: ctx: pointer to a context object Out: sig: pointer to a signature object In: input64: pointer to a 64-byte compact signature recid: the recovery id (0, 1, 2 or 3) </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/include/secp256k1_recovery.h" line="36" column="19" bodyfile="src/secp256k1/src/modules/recovery/main_impl.h" bodystart="38" bodyend="58" declfile="src/secp256k1/include/secp256k1_recovery.h" declline="36" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1__recovery_8h_1ad7a20c9f7ccd9fc6d75a19a3b4195aa5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref> int</type>
        <definition>SECP256K1_API int secp256k1_ecdsa_recoverable_signature_convert</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const secp256k1_ecdsa_recoverable_signature *sigin) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3)</argsstring>
        <name>secp256k1_ecdsa_recoverable_signature_convert</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref> *</type>
          <declname>sigin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a recoverable signature into a normal signature.</para>
<para>Returns: 1 Args: ctx: pointer to a context object. Out: sig: pointer to a normal signature. In: sigin: pointer to a recoverable signature. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/include/secp256k1_recovery.h" line="50" column="19" bodyfile="src/secp256k1/src/modules/recovery/main_impl.h" bodystart="74" bodyend="85" declfile="src/secp256k1/include/secp256k1_recovery.h" declline="50" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1__recovery_8h_1a12f08c89ceb61949c6a4ec6eb2511185" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref> int</type>
        <definition>SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output64, int *recid, const secp256k1_ecdsa_recoverable_signature *sig) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)</argsstring>
        <name>secp256k1_ecdsa_recoverable_signature_serialize_compact</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output64</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>recid</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize an ECDSA signature in compact format (64 bytes + recovery id).</para>
<para>Returns: 1 Args: ctx: pointer to a context object. Out: output64: pointer to a 64-byte array of the compact signature. recid: pointer to an integer to hold the recovery id. In: sig: pointer to an initialized signature object. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/include/secp256k1_recovery.h" line="64" column="19" bodyfile="src/secp256k1/src/modules/recovery/main_impl.h" bodystart="60" bodyend="72" declfile="src/secp256k1/include/secp256k1_recovery.h" declline="64" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1__recovery_8h_1a7868accd4760afcaeaa0ff3d239afc2a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref> int</type>
        <definition>SECP256K1_API int secp256k1_ecdsa_sign_recoverable</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_recoverable_signature *sig, const unsigned char *msghash32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *ndata) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)</argsstring>
        <name>secp256k1_ecdsa_sign_recoverable</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msghash32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
          <declname>noncefp</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>ndata</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a recoverable ECDSA signature.</para>
<para>Returns: 1: signature created 0: the nonce generation function failed, or the secret key was invalid. Args: ctx: pointer to a context object (not secp256k1_context_static). Out: sig: pointer to an array where the signature will be placed. In: msghash32: the 32-byte message hash being signed. seckey: pointer to a 32-byte secret key. noncefp: pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used. ndata: pointer to arbitrary data used by the nonce generation function (can be NULL for secp256k1_nonce_function_default). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/include/secp256k1_recovery.h" line="84" column="19" bodyfile="src/secp256k1/src/modules/recovery/main_impl.h" bodystart="123" bodyend="135" declfile="src/secp256k1/include/secp256k1_recovery.h" declline="84" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1__recovery_8h_1af9f2082776bf8ebdb4c38161a211a02b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref> <ref refid="secp256k1_8h_1aebd5ca8fbfcbb0ba0754a46115143c2c" kindref="member">SECP256K1_WARN_UNUSED_RESULT</ref> int</type>
        <definition>SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdsa_recover</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const secp256k1_ecdsa_recoverable_signature *sig, const unsigned char *msghash32) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4)</argsstring>
        <name>secp256k1_ecdsa_recover</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msghash32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Recover an ECDSA public key from a signature.</para>
<para>Successful public key recovery guarantees that the signature, after normalization, passes <computeroutput><ref refid="secp256k1_8h_1a7dd6acb7ef7100a6aebff91ecb7ede30" kindref="member">secp256k1_ecdsa_verify</ref></computeroutput>. Thus, explicit verification is not necessary.</para>
<para>However, a recoverable signature that successfully passes <computeroutput><ref refid="secp256k1__recovery_8h_1af9f2082776bf8ebdb4c38161a211a02b" kindref="member">secp256k1_ecdsa_recover</ref></computeroutput>, when converted to a non-recoverable signature (using <computeroutput><ref refid="secp256k1__recovery_8h_1ad7a20c9f7ccd9fc6d75a19a3b4195aa5" kindref="member">secp256k1_ecdsa_recoverable_signature_convert</ref></computeroutput>), is not guaranteed to be normalized and thus not guaranteed to pass <computeroutput><ref refid="secp256k1_8h_1a7dd6acb7ef7100a6aebff91ecb7ede30" kindref="member">secp256k1_ecdsa_verify</ref></computeroutput>. If a normalized signature is required, call <computeroutput><ref refid="secp256k1_8h_1a93ec36a19229f08acc5ff1ca613ab3a1" kindref="member">secp256k1_ecdsa_signature_normalize</ref></computeroutput> after <computeroutput><ref refid="secp256k1__recovery_8h_1ad7a20c9f7ccd9fc6d75a19a3b4195aa5" kindref="member">secp256k1_ecdsa_recoverable_signature_convert</ref></computeroutput>.</para>
<para>Returns: 1: public key successfully recovered 0: otherwise. Args: ctx: pointer to a context object. Out: pubkey: pointer to the recovered public key. In: sig: pointer to initialized signature that supports pubkey recovery. msghash32: the 32-byte message hash assumed to be signed. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/secp256k1/include/secp256k1_recovery.h" line="112" column="48" bodyfile="src/secp256k1/src/modules/recovery/main_impl.h" bodystart="137" bodyend="157" declfile="src/secp256k1/include/secp256k1_recovery.h" declline="112" declcolumn="48"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#ifndef<sp/>SECP256K1_RECOVERY_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SECP256K1_RECOVERY_H</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1_8h" kindref="compound">secp256k1.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="24" refid="structsecp256k1__ecdsa__recoverable__signature" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref><sp/>{</highlight></codeline>
<codeline lineno="25" refid="structsecp256k1__ecdsa__recoverable__signature_1ab48ba7b3f2306d572a97eff6da103b93" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature_1ab48ba7b3f2306d572a97eff6da103b93" kindref="member">data</ref>[65];</highlight></codeline>
<codeline lineno="26" refid="secp256k1__recovery_8h_1a458eba22320a4df81ccdbd68c0a2e3c4" refkind="member"><highlight class="normal">}<sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref>;</highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1__recovery_8h_1a6699b45dc75be70f028ac7d8ffaba46e" kindref="member">secp256k1_ecdsa_recoverable_signature_parse_compact</ref>(</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*ctx,</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref><sp/>*sig,</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input64,</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>recid</highlight></codeline>
<codeline lineno="41"><highlight class="normal">)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(1)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(2)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(3);</highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1__recovery_8h_1ad7a20c9f7ccd9fc6d75a19a3b4195aa5" kindref="member">secp256k1_ecdsa_recoverable_signature_convert</ref>(</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*ctx,</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sig,</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref><sp/>*sigin</highlight></codeline>
<codeline lineno="54"><highlight class="normal">)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(1)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(2)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(3);</highlight></codeline>
<codeline lineno="55"><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1__recovery_8h_1a12f08c89ceb61949c6a4ec6eb2511185" kindref="member">secp256k1_ecdsa_recoverable_signature_serialize_compact</ref>(</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*ctx,</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output64,</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*recid,</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref><sp/>*sig</highlight></codeline>
<codeline lineno="69"><highlight class="normal">)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(1)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(2)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(3)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(4);</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal"><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1__recovery_8h_1a7868accd4760afcaeaa0ff3d239afc2a" kindref="member">secp256k1_ecdsa_sign_recoverable</ref>(</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*ctx,</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref><sp/>*sig,</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msghash32,</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/>noncefp,</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*ndata</highlight></codeline>
<codeline lineno="91"><highlight class="normal">)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(1)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(2)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(3)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(4);</highlight></codeline>
<codeline lineno="92"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><ref refid="secp256k1_8h_1a3f1967acd0fe26283877c61b3f2694a5" kindref="member">SECP256K1_API</ref><sp/><ref refid="secp256k1_8h_1aebd5ca8fbfcbb0ba0754a46115143c2c" kindref="member">SECP256K1_WARN_UNUSED_RESULT</ref><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1__recovery_8h_1af9f2082776bf8ebdb4c38161a211a02b" kindref="member">secp256k1_ecdsa_recover</ref>(</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref><sp/>*ctx,</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/><ref refid="structsecp256k1__ecdsa__recoverable__signature" kindref="compound">secp256k1_ecdsa_recoverable_signature</ref><sp/>*sig,</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msghash32</highlight></codeline>
<codeline lineno="117"><highlight class="normal">)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(1)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(2)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(3)<sp/><ref refid="secp256k1_8h_1a03c194d8fa91b9b66758b36c91e0b5cb" kindref="member">SECP256K1_ARG_NONNULL</ref>(4);</highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__cplusplus</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal">}</highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>SECP256K1_RECOVERY_H<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="src/secp256k1/include/secp256k1_recovery.h"/>
  </compounddef>
</doxygen>
