<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_addr_man" kind="class" language="C++" prot="public">
    <compoundname>AddrMan</compoundname>
    <derivedcompoundref refid="class_addr_man_deterministic" prot="public" virt="non-virtual">AddrManDeterministic</derivedcompoundref>
    <includes refid="addrman_8h" local="no">addrman.h</includes>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="class_addr_man_1a810d1e6cf5525f90041da212f6189e89" prot="protected" static="no" mutable="no">
        <type>const std::unique_ptr&lt; <ref refid="class_addr_man_impl" kindref="compound">AddrManImpl</ref> &gt;</type>
        <definition>const std::unique_ptr&lt;AddrManImpl&gt; m_impl</definition>
        <argsstring></argsstring>
        <name>m_impl</name>
        <qualifiedname>AddrMan::m_impl</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="91" column="27" bodyfile="src/addrman.h" bodystart="91" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_addr_man_1a4b6cb9872d13a1e3d821f9b17a8b6db6" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>AddrMan</definition>
        <argsstring>(const NetGroupManager &amp;netgroupman, bool deterministic, int32_t consistency_check_ratio)</argsstring>
        <name>AddrMan</name>
        <qualifiedname>AddrMan::AddrMan</qualifiedname>
        <param>
          <type>const <ref refid="class_net_group_manager" kindref="compound">NetGroupManager</ref> &amp;</type>
          <declname>netgroupman</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>deterministic</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>consistency_check_ratio</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="94" column="14" bodyfile="src/addrman.cpp" bodystart="1272" bodyend="1273"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ae269a6c335d01a48a541f6d7e3b0ecbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>~AddrMan</definition>
        <argsstring>()</argsstring>
        <name>~AddrMan</name>
        <qualifiedname>AddrMan::~AddrMan</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="96" column="5"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ae7b340a1417273fa5fb4dd89b68e90a5" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Stream</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>template void Serialize</definition>
        <argsstring>(Stream &amp;s_) const</argsstring>
        <name>Serialize</name>
        <qualifiedname>AddrMan::Serialize</qualifiedname>
        <param>
          <type>Stream &amp;</type>
          <declname>s_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="99" column="10" bodyfile="src/addrman.cpp" bodystart="1278" bodyend="1281"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ab646bc9d141d8c4971fa522a73677586" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Stream</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>template void Unserialize</definition>
        <argsstring>(Stream &amp;s_)</argsstring>
        <name>Unserialize</name>
        <qualifiedname>AddrMan::Unserialize</qualifiedname>
        <param>
          <type>Stream &amp;</type>
          <declname>s_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="102" column="10" bodyfile="src/addrman.cpp" bodystart="1284" bodyend="1287"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ad14483585857cd4336e052ecdea6eb92" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Size</definition>
        <argsstring>(std::optional&lt; Network &gt; net=std::nullopt, std::optional&lt; bool &gt; in_new=std::nullopt) const</argsstring>
        <name>Size</name>
        <qualifiedname>AddrMan::Size</qualifiedname>
        <param>
          <type>std::optional&lt; <ref refid="netaddress_8h_1acc9a38c714afe79b5035cb36f560dac3" kindref="member">Network</ref> &gt;</type>
          <declname>net</declname>
          <defval>std::nullopt</defval>
        </param>
        <param>
          <type>std::optional&lt; bool &gt;</type>
          <declname>in_new</declname>
          <defval>std::nullopt</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return size information about addrman.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">net</parametername>
</parameternamelist>
<parameterdescription>
<para>Select addresses only from specified network (nullopt = all) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">in_new</parametername>
</parameternamelist>
<parameterdescription>
<para>Select addresses only from one table (true = new, false = tried, nullopt = both) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of unique addresses that match specified options. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="111" column="12" bodyfile="src/addrman.cpp" bodystart="1297" bodyend="1300"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1af0acda4d7598ebd2cb76c8ee97ee845f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Add</definition>
        <argsstring>(const std::vector&lt; CAddress &gt; &amp;vAddr, const CNetAddr &amp;source, std::chrono::seconds time_penalty=0s)</argsstring>
        <name>Add</name>
        <qualifiedname>AddrMan::Add</qualifiedname>
        <param>
          <type>const std::vector&lt; <ref refid="class_c_address" kindref="compound">CAddress</ref> &gt; &amp;</type>
          <declname>vAddr</declname>
        </param>
        <param>
          <type>const <ref refid="class_c_net_addr" kindref="compound">CNetAddr</ref> &amp;</type>
          <declname>source</declname>
        </param>
        <param>
          <type>std::chrono::seconds</type>
          <declname>time_penalty</declname>
          <defval>0s</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Attempt to add one or more addresses to addrman&apos;s new table. If an address already exists in addrman, the existing entry may be updated (e.g. adding additional service flags). If the existing entry is in the new table, it may be added to more buckets, improving the probability of selection.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">vAddr</parametername>
</parameternamelist>
<parameterdescription>
<para>Address records to attempt to add. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">source</parametername>
</parameternamelist>
<parameterdescription>
<para>The address of the node that sent us these addr records. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">time_penalty</parametername>
</parameternamelist>
<parameterdescription>
<para>A &quot;time penalty&quot; to apply to the address record&apos;s nTime. If a peer sends us an address record with nTime=n, then we&apos;ll add it to our addrman with nTime=(n - time_penalty). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if at least one address is successfully added, or added to an additional bucket. Unaffected by updates. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="125" column="10" bodyfile="src/addrman.cpp" bodystart="1302" bodyend="1305"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1a706c1c1b34e109a4c2e5310b15a72c4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Good</definition>
        <argsstring>(const CService &amp;addr, NodeSeconds time=Now&lt; NodeSeconds &gt;())</argsstring>
        <name>Good</name>
        <qualifiedname>AddrMan::Good</qualifiedname>
        <param>
          <type>const <ref refid="class_c_service" kindref="compound">CService</ref> &amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref></type>
          <declname>time</declname>
          <defval><ref refid="util_2time_8h_1a7a4e7e09a41ff922cf1eb6fdaae4b3ba" kindref="member">Now</ref>&lt; <ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref> &gt;()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Mark an address record as accessible and attempt to move it to addrman&apos;s tried table.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>Address record to attempt to move to tried table. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">time</parametername>
</parameternamelist>
<parameterdescription>
<para>The time that we were last connected to this peer. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if the address is successfully moved from the new table to the tried table. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="134" column="10" bodyfile="src/addrman.cpp" bodystart="1307" bodyend="1310"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1af610ed4d0bc8631426d628c08c392585" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Attempt</definition>
        <argsstring>(const CService &amp;addr, bool fCountFailure, NodeSeconds time=Now&lt; NodeSeconds &gt;())</argsstring>
        <name>Attempt</name>
        <qualifiedname>AddrMan::Attempt</qualifiedname>
        <param>
          <type>const <ref refid="class_c_service" kindref="compound">CService</ref> &amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>fCountFailure</declname>
        </param>
        <param>
          <type><ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref></type>
          <declname>time</declname>
          <defval><ref refid="util_2time_8h_1a7a4e7e09a41ff922cf1eb6fdaae4b3ba" kindref="member">Now</ref>&lt; <ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref> &gt;()</defval>
        </param>
        <briefdescription>
<para>Mark an entry as connection attempted to. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="137" column="10" bodyfile="src/addrman.cpp" bodystart="1312" bodyend="1315"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1a15574032976f63a21b1781d0ed08d75b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ResolveCollisions</definition>
        <argsstring>()</argsstring>
        <name>ResolveCollisions</name>
        <qualifiedname>AddrMan::ResolveCollisions</qualifiedname>
        <briefdescription>
<para>See if any to-be-evicted tried table entries have been tested and if so resolve the collisions. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="140" column="10" bodyfile="src/addrman.cpp" bodystart="1317" bodyend="1320"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1af0fc23fd56fa4cfc1327991984fb9389" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; <ref refid="class_c_address" kindref="compound">CAddress</ref>, <ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref> &gt;</type>
        <definition>std::pair&lt; CAddress, NodeSeconds &gt; SelectTriedCollision</definition>
        <argsstring>()</argsstring>
        <name>SelectTriedCollision</name>
        <qualifiedname>AddrMan::SelectTriedCollision</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Randomly select an address in the tried table that another address is attempting to evict.</para>
<para><simplesect kind="return"><para><ref refid="class_c_address" kindref="compound">CAddress</ref> The record for the selected tried peer. seconds The last time we attempted to connect to that peer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="149" column="15" bodyfile="src/addrman.cpp" bodystart="1322" bodyend="1325"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1aef855c09bfa93ccd88508eaf73d5bc74" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; <ref refid="class_c_address" kindref="compound">CAddress</ref>, <ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref> &gt;</type>
        <definition>std::pair&lt; CAddress, NodeSeconds &gt; Select</definition>
        <argsstring>(bool new_only=false, const std::unordered_set&lt; Network &gt; &amp;networks={}) const</argsstring>
        <name>Select</name>
        <qualifiedname>AddrMan::Select</qualifiedname>
        <param>
          <type>bool</type>
          <declname>new_only</declname>
          <defval>false</defval>
        </param>
        <param>
          <type>const std::unordered_set&lt; <ref refid="netaddress_8h_1acc9a38c714afe79b5035cb36f560dac3" kindref="member">Network</ref> &gt; &amp;</type>
          <declname>networks</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Choose an address to connect to.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">new_only</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to only select addresses from the new table. Passing <computeroutput>true</computeroutput> returns an address from the new table or an empty pair. Passing <computeroutput>false</computeroutput> will return an empty pair or an address from either the new or tried table (it does not guarantee a tried entry). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">networks</parametername>
</parameternamelist>
<parameterdescription>
<para>Select only addresses of these networks (empty = all). Passing networks may slow down the search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="class_c_address" kindref="compound">CAddress</ref> The record for the selected peer. seconds The last time we attempted to connect to that peer. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="163" column="15" bodyfile="src/addrman.cpp" bodystart="1327" bodyend="1330"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ab64d634410f099e19c2f2b6b83876118" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; <ref refid="class_c_address" kindref="compound">CAddress</ref> &gt;</type>
        <definition>std::vector&lt; CAddress &gt; GetAddr</definition>
        <argsstring>(size_t max_addresses, size_t max_pct, std::optional&lt; Network &gt; network, const bool filtered=true) const</argsstring>
        <name>GetAddr</name>
        <qualifiedname>AddrMan::GetAddr</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>max_addresses</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>max_pct</declname>
        </param>
        <param>
          <type>std::optional&lt; <ref refid="netaddress_8h_1acc9a38c714afe79b5035cb36f560dac3" kindref="member">Network</ref> &gt;</type>
          <declname>network</declname>
        </param>
        <param>
          <type>const bool</type>
          <declname>filtered</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return all or many randomly selected addresses, optionally by network.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">max_addresses</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum number of addresses to return (0 = all). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">max_pct</parametername>
</parameternamelist>
<parameterdescription>
<para>Maximum percentage of addresses to return (0 = all). Value must be from 0 to 100. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">network</parametername>
</parameternamelist>
<parameterdescription>
<para>Select only addresses of this network (nullopt = all). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">filtered</parametername>
</parameternamelist>
<parameterdescription>
<para>Select only addresses that are considered good quality (false = all).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector of randomly selected addresses from vRandom. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="175" column="17" bodyfile="src/addrman.cpp" bodystart="1332" bodyend="1335"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ae18710a592d984080a6b29c9965b7418" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::pair&lt; <ref refid="class_addr_info" kindref="compound">AddrInfo</ref>, <ref refid="struct_address_position" kindref="compound">AddressPosition</ref> &gt; &gt;</type>
        <definition>std::vector&lt; std::pair&lt; AddrInfo, AddressPosition &gt; &gt; GetEntries</definition>
        <argsstring>(bool from_tried) const</argsstring>
        <name>GetEntries</name>
        <qualifiedname>AddrMan::GetEntries</qualifiedname>
        <param>
          <type>bool</type>
          <declname>from_tried</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns an information-location pair for all addresses in the selected addrman table. If an address appears multiple times in the new table, an information-location pair is returned for each occurrence. Addresses only ever appear once in the tried table.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">from_tried</parametername>
</parameternamelist>
<parameterdescription>
<para>Selects which table to return entries from.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A vector consisting of pairs of <ref refid="class_addr_info" kindref="compound">AddrInfo</ref> and <ref refid="struct_address_position" kindref="compound">AddressPosition</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="186" column="17" bodyfile="src/addrman.cpp" bodystart="1337" bodyend="1340"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1a5db77c65bd764c01b128936f2dcca9ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Connected</definition>
        <argsstring>(const CService &amp;addr, NodeSeconds time=Now&lt; NodeSeconds &gt;())</argsstring>
        <name>Connected</name>
        <qualifiedname>AddrMan::Connected</qualifiedname>
        <param>
          <type>const <ref refid="class_c_service" kindref="compound">CService</ref> &amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref></type>
          <declname>time</declname>
          <defval><ref refid="util_2time_8h_1a7a4e7e09a41ff922cf1eb6fdaae4b3ba" kindref="member">Now</ref>&lt; <ref refid="util_2time_8h_1a8f3f2401a7990dfdbcf694471e95fb1e" kindref="member">NodeSeconds</ref> &gt;()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>We have successfully connected to this peer. Calling this function updates the <ref refid="class_c_address" kindref="compound">CAddress</ref>&apos;s nTime, which is used in our IsTerrible() decisions and gossiped to peers. Callers should be careful that updating this information doesn&apos;t leak topology information to network spies.</para>
<para>net_processing calls this function when it <emphasis>disconnects</emphasis> from a peer to not leak information about currently connected peers.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>The address of the peer we were connected to </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">time</parametername>
</parameternamelist>
<parameterdescription>
<para>The time that we were last connected to this peer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="199" column="10" bodyfile="src/addrman.cpp" bodystart="1342" bodyend="1345"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1a0b0d0a32c294a075972d91681ed918fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void SetServices</definition>
        <argsstring>(const CService &amp;addr, ServiceFlags nServices)</argsstring>
        <name>SetServices</name>
        <qualifiedname>AddrMan::SetServices</qualifiedname>
        <param>
          <type>const <ref refid="class_c_service" kindref="compound">CService</ref> &amp;</type>
          <declname>addr</declname>
        </param>
        <param>
          <type><ref refid="protocol_8h_1ad131f3177584caea787cdbf6f85a9537" kindref="member">ServiceFlags</ref></type>
          <declname>nServices</declname>
        </param>
        <briefdescription>
<para>Update an entry&apos;s service bits. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="202" column="10" bodyfile="src/addrman.cpp" bodystart="1347" bodyend="1350"/>
      </memberdef>
      <memberdef kind="function" id="class_addr_man_1ae6f01245c5edff531298e93e6ed69d42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; <ref refid="struct_address_position" kindref="compound">AddressPosition</ref> &gt;</type>
        <definition>std::optional&lt; AddressPosition &gt; FindAddressEntry</definition>
        <argsstring>(const CAddress &amp;addr)</argsstring>
        <name>FindAddressEntry</name>
        <qualifiedname>AddrMan::FindAddressEntry</qualifiedname>
        <param>
          <type>const <ref refid="class_c_address" kindref="compound">CAddress</ref> &amp;</type>
          <declname>addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Test-only function Find the address record in <ref refid="class_addr_man" kindref="compound">AddrMan</ref> and return information about its position. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">addr</parametername>
</parameternamelist>
<parameterdescription>
<para>The address record to look up. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Information about the address record in <ref refid="class_addr_man" kindref="compound">AddrMan</ref> or nullopt if address is not found. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/addrman.h" line="211" column="19" bodyfile="src/addrman.cpp" bodystart="1352" bodyend="1355"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Stochastic address manager</para>
<para>Design goals:<itemizedlist>
<listitem><para>Keep the address tables in-memory, and asynchronously dump the entire table to peers.dat.</para>
</listitem><listitem><para>Make sure no (localized) attacker can fill the entire table with his nodes/addresses.</para>
</listitem></itemizedlist>
</para>
<para>To that end:<itemizedlist>
<listitem><para>Addresses are organized into buckets that can each store up to 64 entries.<itemizedlist>
<listitem><para>Addresses to which our node has not successfully connected go into 1024 &quot;new&quot; buckets.<itemizedlist>
<listitem><para>Based on the address range (/16 for IPv4) of the source of information, or if an asmap is provided, the AS it belongs to (for IPv4/IPv6), 64 buckets are selected at random.</para>
</listitem><listitem><para>The actual bucket is chosen from one of these, based on the range in which the address itself is located.</para>
</listitem><listitem><para>The position in the bucket is chosen based on the full address.</para>
</listitem><listitem><para>One single address can occur in up to 8 different buckets to increase selection chances for addresses that are seen frequently. The chance for increasing this multiplicity decreases exponentially.</para>
</listitem><listitem><para>When adding a new address to an occupied position of a bucket, it will not replace the existing entry unless that address is also stored in another bucket or it doesn&apos;t meet one of several quality criteria (see IsTerrible for exact criteria).</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Addresses of nodes that are known to be accessible go into 256 &quot;tried&quot; buckets.<itemizedlist>
<listitem><para>Each address range selects at random 8 of these buckets.</para>
</listitem><listitem><para>The actual bucket is chosen from one of these, based on the full address.</para>
</listitem><listitem><para>When adding a new good address to an occupied position of a bucket, a FEELER connection to the old address is attempted. The old entry is only replaced and moved back to the &quot;new&quot; buckets if this attempt was unsuccessful.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not be observable by adversaries.</para>
</listitem><listitem><para>Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman configuration option will introduce (expensive) consistency checks for the entire data structure. </para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>AddrMan</label>
        <link refid="class_addr_man"/>
      </node>
      <node id="2">
        <label>AddrManDeterministic</label>
        <link refid="class_addr_man_deterministic"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="src/addrman.h" line="88" column="1" bodyfile="src/addrman.h" bodystart="89" bodyend="212"/>
    <listofallmembers>
      <member refid="class_addr_man_1af0acda4d7598ebd2cb76c8ee97ee845f" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Add</name></member>
      <member refid="class_addr_man_1a4b6cb9872d13a1e3d821f9b17a8b6db6" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>AddrMan</name></member>
      <member refid="class_addr_man_1af610ed4d0bc8631426d628c08c392585" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Attempt</name></member>
      <member refid="class_addr_man_1a5db77c65bd764c01b128936f2dcca9ef" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Connected</name></member>
      <member refid="class_addr_man_1ae6f01245c5edff531298e93e6ed69d42" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>FindAddressEntry</name></member>
      <member refid="class_addr_man_1ab64d634410f099e19c2f2b6b83876118" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>GetAddr</name></member>
      <member refid="class_addr_man_1ae18710a592d984080a6b29c9965b7418" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>GetEntries</name></member>
      <member refid="class_addr_man_1a706c1c1b34e109a4c2e5310b15a72c4d" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Good</name></member>
      <member refid="class_addr_man_1a810d1e6cf5525f90041da212f6189e89" prot="protected" virt="non-virtual"><scope>AddrMan</scope><name>m_impl</name></member>
      <member refid="class_addr_man_1a15574032976f63a21b1781d0ed08d75b" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>ResolveCollisions</name></member>
      <member refid="class_addr_man_1aef855c09bfa93ccd88508eaf73d5bc74" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Select</name></member>
      <member refid="class_addr_man_1af0fc23fd56fa4cfc1327991984fb9389" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>SelectTriedCollision</name></member>
      <member refid="class_addr_man_1ae7b340a1417273fa5fb4dd89b68e90a5" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Serialize</name></member>
      <member refid="class_addr_man_1a0b0d0a32c294a075972d91681ed918fb" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>SetServices</name></member>
      <member refid="class_addr_man_1ad14483585857cd4336e052ecdea6eb92" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Size</name></member>
      <member refid="class_addr_man_1ab646bc9d141d8c4971fa522a73677586" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>Unserialize</name></member>
      <member refid="class_addr_man_1ae269a6c335d01a48a541f6d7e3b0ecbf" prot="public" virt="non-virtual"><scope>AddrMan</scope><name>~AddrMan</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
