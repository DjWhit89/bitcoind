<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="structmp_1_1_waiter" kind="struct" language="C++" prot="public">
    <compoundname>mp::Waiter</compoundname>
    <includes refid="proxy-io_8h" local="no">proxy-io.h</includes>
    <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structmp_1_1_waiter_1a71aaf23d91d7b7a5611738c4f06e3577" prot="public" static="no" mutable="no">
        <type><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref></type>
        <definition>Mutex m_mutex</definition>
        <argsstring></argsstring>
        <name>m_mutex</name>
        <qualifiedname>mp::Waiter::m_mutex</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><ref refid="sync_8h_1a326d1d46ce05b5316d8ebe2694a10a6e" kindref="member">Mutex</ref> mainly used internally by waiter class, but also used externally to guard access to related state. Specifically, since the thread_local <ref refid="structmp_1_1_thread_context" kindref="compound">ThreadContext</ref> struct owns a <ref refid="structmp_1_1_waiter" kindref="compound">Waiter</ref>, the <ref refid="structmp_1_1_waiter_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">Waiter::m_mutex</ref> is used to guard access to other parts of the struct to avoid needing to deal with more mutexes than necessary. This mutex can be held at the same time as <ref refid="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">EventLoop::m_mutex</ref> as long as Waiter::mutex is locked first and <ref refid="classmp_1_1_event_loop_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">EventLoop::m_mutex</ref> is locked second. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="366" column="11" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="366" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structmp_1_1_waiter_1accca0ab294feb9061406ae9c73a3ceb5" prot="public" static="no" mutable="no">
        <type>std::condition_variable</type>
        <definition>std::condition_variable m_cv</definition>
        <argsstring></argsstring>
        <name>m_cv</name>
        <qualifiedname>mp::Waiter::m_cv</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="367" column="29" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="367" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="structmp_1_1_waiter_1aee95e52957a56b142aae7d97e4d81172" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Waiter</definition>
        <argsstring>()=default</argsstring>
        <name>Waiter</name>
        <qualifiedname>mp::Waiter::Waiter</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="328" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_waiter_1aa406a75cf282d0ac5cb532edd2ba9fa7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Fn</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool post</definition>
        <argsstring>(Fn &amp;&amp;fn)</argsstring>
        <name>post</name>
        <qualifiedname>mp::Waiter::post</qualifiedname>
        <param>
          <type>Fn &amp;&amp;</type>
          <declname>fn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="331" column="10" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="331" bodyend="338"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_waiter_1a365fb970e0590633a23f4a61df876c2b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Predicate</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void wait</definition>
        <argsstring>(Lock &amp;lock, Predicate pred)</argsstring>
        <name>wait</name>
        <qualifiedname>mp::Waiter::wait</qualifiedname>
        <param>
          <type><ref refid="classmp_1_1_lock" kindref="compound">Lock</ref> &amp;</type>
          <declname>lock</declname>
        </param>
        <param>
          <type>Predicate</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="341" column="10" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="341" bodyend="357"/>
      </memberdef>
      <memberdef kind="function" id="structmp_1_1_waiter_1a3923af766063ee5af4ebcb7477371791" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::optional&lt; kj::Function&lt; void()&gt; &gt; m_fn</type>
        <definition>std::optional&lt; kj::Function&lt; void()&gt; &gt; m_fn MP_GUARDED_BY</definition>
        <argsstring>(m_mutex)</argsstring>
        <name>MP_GUARDED_BY</name>
        <qualifiedname>mp::Waiter::MP_GUARDED_BY</qualifiedname>
        <param>
          <type><ref refid="structmp_1_1_waiter_1a71aaf23d91d7b7a5611738c4f06e3577" kindref="member">m_mutex</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="368" column="24"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Single element task queue used to handle recursive capnp calls. (If server makes an callback into the client in the middle of a request, while client thread is blocked waiting for server response, this is what allows the client to run the request in the same thread, the same way code would run in single process, with the callback sharing same thread stack as the original call. </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="2">
        <label>AnnotatedMixin&lt; std::mutex &gt;</label>
        <link refid="class_annotated_mixin"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>Waiter</label>
        <link refid="structmp_1_1_waiter"/>
        <childnode refid="2" relation="usage">
          <edgelabel>m_mutex</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>mutex</label>
      </node>
    </collaborationgraph>
    <location file="src/ipc/libmultiprocess/include/mp/proxy-io.h" line="326" column="1" bodyfile="src/ipc/libmultiprocess/include/mp/proxy-io.h" bodystart="327" bodyend="369"/>
    <listofallmembers>
      <member refid="structmp_1_1_waiter_1accca0ab294feb9061406ae9c73a3ceb5" prot="public" virt="non-virtual"><scope>mp::Waiter</scope><name>m_cv</name></member>
      <member refid="structmp_1_1_waiter_1a71aaf23d91d7b7a5611738c4f06e3577" prot="public" virt="non-virtual"><scope>mp::Waiter</scope><name>m_mutex</name></member>
      <member refid="structmp_1_1_waiter_1a3923af766063ee5af4ebcb7477371791" prot="public" virt="non-virtual"><scope>mp::Waiter</scope><name>MP_GUARDED_BY</name></member>
      <member refid="structmp_1_1_waiter_1aa406a75cf282d0ac5cb532edd2ba9fa7" prot="public" virt="non-virtual"><scope>mp::Waiter</scope><name>post</name></member>
      <member refid="structmp_1_1_waiter_1a365fb970e0590633a23f4a61df876c2b" prot="public" virt="non-virtual"><scope>mp::Waiter</scope><name>wait</name></member>
      <member refid="structmp_1_1_waiter_1aee95e52957a56b142aae7d97e4d81172" prot="public" virt="non-virtual"><scope>mp::Waiter</scope><name>Waiter</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
