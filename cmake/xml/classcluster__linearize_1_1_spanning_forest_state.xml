<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="classcluster__linearize_1_1_spanning_forest_state" kind="class" language="C++" prot="public">
    <compoundname>cluster_linearize::SpanningForestState</compoundname>
    <includes refid="cluster__linearize_8h" local="no">cluster_linearize.h</includes>
    <innerclass refid="structcluster__linearize_1_1_spanning_forest_state_1_1_tx_data" prot="private">cluster_linearize::SpanningForestState::TxData</innerclass>
    <innerclass refid="structcluster__linearize_1_1_spanning_forest_state_1_1_dep_data" prot="private">cluster_linearize::SpanningForestState::DepData</innerclass>
    <templateparamlist>
      <param>
        <type>typename SetType</type>
      </param>
    </templateparamlist>
    <sectiondef kind="private-type">
      <memberdef kind="typedef" id="classcluster__linearize_1_1_spanning_forest_state_1a34323c850028ac784151250534cb2274" prot="private" static="no">
        <type>uint32_t</type>
        <definition>using TxIdx =  uint32_t</definition>
        <argsstring></argsstring>
        <name>TxIdx</name>
        <qualifiedname>cluster_linearize::SpanningForestState::TxIdx</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Data type to represent indexing into m_tx_data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="606" column="5" bodyfile="src/cluster_linearize.h" bodystart="606" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classcluster__linearize_1_1_spanning_forest_state_1a6fbb7b82e6ce59d43e6e64d7297f822e" prot="private" static="no">
        <type>uint32_t</type>
        <definition>using DepIdx =  uint32_t</definition>
        <argsstring></argsstring>
        <name>DepIdx</name>
        <qualifiedname>cluster_linearize::SpanningForestState::DepIdx</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Data type to represent indexing into m_dep_data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="608" column="5" bodyfile="src/cluster_linearize.h" bodystart="608" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classcluster__linearize_1_1_spanning_forest_state_1a93cac939eefb3b57fe0b87452db13d27" prot="private" static="no" mutable="no">
        <type><ref refid="class_insecure_random_context" kindref="compound">InsecureRandomContext</ref></type>
        <definition>InsecureRandomContext m_rng</definition>
        <argsstring></argsstring>
        <name>m_rng</name>
        <qualifiedname>cluster_linearize::SpanningForestState::m_rng</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Internal RNG. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="603" column="27" bodyfile="src/cluster_linearize.h" bodystart="603" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcluster__linearize_1_1_spanning_forest_state_1abca75948883474e37c50e90625da0248" prot="private" static="no" mutable="no">
        <type>SetType</type>
        <definition>SetType m_transaction_idxs</definition>
        <argsstring></argsstring>
        <name>m_transaction_idxs</name>
        <qualifiedname>cluster_linearize::SpanningForestState::m_transaction_idxs</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The set of all TxIdx&apos;s of transactions in the cluster indexing into m_tx_data. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="639" column="13" bodyfile="src/cluster_linearize.h" bodystart="639" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcluster__linearize_1_1_spanning_forest_state_1afbec685e290b38779d6681d688f534a2" prot="private" static="no" mutable="no">
        <type>std::vector&lt; TxData &gt;</type>
        <definition>std::vector&lt;TxData&gt; m_tx_data</definition>
        <argsstring></argsstring>
        <name>m_tx_data</name>
        <qualifiedname>cluster_linearize::SpanningForestState::m_tx_data</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Information about each transaction (and chunks). Keeps the &quot;holes&quot; from <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref> during construction. Indexed by TxIdx. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="642" column="17" bodyfile="src/cluster_linearize.h" bodystart="642" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcluster__linearize_1_1_spanning_forest_state_1a9bc867ba0f49217397622f39e0a019d2" prot="private" static="no" mutable="no">
        <type>std::vector&lt; DepData &gt;</type>
        <definition>std::vector&lt;DepData&gt; m_dep_data</definition>
        <argsstring></argsstring>
        <name>m_dep_data</name>
        <qualifiedname>cluster_linearize::SpanningForestState::m_dep_data</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Information about each dependency. Indexed by DepIdx. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="644" column="17" bodyfile="src/cluster_linearize.h" bodystart="644" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcluster__linearize_1_1_spanning_forest_state_1a357d72c813fbf0b5a6519ff767695f49" prot="private" static="no" mutable="no">
        <type><ref refid="class_vec_deque" kindref="compound">VecDeque</ref>&lt; TxIdx &gt;</type>
        <definition>VecDeque&lt;TxIdx&gt; m_suboptimal_chunks</definition>
        <argsstring></argsstring>
        <name>m_suboptimal_chunks</name>
        <qualifiedname>cluster_linearize::SpanningForestState::m_suboptimal_chunks</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A FIFO of chunk representatives of chunks that may be improved still. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="646" column="14" bodyfile="src/cluster_linearize.h" bodystart="646" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classcluster__linearize_1_1_spanning_forest_state_1ac75c8906d467c025ad467c624875aa8e" prot="private" static="no" mutable="no">
        <type>uint64_t</type>
        <definition>uint64_t m_cost</definition>
        <argsstring></argsstring>
        <name>m_cost</name>
        <qualifiedname>cluster_linearize::SpanningForestState::m_cost</qualifiedname>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The number of updated transactions in activations/deactivations. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="649" column="14" bodyfile="src/cluster_linearize.h" bodystart="649" bodyend="649"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a58d17a8172f81fa2a4877641e4f85bc8" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>Subtract</declname>
            <defname>Subtract</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void UpdateChunk</definition>
        <argsstring>(const SetType &amp;chunk, TxIdx query, TxIdx chunk_rep, const SetInfo&lt; SetType &gt; &amp;dep_change) noexcept</argsstring>
        <name>UpdateChunk</name>
        <qualifiedname>cluster_linearize::SpanningForestState::UpdateChunk</qualifiedname>
        <param>
          <type>const SetType &amp;</type>
          <declname>chunk</declname>
        </param>
        <param>
          <type>TxIdx</type>
          <declname>query</declname>
        </param>
        <param>
          <type>TxIdx</type>
          <declname>chunk_rep</declname>
        </param>
        <param>
          <type>const <ref refid="structcluster__linearize_1_1_set_info" kindref="compound">SetInfo</ref>&lt; SetType &gt; &amp;</type>
          <declname>dep_change</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Update a chunk:<itemizedlist>
<listitem><para>All transactions have their chunk representative set to <computeroutput>chunk_rep</computeroutput>.</para>
</listitem><listitem><para>All dependencies which have <computeroutput>query</computeroutput> in their top_setinfo get <computeroutput>dep_change</computeroutput> added to it (if <computeroutput>!Subtract</computeroutput>) or removed from it (if <computeroutput>Subtract</computeroutput>). </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="657" column="10" bodyfile="src/cluster_linearize.h" bodystart="657" bodyend="683"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a07e8aef3bf274b672e309c891b9fdf71" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>TxIdx</type>
        <definition>TxIdx Activate</definition>
        <argsstring>(DepIdx dep_idx) noexcept</argsstring>
        <name>Activate</name>
        <qualifiedname>cluster_linearize::SpanningForestState::Activate</qualifiedname>
        <param>
          <type>DepIdx</type>
          <declname>dep_idx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make a specified inactive dependency active. Returns the merged chunk representative. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="686" column="11" bodyfile="src/cluster_linearize.h" bodystart="686" bodyend="735"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a06c258bcf1e1f729c1476e929aa5bc82" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Deactivate</definition>
        <argsstring>(DepIdx dep_idx) noexcept</argsstring>
        <name>Deactivate</name>
        <qualifiedname>cluster_linearize::SpanningForestState::Deactivate</qualifiedname>
        <param>
          <type>DepIdx</type>
          <declname>dep_idx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make a specified active dependency inactive. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="738" column="10" bodyfile="src/cluster_linearize.h" bodystart="738" bodyend="770"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1aa8f38c8e32ddec776ebd19a88cdae8c1" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>TxIdx</type>
        <definition>TxIdx MergeChunks</definition>
        <argsstring>(TxIdx top_rep, TxIdx bottom_rep) noexcept</argsstring>
        <name>MergeChunks</name>
        <qualifiedname>cluster_linearize::SpanningForestState::MergeChunks</qualifiedname>
        <param>
          <type>TxIdx</type>
          <declname>top_rep</declname>
        </param>
        <param>
          <type>TxIdx</type>
          <declname>bottom_rep</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Activate a dependency from the chunk represented by bottom_rep to the chunk represented by top_rep, which must exist. Return the representative of the merged chunk. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="774" column="11" bodyfile="src/cluster_linearize.h" bodystart="774" bodyend="807"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a0f81360d52b2a8bdb3963c7b652f51ae" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>DownWard</declname>
            <defname>DownWard</defname>
          </param>
        </templateparamlist>
        <type>TxIdx</type>
        <definition>TxIdx MergeStep</definition>
        <argsstring>(TxIdx chunk_rep) noexcept</argsstring>
        <name>MergeStep</name>
        <qualifiedname>cluster_linearize::SpanningForestState::MergeStep</qualifiedname>
        <param>
          <type>TxIdx</type>
          <declname>chunk_rep</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Perform an upward or downward merge step, on the specified chunk representative. Returns the representative of the merged chunk, or TxIdx(-1) if no merge took place. </para>
        </detaileddescription>
        <inbodydescription>
<para>Information about the chunk that tx_idx is currently in.</para>
<para>Which transactions have been reached from this chunk already. Initialize with the chunk itself, so internal dependencies within the chunk are ignored.</para>
<para>The minimum feerate (if downward) or maximum feerate (if upward) to consider when looking for candidate chunks to merge with. Initially, this is the original chunk&apos;s feerate, but is updated to be the current best candidate whenever one is found.</para>
<para>The representative for the best candidate chunk to merge with. -1 if none.</para>
<para>We generate random tiebreak values to pick between equal-feerate candidate chunks. This variable stores the tiebreak of the current best candidate.</para>
<para>The transactions reached by following dependencies from tx that have not been explored before.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="812" column="11" bodyfile="src/cluster_linearize.h" bodystart="812" bodyend="867"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a61be571decf65cb2f49f348ddfe58e7e" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>DownWard</declname>
            <defname>DownWard</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void MergeSequence</definition>
        <argsstring>(TxIdx tx_idx) noexcept</argsstring>
        <name>MergeSequence</name>
        <qualifiedname>cluster_linearize::SpanningForestState::MergeSequence</qualifiedname>
        <param>
          <type>TxIdx</type>
          <declname>tx_idx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Perform an upward or downward merge sequence on the specified transaction. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="872" column="10" bodyfile="src/cluster_linearize.h" bodystart="872" bodyend="882"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a412e805139b72c36e96fc96caab44a5f" prot="private" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void Improve</definition>
        <argsstring>(DepIdx dep_idx) noexcept</argsstring>
        <name>Improve</name>
        <qualifiedname>cluster_linearize::SpanningForestState::Improve</qualifiedname>
        <param>
          <type>DepIdx</type>
          <declname>dep_idx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Split a chunk, and then merge the resulting two chunks to make the graph topological again. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="886" column="10" bodyfile="src/cluster_linearize.h" bodystart="886" bodyend="904"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a99e10087e4faff7a5779e76f0f90100f" prot="public" static="no" const="no" explicit="yes" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>SpanningForestState</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph, uint64_t rng_seed) noexcept</argsstring>
        <name>SpanningForestState</name>
        <qualifiedname>cluster_linearize::SpanningForestState::SpanningForestState</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>rng_seed</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct a spanning forest for the given <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>, with every transaction in its own chunk (not topological). </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="909" column="14" bodyfile="src/cluster_linearize.h" bodystart="909" bodyend="945"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a6fd1ccc234cce3b9aaa7738e0d2fb364" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void LoadLinearization</definition>
        <argsstring>(std::span&lt; const DepGraphIndex &gt; old_linearization) noexcept</argsstring>
        <name>LoadLinearization</name>
        <qualifiedname>cluster_linearize::SpanningForestState::LoadLinearization</qualifiedname>
        <param>
          <type>std::span&lt; const <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
          <declname>old_linearization</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Load an existing linearization. Must be called immediately after constructor. The result is topological if the linearization is valid. Otherwise, MakeTopological still needs to be called. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="950" column="10" bodyfile="src/cluster_linearize.h" bodystart="950" bodyend="961"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1aee465890767b94947e60205811ec4885" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void MakeTopological</definition>
        <argsstring>() noexcept</argsstring>
        <name>MakeTopological</name>
        <qualifiedname>cluster_linearize::SpanningForestState::MakeTopological</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Make state topological. Can be called after constructing, or after LoadLinearization. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="964" column="10" bodyfile="src/cluster_linearize.h" bodystart="964" bodyend="1004"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a803f9f1a5a058d2b363b4ed1b8b7e4fa" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void StartOptimizing</definition>
        <argsstring>() noexcept</argsstring>
        <name>StartOptimizing</name>
        <qualifiedname>cluster_linearize::SpanningForestState::StartOptimizing</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialize the data structure for optimization. It must be topological already. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1007" column="10" bodyfile="src/cluster_linearize.h" bodystart="1007" bodyend="1021"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1af6b5a7d19cadd4d6a59d0caa63cd03b6" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool OptimizeStep</definition>
        <argsstring>() noexcept</argsstring>
        <name>OptimizeStep</name>
        <qualifiedname>cluster_linearize::SpanningForestState::OptimizeStep</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Try to improve the forest. Returns false if it is optimal, true otherwise. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1024" column="10" bodyfile="src/cluster_linearize.h" bodystart="1024" bodyend="1069"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a444fd02b9f97e5d7f97fa42965d721ec" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>std::vector&lt; <ref refid="namespacecluster__linearize_1afe7ae098b4cbd5b112f81d1e9429e90d" kindref="member">DepGraphIndex</ref> &gt;</type>
        <definition>std::vector&lt; DepGraphIndex &gt; GetLinearization</definition>
        <argsstring>() noexcept</argsstring>
        <name>GetLinearization</name>
        <qualifiedname>cluster_linearize::SpanningForestState::GetLinearization</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Construct a topologically-valid linearization from the current forest state. Must be topological. </para>
        </detaileddescription>
        <inbodydescription>
<para>The output linearization.</para>
<para>A heap with all chunks (by representative) that can currently be included, sorted by chunk feerate and a random tie-breaker.</para>
<para>Information about chunks:<itemizedlist>
<listitem><para>The first value is only used for chunk representatives, and counts the number of unmet dependencies this chunk has on other chunks (not including dependencies within the chunk itself).</para>
</listitem><listitem><para>The second value is the number of unmet dependencies overall.</para>
</listitem></itemizedlist>
</para>
<para>The set of all chunk representatives.</para>
<para>A list with all transactions within the current chunk that can be included.</para>
<para>Comparison function for the heap.</para>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1073" column="17" bodyfile="src/cluster_linearize.h" bodystart="1073" bodyend="1175"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1af0e6a44de93624003ce97ebf594aae4e" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>std::vector&lt; <ref refid="struct_fee_frac" kindref="compound">FeeFrac</ref> &gt;</type>
        <definition>std::vector&lt; FeeFrac &gt; GetDiagram</definition>
        <argsstring>() const noexcept</argsstring>
        <name>GetDiagram</name>
        <qualifiedname>cluster_linearize::SpanningForestState::GetDiagram</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the diagram for the current state, which must be topological. Test-only.</para>
<para>The linearization produced by <ref refid="classcluster__linearize_1_1_spanning_forest_state_1a444fd02b9f97e5d7f97fa42965d721ec" kindref="member">GetLinearization()</ref> is always at least as good (in the <ref refid="util_2feefrac_8cpp_1ac6b51471a8ec142402968632e02bbfe5" kindref="member">CompareChunks()</ref> sense) as this diagram, but may be better.</para>
<para>After an <ref refid="classcluster__linearize_1_1_spanning_forest_state_1af6b5a7d19cadd4d6a59d0caa63cd03b6" kindref="member">OptimizeStep()</ref>, the diagram will always be at least as good as before. Once <ref refid="classcluster__linearize_1_1_spanning_forest_state_1af6b5a7d19cadd4d6a59d0caa63cd03b6" kindref="member">OptimizeStep()</ref> returns false, the diagram will be equivalent to that produced by <ref refid="classcluster__linearize_1_1_spanning_forest_state_1a444fd02b9f97e5d7f97fa42965d721ec" kindref="member">GetLinearization()</ref>, and optimal. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1186" column="17" bodyfile="src/cluster_linearize.h" bodystart="1186" bodyend="1196"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a3f2da53fd4decdf7cfaa45d15b50fe3d" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>uint64_t</type>
        <definition>uint64_t GetCost</definition>
        <argsstring>() const noexcept</argsstring>
        <name>GetCost</name>
        <qualifiedname>cluster_linearize::SpanningForestState::GetCost</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Determine how much work was performed so far. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1199" column="14" bodyfile="src/cluster_linearize.h" bodystart="1199" bodyend="1199"/>
      </memberdef>
      <memberdef kind="function" id="classcluster__linearize_1_1_spanning_forest_state_1a9b196bf02d22db423ce35383355824ed" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void SanityCheck</definition>
        <argsstring>(const DepGraph&lt; SetType &gt; &amp;depgraph) const</argsstring>
        <name>SanityCheck</name>
        <qualifiedname>cluster_linearize::SpanningForestState::SanityCheck</qualifiedname>
        <param>
          <type>const <ref refid="classcluster__linearize_1_1_dep_graph" kindref="compound">DepGraph</ref>&lt; SetType &gt; &amp;</type>
          <declname>depgraph</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Verify internal consistency of the data structure. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/cluster_linearize.h" line="1202" column="10" bodyfile="src/cluster_linearize.h" bodystart="1202" bodyend="1331"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Class to represent the internal state of the spanning-forest linearization (SFL) algorithm.</para>
<para>At all times, each dependency is marked as either &quot;active&quot; or &quot;inactive&quot;. The subset of active dependencies is the state of the SFL algorithm. The implementation maintains several other values to speed up operations, but everything is ultimately a function of what that subset of active dependencies is.</para>
<para>Given such a subset, define a chunk as the set of transactions that are connected through active dependencies (ignoring their parent/child direction). Thus, every state implies a particular partitioning of the graph into chunks (including potential singletons). In the extreme, each transaction may be in its own chunk, or in the other extreme all transactions may form a single chunk. A chunk&apos;s feerate is its total fee divided by its total size.</para>
<para>The algorithm consists of switching dependencies between active and inactive. The final linearization that is produced at the end consists of these chunks, sorted from high to low feerate, each individually sorted in an arbitrary but topological (= no child before parent) way.</para>
<para>We define three quality properties the state can have, each being stronger than the previous:</para>
<para><itemizedlist>
<listitem><para>acyclic: The state is acyclic whenever no cycle of active dependencies exists within the graph, ignoring the parent/child direction. This is equivalent to saying that within each chunk the set of active dependencies form a tree, and thus the overall set of active dependencies in the graph form a spanning forest, giving the algorithm its name. Being acyclic is also equivalent to every chunk of N transactions having exactly N-1 active dependencies.</para>
<para>For example in a diamond graph, D-&gt;{B,C}-&gt;A, the 4 dependencies cannot be simultaneously active. If at least one is inactive, the state is acyclic.</para>
<para>The algorithm maintains an acyclic state at <emphasis>all</emphasis> times as an invariant. This implies that activating a dependency always corresponds to merging two chunks, and that deactivating one always corresponds to splitting two chunks.</para>
</listitem><listitem><para>topological: We say the state is topological whenever it is acyclic and no inactive dependency exists between two distinct chunks such that the child chunk has higher or equal feerate than the parent chunk.</para>
<para>The relevance is that whenever the state is topological, the produced output linearization will be topological too (i.e., not have children before parents). Note that the &quot;or equal&quot; part of the definition matters: if not, one can end up in a situation with mutually-dependent equal-feerate chunks that cannot be linearized. For example C-&gt;{A,B} and D-&gt;{A,B}, with C-&gt;A and D-&gt;B active. The AC chunk depends on <ref refid="class_d_b" kindref="compound">DB</ref> through C-&gt;B, and the BD chunk depends on AC through D-&gt;A. Merging them into a single ABCD chunk fixes this.</para>
<para>The algorithm attempts to keep the state topological as much as possible, so it can be interrupted to produce an output whenever, but will sometimes need to temporarily deviate from it when improving the state.</para>
</listitem><listitem><para>optimal: For every active dependency, define its top and bottom set as the set of transactions in the chunks that would result if the dependency were deactivated; the top being the one with the dependency&apos;s parent, and the bottom being the one with the child. Note that due to acyclicity, every deactivation splits a chunk exactly in two.</para>
<para>We say the state is optimal whenever it is topological and it has no active dependency whose top feerate is strictly higher than its bottom feerate. The relevance is that it can be proven that whenever the state is optimal, the produced linearization will also be optimal (in the convexified feerate diagram sense). It can also be proven that for every graph at least one optimal state exists.</para>
<para>Note that it is possible for the SFL state to not be optimal, but the produced linearization to still be optimal. This happens when the chunks of a state are identical to those of an optimal state, but the exact set of active dependencies within a chunk differ in such a way that the state optimality condition is not satisfied. Thus, the state being optimal is more a &quot;the eventual output is *known*
           to be optimal&quot;.</para>
<para>The algorithm terminates whenever an optimal state is reached.</para>
</listitem></itemizedlist>
</para>
<para>This leads to the following high-level algorithm:<itemizedlist>
<listitem><para>Start with all dependencies inactive, and thus all transactions in their own chunk. This is definitely acyclic.</para>
</listitem><listitem><para>Activate dependencies (merging chunks) until the state is topological.</para>
</listitem><listitem><para>Loop until optimal (no dependencies with higher-feerate top than bottom), or time runs out:<itemizedlist>
<listitem><para>Deactivate a violating dependency, potentially making the state non-topological.</para>
</listitem><listitem><para>Activate other dependencies to make the state topological again.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Output the chunks from high to low feerate, each internally sorted topologically.</para>
</listitem></itemizedlist>
</para>
<para>When merging, we always either:<itemizedlist>
<listitem><para>Merge upwards: merge a chunk with the lowest-feerate other chunk it depends on, among those with lower or equal feerate than itself.</para>
</listitem><listitem><para>Merge downwards: merge a chunk with the highest-feerate other chunk that depends on it, among those with higher or equal feerate than itself.</para>
</listitem></itemizedlist>
</para>
<para>Using these strategies in the improvement loop above guarantees that the output linearization after a deactivate + merge step is never worse or incomparable (in the convexified feerate diagram sense) than the output linearization that would be produced before the step. With that, we can refine the high-level algorithm to:<itemizedlist>
<listitem><para>Start with all dependencies inactive.</para>
</listitem><listitem><para>Perform merges as described until none are possible anymore, making the state topological.</para>
</listitem><listitem><para>Loop until optimal or time runs out:<itemizedlist>
<listitem><para>Pick a dependency D to deactivate among those with higher feerate top than bottom.</para>
</listitem><listitem><para>Deactivate D, causing the chunk it is in to split into top T and bottom B.</para>
</listitem><listitem><para>Do an upwards merge of T, if possible. If so, repeat the same with the merged result.</para>
</listitem><listitem><para>Do a downwards merge of B, if possible. If so, repeat the same with the merged result.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>Output the chunks from high to low feerate, each internally sorted topologically.</para>
</listitem></itemizedlist>
</para>
<para>Instead of performing merges arbitrarily to make the initial state topological, it is possible to do so guided by an existing linearization. This has the advantage that the state&apos;s would-be output linearization is immediately as good as the existing linearization it was based on:<itemizedlist>
<listitem><para>Start with all dependencies inactive.</para>
</listitem><listitem><para>For each transaction t in the existing linearization:<itemizedlist>
<listitem><para>Find the chunk C that transaction is in (which will be singleton).</para>
</listitem><listitem><para>Do an upwards merge of C, if possible. If so, repeat the same with the merged result. No downwards merges are needed in this case.</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para>What remains to be specified are a number of heuristics:</para>
<para><itemizedlist>
<listitem><para>How to decide which chunks to merge:<itemizedlist>
<listitem><para>The merge upwards and downward rules specify that the lowest-feerate respectively highest-feerate candidate chunk is merged with, but if there are multiple equal-feerate candidates, a uniformly random one among them is picked.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>How to decide what dependency to activate (when merging chunks):<itemizedlist>
<listitem><para>After picking two chunks to be merged (see above), a uniformly random dependency between the two chunks is activated.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>How to decide which chunk to find a dependency to split in:<itemizedlist>
<listitem><para>A round-robin queue of chunks to improve is maintained. The initial ordering of this queue is uniformly randomly permuted.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>How to decide what dependency to deactivate (when splitting chunks):<itemizedlist>
<listitem><para>Inside the selected chunk (see above), among the dependencies whose top feerate is strictly higher than its bottom feerate in the selected chunk, if any, a uniformly random dependency is deactivated.</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>How to decide the exact output linearization:<itemizedlist>
<listitem><para>When there are multiple equal-feerate chunks with no dependencies between them, output a uniformly random one among the ones with no missing dependent chunks first.</para>
</listitem><listitem><para>Within chunks, repeatedly pick a uniformly random transaction among those with no missing dependencies. </para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <location file="src/cluster_linearize.h" line="599" column="1" bodyfile="src/cluster_linearize.h" bodystart="600" bodyend="1332"/>
    <listofallmembers>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a07e8aef3bf274b672e309c891b9fdf71" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>Activate</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a06c258bcf1e1f729c1476e929aa5bc82" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>Deactivate</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a6fbb7b82e6ce59d43e6e64d7297f822e" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>DepIdx</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a3f2da53fd4decdf7cfaa45d15b50fe3d" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>GetCost</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1af0e6a44de93624003ce97ebf594aae4e" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>GetDiagram</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a444fd02b9f97e5d7f97fa42965d721ec" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>GetLinearization</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a412e805139b72c36e96fc96caab44a5f" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>Improve</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a6fd1ccc234cce3b9aaa7738e0d2fb364" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>LoadLinearization</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1ac75c8906d467c025ad467c624875aa8e" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>m_cost</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a9bc867ba0f49217397622f39e0a019d2" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>m_dep_data</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a93cac939eefb3b57fe0b87452db13d27" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>m_rng</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a357d72c813fbf0b5a6519ff767695f49" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>m_suboptimal_chunks</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1abca75948883474e37c50e90625da0248" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>m_transaction_idxs</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1afbec685e290b38779d6681d688f534a2" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>m_tx_data</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1aee465890767b94947e60205811ec4885" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>MakeTopological</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1aa8f38c8e32ddec776ebd19a88cdae8c1" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>MergeChunks</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a61be571decf65cb2f49f348ddfe58e7e" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>MergeSequence</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a0f81360d52b2a8bdb3963c7b652f51ae" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>MergeStep</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1af6b5a7d19cadd4d6a59d0caa63cd03b6" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>OptimizeStep</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a9b196bf02d22db423ce35383355824ed" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>SanityCheck</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a99e10087e4faff7a5779e76f0f90100f" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>SpanningForestState</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a803f9f1a5a058d2b363b4ed1b8b7e4fa" prot="public" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>StartOptimizing</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a34323c850028ac784151250534cb2274" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>TxIdx</name></member>
      <member refid="classcluster__linearize_1_1_spanning_forest_state_1a58d17a8172f81fa2a4877641e4f85bc8" prot="private" virt="non-virtual"><scope>cluster_linearize::SpanningForestState</scope><name>UpdateChunk</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
