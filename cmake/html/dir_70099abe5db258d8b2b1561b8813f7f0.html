<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: src/minisketch Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_70099abe5db258d8b2b1561b8813f7f0.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">minisketch Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-subdirs" class="groupheader"><a id="subdirs" name="subdirs"></a>
Directories</h2></td></tr>
<tr class="memitem:doc" id="r_doc"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_c5d288e05915cf360f186dc892f5e38c.html">doc</a></td></tr>
<tr class="memitem:include" id="r_include"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_e4bd1dc231b7eb1532b49bf0356c9b1e.html">include</a></td></tr>
<tr class="memitem:src" id="r_src"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_47112eaf970aa5ce4ab22e9c5a8c5f8b.html">src</a></td></tr>
<tr class="memitem:tests" id="r_tests"><td class="memItemLeft" align="right" valign="top"><span class="iconfolder"><div class="folder-icon"></div></span>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dir_00a07ad4f96b9c9944bada2a6872ec71.html">tests</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
Minisketch: a library for [BCH](<a href="https://en.wikipedia.org/wiki/BCH_code">https://en.wikipedia.org/wiki/BCH_code</a>)-based set reconciliation</h1>
<p><img src="doc/minisketch-vs.png" alt="" align="right" class="inline"/></p>
<p><span class="tt">libminisketch</span> is an optimized standalone MIT-licensed library with C API for constructing and decoding <em>set sketches</em>, which can be used for compact set reconciliation and other applications. It is an implementation of the PinSketch<sup><a class="el" href="#myfootnote1">[1]</a></sup> algorithm. An explanation of the algorithm can be found <a class="el" href="md_src_2minisketch_2doc_2math.html">here</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
Sketches for set reconciliation</h1>
<p>Sketches, as produced by this library, can be seen as "set checksums" with two peculiar properties:</p><ul>
<li>Sketches have a predetermined capacity, and when the number of elements in the set is not higher than the capacity, <span class="tt">libminisketch</span> will always recover the entire set from the sketch. A sketch of <em>b</em>-bit elements with capacity <em>c</em> can be stored in <em>bc</em> bits.</li>
<li>The sketches of two sets can be combined by adding them (XOR) to obtain a sketch of the <a href="https://en.wikipedia.org/wiki/Symmetric_difference">symmetric difference</a> between the two sets (<em>i.e.</em>, all elements that occur in one but not both input sets).</li>
</ul>
<p>This makes them appropriate for a very bandwidth-efficient set reconciliation protocol. If Alice and Bob each have a set of elements, and they suspect that the sets largely but not entirely overlap, they can use the following protocol to let both parties learn all the elements:</p><ul>
<li>Alice and Bob both compute a sketch of their set elements.</li>
<li>Alice sends her sketch to Bob.</li>
<li>Bob combines the two sketches, and obtains a sketch of the symmetric difference.</li>
<li>Bob tries to recover the elements from the difference sketch.</li>
<li>Bob sends every element in the difference that he has to Alice.</li>
</ul>
<p>This will always succeed when the size of the difference (elements that Alice has but Bob doesn't plus elements that Bob has but Alice doesn't) does not exceed the capacity of the sketch that Alice sent. The interesting part is that this works regardless of the actual set sizes—only the difference matters.</p>
<p>If the elements are large, it may be preferable to compute the sketches over <em>hashes</em> of the set elements. In that case an additional step is added to the protocol, where Bob also sends the hash of every element he does not have to Alice, who responds with the requested elements.</p>
<p>The doc/ directory has additional <a class="el" href="md_src_2minisketch_2doc_2protocoltips.html">tips for designing reconciliation protocols using libminisketch</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
Evaluation</h1>
<p><img src="doc/plot_capacity.png" alt="" width="432" height="324" class="inline"/> <img src="doc/plot_diff.png" alt="" width="432" height="324" class="inline"/></p>
<p><img src="doc/plot_size.png" alt="" width="432" height="324" class="inline"/> <img src="doc/plot_bits.png" alt="" width="432" height="324" class="inline"/></p>
<p><b>The first graph</b> above shows a benchmark of <span class="tt">libminisketch</span> against three other set reconciliation algorithms/implementations. The benchmarks were performed using a single core on a system with an Intel Core i7-7820HQ CPU with clock speed locked at 2.4 GHz. The diagram shows the time needed for merging of two sketches and decoding the result. The creation of a sketch on the same machine takes around 5 ns per capacity and per set element. The other implementations are:</p><ul>
<li><a href="https://www.cs.bu.edu/~reyzin/code/fuzzy.html"><span class="tt">pinsketch</span></a>, the original PinSketch implementation.</li>
<li><a href="https://github.com/trachten/cpisync"><span class="tt">cpisync</span></a>, a software project which implements a number of set reconciliation algorithms and protocols. The included benchmark analyzes the non-probabilistic version of the original CPISync algorithm<sup><a class="el" href="#myfootnote5">[5]</a></sup> only.</li>
<li>A high-performance custom IBLT implementation using 4 hash functions and 32-bit checksums.</li>
</ul>
<p>For the largest sizes currently of interest to the authors, such as a set of capacity 4096 with 1024 differences, <span class="tt">libminisketch</span> is forty-nine times faster than <span class="tt">pinsketch</span> and over eight thousand times faster than <span class="tt">cpisync</span>. <span class="tt">libminisketch</span> is fast enough on realistic set sizes for use on high-traffic network servers where computational resources are limited.</p>
<p>Even where performance is latency-limited, small minisketches can be fast enough to improve performance. On the above i7-7820HQ, a set of 2500 30-bit entries with a difference of 20 elements can be communicated in less time with a minisketch than sending the raw set so long as the communications bandwidth is 1 gigabit per second or less; an eight-element difference can be communicated in better than one-fifth the time on a gigabit link.</p>
<p><b>The second graph</b> above shows the performance of the same algorithms on the same system, but this time keeping the capacity constant at 128, while varying the number of differences to reconcile between 1 and 128. It shows how <span class="tt">cpisync</span>'s reconciliation speed is mostly dependent on capacity, while <span class="tt">pinsketch</span>/<span class="tt">libminisketch</span> are more dependent on number of differences.</p>
<p><b>The third graph</b> above shows the size overhead of a typical IBLT scheme over the other algorithms (which are near-optimal bandwidth), for various levels of failure probability. IBLT takes tens of times the bandwidth of <span class="tt">libminisketch</span> sketches when the set difference size is small and the required failure rate is low.</p>
<p><b>The fourth graph</b> above shows the effect of the field size on speed in <span class="tt">libminisketch</span>. The three lines correspond to:</p><ul>
<li>CLMUL 64-bit: Intel Core i7-7820HQ system at 2.4 GHz</li>
<li>Generic 64-bit: POWER9 CP9M06 system at 2.8 GHz (Talos II)</li>
<li>Generic 32-bit: Cortex-A53 at 1.2 GHz (Raspberry Pi 3B)</li>
</ul>
<p>It shows how CLMUL implementations are faster for certain fields (specifically, field sizes for which an irreducible polynomial of the form *x<sup>b</sup> + x + 1* over <em>GF(2)</em> exists, and to a lesser extent, fields which are a multiple of 8 bits). It also shows how (for now) a significant performance drop exists for fields larger than 32 bits on 32-bit platforms. Note that the three lines are not at the same scale (the Raspberry Pi 3B is around 10x slower for 32-bit fields than the Core i7; the POWER9 is around 1.3x slower).</p>
<p>Below we compare the PinSketch algorithm (which <span class="tt">libminisketch</span> is an implementation of) with other set reconciliation algorithms:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Algorithm  </th><th class="markdownTableHeadNone"><a class="el" href="class_sketch.html">Sketch</a> size  </th><th class="markdownTableHeadNone">Decode success  </th><th class="markdownTableHeadNone">Decoding complexity  </th><th class="markdownTableHeadNone">Difference type  </th><th class="markdownTableHeadNone">Secure sketch  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPISync<sup><a class="el" href="#myfootnote2">[2]</a></sup>  </td><td class="markdownTableBodyNone"><em>(b+1)c</em>  </td><td class="markdownTableBodyNone">Always  </td><td class="markdownTableBodyNone">*O(n<sup>3</sup>)*  </td><td class="markdownTableBodyNone">Both  </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PinSketch<sup><a class="el" href="#myfootnote1">[1]</a></sup>  </td><td class="markdownTableBodyNone"><em>bc</em>  </td><td class="markdownTableBodyNone">Always  </td><td class="markdownTableBodyNone">*O(n<sup>2</sup>)*  </td><td class="markdownTableBodyNone">Symmetric only  </td><td class="markdownTableBodyNone">Yes  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IBLT<sup><a class="el" href="#myfootnote1">[6]</a><a class="el" href="#myfootnote1">[7]</a></sup>  </td><td class="markdownTableBodyNone"><em>&alpha;bc</em> (see graph 3)  </td><td class="markdownTableBodyNone">Probabilistic  </td><td class="markdownTableBodyNone"><em>O(n)</em>  </td><td class="markdownTableBodyNone">Depends  </td><td class="markdownTableBodyNone">No  </td></tr>
</table>
<ul>
<li><b><a class="el" href="class_sketch.html">Sketch</a> size:</b> This column shows the size in bits of a sketch designed for reconciling <em>c</em> different <em>b</em>-bit elements. PinSketch and CPISync have a near-optimal<sup><a class="el" href="#myfootnote11">[11]</a></sup> communication overhead, which in practice means the sketch size is very close (or equal to) <em>bc</em> bits. That is the same size as would be needed to transfer the elements of the difference naively (which is remarkable, as the difference isn't even known by the sender). For IBLT there is an overhead factor <em>&alpha;</em>, which depends on various design parameters, but is often between <em>2</em> and <em>10</em>.</li>
<li><b>Decode success:</b> Whenever a sketch is designed with a capacity not lower than the actual difference size, CPISync and PinSketch guarantee that decoding of the difference will always succeed. IBLT always has a chance of failure, though that chance can be made arbitrarily small by increasing the communication overhead.</li>
<li><b>Decoding complexity:</b> The space savings achieved by near-optimal algorithms come at a cost in performance, as their asymptotic decode complexity is quadratic or cubic, while IBLT is linear. This means that using near-optimal algorithms can be too expensive for applications where the difference is sufficiently large.</li>
<li><b>Difference type:</b> PinSketch can only compute the symmetric difference from a merged sketch, while CPISync and IBLT can distinguish which side certain elements were missing on. When the decoder has access to one of the sets, this generally doesn't matter, as he can look up each of the elements in the symmetric difference with one of the sets.</li>
<li><b>Secure sketch:</b> Whether the sketch satisfies the definition of a secure sketch<sup><a class="el" href="#myfootnote1">[1]</a></sup>, which implies a minimal amount about a set can be extracted from a sketch by anyone who does not know most of the elements already. This makes the algorithm appropriate for applications like fingerprint authentication.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
Building with Autotools</h1>
<p>The build system is very rudimentary for now, and <a href="https://github.com/bitcoin-core/minisketch/pulls">improvements</a> are welcome.</p>
<p>The following may work and produce a <span class="tt">libminisketch.a</span> file you can link against:</p>
<div class="fragment"><div class="line">git clone https://github.com/bitcoin-core/minisketch</div>
<div class="line">cd minisketch</div>
<div class="line">./autogen.sh &amp;&amp; ./configure &amp;&amp; make</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
Building with CMake</h1>
<p>To maintain a pristine source tree, CMake encourages performing an out-of-source build by using a separate dedicated build directory.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
Building on POSIX systems</h2>
<p>The following commands will produce the same <span class="tt">libminisketch.a</span> file as in the example above:</p>
<div class="fragment"><div class="line">cmake -B build -DCMAKE_CXX_FLAGS=&quot;-g -O2&quot;  # Generate a build system in subdirectory &quot;build&quot;</div>
<div class="line">cmake --build build                        # Run the actual build process</div>
<div class="line">ctest --test-dir build                     # Run the test suite</div>
<div class="line">sudo cmake --install build                 # Install the library into the system (optional)</div>
</div><!-- fragment --><p>Run <span class="tt">cmake -<a class="el" href="util__tests_8cpp.html#a111da81ae5883147168bbb8366377b10">B</a> build -LH</span> or <span class="tt">ccmake -<a class="el" href="util__tests_8cpp.html#a111da81ae5883147168bbb8366377b10">B</a> build</span> to see the full list of configurable build options.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
Cross compiling</h2>
<p>The following example works on modern Ubuntu/Debian systems:</p>
<div class="fragment"><div class="line">sudo apt install g++-mingw-w64-x86-64-posix</div>
<div class="line">cmake -B build -DCMAKE_SYSTEM_NAME=Windows -DCMAKE_CXX_COMPILER=x86_64-w64-mingw32-g++-posix</div>
<div class="line">cmake --build build</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
Building on Windows</h2>
<p>The following example assumes the use of Visual Studio 2022 and CMake v3.21 or newer.</p>
<p>In "Developer Command Prompt for VS 2022":</p>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build --config Release</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
Usage</h1>
<p>In this section Alice and Bob are trying to find the difference between their sets. Alice has the set <em>[3000 ... 3009]</em>, while Bob has <em>[3002 ... 3011]</em>.</p>
<p>First, Alice creates a sketch:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;../include/minisketch.h&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="crc32c__capi__unittest_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">void</span>) {</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_typedef" href="minisketch_8h.html#adffb4f5b48fcdd25b57ae22f5b2147f4">minisketch</a> *sketch_a = <a class="code hl_function" href="minisketch_8h.html#a4d39dce1593d829c3fde622807fda244">minisketch_create</a>(12, 0, 4);</div>
<div class="ttc" id="acrc32c__capi__unittest_8c_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="crc32c__capi__unittest_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> crc32c_capi_unittest.c:13</div></div>
<div class="ttc" id="aminisketch_8h_html_a4d39dce1593d829c3fde622807fda244"><div class="ttname"><a href="minisketch_8h.html#a4d39dce1593d829c3fde622807fda244">minisketch_create</a></div><div class="ttdeci">MINISKETCH_API minisketch * minisketch_create(uint32_t bits, uint32_t implementation, size_t capacity)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:378</div></div>
<div class="ttc" id="aminisketch_8h_html_adffb4f5b48fcdd25b57ae22f5b2147f4"><div class="ttname"><a href="minisketch_8h.html#adffb4f5b48fcdd25b57ae22f5b2147f4">minisketch</a></div><div class="ttdeci">struct minisketch minisketch</div><div class="ttdef"><b>Definition</b> minisketch.h:41</div></div>
</div><!-- fragment --><p>The arguments are:</p><ul>
<li>The field size <em>b</em>, which specifies the size of the elements being reconciled. With a field size <em>b</em>, the supported range of set elements is the integers from <em>1</em> to *2<sup>b* <em>- 1</em>, inclusive. Note that elements cannot be zero.</sup></li>
<li><sup>The implementation number. Implementation <em>0</em> is always supported, but more efficient algorithms may be available on some hardware. The serialized form of a sketch is independent of the implementation, so different implementations can interoperate.</sup></li>
<li><sup>The capacity <em>c</em>, which specifies how many differences the resulting sketch can reconcile.</sup></li>
</ul>
<p><sup>Then Alice adds her elements to her sketch. Note that adding the same element a second time removes it again, as sketches have set semantics, not multiset semantics.</sup></p>
<p><sup></p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 3000; i &lt; 3010; ++i) {</div>
<div class="line">  <a class="code hl_function" href="minisketch_8h.html#a6e0d272f72df96765d9041f859324880">minisketch_add_uint64</a>(sketch_a, i);</div>
<div class="line">}</div>
<div class="ttc" id="aminisketch_8h_html_a6e0d272f72df96765d9041f859324880"><div class="ttname"><a href="minisketch_8h.html#a6e0d272f72df96765d9041f859324880">minisketch_add_uint64</a></div><div class="ttdeci">MINISKETCH_API void minisketch_add_uint64(minisketch *sketch, uint64_t element)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:452</div></div>
</div><!-- fragment --><p></sup></p>
<p><sup>The next step is serializing the sketch into a byte array:</sup></p>
<p><sup></p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> sersize = <a class="code hl_function" href="minisketch_8h.html#a3ab706ecc86c75ca06651ecc62024a23">minisketch_serialized_size</a>(sketch_a);</div>
<div class="line"><a class="code hl_function" href="validation_8cpp.html#afb7ea74ba028421697aa7f364741ee6c">assert</a>(sersize == 12 * 4 / 8); <span class="comment">// 4 12-bit values is 6 bytes.</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer_a = malloc(sersize);</div>
<div class="line"><a class="code hl_function" href="minisketch_8h.html#a03a014a1f2885b473c14f6aa24de24f4">minisketch_serialize</a>(sketch_a, buffer_a);</div>
<div class="line"><a class="code hl_function" href="minisketch_8h.html#ad603da5dcb6bfe0dd3bbe4b03895c73b">minisketch_destroy</a>(sketch_a);</div>
<div class="ttc" id="aminisketch_8h_html_a03a014a1f2885b473c14f6aa24de24f4"><div class="ttname"><a href="minisketch_8h.html#a03a014a1f2885b473c14f6aa24de24f4">minisketch_serialize</a></div><div class="ttdeci">MINISKETCH_API void minisketch_serialize(const minisketch *sketch, unsigned char *output)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:440</div></div>
<div class="ttc" id="aminisketch_8h_html_a3ab706ecc86c75ca06651ecc62024a23"><div class="ttname"><a href="minisketch_8h.html#a3ab706ecc86c75ca06651ecc62024a23">minisketch_serialized_size</a></div><div class="ttdeci">MINISKETCH_API size_t minisketch_serialized_size(const minisketch *sketch)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:432</div></div>
<div class="ttc" id="aminisketch_8h_html_ad603da5dcb6bfe0dd3bbe4b03895c73b"><div class="ttname"><a href="minisketch_8h.html#ad603da5dcb6bfe0dd3bbe4b03895c73b">minisketch_destroy</a></div><div class="ttdeci">MINISKETCH_API void minisketch_destroy(minisketch *sketch)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:424</div></div>
<div class="ttc" id="avalidation_8cpp_html_afb7ea74ba028421697aa7f364741ee6c"><div class="ttname"><a href="validation_8cpp.html#afb7ea74ba028421697aa7f364741ee6c">assert</a></div><div class="ttdeci">assert(!tx.IsCoinBase())</div></div>
</div><!-- fragment --><p></sup></p>
<p><sup>The contents of the buffer can then be submitted to Bob, who can create his own sketch:</sup></p>
<p><sup></p><div class="fragment"><div class="line"><a class="code hl_typedef" href="minisketch_8h.html#adffb4f5b48fcdd25b57ae22f5b2147f4">minisketch</a> *sketch_b = <a class="code hl_function" href="minisketch_8h.html#a4d39dce1593d829c3fde622807fda244">minisketch_create</a>(12, 0, 4); <span class="comment">// Bob&#39;s own sketch</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 3002; i &lt; 3012; ++i) {</div>
<div class="line">  <a class="code hl_function" href="minisketch_8h.html#a6e0d272f72df96765d9041f859324880">minisketch_add_uint64</a>(sketch_b, i);</div>
<div class="line">}</div>
</div><!-- fragment --><p></sup></p>
<p><sup>After Bob receives Alice's serialized sketch, he can reconcile:</sup></p>
<p><sup></p><div class="fragment"><div class="line">  sketch_a = <a class="code hl_function" href="minisketch_8h.html#a4d39dce1593d829c3fde622807fda244">minisketch_create</a>(12, 0, 4);     <span class="comment">// Alice&#39;s sketch</span></div>
<div class="line">  <a class="code hl_function" href="minisketch_8h.html#ad283ad30bb9ac697a42d81ca2796414b">minisketch_deserialize</a>(sketch_a, buffer_a); <span class="comment">// Load Alice&#39;s sketch</span></div>
<div class="line">  free(buffer_a);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Merge the elements from sketch_a into sketch_b. The result is a sketch_b</span></div>
<div class="line">  <span class="comment">// which contains all elements that occurred in Alice&#39;s or Bob&#39;s sets, but not</span></div>
<div class="line">  <span class="comment">// in both.</span></div>
<div class="line">  <a class="code hl_function" href="minisketch_8h.html#a33e9c31b9b1ec357f85ba05c4d6724a2">minisketch_merge</a>(sketch_b, sketch_a);</div>
<div class="line"> </div>
<div class="line">  uint64_t differences[4];</div>
<div class="line">  ssize_t num_differences = <a class="code hl_function" href="minisketch_8h.html#a20adb9ea07329cdceb1f7254aee870b0">minisketch_decode</a>(sketch_b, 4, differences);</div>
<div class="line">  <a class="code hl_function" href="minisketch_8h.html#ad603da5dcb6bfe0dd3bbe4b03895c73b">minisketch_destroy</a>(sketch_a);</div>
<div class="line">  <a class="code hl_function" href="minisketch_8h.html#ad603da5dcb6bfe0dd3bbe4b03895c73b">minisketch_destroy</a>(sketch_b);</div>
<div class="line">  <span class="keywordflow">if</span> (num_differences &lt; 0) {</div>
<div class="line">    printf(<span class="stringliteral">&quot;More than 4 differences!\n&quot;</span>);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    ssize_t i;</div>
<div class="line">    <span class="keywordflow">for</span> (i = 0; i &lt; num_differences; ++i) {</div>
<div class="line">      printf(<span class="stringliteral">&quot;%u is in only one of the two sets\n&quot;</span>, (<span class="keywordtype">unsigned</span>)differences[i]);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aminisketch_8h_html_a20adb9ea07329cdceb1f7254aee870b0"><div class="ttname"><a href="minisketch_8h.html#a20adb9ea07329cdceb1f7254aee870b0">minisketch_decode</a></div><div class="ttdeci">MINISKETCH_API ssize_t minisketch_decode(const minisketch *sketch, size_t max_elements, uint64_t *output)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:468</div></div>
<div class="ttc" id="aminisketch_8h_html_a33e9c31b9b1ec357f85ba05c4d6724a2"><div class="ttname"><a href="minisketch_8h.html#a33e9c31b9b1ec357f85ba05c4d6724a2">minisketch_merge</a></div><div class="ttdeci">MINISKETCH_API size_t minisketch_merge(minisketch *sketch, const minisketch *other_sketch)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:458</div></div>
<div class="ttc" id="aminisketch_8h_html_ad283ad30bb9ac697a42d81ca2796414b"><div class="ttname"><a href="minisketch_8h.html#ad283ad30bb9ac697a42d81ca2796414b">minisketch_deserialize</a></div><div class="ttdeci">MINISKETCH_API void minisketch_deserialize(minisketch *sketch, const unsigned char *input)</div><div class="ttdef"><b>Definition</b> minisketch.cpp:446</div></div>
</div><!-- fragment --><p></sup></p>
<p><sup>In this example Bob would see output such as:</sup></p>
<p><sup></p><div class="fragment"><div class="line">$ gcc -std=c99 -Wall -Wextra -o example ./doc/example.c -Lsrc/ -lminisketch -lstdc++ &amp;&amp; ./example</div>
<div class="line">3000 is in only one of the two sets</div>
<div class="line">3011 is in only one of the two sets</div>
<div class="line">3001 is in only one of the two sets</div>
<div class="line">3010 is in only one of the two sets</div>
</div><!-- fragment --><p></sup></p>
<p><sup>The order of the output is arbitrary and will differ on different runs of <a class="el" href="minisketch_8h.html#a20adb9ea07329cdceb1f7254aee870b0">minisketch_decode()</a>.</sup></p>
<p><sup></sup></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
<sup>Applications</sup></h1>
<p><sup></sup></p>
<p><sup>Communications efficient set reconciliation has been proposed to optimize Bitcoin transaction distribution<sup><a class="el" href="#myfootnote8">[8]</a></sup>, which would allow Bitcoin nodes to have many more peers while reducing bandwidth usage. It could also be used for Bitcoin block distribution<sup><a class="el" href="#myfootnote9">[9]</a></sup>, particularly for very low bandwidth links such as satellite. A similar approach (CPISync) is used by PGP SKS keyservers to synchronize their databases efficiently. Secure sketches can also be used as helper data to reliably extract a consistent cryptographic key from fuzzy biometric data while leaking minimal information<sup><a class="el" href="#myfootnote1">[1]</a></sup>. They can be combined with <a href="https://en.wikipedia.org/wiki/Dining_cryptographers_problem">dcnets</a> to create cryptographic multiparty anonymous communication<sup><a class="el" href="#myfootnote10">[10]</a></sup>.</sup></p>
<p><sup></sup></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
<sup>Implementation notes</sup></h1>
<p><sup></sup></p>
<p><sup><span class="tt">libminisketch</span> is written in C++11, but has a <a href="include/minisketch.h">C API</a> for compatibility reasons.</sup></p>
<p><sup>Specific algorithms and optimizations used:</p><ul>
<li>Finite field implementations:<ul>
<li>A generic implementation using C unsigned integer bit operations, and one using the <a href="https://en.wikipedia.org/wiki/CLMUL_instruction_set">CLMUL instruction</a> where available. The latter has specializations for different classes of fields that permit optimizations (those with trinomial irreducible polynomials, and those whose size is a multiple of 8 bits).</li>
<li>Precomputed tables for (repeated) squaring, and for solving equations of the form *x<sup>2</sup> + x = a*<sup><a class="el" href="#myfootnote2">[2]</a></sup>.</li>
<li>Inverses are computed using an <a href="https://en.wikipedia.org/w/index.php?title=Exponentiation_by_squaring&amp;oldid=868883860">exponentiation ladder</a><sup><a class="el" href="#myfootnote12">[12]</a></sup> on systems where multiplications are relatively fast, and using an <a href="https://en.wikipedia.org/w/index.php?title=Extended_Euclidean_algorithm&amp;oldid=865802511#Computing_multiplicative_inverses_in_modular_structures">extended GCD algorithm</a> otherwise.</li>
<li>Repeated multiplications are accelerated using runtime precomputations on systems where multiplications are relatively slow.</li>
<li>The serialization of field elements always represents them as bits that are coefficients of the lowest-weight (using lexicographic order as tie breaker) irreducible polynomials over <em>GF(2)</em> (see <a class="el" href="md_src_2minisketch_2doc_2moduli.html">this list</a>), but for some implementations they are converted to a different representation internally.</li>
</ul>
</li>
<li>The sketch algorithms are specialized for each separate field implementation, permitting inlining and specific optimizations while avoiding dynamic allocations and branching costs.</li>
<li>Decoding of sketches uses the <a href="https://en.wikipedia.org/w/index.php?title=Berlekamp%E2%80%93Massey_algorithm&amp;oldid=870768940">Berlekamp-Massey algorithm</a><sup><a class="el" href="#myfootnote3">[3]</a></sup> to compute the characteristic polynomial.</li>
<li>Finding the roots of polynomials is done using the Berlekamp trace algorithm with explicit formula for quadratic polynomials<sup><a class="el" href="#myfootnote4">[4]</a></sup>. The root finding is randomized to prevent adversarial inputs that intentionally trigger worst-case decode time.</li>
<li>A (possibly) novel optimization combines a test for unique roots with the Berlekamp trace algorithm.</li>
</ul>
<p></sup></p>
<p><sup>Some improvements that are still TODO:</p><ul>
<li>Explicit formulas for the roots of polynomials of higher degree than 2</li>
<li>Subquadratic multiplication and modulus algorithms</li>
<li>The <a href="http://mathworld.wolfram.com/Half-GCD.html">Half-GCD algorithm</a> for faster GCDs</li>
<li>An interface for incremental decoding: most of the computation in most failed decodes can be reused when attempting to decode a longer sketch of the same set</li>
<li>Platform specific optimizations for platforms other than x86</li>
<li>Avoid using slow uint64_t for calculations on 32-bit hosts</li>
<li>Optional IBLT / Hybrid and set entropy coder under the same interface</li>
</ul>
<p></sup></p>
<p><sup></sup></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
<sup>References</sup></h1>
<p><sup></sup></p>
<p><sup></p><ul>
<li><a class="anchor" id="myfootnote1"></a>[1] Dodis, Ostrovsky, Reyzin and Smith. <em>Fuzzy Extractors: How to Generate Strong Keys from Biometrics and Other Noisy Data.</em> SIAM Journal on Computing, volume 38, number 1, pages 97-139, 2008). <a href="http://eprint.iacr.org/2003/235">[URL]</a> <a href="https://eprint.iacr.org/2003/235.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote5"></a>[5] A. Trachtenberg, D. Starobinski and S. Agarwal. <em>Fast PDA synchronization using characteristic polynomial interpolation.</em> Proceedings, Twenty-First Annual Joint Conference of the IEEE Computer and Communications Societies, New York, NY, USA, 2002, pp. 1510-1519 vol.3. <a href="https://pdfs.semanticscholar.org/43da/2070b6b7b2320a1fed2fd5e70e87332c9c5e.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote2"></a>[2] Cherly, Jørgen, Luis Gallardo, Leonid Vaserstein, and Ethel Wheland. <em>Solving quadratic equations over polynomial rings of characteristic two.</em> Publicacions Matemàtiques (1998): 131-142. <a href="https://www.raco.cat/index.php/PublicacionsMatematiques/article/viewFile/37927/40412">[PDF]</a></li>
<li><a class="anchor" id="myfootnote3"></a>[3] J. Massey. <em>Shift-register synthesis and BCH decoding.</em> IEEE Transactions on Information Theory, vol. 15, no. 1, pp. 122-127, January 1969. <a href="http://crypto.stanford.edu/~mironov/cs359/massey.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote4"></a>[4] Bhaskar Biswas, Vincent Herbert. <em>Efficient Root Finding of Polynomials over Fields of Characteristic 2.</em> 2009. hal-00626997. <a href="https://hal.archives-ouvertes.fr/hal-00626997">[URL]</a> <a href="https://hal.archives-ouvertes.fr/hal-00626997/document">[PDF]</a></li>
<li><a class="anchor" id="myfootnote6"></a>[6] Eppstein, David, Michael T. Goodrich, Frank Uyeda, and George Varghese. <em>What's the difference?: efficient set reconciliation without prior context.</em> ACM SIGCOMM Computer Communication Review, vol. 41, no. 4, pp. 218-229. ACM, 2011. <a href="https://www.ics.uci.edu/~eppstein/pubs/EppGooUye-SIGCOMM-11.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote7"></a>[7] Goodrich, Michael T. and Michael Mitzenmacher. <em>Invertible bloom lookup tables.</em> 2011 49th Annual Allerton Conference on Communication, Control, and Computing (Allerton) (2011): 792-799. <a href="https://arxiv.org/pdf/1101.2245.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote8"></a>[8] Maxwell, Gregory F. <em><a href="https://bitcointalk.org/index.php?topic=1377345.0">Blocksonly mode BW savings, the limits of efficient block xfer, and better relay</a></em> Bitcointalk 2016, <em><a href="https://nt4tn.net/tech-notes/2016.mempool_sync_relay.txt">Technical notes on mempool synchronizing relay</a></em> #bitcoin-wizards 2016.</li>
<li><a class="anchor" id="myfootnote9"></a>[9] Maxwell, Gregory F. <em><a href="https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_coding">Block network coding</a></em> Bitcoin Wiki 2014, <em><a href="https://nt4tn.net/tech-notes/201512.efficient.block.xfer.txt">Technical notes on efficient block xfer</a></em> #bitcoin-wizards 2015.</li>
<li><a class="anchor" id="myfootnote10"></a>[10] Ruffing, Tim, Moreno-Sanchez, Pedro, Aniket, Kate, <em>P2P Mixing and Unlinkable Bitcoin Transactions</em> NDSS Symposium 2017 <a href="https://eprint.iacr.org/2016/824">[URL]</a> <a href="https://eprint.iacr.org/2016/824.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote11"></a>[11] Y. Misky, A. Trachtenberg, R. Zippel. <em>Set Reconciliation with Nearly Optimal Communication Complexity.</em> Cornell University, 2000. <a href="https://ecommons.cornell.edu/handle/1813/5803">[URL]</a> <a href="https://ecommons.cornell.edu/bitstream/handle/1813/5803/2000-1813.pdf">[PDF]</a></li>
<li><a class="anchor" id="myfootnote12"></a>[12] Itoh, Toshiya, and Shigeo Tsujii. "A fast algorithm for computing multiplicative inverses in GF (2m) using normal bases." Information and computation 78, no. 3 (1988): 171-177. <a href="https://www.sciencedirect.com/science/article/pii/0890540188900247">[URL]</a> </li>
</ul>
<p></sup></p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_70099abe5db258d8b2b1561b8813f7f0.html">minisketch</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
