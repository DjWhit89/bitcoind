<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: leveldb</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_src_2leveldb_2doc_2index.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">leveldb </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>Jeff Dean, Sanjay Ghemawat</em></p>
<p>The leveldb library provides a persistent key value store. Keys and values are arbitrary byte arrays. The keys are ordered within the key value store according to a user-specified comparator function.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
Opening A Database</h1>
<p>A leveldb database has a name which corresponds to a file system directory. All of the contents of database are stored in this directory. The following example shows how to open a database, creating it if necessary:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="leveldb_2include_2leveldb_2db_8h.html">leveldb/db.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_d_b.html">leveldb::DB</a>* db;</div>
<div class="line"><a class="code hl_struct" href="structleveldb_1_1_options.html">leveldb::Options</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#ae5705099c20de542830760b9ae7ce090">create_if_missing</a> = <span class="keyword">true</span>;</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_status.html">leveldb::Status</a> status = <a class="code hl_function" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a>(options, <span class="stringliteral">&quot;/tmp/testdb&quot;</span>, &amp;db);</div>
<div class="line"><a class="code hl_function" href="validation_8cpp.html#afb7ea74ba028421697aa7f364741ee6c">assert</a>(status.<a class="code hl_function" href="classleveldb_1_1_status.html#a03cb7eaa663dc83af68bc28a596d09e6">ok</a>());</div>
<div class="line">...</div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html"><div class="ttname"><a href="classleveldb_1_1_d_b.html">leveldb::DB</a></div><div class="ttdef"><b>Definition</b> db.h:46</div></div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_a26c15fb67157cbad02208d0f949393dd"><div class="ttname"><a href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a></div><div class="ttdeci">static Status Open(const Options &amp;options, const std::string &amp;name, DB **dbptr)</div><div class="ttdef"><b>Definition</b> db_impl.cc:1479</div></div>
<div class="ttc" id="aclassleveldb_1_1_status_html"><div class="ttname"><a href="classleveldb_1_1_status.html">leveldb::Status</a></div><div class="ttdef"><b>Definition</b> status.h:24</div></div>
<div class="ttc" id="aclassleveldb_1_1_status_html_a03cb7eaa663dc83af68bc28a596d09e6"><div class="ttname"><a href="classleveldb_1_1_status.html#a03cb7eaa663dc83af68bc28a596d09e6">leveldb::Status::ok</a></div><div class="ttdeci">bool ok() const</div><div class="ttdef"><b>Definition</b> status.h:57</div></div>
<div class="ttc" id="aleveldb_2include_2leveldb_2db_8h_html"><div class="ttname"><a href="leveldb_2include_2leveldb_2db_8h.html">db.h</a></div></div>
<div class="ttc" id="astructleveldb_1_1_options_html"><div class="ttname"><a href="structleveldb_1_1_options.html">leveldb::Options</a></div><div class="ttdef"><b>Definition</b> options.h:33</div></div>
<div class="ttc" id="astructleveldb_1_1_options_html_ae5705099c20de542830760b9ae7ce090"><div class="ttname"><a href="structleveldb_1_1_options.html#ae5705099c20de542830760b9ae7ce090">leveldb::Options::create_if_missing</a></div><div class="ttdeci">bool create_if_missing</div><div class="ttdef"><b>Definition</b> options.h:49</div></div>
<div class="ttc" id="avalidation_8cpp_html_afb7ea74ba028421697aa7f364741ee6c"><div class="ttname"><a href="validation_8cpp.html#afb7ea74ba028421697aa7f364741ee6c">assert</a></div><div class="ttdeci">assert(!tx.IsCoinBase())</div></div>
</div><!-- fragment --><p>If you want to raise an error if the database already exists, add the following line before the <span class="tt"><a class="el" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a></span> call:</p>
<div class="fragment"><div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#a5ace215db309ff8d360c14c08ef644f7">error_if_exists</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="astructleveldb_1_1_options_html_a5ace215db309ff8d360c14c08ef644f7"><div class="ttname"><a href="structleveldb_1_1_options.html#a5ace215db309ff8d360c14c08ef644f7">leveldb::Options::error_if_exists</a></div><div class="ttdeci">bool error_if_exists</div><div class="ttdef"><b>Definition</b> options.h:52</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
Status</h1>
<p>You may have noticed the <span class="tt"><a class="el" href="classleveldb_1_1_status.html">leveldb::Status</a></span> type above. Values of this type are returned by most functions in leveldb that may encounter an error. You can check if such a result is ok, and also print an associated error message:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classleveldb_1_1_status.html">leveldb::Status</a> s = ...;</div>
<div class="line"><span class="keywordflow">if</span> (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
Closing A Database</h1>
<p>When you are done with a database, just delete the database object. Example:</p>
<div class="fragment"><div class="line">... open the db as described above ...</div>
<div class="line">... <span class="keywordflow">do</span> something with db ...</div>
<div class="line">delete db;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
Reads And Writes</h1>
<p>The database provides Put, Delete, and Get methods to modify/query the database. For example, the following code moves the value stored under key1 to key2.</p>
<div class="fragment"><div class="line">std::string value;</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_status.html">leveldb::Status</a> s = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#aa9b1498e3f5f27de1844a6652899a9a9">Get</a>(<a class="code hl_struct" href="structleveldb_1_1_read_options.html">leveldb::ReadOptions</a>(), key1, &amp;value);</div>
<div class="line"><span class="keywordflow">if</span> (s.ok()) s = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a8f25d8d2a5938b0121cdbbef58610132">Put</a>(<a class="code hl_struct" href="structleveldb_1_1_write_options.html">leveldb::WriteOptions</a>(), key2, value);</div>
<div class="line"><span class="keywordflow">if</span> (s.ok()) s = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a925b2e6f9e0788b8bbc0fc564dff1e09">Delete</a>(<a class="code hl_struct" href="structleveldb_1_1_write_options.html">leveldb::WriteOptions</a>(), key1);</div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_a8f25d8d2a5938b0121cdbbef58610132"><div class="ttname"><a href="classleveldb_1_1_d_b.html#a8f25d8d2a5938b0121cdbbef58610132">leveldb::DB::Put</a></div><div class="ttdeci">virtual Status Put(const WriteOptions &amp;options, const Slice &amp;key, const Slice &amp;value)=0</div><div class="ttdef"><b>Definition</b> db_impl.cc:1465</div></div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_a925b2e6f9e0788b8bbc0fc564dff1e09"><div class="ttname"><a href="classleveldb_1_1_d_b.html#a925b2e6f9e0788b8bbc0fc564dff1e09">leveldb::DB::Delete</a></div><div class="ttdeci">virtual Status Delete(const WriteOptions &amp;options, const Slice &amp;key)=0</div><div class="ttdef"><b>Definition</b> db_impl.cc:1471</div></div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_aa9b1498e3f5f27de1844a6652899a9a9"><div class="ttname"><a href="classleveldb_1_1_d_b.html#aa9b1498e3f5f27de1844a6652899a9a9">leveldb::DB::Get</a></div><div class="ttdeci">virtual Status Get(const ReadOptions &amp;options, const Slice &amp;key, std::string *value)=0</div></div>
<div class="ttc" id="astructleveldb_1_1_read_options_html"><div class="ttname"><a href="structleveldb_1_1_read_options.html">leveldb::ReadOptions</a></div><div class="ttdef"><b>Definition</b> options.h:146</div></div>
<div class="ttc" id="astructleveldb_1_1_write_options_html"><div class="ttname"><a href="structleveldb_1_1_write_options.html">leveldb::WriteOptions</a></div><div class="ttdef"><b>Definition</b> options.h:165</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md45"></a>
Atomic Updates</h1>
<p>Note that if the process dies after the Put of key2 but before the delete of key1, the same value may be left stored under multiple keys. Such problems can be avoided by using the <span class="tt"><a class="el" href="class_write_batch.html">WriteBatch</a></span> class to atomically apply a set of updates:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="write__batch_8h.html">leveldb/write_batch.h</a>&quot;</span></div>
<div class="line">...</div>
<div class="line">std::string value;</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_status.html">leveldb::Status</a> s = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#aa9b1498e3f5f27de1844a6652899a9a9">Get</a>(<a class="code hl_struct" href="structleveldb_1_1_read_options.html">leveldb::ReadOptions</a>(), key1, &amp;value);</div>
<div class="line"><span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">  <a class="code hl_class" href="classleveldb_1_1_write_batch.html">leveldb::WriteBatch</a> batch;</div>
<div class="line">  batch.<a class="code hl_function" href="classleveldb_1_1_write_batch.html#a75b31fc39374c2193e817cfc59343a43">Delete</a>(key1);</div>
<div class="line">  batch.<a class="code hl_function" href="classleveldb_1_1_write_batch.html#a2cd376f791391064946166edfbe9bcea">Put</a>(key2, value);</div>
<div class="line">  s = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#af9225d284fbb972951e13c58965e1680">Write</a>(<a class="code hl_struct" href="structleveldb_1_1_write_options.html">leveldb::WriteOptions</a>(), &amp;batch);</div>
<div class="line">}</div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_af9225d284fbb972951e13c58965e1680"><div class="ttname"><a href="classleveldb_1_1_d_b.html#af9225d284fbb972951e13c58965e1680">leveldb::DB::Write</a></div><div class="ttdeci">virtual Status Write(const WriteOptions &amp;options, WriteBatch *updates)=0</div></div>
<div class="ttc" id="aclassleveldb_1_1_write_batch_html"><div class="ttname"><a href="classleveldb_1_1_write_batch.html">leveldb::WriteBatch</a></div><div class="ttdef"><b>Definition</b> write_batch.h:33</div></div>
<div class="ttc" id="aclassleveldb_1_1_write_batch_html_a2cd376f791391064946166edfbe9bcea"><div class="ttname"><a href="classleveldb_1_1_write_batch.html#a2cd376f791391064946166edfbe9bcea">leveldb::WriteBatch::Put</a></div><div class="ttdeci">void Put(const Slice &amp;key, const Slice &amp;value)</div><div class="ttdef"><b>Definition</b> write_batch.cc:98</div></div>
<div class="ttc" id="aclassleveldb_1_1_write_batch_html_a75b31fc39374c2193e817cfc59343a43"><div class="ttname"><a href="classleveldb_1_1_write_batch.html#a75b31fc39374c2193e817cfc59343a43">leveldb::WriteBatch::Delete</a></div><div class="ttdeci">void Delete(const Slice &amp;key)</div><div class="ttdef"><b>Definition</b> write_batch.cc:105</div></div>
<div class="ttc" id="awrite__batch_8h_html"><div class="ttname"><a href="write__batch_8h.html">write_batch.h</a></div></div>
</div><!-- fragment --><p>The <span class="tt"><a class="el" href="class_write_batch.html">WriteBatch</a></span> holds a sequence of edits to be made to the database, and these edits within the batch are applied in order. Note that we called Delete before Put so that if key1 is identical to key2, we do not end up erroneously dropping the value entirely.</p>
<p>Apart from its atomicity benefits, <span class="tt"><a class="el" href="class_write_batch.html">WriteBatch</a></span> may also be used to speed up bulk updates by placing lots of individual mutations into the same batch.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md46"></a>
Synchronous Writes</h1>
<p>By default, each write to leveldb is asynchronous: it returns after pushing the write from the process into the operating system. The transfer from operating system memory to the underlying persistent storage happens asynchronously. The sync flag can be turned on for a particular write to make the write operation not return until the data being written has been pushed all the way to persistent storage. (On Posix systems, this is implemented by calling either <span class="tt">fsync(...)</span> or <span class="tt">fdatasync(...)</span> or <span class="tt">msync(..., MS_SYNC)</span> before the write operation returns.)</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structleveldb_1_1_write_options.html">leveldb::WriteOptions</a> write_options;</div>
<div class="line">write_options.<a class="code hl_variable" href="structleveldb_1_1_write_options.html#af5bad216eac9aefc703a450d3163e542">sync</a> = <span class="keyword">true</span>;</div>
<div class="line">db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a8f25d8d2a5938b0121cdbbef58610132">Put</a>(write_options, ...);</div>
<div class="ttc" id="astructleveldb_1_1_write_options_html_af5bad216eac9aefc703a450d3163e542"><div class="ttname"><a href="structleveldb_1_1_write_options.html#af5bad216eac9aefc703a450d3163e542">leveldb::WriteOptions::sync</a></div><div class="ttdeci">bool sync</div><div class="ttdef"><b>Definition</b> options.h:182</div></div>
</div><!-- fragment --><p>Asynchronous writes are often more than a thousand times as fast as synchronous writes. The downside of asynchronous writes is that a crash of the machine may cause the last few updates to be lost. Note that a crash of just the writing process (i.e., not a reboot) will not cause any loss since even when sync is false, an update is pushed from the process memory into the operating system before it is considered done.</p>
<p>Asynchronous writes can often be used safely. For example, when loading a large amount of data into the database you can handle lost updates by restarting the bulk load after a crash. A hybrid scheme is also possible where every Nth write is synchronous, and in the event of a crash, the bulk load is restarted just after the last synchronous write finished by the previous run. (The synchronous write can update a marker that describes where to restart on a crash.)</p>
<p><span class="tt"><a class="el" href="class_write_batch.html">WriteBatch</a></span> provides an alternative to asynchronous writes. Multiple updates may be placed in the same <a class="el" href="class_write_batch.html">WriteBatch</a> and applied together using a synchronous write (i.e., <span class="tt">write_options.sync</span> is set to true). The extra cost of the synchronous write will be amortized across all of the writes in the batch.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md47"></a>
Concurrency</h1>
<p>A database may only be opened by one process at a time. The leveldb implementation acquires a lock from the operating system to prevent misuse. Within a single process, the same <span class="tt"><a class="el" href="classleveldb_1_1_d_b.html">leveldb::DB</a></span> object may be safely shared by multiple concurrent threads. I.e., different threads may write into or fetch iterators or call Get on the same database without any external synchronization (the leveldb implementation will automatically do the required synchronization). However other objects (like <a class="el" href="class_iterator.html">Iterator</a> and <span class="tt"><a class="el" href="class_write_batch.html">WriteBatch</a></span>) may require external synchronization. If two threads share such an object, they must protect access to it using their own locking protocol. More details are available in the public header files.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md48"></a>
Iteration</h1>
<p>The following example demonstrates how to print all key,value pairs in a database.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classleveldb_1_1_iterator.html">leveldb::Iterator</a>* it = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a793c60f02d9b46af6d1060fbb87fbe30">NewIterator</a>(<a class="code hl_struct" href="structleveldb_1_1_read_options.html">leveldb::ReadOptions</a>());</div>
<div class="line"><span class="keywordflow">for</span> (it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a061b52ea09e8b77c60c212ee5655fc06">SeekToFirst</a>(); it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#aa074dd76e0eb2f214d1eed4093e5fbd8">Valid</a>(); it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a5e6ce1b8883cf6764780b7108dbb8495">Next</a>()) {</div>
<div class="line">  cout &lt;&lt; it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#ad99e78dda00539f1072e70e07e528df3">key</a>().<a class="code hl_function" href="classleveldb_1_1_slice.html#a19c380b03cea21d7ac7325136a131ff0">ToString</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span>  &lt;&lt; it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a16c33c5114445c609cc887cc090ea128">value</a>().<a class="code hl_function" href="classleveldb_1_1_slice.html#a19c380b03cea21d7ac7325136a131ff0">ToString</a>() &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="validation_8cpp.html#afb7ea74ba028421697aa7f364741ee6c">assert</a>(it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#adfba9b39542cba955a02b8ff3ba023a9">status</a>().<a class="code hl_function" href="classleveldb_1_1_status.html#a03cb7eaa663dc83af68bc28a596d09e6">ok</a>());  <span class="comment">// Check for any errors found during the scan</span></div>
<div class="line"><span class="keyword">delete</span> it;</div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_a793c60f02d9b46af6d1060fbb87fbe30"><div class="ttname"><a href="classleveldb_1_1_d_b.html#a793c60f02d9b46af6d1060fbb87fbe30">leveldb::DB::NewIterator</a></div><div class="ttdeci">virtual Iterator * NewIterator(const ReadOptions &amp;options)=0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html"><div class="ttname"><a href="classleveldb_1_1_iterator.html">leveldb::Iterator</a></div><div class="ttdef"><b>Definition</b> iterator.h:24</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_a061b52ea09e8b77c60c212ee5655fc06"><div class="ttname"><a href="classleveldb_1_1_iterator.html#a061b52ea09e8b77c60c212ee5655fc06">leveldb::Iterator::SeekToFirst</a></div><div class="ttdeci">virtual void SeekToFirst()=0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_a16c33c5114445c609cc887cc090ea128"><div class="ttname"><a href="classleveldb_1_1_iterator.html#a16c33c5114445c609cc887cc090ea128">leveldb::Iterator::value</a></div><div class="ttdeci">virtual Slice value() const =0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_a5e6ce1b8883cf6764780b7108dbb8495"><div class="ttname"><a href="classleveldb_1_1_iterator.html#a5e6ce1b8883cf6764780b7108dbb8495">leveldb::Iterator::Next</a></div><div class="ttdeci">virtual void Next()=0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_aa074dd76e0eb2f214d1eed4093e5fbd8"><div class="ttname"><a href="classleveldb_1_1_iterator.html#aa074dd76e0eb2f214d1eed4093e5fbd8">leveldb::Iterator::Valid</a></div><div class="ttdeci">virtual bool Valid() const =0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_ad99e78dda00539f1072e70e07e528df3"><div class="ttname"><a href="classleveldb_1_1_iterator.html#ad99e78dda00539f1072e70e07e528df3">leveldb::Iterator::key</a></div><div class="ttdeci">virtual Slice key() const =0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_adfba9b39542cba955a02b8ff3ba023a9"><div class="ttname"><a href="classleveldb_1_1_iterator.html#adfba9b39542cba955a02b8ff3ba023a9">leveldb::Iterator::status</a></div><div class="ttdeci">virtual Status status() const =0</div></div>
<div class="ttc" id="aclassleveldb_1_1_slice_html_a19c380b03cea21d7ac7325136a131ff0"><div class="ttname"><a href="classleveldb_1_1_slice.html#a19c380b03cea21d7ac7325136a131ff0">leveldb::Slice::ToString</a></div><div class="ttdeci">std::string ToString() const</div><div class="ttdef"><b>Definition</b> slice.h:79</div></div>
</div><!-- fragment --><p>The following variation shows how to process just the keys in the range [start,limit):</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#af62e72b82159acc9682d48b9276e86cb">Seek</a>(start);</div>
<div class="line">   it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#aa074dd76e0eb2f214d1eed4093e5fbd8">Valid</a>() &amp;&amp; it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#ad99e78dda00539f1072e70e07e528df3">key</a>().<a class="code hl_function" href="classleveldb_1_1_slice.html#a19c380b03cea21d7ac7325136a131ff0">ToString</a>() &lt; limit;</div>
<div class="line">   it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a5e6ce1b8883cf6764780b7108dbb8495">Next</a>()) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_af62e72b82159acc9682d48b9276e86cb"><div class="ttname"><a href="classleveldb_1_1_iterator.html#af62e72b82159acc9682d48b9276e86cb">leveldb::Iterator::Seek</a></div><div class="ttdeci">virtual void Seek(const Slice &amp;target)=0</div></div>
</div><!-- fragment --><p>You can also process entries in reverse order. (Caveat: reverse iteration may be somewhat slower than forward iteration.)</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a303c79ac05bf2946cc2d042992ab14e8">SeekToLast</a>(); it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#aa074dd76e0eb2f214d1eed4093e5fbd8">Valid</a>(); it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a0381264b3ad91e591d03c34271897682">Prev</a>()) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_a0381264b3ad91e591d03c34271897682"><div class="ttname"><a href="classleveldb_1_1_iterator.html#a0381264b3ad91e591d03c34271897682">leveldb::Iterator::Prev</a></div><div class="ttdeci">virtual void Prev()=0</div></div>
<div class="ttc" id="aclassleveldb_1_1_iterator_html_a303c79ac05bf2946cc2d042992ab14e8"><div class="ttname"><a href="classleveldb_1_1_iterator.html#a303c79ac05bf2946cc2d042992ab14e8">leveldb::Iterator::SeekToLast</a></div><div class="ttdeci">virtual void SeekToLast()=0</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md49"></a>
Snapshots</h1>
<p>Snapshots provide consistent read-only views over the entire state of the key-value store. <span class="tt"><a class="el" href="struct_read_options.html#a6e703d6a814fc977ccb6b6a7aa441cf7">ReadOptions::snapshot</a></span> may be non-NULL to indicate that a read should operate on a particular version of the <a class="el" href="class_d_b.html">DB</a> state. If <span class="tt"><a class="el" href="struct_read_options.html#a6e703d6a814fc977ccb6b6a7aa441cf7">ReadOptions::snapshot</a></span> is NULL, the read will operate on an implicit snapshot of the current state.</p>
<p>Snapshots are created by the <span class="tt"><a class="el" href="class_d_b.html#a97d4baa430a8a5df1a70bf5fe152b4f4">DB::GetSnapshot()</a></span> method:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structleveldb_1_1_read_options.html">leveldb::ReadOptions</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_read_options.html#a6e703d6a814fc977ccb6b6a7aa441cf7">snapshot</a> = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a97d4baa430a8a5df1a70bf5fe152b4f4">GetSnapshot</a>();</div>
<div class="line">... apply some updates to db ...</div>
<div class="line">leveldb::Iterator* iter = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a793c60f02d9b46af6d1060fbb87fbe30">NewIterator</a>(options);</div>
<div class="line">... read <span class="keyword">using </span>iter to view the state when the snapshot was created ...</div>
<div class="line">delete iter;</div>
<div class="line">db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a9bde7504ecef36d21478f7e10afafa2a">ReleaseSnapshot</a>(options.<a class="code hl_variable" href="structleveldb_1_1_read_options.html#a6e703d6a814fc977ccb6b6a7aa441cf7">snapshot</a>);</div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_a97d4baa430a8a5df1a70bf5fe152b4f4"><div class="ttname"><a href="classleveldb_1_1_d_b.html#a97d4baa430a8a5df1a70bf5fe152b4f4">leveldb::DB::GetSnapshot</a></div><div class="ttdeci">virtual const Snapshot * GetSnapshot()=0</div></div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_a9bde7504ecef36d21478f7e10afafa2a"><div class="ttname"><a href="classleveldb_1_1_d_b.html#a9bde7504ecef36d21478f7e10afafa2a">leveldb::DB::ReleaseSnapshot</a></div><div class="ttdeci">virtual void ReleaseSnapshot(const Snapshot *snapshot)=0</div></div>
<div class="ttc" id="astructleveldb_1_1_read_options_html_a6e703d6a814fc977ccb6b6a7aa441cf7"><div class="ttname"><a href="structleveldb_1_1_read_options.html#a6e703d6a814fc977ccb6b6a7aa441cf7">leveldb::ReadOptions::snapshot</a></div><div class="ttdeci">const Snapshot * snapshot</div><div class="ttdef"><b>Definition</b> options.h:161</div></div>
</div><!-- fragment --><p>Note that when a snapshot is no longer needed, it should be released using the <span class="tt"><a class="el" href="class_d_b.html#a9bde7504ecef36d21478f7e10afafa2a">DB::ReleaseSnapshot</a></span> interface. This allows the implementation to get rid of state that was being maintained just to support reading as of that snapshot.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md50"></a>
Slice</h1>
<p>The return value of the <span class="tt">it-&gt;key()</span> and <span class="tt">it-&gt;value()</span> calls above are instances of the <span class="tt"><a class="el" href="classleveldb_1_1_slice.html">leveldb::Slice</a></span> type. <a class="el" href="class_slice.html">Slice</a> is a simple structure that contains a length and a pointer to an external byte array. Returning a <a class="el" href="class_slice.html">Slice</a> is a cheaper alternative to returning a <span class="tt">std::string</span> since we do not need to copy potentially large keys and values. In addition, leveldb methods do not return null-terminated C-style strings since leveldb keys and values are allowed to contain <span class="tt">'\0'</span> bytes.</p>
<p>C++ strings and null-terminated C-style strings can be easily converted to a <a class="el" href="class_slice.html">Slice</a>:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classleveldb_1_1_slice.html">leveldb::Slice</a> s1 = <span class="stringliteral">&quot;hello&quot;</span>;</div>
<div class="line"> </div>
<div class="line">std::string str(<span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_slice.html">leveldb::Slice</a> s2 = str;</div>
<div class="ttc" id="aclassleveldb_1_1_slice_html"><div class="ttname"><a href="classleveldb_1_1_slice.html">leveldb::Slice</a></div><div class="ttdef"><b>Definition</b> slice.h:28</div></div>
</div><!-- fragment --><p>A <a class="el" href="class_slice.html">Slice</a> can be easily converted back to a C++ string:</p>
<div class="fragment"><div class="line">std::string str = s1.<a class="code hl_function" href="classleveldb_1_1_slice.html#a19c380b03cea21d7ac7325136a131ff0">ToString</a>();</div>
<div class="line"><a class="code hl_function" href="validation_8cpp.html#afb7ea74ba028421697aa7f364741ee6c">assert</a>(str == std::string(<span class="stringliteral">&quot;hello&quot;</span>));</div>
</div><!-- fragment --><p>Be careful when using Slices since it is up to the caller to ensure that the external byte array into which the <a class="el" href="class_slice.html">Slice</a> points remains live while the <a class="el" href="class_slice.html">Slice</a> is in use. For example, the following is buggy:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classleveldb_1_1_slice.html">leveldb::Slice</a> slice;</div>
<div class="line"><span class="keywordflow">if</span> (...) {</div>
<div class="line">  std::string str = ...;</div>
<div class="line">  slice = str;</div>
<div class="line">}</div>
<div class="line">Use(slice);</div>
</div><!-- fragment --><p>When the if statement goes out of scope, str will be destroyed and the backing storage for slice will disappear.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md51"></a>
Comparators</h1>
<p>The preceding examples used the default ordering function for key, which orders bytes lexicographically. You can however supply a custom comparator when opening a database. For example, suppose each database key consists of two numbers and we should sort by the first number, breaking ties by the second number. First, define a proper subclass of <span class="tt"><a class="el" href="structleveldb_1_1_comparator.html">leveldb::Comparator</a></span> that expresses these rules:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>TwoPartComparator : <span class="keyword">public</span> <a class="code hl_class" href="structleveldb_1_1_comparator.html">leveldb::Comparator</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Three-way comparison function:</span></div>
<div class="line">  <span class="comment">//   if a &lt; b: negative result</span></div>
<div class="line">  <span class="comment">//   if a &gt; b: positive result</span></div>
<div class="line">  <span class="comment">//   else: zero result</span></div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_function" href="structleveldb_1_1_comparator.html#ae54e9ac18597e67b5f82ea6458a2b05c">Compare</a>(<span class="keyword">const</span> <a class="code hl_class" href="classleveldb_1_1_slice.html">leveldb::Slice</a>&amp; a, <span class="keyword">const</span> <a class="code hl_class" href="classleveldb_1_1_slice.html">leveldb::Slice</a>&amp; b)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">int</span> a1, a2, b1, b2;</div>
<div class="line">    ParseKey(a, &amp;a1, &amp;a2);</div>
<div class="line">    ParseKey(b, &amp;b1, &amp;b2);</div>
<div class="line">    <span class="keywordflow">if</span> (a1 &lt; b1) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (a1 &gt; b1) <span class="keywordflow">return</span> +1;</div>
<div class="line">    <span class="keywordflow">if</span> (a2 &lt; b2) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (a2 &gt; b2) <span class="keywordflow">return</span> +1;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Ignore the following methods for now:</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code hl_function" href="structleveldb_1_1_comparator.html#a3c53815bb616ea234f94f36518a8f755">Name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;TwoPartComparator&quot;</span>; }</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="structleveldb_1_1_comparator.html#ac4834df0551e56c74e6b2d41631c9c8d">FindShortestSeparator</a>(std::string*, <span class="keyword">const</span> leveldb::Slice&amp;)<span class="keyword"> const </span>{}</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="structleveldb_1_1_comparator.html#aa63238380527c1c812b7a85d9098bf68">FindShortSuccessor</a>(std::string*)<span class="keyword"> const </span>{}</div>
<div class="line">};</div>
<div class="ttc" id="astructleveldb_1_1_comparator_html"><div class="ttname"><a href="structleveldb_1_1_comparator.html">leveldb::Comparator</a></div><div class="ttdef"><b>Definition</b> skiplist_test.cc:22</div></div>
<div class="ttc" id="astructleveldb_1_1_comparator_html_a3c53815bb616ea234f94f36518a8f755"><div class="ttname"><a href="structleveldb_1_1_comparator.html#a3c53815bb616ea234f94f36518a8f755">leveldb::Comparator::Name</a></div><div class="ttdeci">virtual const char * Name() const =0</div></div>
<div class="ttc" id="astructleveldb_1_1_comparator_html_aa63238380527c1c812b7a85d9098bf68"><div class="ttname"><a href="structleveldb_1_1_comparator.html#aa63238380527c1c812b7a85d9098bf68">leveldb::Comparator::FindShortSuccessor</a></div><div class="ttdeci">virtual void FindShortSuccessor(std::string *key) const =0</div></div>
<div class="ttc" id="astructleveldb_1_1_comparator_html_ac4834df0551e56c74e6b2d41631c9c8d"><div class="ttname"><a href="structleveldb_1_1_comparator.html#ac4834df0551e56c74e6b2d41631c9c8d">leveldb::Comparator::FindShortestSeparator</a></div><div class="ttdeci">virtual void FindShortestSeparator(std::string *start, const Slice &amp;limit) const =0</div></div>
<div class="ttc" id="astructleveldb_1_1_comparator_html_ae54e9ac18597e67b5f82ea6458a2b05c"><div class="ttname"><a href="structleveldb_1_1_comparator.html#ae54e9ac18597e67b5f82ea6458a2b05c">leveldb::Comparator::Compare</a></div><div class="ttdeci">virtual int Compare(const Slice &amp;a, const Slice &amp;b) const =0</div></div>
</div><!-- fragment --><p>Now create a database using this custom comparator:</p>
<div class="fragment"><div class="line">TwoPartComparator cmp;</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_d_b.html">leveldb::DB</a>* db;</div>
<div class="line"><a class="code hl_struct" href="structleveldb_1_1_options.html">leveldb::Options</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#ae5705099c20de542830760b9ae7ce090">create_if_missing</a> = <span class="keyword">true</span>;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#a1839c90c09816ba849d7f4dc8273bcee">comparator</a> = &amp;cmp;</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_status.html">leveldb::Status</a> status = <a class="code hl_function" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a>(options, <span class="stringliteral">&quot;/tmp/testdb&quot;</span>, &amp;db);</div>
<div class="line">...</div>
<div class="ttc" id="astructleveldb_1_1_options_html_a1839c90c09816ba849d7f4dc8273bcee"><div class="ttname"><a href="structleveldb_1_1_options.html#a1839c90c09816ba849d7f4dc8273bcee">leveldb::Options::comparator</a></div><div class="ttdeci">const Comparator * comparator</div><div class="ttdef"><b>Definition</b> options.h:46</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md52"></a>
Backwards compatibility</h2>
<p>The result of the comparator's Name method is attached to the database when it is created, and is checked on every subsequent database open. If the name changes, the <span class="tt"><a class="el" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a></span> call will fail. Therefore, change the name if and only if the new key format and comparison function are incompatible with existing databases, and it is ok to discard the contents of all existing databases.</p>
<p>You can however still gradually evolve your key format over time with a little bit of pre-planning. For example, you could store a version number at the end of each key (one byte should suffice for most uses). When you wish to switch to a new key format (e.g., adding an optional third part to the keys processed by <span class="tt">TwoPartComparator</span>), (a) keep the same comparator name (b) increment the version number for new keys (c) change the comparator function so it uses the version numbers found in the keys to decide how to interpret them.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md53"></a>
Performance</h1>
<p>Performance can be tuned by changing the default values of the types defined in <span class="tt">include/options.h</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md54"></a>
Block size</h2>
<p>leveldb groups adjacent keys together into the same block and such a block is the unit of transfer to and from persistent storage. The default block size is approximately 4096 uncompressed bytes. Applications that mostly do bulk scans over the contents of the database may wish to increase this size. Applications that do a lot of point reads of small values may wish to switch to a smaller block size if performance measurements indicate an improvement. There isn't much benefit in using blocks smaller than one kilobyte, or larger than a few megabytes. Also note that compression will be more effective with larger block sizes.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md55"></a>
Compression</h2>
<p>Each block is individually compressed before being written to persistent storage. Compression is on by default since the default compression method is very fast, and is automatically disabled for incompressible data. In rare cases, applications may want to disable compression entirely, but should only do so if benchmarks show a performance improvement:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structleveldb_1_1_options.html">leveldb::Options</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#a27966b66d4a1071574d83d5d5d5443d2">compression</a> = <a class="code hl_enumvalue" href="namespaceleveldb.html#affec749ed88365143745313ae9168263a575e0de7518c405f85e3a1a640cfeeff">leveldb::kNoCompression</a>;</div>
<div class="line">... <a class="code hl_function" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a>(options, <a class="code hl_variable" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, ...) ....</div>
<div class="ttc" id="anamespaceleveldb_html_affec749ed88365143745313ae9168263a575e0de7518c405f85e3a1a640cfeeff"><div class="ttname"><a href="namespaceleveldb.html#affec749ed88365143745313ae9168263a575e0de7518c405f85e3a1a640cfeeff">leveldb::kNoCompression</a></div><div class="ttdeci">@ kNoCompression</div><div class="ttdef"><b>Definition</b> options.h:28</div></div>
<div class="ttc" id="arest_8cpp_html_a8f8f80d37794cde9472343e4487ba3eb"><div class="ttname"><a href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a></div><div class="ttdeci">const char * name</div><div class="ttdef"><b>Definition</b> rest.cpp:48</div></div>
<div class="ttc" id="astructleveldb_1_1_options_html_a27966b66d4a1071574d83d5d5d5443d2"><div class="ttname"><a href="structleveldb_1_1_options.html#a27966b66d4a1071574d83d5d5d5443d2">leveldb::Options::compression</a></div><div class="ttdeci">CompressionType compression</div><div class="ttdef"><b>Definition</b> options.h:131</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md56"></a>
Cache</h2>
<p>The contents of the database are stored in a set of files in the filesystem and each file stores a sequence of compressed blocks. If options.block_cache is non-NULL, it is used to cache frequently used uncompressed block contents.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cache_8h.html">leveldb/cache.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structleveldb_1_1_options.html">leveldb::Options</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#ade95c62b461bb65b802c2b5a3b437780">block_cache</a> = <a class="code hl_function" href="namespaceleveldb.html#ac9e55cee12c519cd8944f48a2520b9d4">leveldb::NewLRUCache</a>(100 * 1048576);  <span class="comment">// 100MB cache</span></div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_d_b.html">leveldb::DB</a>* db;</div>
<div class="line"><a class="code hl_function" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a>(options, <a class="code hl_variable" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>, &amp;db);</div>
<div class="line">... use the db ...</div>
<div class="line">delete db</div>
<div class="line"><span class="keyword">delete</span> options.<a class="code hl_variable" href="structleveldb_1_1_options.html#ade95c62b461bb65b802c2b5a3b437780">block_cache</a>;</div>
<div class="ttc" id="acache_8h_html"><div class="ttname"><a href="cache_8h.html">cache.h</a></div></div>
<div class="ttc" id="anamespaceleveldb_html_ac9e55cee12c519cd8944f48a2520b9d4"><div class="ttname"><a href="namespaceleveldb.html#ac9e55cee12c519cd8944f48a2520b9d4">leveldb::NewLRUCache</a></div><div class="ttdeci">LEVELDB_EXPORT Cache * NewLRUCache(size_t capacity)</div><div class="ttdef"><b>Definition</b> cache.cc:398</div></div>
<div class="ttc" id="astructleveldb_1_1_options_html_ade95c62b461bb65b802c2b5a3b437780"><div class="ttname"><a href="structleveldb_1_1_options.html#ade95c62b461bb65b802c2b5a3b437780">leveldb::Options::block_cache</a></div><div class="ttdeci">Cache * block_cache</div><div class="ttdef"><b>Definition</b> options.h:94</div></div>
</div><!-- fragment --><p>Note that the cache holds uncompressed data, and therefore it should be sized according to application level data sizes, without any reduction from compression. (Caching of compressed blocks is left to the operating system buffer cache, or any custom <a class="el" href="class_env.html">Env</a> implementation provided by the client.)</p>
<p>When performing a bulk read, the application may wish to disable caching so that the data processed by the bulk read does not end up displacing most of the cached contents. A per-iterator option can be used to achieve this:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structleveldb_1_1_read_options.html">leveldb::ReadOptions</a> options;</div>
<div class="line">options.fill_cache = <span class="keyword">false</span>;</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_iterator.html">leveldb::Iterator</a>* it = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#a793c60f02d9b46af6d1060fbb87fbe30">NewIterator</a>(options);</div>
<div class="line"><span class="keywordflow">for</span> (it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a061b52ea09e8b77c60c212ee5655fc06">SeekToFirst</a>(); it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#aa074dd76e0eb2f214d1eed4093e5fbd8">Valid</a>(); it-&gt;<a class="code hl_function" href="classleveldb_1_1_iterator.html#a5e6ce1b8883cf6764780b7108dbb8495">Next</a>()) {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md57"></a>
Key Layout</h2>
<p>Note that the unit of disk transfer and caching is a block. Adjacent keys (according to the database sort order) will usually be placed in the same block. Therefore the application can improve its performance by placing keys that are accessed together near each other and placing infrequently used keys in a separate region of the key space.</p>
<p>For example, suppose we are implementing a simple file system on top of leveldb. The types of entries we might wish to store are: </p><pre class="fragment">filename -&gt; permission-bits, length, list of file_block_ids
file_block_id -&gt; data
</pre><p>We might want to prefix filename keys with one letter (say '/') and the <span class="tt">file_block_id</span> keys with a different letter (say '0') so that scans over just the metadata do not force us to fetch and cache bulky file contents.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md58"></a>
Filters</h2>
<p>Because of the way leveldb data is organized on disk, a single <span class="tt">Get()</span> call may involve multiple reads from disk. The optional <a class="el" href="class_filter_policy.html">FilterPolicy</a> mechanism can be used to reduce the number of disk reads substantially.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structleveldb_1_1_options.html">leveldb::Options</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#a204e91801e7a1f4800904b42b41d7ce2">filter_policy</a> = <a class="code hl_function" href="c_8cc.html#a3e8016272c0a64b20d954afcc4a87009">NewBloomFilterPolicy</a>(10);</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_d_b.html">leveldb::DB</a>* db;</div>
<div class="line"><a class="code hl_function" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a>(options, <span class="stringliteral">&quot;/tmp/testdb&quot;</span>, &amp;db);</div>
<div class="line">... use the database ...</div>
<div class="line">delete db;</div>
<div class="line"><span class="keyword">delete</span> options.<a class="code hl_variable" href="structleveldb_1_1_options.html#a204e91801e7a1f4800904b42b41d7ce2">filter_policy</a>;</div>
<div class="ttc" id="ac_8cc_html_a3e8016272c0a64b20d954afcc4a87009"><div class="ttname"><a href="c_8cc.html#a3e8016272c0a64b20d954afcc4a87009">NewBloomFilterPolicy</a></div><div class="ttdeci">LEVELDB_EXPORT const FilterPolicy * NewBloomFilterPolicy(int bits_per_key)</div><div class="ttdef"><b>Definition</b> bloom.cc:88</div></div>
<div class="ttc" id="astructleveldb_1_1_options_html_a204e91801e7a1f4800904b42b41d7ce2"><div class="ttname"><a href="structleveldb_1_1_options.html#a204e91801e7a1f4800904b42b41d7ce2">leveldb::Options::filter_policy</a></div><div class="ttdeci">const FilterPolicy * filter_policy</div><div class="ttdef"><b>Definition</b> options.h:142</div></div>
</div><!-- fragment --><p>The preceding code associates a Bloom filter based filtering policy with the database. Bloom filter based filtering relies on keeping some number of bits of data in memory per key (in this case 10 bits per key since that is the argument we passed to <span class="tt"><a class="el" href="c_8cc.html#a3e8016272c0a64b20d954afcc4a87009">NewBloomFilterPolicy</a></span>). This filter will reduce the number of unnecessary disk reads needed for Get() calls by a factor of approximately a 100. Increasing the bits per key will lead to a larger reduction at the cost of more memory usage. We recommend that applications whose working set does not fit in memory and that do a lot of random reads set a filter policy.</p>
<p>If you are using a custom comparator, you should ensure that the filter policy you are using is compatible with your comparator. For example, consider a comparator that ignores trailing spaces when comparing keys. <span class="tt"><a class="el" href="c_8cc.html#a3e8016272c0a64b20d954afcc4a87009">NewBloomFilterPolicy</a></span> must not be used with such a comparator. Instead, the application should provide a custom filter policy that also ignores trailing spaces. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CustomFilterPolicy : <span class="keyword">public</span> <a class="code hl_class" href="classleveldb_1_1_filter_policy.html">leveldb::FilterPolicy</a> {</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <a class="code hl_class" href="class_filter_policy.html">FilterPolicy</a>* builtin_policy_;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  CustomFilterPolicy() : builtin_policy_(<a class="code hl_function" href="c_8cc.html#a3e8016272c0a64b20d954afcc4a87009">NewBloomFilterPolicy</a>(10)) {}</div>
<div class="line">  ~CustomFilterPolicy() { <span class="keyword">delete</span> builtin_policy_; }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code hl_function" href="classleveldb_1_1_filter_policy.html#a3c53815bb616ea234f94f36518a8f755">Name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;IgnoreTrailingSpacesFilter&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classleveldb_1_1_filter_policy.html#a71c959bf5bff4f1e207f58849dd0991d">CreateFilter</a>(<span class="keyword">const</span> Slice* keys, <span class="keywordtype">int</span> n, std::string* dst)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="comment">// Use builtin bloom filter code after removing trailing spaces</span></div>
<div class="line">    std::vector&lt;Slice&gt; trimmed(n);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {</div>
<div class="line">      trimmed[i] = RemoveTrailingSpaces(keys[i]);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> builtin_policy_-&gt;<a class="code hl_function" href="class_filter_policy.html#a241d436d9ae9acf92f551d2238ad4b71">CreateFilter</a>(&amp;trimmed[i], n, dst);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_filter_policy_html"><div class="ttname"><a href="class_filter_policy.html">FilterPolicy</a></div><div class="ttdef"><b>Definition</b> filter_policy.h:27</div></div>
<div class="ttc" id="aclass_filter_policy_html_a241d436d9ae9acf92f551d2238ad4b71"><div class="ttname"><a href="class_filter_policy.html#a241d436d9ae9acf92f551d2238ad4b71">FilterPolicy::CreateFilter</a></div><div class="ttdeci">virtual void CreateFilter(const Slice *keys, int n, std::string *dst) const =0</div></div>
<div class="ttc" id="aclassleveldb_1_1_filter_policy_html"><div class="ttname"><a href="classleveldb_1_1_filter_policy.html">leveldb::FilterPolicy</a></div><div class="ttdef"><b>Definition</b> filter_policy.h:27</div></div>
<div class="ttc" id="aclassleveldb_1_1_filter_policy_html_a3c53815bb616ea234f94f36518a8f755"><div class="ttname"><a href="classleveldb_1_1_filter_policy.html#a3c53815bb616ea234f94f36518a8f755">leveldb::FilterPolicy::Name</a></div><div class="ttdeci">virtual const char * Name() const =0</div></div>
<div class="ttc" id="aclassleveldb_1_1_filter_policy_html_a71c959bf5bff4f1e207f58849dd0991d"><div class="ttname"><a href="classleveldb_1_1_filter_policy.html#a71c959bf5bff4f1e207f58849dd0991d">leveldb::FilterPolicy::CreateFilter</a></div><div class="ttdeci">virtual void CreateFilter(const Slice *keys, int n, std::string *dst) const =0</div></div>
</div><!-- fragment --><p>Advanced applications may provide a filter policy that does not use a bloom filter but uses some other mechanism for summarizing a set of keys. See <span class="tt"><a class="el" href="filter__policy_8h.html">leveldb/filter_policy.h</a></span> for detail.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md59"></a>
Checksums</h1>
<p>leveldb associates checksums with all data it stores in the file system. There are two separate controls provided over how aggressively these checksums are verified:</p>
<p><span class="tt"><a class="el" href="struct_read_options.html#a746d25cabe5e8fc6b92c1e480fc2c319">ReadOptions::verify_checksums</a></span> may be set to true to force checksum verification of all data that is read from the file system on behalf of a particular read. By default, no such verification is done.</p>
<p><span class="tt"><a class="el" href="struct_options.html#a19e3dfb797bfb0f305bfdadd127ead24">Options::paranoid_checks</a></span> may be set to true before opening a database to make the database implementation raise an error as soon as it detects an internal corruption. Depending on which portion of the database has been corrupted, the error may be raised when the database is opened, or later by another database operation. By default, paranoid checking is off so that the database can be used even if parts of its persistent storage have been corrupted.</p>
<p>If a database is corrupted (perhaps it cannot be opened when paranoid checking is turned on), the <span class="tt"><a class="el" href="namespaceleveldb.html#affc6507c0c910cf5844d2ee3be2b6607">leveldb::RepairDB</a></span> function may be used to recover as much of the data as possible</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md60"></a>
Approximate Sizes</h1>
<p>The <span class="tt">GetApproximateSizes</span> method can used to get the approximate number of bytes of file system space used by one or more key ranges.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structleveldb_1_1_range.html">leveldb::Range</a> ranges[2];</div>
<div class="line">ranges[0] = <a class="code hl_struct" href="structleveldb_1_1_range.html">leveldb::Range</a>(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>);</div>
<div class="line">ranges[1] = <a class="code hl_struct" href="structleveldb_1_1_range.html">leveldb::Range</a>(<span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot;z&quot;</span>);</div>
<div class="line">uint64_t sizes[2];</div>
<div class="line"><a class="code hl_class" href="classleveldb_1_1_status.html">leveldb::Status</a> s = db-&gt;<a class="code hl_function" href="classleveldb_1_1_d_b.html#aa44c5ba846ce3e9db6fb540c2c523924">GetApproximateSizes</a>(ranges, 2, sizes);</div>
<div class="ttc" id="aclassleveldb_1_1_d_b_html_aa44c5ba846ce3e9db6fb540c2c523924"><div class="ttname"><a href="classleveldb_1_1_d_b.html#aa44c5ba846ce3e9db6fb540c2c523924">leveldb::DB::GetApproximateSizes</a></div><div class="ttdeci">virtual void GetApproximateSizes(const Range *range, int n, uint64_t *sizes)=0</div></div>
<div class="ttc" id="astructleveldb_1_1_range_html"><div class="ttname"><a href="structleveldb_1_1_range.html">leveldb::Range</a></div><div class="ttdef"><b>Definition</b> db.h:35</div></div>
</div><!-- fragment --><p>The preceding call will set <span class="tt">sizes[0]</span> to the approximate number of bytes of file system space used by the key range <span class="tt">[a..c)</span> and <span class="tt">sizes[1]</span> to the approximate number of bytes used by the key range <span class="tt">[x..z)</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md61"></a>
Environment</h1>
<p>All file operations (and other operating system calls) issued by the leveldb implementation are routed through a <span class="tt"><a class="el" href="classleveldb_1_1_env.html">leveldb::Env</a></span> object. Sophisticated clients may wish to provide their own <a class="el" href="class_env.html">Env</a> implementation to get better control. For example, an application may introduce artificial delays in the file IO paths to limit the impact of leveldb on other activities in the system.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>SlowEnv : <span class="keyword">public</span> <a class="code hl_class" href="classleveldb_1_1_env.html">leveldb::Env</a> {</div>
<div class="line">  ... implementation of the <a class="code hl_class" href="class_env.html">Env</a> <span class="keyword">interface </span>...</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">SlowEnv env;</div>
<div class="line"><a class="code hl_struct" href="structleveldb_1_1_options.html">leveldb::Options</a> options;</div>
<div class="line">options.<a class="code hl_variable" href="structleveldb_1_1_options.html#a5cd3f8825058fa594646d13638c40d6d">env</a> = &amp;env;</div>
<div class="line"><a class="code hl_class" href="class_status.html">Status</a> s = <a class="code hl_function" href="classleveldb_1_1_d_b.html#a26c15fb67157cbad02208d0f949393dd">leveldb::DB::Open</a>(options, ...);</div>
<div class="ttc" id="aclass_env_html"><div class="ttname"><a href="class_env.html">Env</a></div><div class="ttdef"><b>Definition</b> env.h:55</div></div>
<div class="ttc" id="aclass_status_html"><div class="ttname"><a href="class_status.html">Status</a></div><div class="ttdef"><b>Definition</b> status.h:24</div></div>
<div class="ttc" id="aclassleveldb_1_1_env_html"><div class="ttname"><a href="classleveldb_1_1_env.html">leveldb::Env</a></div><div class="ttdef"><b>Definition</b> env.h:55</div></div>
<div class="ttc" id="astructleveldb_1_1_options_html_a5cd3f8825058fa594646d13638c40d6d"><div class="ttname"><a href="structleveldb_1_1_options.html#a5cd3f8825058fa594646d13638c40d6d">leveldb::Options::env</a></div><div class="ttdeci">Env * env</div><div class="ttdef"><b>Definition</b> options.h:64</div></div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md62"></a>
Porting</h1>
<p>leveldb may be ported to a new platform by providing platform specific implementations of the types/methods/functions exported by <span class="tt"><a class="el" href="port_8h.html">leveldb/port/port.h</a></span>. See <span class="tt"><a class="el" href="port__example_8h.html">leveldb/port/port_example.h</a></span> for more details.</p>
<p>In addition, the new platform may need a new default <span class="tt"><a class="el" href="classleveldb_1_1_env.html">leveldb::Env</a></span> implementation. See <span class="tt">leveldb/util/env_posix.h</span> for an example.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md63"></a>
Other Information</h1>
<p>Details about the leveldb implementation may be found in the following documents:</p>
<ol type="1">
<li><a class="el" href="md_src_2leveldb_2doc_2impl.html">Implementation notes</a></li>
<li><a class="el" href="md_src_2leveldb_2doc_2table__format.html">Format of an immutable Table file</a></li>
<li><a class="el" href="md_src_2leveldb_2doc_2log__format.html">Format of a log file</a> </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
