<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: src/secp256k1/include/secp256k1_extrakeys.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('secp256k1__extrakeys_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">secp256k1_extrakeys.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="secp256k1_8h_source.html">secp256k1.h</a>&quot;</code><br />
</div>
<p><a href="secp256k1__extrakeys_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:secp256k1_5Fxonly_5Fpubkey" id="r_secp256k1_5Fxonly_5Fpubkey"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a></td></tr>
<tr class="memitem:secp256k1_5Fkeypair" id="r_secp256k1_5Fkeypair"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0868e774c9b0692ede20b4ce2a7d2a85" id="r_a0868e774c9b0692ede20b4ce2a7d2a85"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_xonly_pubkey&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0868e774c9b0692ede20b4ce2a7d2a85">secp256k1_xonly_pubkey</a></td></tr>
<tr class="memitem:ad8d14ec4a23d43f16eb45e216c414a9b" id="r_ad8d14ec4a23d43f16eb45e216c414a9b"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_keypair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8d14ec4a23d43f16eb45e216c414a9b">secp256k1_keypair</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9e5f1dae6a1e3e03d0093aa17e6c21c" id="r_ad9e5f1dae6a1e3e03d0093aa17e6c21c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e5f1dae6a1e3e03d0093aa17e6c21c">secp256k1_xonly_pubkey_parse</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *pubkey, const unsigned char *input32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a455e86be0f18f4313ba8ea73e34a25a6" id="r_a455e86be0f18f4313ba8ea73e34a25a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a455e86be0f18f4313ba8ea73e34a25a6">secp256k1_xonly_pubkey_serialize</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, unsigned char *output32, const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *pubkey) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a06f07f2cde819fd612ff4cc13e785aa9" id="r_a06f07f2cde819fd612ff4cc13e785aa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f07f2cde819fd612ff4cc13e785aa9">secp256k1_xonly_pubkey_cmp</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *pk1, const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *pk2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a38e6de43d8ee12d83e5cc85c47fcdc98" id="r_a38e6de43d8ee12d83e5cc85c47fcdc98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e6de43d8ee12d83e5cc85c47fcdc98">secp256k1_xonly_pubkey_from_pubkey</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *xonly_pubkey, int *pk_parity, const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *pubkey) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
<tr class="memitem:aaf832fa110c2610d69dee6ca74c856e8" id="r_aaf832fa110c2610d69dee6ca74c856e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf832fa110c2610d69dee6ca74c856e8">secp256k1_xonly_pubkey_tweak_add</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *output_pubkey, const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *internal_pubkey, const unsigned char *tweak32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
<tr class="memitem:a466fe5b6ca122c33e51f7a3e70ff3590" id="r_a466fe5b6ca122c33e51f7a3e70ff3590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a466fe5b6ca122c33e51f7a3e70ff3590">secp256k1_xonly_pubkey_tweak_add_check</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *internal_pubkey, const unsigned char *tweak32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(5)</td></tr>
<tr class="memitem:a61b1362ada2435ab10240e52ff738476" id="r_a61b1362ada2435ab10240e52ff738476"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61b1362ada2435ab10240e52ff738476">secp256k1_keypair_create</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair, const unsigned char *seckey) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:aff2e05c76e2eeac729a1eec6796778b8" id="r_aff2e05c76e2eeac729a1eec6796778b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2e05c76e2eeac729a1eec6796778b8">secp256k1_keypair_sec</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, unsigned char *seckey, const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:af9c115df738fabe6b04574d4880495bc" id="r_af9c115df738fabe6b04574d4880495bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9c115df738fabe6b04574d4880495bc">secp256k1_keypair_pub</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *pubkey, const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a96800411deb08bb3b6b0876fea6f6eb4" id="r_a96800411deb08bb3b6b0876fea6f6eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96800411deb08bb3b6b0876fea6f6eb4">secp256k1_keypair_xonly_pub</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *pubkey, int *pk_parity, const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
<tr class="memitem:aa99a68bfe473704d08eac556915883b6" id="r_aa99a68bfe473704d08eac556915883b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa99a68bfe473704d08eac556915883b6">secp256k1_keypair_xonly_tweak_add</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair, const unsigned char *tweak32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ad8d14ec4a23d43f16eb45e216c414a9b" name="ad8d14ec4a23d43f16eb45e216c414a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d14ec4a23d43f16eb45e216c414a9b">&#9670;&#160;</a></span>secp256k1_keypair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_keypair secp256k1_keypair</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds a keypair consisting of a secret and a public key.</p>
<p>The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions. It is however guaranteed to be 96 bytes in size, and can be safely copied/moved. </p>

</div>
</div>
<a id="a0868e774c9b0692ede20b4ce2a7d2a85" name="a0868e774c9b0692ede20b4ce2a7d2a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0868e774c9b0692ede20b4ce2a7d2a85">&#9670;&#160;</a></span>secp256k1_xonly_pubkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_xonly_pubkey secp256k1_xonly_pubkey</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds a parsed and valid "x-only" public key. An x-only pubkey encodes a point whose Y coordinate is even. It is serialized using only its X coordinate (32 bytes). See BIP-340 for more information about x-only pubkeys.</p>
<p>The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions. It is however guaranteed to be 64 bytes in size, and can be safely copied/moved. If you need to convert to a format suitable for storage, transmission, use use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse. To compare keys, use secp256k1_xonly_pubkey_cmp. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a61b1362ada2435ab10240e52ff738476" name="a61b1362ada2435ab10240e52ff738476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b1362ada2435ab10240e52ff738476">&#9670;&#160;</a></span>secp256k1_keypair_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_keypair_create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seckey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the keypair for a valid secret key.</p>
<p>See the documentation of <span class="tt"><a class="el" href="secp256k1_8h.html#a366f922fc0c787351e82ff8e3a95f652">secp256k1_ec_seckey_verify</a></span> for more information about the validity of secret keys.</p>
<p>Returns: 1: secret key is valid 0: secret key is invalid Args: ctx: pointer to a context object (not secp256k1_context_static). Out: keypair: pointer to the created keypair. In: seckey: pointer to a 32-byte secret key. </p>

</div>
</div>
<a id="af9c115df738fabe6b04574d4880495bc" name="af9c115df738fabe6b04574d4880495bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c115df738fabe6b04574d4880495bc">&#9670;&#160;</a></span>secp256k1_keypair_pub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_keypair_pub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the public key from a keypair.</p>
<p>Returns: 1 always. Args: ctx: pointer to a context object. Out: pubkey: pointer to a pubkey object, set to the keypair public key. In: keypair: pointer to a keypair. </p>

</div>
</div>
<a id="aff2e05c76e2eeac729a1eec6796778b8" name="aff2e05c76e2eeac729a1eec6796778b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2e05c76e2eeac729a1eec6796778b8">&#9670;&#160;</a></span>secp256k1_keypair_sec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_keypair_sec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seckey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the secret key from a keypair.</p>
<p>Returns: 1 always. Args: ctx: pointer to a context object. Out: seckey: pointer to a 32-byte buffer for the secret key. In: keypair: pointer to a keypair. </p>

</div>
</div>
<a id="a96800411deb08bb3b6b0876fea6f6eb4" name="a96800411deb08bb3b6b0876fea6f6eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96800411deb08bb3b6b0876fea6f6eb4">&#9670;&#160;</a></span>secp256k1_keypair_xonly_pub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_keypair_xonly_pub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>pk_parity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the x-only public key from a keypair.</p>
<p>This is the same as calling secp256k1_keypair_pub and then secp256k1_xonly_pubkey_from_pubkey.</p>
<p>Returns: 1 always. Args: ctx: pointer to a context object. Out: pubkey: pointer to an xonly_pubkey object, set to the keypair public key after converting it to an xonly_pubkey. pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to the pk_parity argument of secp256k1_xonly_pubkey_from_pubkey. In: keypair: pointer to a keypair. </p>

</div>
</div>
<a id="aa99a68bfe473704d08eac556915883b6" name="aa99a68bfe473704d08eac556915883b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99a68bfe473704d08eac556915883b6">&#9670;&#160;</a></span>secp256k1_keypair_xonly_tweak_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_keypair_xonly_tweak_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>tweak32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tweak a keypair by adding tweak32 to the secret key and updating the public key accordingly.</p>
<p>Calling this function and then secp256k1_keypair_pub results in the same public key as calling secp256k1_keypair_xonly_pub and then secp256k1_xonly_pubkey_tweak_add.</p>
<p>Returns: 0 if the arguments are invalid or the resulting keypair would be invalid (only when the tweak is the negation of the keypair's secret key). 1 otherwise.</p>
<p>Args: ctx: pointer to a context object. In/Out: keypair: pointer to a keypair to apply the tweak to. Will be set to an invalid value if this function returns 0. In: tweak32: pointer to a 32-byte tweak, which must be valid according to secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly random 32-byte tweaks, the chance of being invalid is negligible (around 1 in 2^128). </p>

</div>
</div>
<a id="a06f07f2cde819fd612ff4cc13e785aa9" name="a06f07f2cde819fd612ff4cc13e785aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f07f2cde819fd612ff4cc13e785aa9">&#9670;&#160;</a></span>secp256k1_xonly_pubkey_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_xonly_pubkey_cmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pk1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pk2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two x-only public keys using lexicographic order</p>
<p>Returns: &lt;0 if the first public key is less than the second &gt;0 if the first public key is greater than the second 0 if the two public keys are equal Args: ctx: pointer to a context object. In: pubkey1: first public key to compare pubkey2: second public key to compare </p>

</div>
</div>
<a id="a38e6de43d8ee12d83e5cc85c47fcdc98" name="a38e6de43d8ee12d83e5cc85c47fcdc98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e6de43d8ee12d83e5cc85c47fcdc98">&#9670;&#160;</a></span>secp256k1_xonly_pubkey_from_pubkey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_xonly_pubkey_from_pubkey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>xonly_pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>pk_parity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> into a <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a>.</p>
<p>Returns: 1 always.</p>
<p>Args: ctx: pointer to a context object. Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key. pk_parity: Ignored if NULL. Otherwise, pointer to an integer that will be set to 1 if the point encoded by xonly_pubkey is the negation of the pubkey and set to 0 otherwise. In: pubkey: pointer to a public key that is converted. </p>

</div>
</div>
<a id="ad9e5f1dae6a1e3e03d0093aa17e6c21c" name="ad9e5f1dae6a1e3e03d0093aa17e6c21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e5f1dae6a1e3e03d0093aa17e6c21c">&#9670;&#160;</a></span>secp256k1_xonly_pubkey_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_xonly_pubkey_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>input32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a 32-byte sequence into a xonly_pubkey object.</p>
<p>Returns: 1 if the public key was fully valid. 0 if the public key could not be parsed or is invalid.</p>
<p>Args: ctx: pointer to a context object. Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a parsed version of input. If not, it's set to an invalid value. In: input32: pointer to a serialized xonly_pubkey. </p>

</div>
</div>
<a id="a455e86be0f18f4313ba8ea73e34a25a6" name="a455e86be0f18f4313ba8ea73e34a25a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455e86be0f18f4313ba8ea73e34a25a6">&#9670;&#160;</a></span>secp256k1_xonly_pubkey_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_xonly_pubkey_serialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>output32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize an xonly_pubkey object into a 32-byte sequence.</p>
<p>Returns: 1 always.</p>
<p>Args: ctx: pointer to a context object. Out: output32: pointer to a 32-byte array to place the serialized key in. In: pubkey: pointer to a <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> containing an initialized public key. </p>

</div>
</div>
<a id="aaf832fa110c2610d69dee6ca74c856e8" name="aaf832fa110c2610d69dee6ca74c856e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf832fa110c2610d69dee6ca74c856e8">&#9670;&#160;</a></span>secp256k1_xonly_pubkey_tweak_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_xonly_pubkey_tweak_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>output_pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>internal_pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>tweak32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tweak an x-only public key by adding the generator multiplied with tweak32 to it.</p>
<p>Note that the resulting point can not in general be represented by an x-only pubkey because it may have an odd Y coordinate. Instead, the output_pubkey is a normal <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a>.</p>
<p>Returns: 0 if the arguments are invalid or the resulting public key would be invalid (only when the tweak is the negation of the corresponding secret key). 1 otherwise.</p>
<p>Args: ctx: pointer to a context object. Out: output_pubkey: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to. tweak32: pointer to a 32-byte tweak, which must be valid according to secp256k1_ec_seckey_verify or 32 zero bytes. For uniformly random 32-byte tweaks, the chance of being invalid is negligible (around 1 in 2^128). </p>

</div>
</div>
<a id="a466fe5b6ca122c33e51f7a3e70ff3590" name="a466fe5b6ca122c33e51f7a3e70ff3590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fe5b6ca122c33e51f7a3e70ff3590">&#9670;&#160;</a></span>secp256k1_xonly_pubkey_tweak_add_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_xonly_pubkey_tweak_add_check </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>tweaked_pubkey32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tweaked_pk_parity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>internal_pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>tweak32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that a tweaked pubkey is the result of calling secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32.</p>
<p>The tweaked pubkey is represented by its 32-byte x-only serialization and its pk_parity, which can both be obtained by converting the result of tweak_add to a <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a>.</p>
<p>Note that this alone does <em>not</em> verify that the tweaked pubkey is a commitment. If the tweak is not chosen in a specific way, the tweaked pubkey can easily be the result of a different internal_pubkey and tweak.</p>
<p>Returns: 0 if the arguments are invalid or the tweaked pubkey is not the result of tweaking the internal_pubkey with tweak32. 1 otherwise. Args: ctx: pointer to a context object. In: tweaked_pubkey32: pointer to a serialized xonly_pubkey. tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization is passed in as tweaked_pubkey32). This must match the pk_parity value that is returned when calling <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> with the tweaked pubkey, or this function will fail. internal_pubkey: pointer to an x-only public key object to apply the tweak to. tweak32: pointer to a 32-byte tweak. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_44f34d1e62fda08bdb4ca69ab2d205ae.html">secp256k1</a></li><li class="navelem"><a href="dir_1b4df0b9bba47cf333db333897c5a5a4.html">include</a></li><li class="navelem"><a href="secp256k1__extrakeys_8h.html">secp256k1_extrakeys.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
