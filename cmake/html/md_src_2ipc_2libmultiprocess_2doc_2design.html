<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: libmultiprocess Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_src_2ipc_2libmultiprocess_2doc_2design.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">libmultiprocess Design </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md14"></a></p>
<p>Given an interface description of an object with one or more methods, libmultiprocess generates:</p>
<ul>
<li>A C++ <span class="tt">ProxyClient</span> class template specialization with an implementation of each interface method that sends a request over a socket, waits for a response, and returns the result.</li>
<li>A C++ <span class="tt">ProxyServer</span> class template specialization that listens for requests over a socket and calls a wrapped C++ object implementing the same interface to actually execute the requests.</li>
</ul>
<p>The function call â‡† request translation supports input and output arguments, standard types like <span class="tt">unique_ptr</span>, <span class="tt">vector</span>, <span class="tt">map</span>, and <span class="tt">optional</span>, and bidirectional calls between processes through interface pointer and <span class="tt">std::function</span> arguments.</p>
<p>If the wrapped C++ object inherits from an abstract base class declaring virtual methods, the generated <span class="tt">ProxyClient</span> objects can inherit from the same class, allowing interprocess calls to replace local calls without changes to existing code.</p>
<p>There is also optional support for thread mapping, so each thread making interprocess calls can have a dedicated thread processing requests from it, and callbacks from processing threads are executed on corresponding request threads (so recursive mutexes and thread names function as expected in callbacks).</p>
<p>Libmultiprocess acts as a pure wrapper or layer over the underlying protocol. Clients and servers written in other languages, but using a shared capnproto schema can communicate with interprocess counterparties using libmultiprocess without having to use libmultiprocess themselves or having to know about the implementation details of libmultiprocess.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Internals</h2>
<p>The <span class="tt">ProxyClient</span> and <span class="tt">ProxyServer</span> generated classes are not directly exposed to the user, as described in <a class="el" href="md_src_2ipc_2libmultiprocess_2doc_2usage.html">usage.md</a>. Instead, they wrap C++ interfaces and appear to the user as pointers to an interface. They are first instantiated when calling <span class="tt">ConnectStream</span> and <span class="tt">ServeStream</span> respectively for creating the <span class="tt">InitInterface</span>. These methods establish connections through sockets, internally creating <span class="tt">Connection</span> objects wrapping a <span class="tt">capnp::RpcSystem</span> configured for client and server mode respectively.</p>
<p>The <span class="tt">InitInterface</span> interface will typically have methods which return other interfaces, giving the connecting process the ability to call other functions in the serving process. Interfaces can also have methods accepting other interfaces as parameters, giving serving processes the ability to call back and invoke functions in connecting processes. Creating new interfaces does not create new connections, and typically many interface objects will share the same connection.</p>
<p>Both <span class="tt">ConnectStream</span> and <span class="tt">ServeStream</span> also require an instantiation of the <span class="tt">EventLoop</span>. The <span class="tt">EventLoop</span> owns pending requests, notifies on request dispatch, allows clients from multiple threads to make synchronous calls, and handles some cleanup routines on exit. It must be run in a separate thread so it is always active and can process incoming requests from local clients and remote connections.</p>
<p>When a generated method on the <span class="tt">ProxyClient</span> is called, it calls <span class="tt">clientInvoke</span> with the capnp-translated types. <span class="tt">clientInvoke</span> creates a self-executing promise (<span class="tt">kj::TaskSet</span>) that drives the execution of the request and gives ownership of it to the <span class="tt">EventLoop</span>. <span class="tt">clientInvoke</span> blocks until a response is received, or until there is a call from the server that needs to run on the same client thread, using a <span class="tt">Waiter</span> object.</p>
<p>On the server side, the <span class="tt">capnp::RpcSystem</span> receives the capnp request and invokes the corresponding C++ method through the corresponding <span class="tt">ProxyServer</span> and the heavily templated <span class="tt">serverInvoke</span> triggering a <span class="tt">ServerCall</span>. The return values from the actual C++ methods are copied into capnp responses by <span class="tt">ServerRet</span> and exceptions are caught and copied by <span class="tt">ServerExcept</span>. The two are connected through <span class="tt">ServerField</span>. The main method driving execution of a request is <span class="tt">PassField</span>, which is invoked through <span class="tt">ServerField</span>. Instantiated interfaces, or capabilities in capnp speak, are tracked and owned by the server's <span class="tt">capnp::RpcSystem</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Interface descriptions</h1>
<p>As explained in the <a class="el" href="md_src_2ipc_2libmultiprocess_2doc_2usage.html">usage</a> document, interface descriptions need to be consumed both by the <em>libmultiprocess</em> code generator, and by C++ code that calls and implements the interfaces. The C++ code only needs to know about C++ arguments and return types, while the code generator only needs to know about capnp arguments and return types, but both need to know class and method names, so the corresponding <span class="tt">.h</span> and <span class="tt">.capnp</span> source files contain some of the same information, and have to be kept in sync manually when methods or parameters change. Despite the redundancy, reconciling the interface definitions is designed to be <em>straightforward</em> and <em>safe</em>. <em>Straightforward</em> because there is no need to write manual serialization code or use awkward intermediate types like <a href="https://github.com/bitcoin/bitcoin/blob/master/src/univalue/include/univalue.h"><span class="tt">UniValue</span></a> instead of native types. <em>Safe</em> because if there are any inconsistencies between API and data definitions (even minor ones like using a narrow int data type for a wider int API input), there are errors at build time instead of errors or bugs at runtime.</p>
<p>In the future, it would be possible to combine API and data definitions together using <a href="https://en.cppreference.com/w/cpp/language/attributes">C++ attributes</a>. To do this we would add attributes to the API definition files, and then generate the data definitions from the API definitions and attributes. I didn't take this approach mostly because it would be extra work, but also because until C++ standardizes reflection, this would require either hooking into compiler APIs like <a href="https://github.com/RosettaCommons/binder">https://github.com/RosettaCommons/binder</a>, or parsing C++ code manually like <a href="http://www.swig.org/">http://www.swig.org/</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
What is <span class="tt">kj</span>?</h1>
<p>KJ is a concurrency framework <a href="https://capnproto.org/cxxrpc.html#kj-concurrency-framework">bundled with capnproto</a>; it is used as a basis in this library to construct the event-loop necessary to service IPC requests.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Future directions</h1>
<p><em>libmultiprocess</em> uses the <a href="https://capnproto.org">Cap'n Proto</a> interface description language and protocol, but it could be extended or changed to use a different IDL/protocol like <a href="https://grpc.io">gRPC</a>. The nice thing about <em>Cap'n Proto</em> compared to <em>gRPC</em> and most other lower level protocols is that it allows interface pointers (<em>Services</em> in gRPC parlance) to be passed as method arguments and return values, so object references and bidirectional requests work out of the box. Supporting a lower-level protocol would require adding maps and tracking code to proxy objects.</p>
<p><em>libmultiprocess</em> is currently compatible with sandboxing but could add platform-specific sandboxing support or integration with a sandboxing library like <a href="https://github.com/google/sandboxed-api">SAPI</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
