<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: TxRequestTracker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_tx_request_tracker.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">TxRequestTracker Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="txrequest_8h_source.html">txrequest.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:Impl" id="r_Impl"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tx_request_tracker_1_1_impl.html">Impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91b88cd9d3a7b9dc637648b3fb65966f" id="r_a91b88cd9d3a7b9dc637648b3fb65966f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b88cd9d3a7b9dc637648b3fb65966f">TxRequestTracker</a> (bool deterministic=false)</td></tr>
<tr class="memdesc:a91b88cd9d3a7b9dc637648b3fb65966f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_tx_request_tracker.html">TxRequestTracker</a>.  <br /></td></tr>
<tr class="memitem:a9cf8129fe55c14f6ac59cac978024c30" id="r_a9cf8129fe55c14f6ac59cac978024c30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cf8129fe55c14f6ac59cac978024c30">~TxRequestTracker</a> ()</td></tr>
<tr class="memitem:acad3e24a428b090855d7ef518e46710b" id="r_acad3e24a428b090855d7ef518e46710b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad3e24a428b090855d7ef518e46710b">ReceivedInv</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer, const <a class="el" href="class_gen_txid.html">GenTxid</a> &amp;gtxid, bool preferred, std::chrono::microseconds reqtime)</td></tr>
<tr class="memitem:a3d7c67db0b3dd733c3f7846504b71442" id="r_a3d7c67db0b3dd733c3f7846504b71442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7c67db0b3dd733c3f7846504b71442">DisconnectedPeer</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer)</td></tr>
<tr class="memitem:ae97e1b0869138b01a54d280f6af14770" id="r_ae97e1b0869138b01a54d280f6af14770"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae97e1b0869138b01a54d280f6af14770">ForgetTxHash</a> (const <a class="el" href="classuint256.html">uint256</a> &amp;txhash)</td></tr>
<tr class="memitem:a105957ea1e25a6cdb45a55ada1b1489d" id="r_a105957ea1e25a6cdb45a55ada1b1489d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_gen_txid.html">GenTxid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a105957ea1e25a6cdb45a55ada1b1489d">GetRequestable</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer, std::chrono::microseconds now, std::vector&lt; std::pair&lt; <a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a>, <a class="el" href="class_gen_txid.html">GenTxid</a> &gt; &gt; *expired=nullptr)</td></tr>
<tr class="memitem:a9088a92c7af121ce4dcb070b561d3d45" id="r_a9088a92c7af121ce4dcb070b561d3d45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9088a92c7af121ce4dcb070b561d3d45">RequestedTx</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer, const <a class="el" href="classuint256.html">uint256</a> &amp;txhash, std::chrono::microseconds expiry)</td></tr>
<tr class="memitem:a6e0a1fc953d537d7b61258bf7b47e8cc" id="r_a6e0a1fc953d537d7b61258bf7b47e8cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e0a1fc953d537d7b61258bf7b47e8cc">ReceivedResponse</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer, const <a class="el" href="classuint256.html">uint256</a> &amp;txhash)</td></tr>
<tr class="memitem:a0dd6f7567b0cf28f74942c089114da35" id="r_a0dd6f7567b0cf28f74942c089114da35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd6f7567b0cf28f74942c089114da35">CountInFlight</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer) const</td></tr>
<tr class="memitem:ae6a777cf1e78d119a75680b7c69c361e" id="r_ae6a777cf1e78d119a75680b7c69c361e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6a777cf1e78d119a75680b7c69c361e">CountCandidates</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer) const</td></tr>
<tr class="memitem:a08b340d3405b943de736d5528defa5e9" id="r_a08b340d3405b943de736d5528defa5e9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08b340d3405b943de736d5528defa5e9">Count</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer) const</td></tr>
<tr class="memitem:a58f4b9e873b7c1c7d512bd9f7d1489d8" id="r_a58f4b9e873b7c1c7d512bd9f7d1489d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58f4b9e873b7c1c7d512bd9f7d1489d8">Size</a> () const</td></tr>
<tr class="memitem:a06102a056fb3da301fb2421e70137681" id="r_a06102a056fb3da301fb2421e70137681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06102a056fb3da301fb2421e70137681">GetCandidatePeers</a> (const <a class="el" href="classuint256.html">uint256</a> &amp;txhash, std::vector&lt; <a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> &gt; &amp;result_peers) const</td></tr>
<tr class="memitem:a80c51bb9a5cfdb46157aab67616c6440" id="r_a80c51bb9a5cfdb46157aab67616c6440"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c51bb9a5cfdb46157aab67616c6440">ComputePriority</a> (const <a class="el" href="classuint256.html">uint256</a> &amp;txhash, <a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> peer, bool preferred) const</td></tr>
<tr class="memitem:a234d9f2765fec4cf82214f30a06813aa" id="r_a234d9f2765fec4cf82214f30a06813aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a234d9f2765fec4cf82214f30a06813aa">SanityCheck</a> () const</td></tr>
<tr class="memitem:ad8c8fd5aaaffa11a150c6b4684fe2b73" id="r_ad8c8fd5aaaffa11a150c6b4684fe2b73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8c8fd5aaaffa11a150c6b4684fe2b73">PostGetRequestableSanityCheck</a> (std::chrono::microseconds now) const</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structure to keep track of, and schedule, transaction downloads from peers.</p>
<p>=== Specification ===</p>
<p>We keep track of which peers have announced which transactions, and use that to determine which requests should go to which peer, when, and in what order.</p>
<p>The following information is tracked per peer/tx combination ("announcement"):</p><ul>
<li>Which peer announced it (through their <a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a>)</li>
<li>The txid or wtxid of the transaction (collectively called "txhash" in what follows)</li>
<li>Whether it was a tx or wtx announcement (see BIP339).</li>
<li>What the earliest permitted time is that that transaction can be requested from that peer (called "reqtime").</li>
<li>Whether it's from a "preferred" peer or not. Which announcements get this flag is determined by the caller, but this is designed for outbound peers, or other peers that we have a higher level of trust in. Even when the peers' preferredness changes, the preferred flag of existing announcements from that peer won't change.</li>
<li>Whether or not the transaction was requested already, and if so, when it times out (called "expiry").</li>
<li>Whether or not the transaction request failed already (timed out, or invalid transaction or NOTFOUND was received).</li>
</ul>
<p>Transaction requests are then assigned to peers, following these rules:</p>
<ul>
<li><p class="startli">No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).</p>
<p class="startli">Rationale: to avoid wasting bandwidth on multiple copies of the same transaction. Note that this only works per txhash, so if the same transaction is announced both through txid and wtxid, we have no means to prevent fetching both (the caller can however mitigate this by delaying one, see further).</p>
</li>
<li><p class="startli">The same transaction is never requested twice from the same peer, unless the announcement was forgotten in between, and re-announced. Announcements are forgotten only:</p><ul>
<li>If a peer goes offline, all its announcements are forgotten.</li>
<li>If a transaction has been successfully received, or is otherwise no longer needed, the caller can call ForgetTxHash, which removes all announcements across all peers with the specified txhash.</li>
<li>If for a given txhash only already-failed announcements remain, they are all forgotten.</li>
</ul>
<p class="startli">Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their favor, worsening transaction censoring attacks. The flip side is that as long as an attacker manages to prevent us from receiving a transaction, failed announcements (including those from honest peers) will linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on the number of tracked announcements per peer. As failed requests in response to announcements from honest peers should be rare, this almost solely hinders attackers. Transaction censoring attacks can be done by announcing transactions quickly while not answering requests for them. See <a href="https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf">https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf</a> for more information.</p>
</li>
<li><p class="startli">Transactions are not requested from a peer until its reqtime has passed.</p>
<p class="startli">Rationale: enable the calling code to define a delay for less-than-ideal peers, so that (presumed) better peers have a chance to give their announcement first.</p>
</li>
<li>If multiple viable candidate peers exist according to the above rules, pick a peer as follows:<ul>
<li><p class="startli">If any preferred peers are available, non-preferred peers are not considered for what follows.</p>
<p class="startli">Rationale: preferred peers are more trusted by us, so are less likely to be under attacker control.</p>
</li>
<li><p class="startli">Pick a uniformly random peer among the candidates.</p>
<p class="startli">Rationale: random assignments are hard to influence for attackers.</p>
</li>
</ul>
</li>
</ul>
<p>Together these rules strike a balance between being fast in non-adverserial conditions and minimizing susceptibility to censorship attacks. An attacker that races the network:</p><ul>
<li>Will be unsuccessful if all preferred connections are honest (and there is at least one preferred connection).</li>
<li>If there are P preferred connections of which Ph&gt;=1 are honest, the attacker can delay us from learning about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution). The "1 +" is due to the fact that the attacker can be the first to announce through a preferred connection in this scenario, which very likely means they get the first request.</li>
<li>If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh&gt;=1 are honest, where we assume that the attacker can disconnect and reconnect those connections, the distribution becomes k ~ P + NB(p=1-NPh/NP,r=1) (where NB stands for Negative Binomial distribution), which has mean P-1+NP/NPh.</li>
</ul>
<p>Complexity:</p><ul>
<li>Memory usage is proportional to the total number of tracked announcements (<a class="el" href="#a58f4b9e873b7c1c7d512bd9f7d1489d8">Size()</a>) plus the number of peers with a nonzero number of tracked announcements.</li>
<li>CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of announcements affected by an operation (amortized O(1) per announcement).</li>
</ul>
<p>Context:</p><ul>
<li>In an earlier version of the transaction request logic it was possible for a peer to prevent us from seeing a specific transaction. See <a href="https://bitcoincore.org/en/2024/07/03/disclose_already_asked_for">https://bitcoincore.org/en/2024/07/03/disclose_already_asked_for</a>. </li>
</ul>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91b88cd9d3a7b9dc637648b3fb65966f" name="a91b88cd9d3a7b9dc637648b3fb65966f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b88cd9d3a7b9dc637648b3fb65966f">&#9670;&#160;</a></span>TxRequestTracker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_tx_request_tracker.html">TxRequestTracker</a> </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deterministic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_tx_request_tracker.html">TxRequestTracker</a>. </p>

</div>
</div>
<a id="a9cf8129fe55c14f6ac59cac978024c30" name="a9cf8129fe55c14f6ac59cac978024c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf8129fe55c14f6ac59cac978024c30">&#9670;&#160;</a></span>~TxRequestTracker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_tx_request_tracker.html">TxRequestTracker</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a80c51bb9a5cfdb46157aab67616c6440" name="a80c51bb9a5cfdb46157aab67616c6440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c51bb9a5cfdb46157aab67616c6440">&#9670;&#160;</a></span>ComputePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ComputePriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuint256.html">uint256</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>txhash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preferred</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to the internal priority computation (testing only) </p>

</div>
</div>
<a id="a08b340d3405b943de736d5528defa5e9" name="a08b340d3405b943de736d5528defa5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b340d3405b943de736d5528defa5e9">&#9670;&#160;</a></span>Count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many announcements a peer has (REQUESTED, CANDIDATE, and COMPLETED combined). </p>

</div>
</div>
<a id="ae6a777cf1e78d119a75680b7c69c361e" name="ae6a777cf1e78d119a75680b7c69c361e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a777cf1e78d119a75680b7c69c361e">&#9670;&#160;</a></span>CountCandidates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CountCandidates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many CANDIDATE announcements a peer has. </p>

</div>
</div>
<a id="a0dd6f7567b0cf28f74942c089114da35" name="a0dd6f7567b0cf28f74942c089114da35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd6f7567b0cf28f74942c089114da35">&#9670;&#160;</a></span>CountInFlight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t CountInFlight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many REQUESTED announcements a peer has. </p>

</div>
</div>
<a id="a3d7c67db0b3dd733c3f7846504b71442" name="a3d7c67db0b3dd733c3f7846504b71442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7c67db0b3dd733c3f7846504b71442">&#9670;&#160;</a></span>DisconnectedPeer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DisconnectedPeer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all announcements for a given peer.</p>
<p>It should be called when a peer goes offline. </p>

</div>
</div>
<a id="ae97e1b0869138b01a54d280f6af14770" name="ae97e1b0869138b01a54d280f6af14770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97e1b0869138b01a54d280f6af14770">&#9670;&#160;</a></span>ForgetTxHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ForgetTxHash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuint256.html">uint256</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>txhash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all announcements for a given txhash (both txid and wtxid ones).</p>
<p>This should be called when a transaction is no longer needed. The caller should ensure that new announcements for the same txhash will not trigger new ReceivedInv calls, at least in the short term after this call. </p>

</div>
</div>
<a id="a06102a056fb3da301fb2421e70137681" name="a06102a056fb3da301fb2421e70137681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06102a056fb3da301fb2421e70137681">&#9670;&#160;</a></span>GetCandidatePeers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GetCandidatePeers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuint256.html">uint256</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>txhash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result_peers</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For some txhash (txid or wtxid), finds all peers with non-COMPLETED announcements and appends them to result_peers. Does not try to ensure that result_peers contains no duplicates. </p>

</div>
</div>
<a id="a105957ea1e25a6cdb45a55ada1b1489d" name="a105957ea1e25a6cdb45a55ada1b1489d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105957ea1e25a6cdb45a55ada1b1489d">&#9670;&#160;</a></span>GetRequestable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_gen_txid.html">GenTxid</a> &gt; GetRequestable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds</td>          <td class="paramname"><span class="paramname"><em>now</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a>, <a class="el" href="class_gen_txid.html">GenTxid</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>expired</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the txids to request now from peer.</p>
<p>It does the following:</p><ul>
<li>Convert all REQUESTED announcements (for all txhashes/peers) with (expiry &lt;= now) to COMPLETED ones. These are returned in expired, if non-nullptr.</li>
<li>Requestable announcements are selected: CANDIDATE announcements from the specified peer with (reqtime &lt;= now) for which no existing REQUESTED announcement with the same txhash from a different peer exists, and for which the specified peer is the best choice among all (reqtime &lt;= now) CANDIDATE announcements with the same txhash (subject to preferredness rules, and tiebreaking using a deterministic salted hash of peer and txhash).</li>
<li>The selected announcements are returned in announcement order (even if multiple were added at the same time, or when the clock went backwards while they were being added). This is done to minimize disruption from dependent transactions being requested out of order: if multiple dependent transactions are announced simultaneously by one peer, and end up being requested from them, the requests will happen in announcement order. </li>
</ul>

</div>
</div>
<a id="ad8c8fd5aaaffa11a150c6b4684fe2b73" name="ad8c8fd5aaaffa11a150c6b4684fe2b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c8fd5aaaffa11a150c6b4684fe2b73">&#9670;&#160;</a></span>PostGetRequestableSanityCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostGetRequestableSanityCheck </td>
          <td>(</td>
          <td class="paramtype">std::chrono::microseconds</td>          <td class="paramname"><span class="paramname"><em>now</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a time-dependent internal consistency check (testing only).</p>
<p>This can only be called immediately after GetRequestable, with the same 'now' parameter. </p>

</div>
</div>
<a id="acad3e24a428b090855d7ef518e46710b" name="acad3e24a428b090855d7ef518e46710b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad3e24a428b090855d7ef518e46710b">&#9670;&#160;</a></span>ReceivedInv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReceivedInv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gen_txid.html">GenTxid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gtxid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>preferred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds</td>          <td class="paramname"><span class="paramname"><em>reqtime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new CANDIDATE announcement.</p>
<p>Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or COMPLETED). Note that the txid/wtxid property is ignored for determining uniqueness, so if an announcement is added for a wtxid H, while one for txid H from the same peer already exists, it will be ignored. This is harmless as the txhashes being equal implies it is a non-segwit transaction, so it doesn't matter how it is fetched. The new announcement is given the specified preferred and reqtime values, and takes its is_wtxid from the specified gtxid. </p>

</div>
</div>
<a id="a6e0a1fc953d537d7b61258bf7b47e8cc" name="a6e0a1fc953d537d7b61258bf7b47e8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0a1fc953d537d7b61258bf7b47e8cc">&#9670;&#160;</a></span>ReceivedResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ReceivedResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuint256.html">uint256</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>txhash</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a CANDIDATE or REQUESTED announcement to a COMPLETED one. If no such announcement exists for the provided peer and txhash, nothing happens.</p>
<p>It should be called whenever a transaction or NOTFOUND was received from a peer. When the transaction is not needed entirely anymore, ForgetTxhash should be called instead of, or in addition to, this call. </p>

</div>
</div>
<a id="a9088a92c7af121ce4dcb070b561d3d45" name="a9088a92c7af121ce4dcb070b561d3d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9088a92c7af121ce4dcb070b561d3d45">&#9670;&#160;</a></span>RequestedTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RequestedTx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>peer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuint256.html">uint256</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>txhash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds</td>          <td class="paramname"><span class="paramname"><em>expiry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a transaction as requested, with a specified expiry.</p>
<p>If no CANDIDATE announcement for the provided peer and txhash exists, this call has no effect. Otherwise:</p><ul>
<li>That announcement is converted to REQUESTED.</li>
<li>If any other REQUESTED announcement for the same txhash already existed, it means an unexpected request was made (GetRequestable will never advise doing so). In this case it is converted to COMPLETED, as we're no longer waiting for a response to it. </li>
</ul>

</div>
</div>
<a id="a234d9f2765fec4cf82214f30a06813aa" name="a234d9f2765fec4cf82214f30a06813aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234d9f2765fec4cf82214f30a06813aa">&#9670;&#160;</a></span>SanityCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SanityCheck </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run internal consistency check (testing only). </p>

</div>
</div>
<a id="a58f4b9e873b7c1c7d512bd9f7d1489d8" name="a58f4b9e873b7c1c7d512bd9f7d1489d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f4b9e873b7c1c7d512bd9f7d1489d8">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many announcements are being tracked in total across all peers and transaction hashes. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="txrequest_8h_source.html">txrequest.h</a></li>
<li>src/<a class="el" href="txrequest_8cpp.html">txrequest.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_tx_request_tracker.html">TxRequestTracker</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
