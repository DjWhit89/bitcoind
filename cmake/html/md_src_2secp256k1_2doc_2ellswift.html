<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: ElligatorSwift for secp256k1 explained</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_src_2secp256k1_2doc_2ellswift.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ElligatorSwift for secp256k1 explained </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md182"></a></p>
<p>In this document we explain how the <span class="tt">ellswift</span> module implementation is related to the construction in the <a href="https://eprint.iacr.org/2022/759">"SwiftEC: Shallue–van de Woestijne Indifferentiable Function To Elliptic Curves"</a> paper by Jorge Chávez-Saab, Francisco Rodríguez-Henríquez, and Mehdi Tibouchi.</p>
<ul>
<li>1. Introduction</li>
<li>2. The decoding function<ul>
<li>2.1 Decoding for `secp256k1`</li>
</ul>
</li>
<li>3. The encoding function<ul>
<li>3.1 Switching to *v, w* coordinates</li>
<li>3.2 Avoiding computing all inverses</li>
<li>3.3 Finding the inverse</li>
<li>3.4 Dealing with special cases</li>
<li>3.5 Encoding for `secp256k1`</li>
</ul>
</li>
<li>4. Encoding and decoding full *(x, y)* coordinates<ul>
<li>4.1 Full *(x, y)* coordinates for `secp256k1`</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md183"></a>
1. Introduction</h1>
<p>The <span class="tt">ellswift</span> module effectively introduces a new 64-byte public key format, with the property that (uniformly random) public keys can be encoded as 64-byte arrays which are computationally indistinguishable from uniform byte arrays. The module provides functions to convert public keys from and to this format, as well as convenience functions for key generation and ECDH that operate directly on ellswift-encoded keys.</p>
<p>The encoding consists of the concatenation of two (32-byte big endian) encoded field elements $u$ and $t.$ Together they encode an x-coordinate on the curve $x$, or (see further) a full point $(x, y)$ on the curve.</p>
<p><b>Decoding</b> consists of decoding the field elements $u$ and $t$ (values above the field size $p$ are taken modulo $p$), and then evaluating $F_u(t)$, which for every $u$ and $t$ results in a valid x-coordinate on the curve. The functions $F_u$ will be defined in Section 2.</p>
<p><b>Encoding</b> a given $x$ coordinate is conceptually done as follows:</p><ul>
<li>Loop:<ul>
<li>Pick a uniformly random field element $u.$</li>
<li>Compute the set $L = F_u^{-1}(x)$ of $t$ values for which $F_u(t) = x$, which may have up to <em>8</em> elements.</li>
<li>With probability $1 - \dfrac{\#L}{8}$, restart the loop.</li>
<li>Select a uniformly random $t \in L$ and return $(u, t).$</li>
</ul>
</li>
</ul>
<p>This is the <em>ElligatorSwift</em> algorithm, here given for just x-coordinates. An extension to full $(x, y)$ points will be given in Section 4. The algorithm finds a uniformly random $(u, t)$ among (almost all) those for which $F_u(t) = x.$ <a class="el" href="struct_section.html">Section</a> 3.2 in the paper proves that the number of such encodings for almost all x-coordinates on the curve (all but at most 39) is close to two times the field size (specifically, it lies in the range $2q \pm (22\sqrt{q} + O(1))$, where $q$ is the size of the field).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md184"></a>
2. The decoding function</h1>
<p>First some definitions:</p><ul>
<li>$\mathbb{F}$ is the finite field of size $q$, of characteristic 5 or more, and $q \equiv 1 \mod 3.$<ul>
<li>For <span class="tt">secp256k1</span>, $q = 2^{256} - 2^{32} - 977$, which satisfies that requirement.</li>
</ul>
</li>
<li>Let $E$ be the elliptic curve of points $(x, y) \in \mathbb{F}^2$ for which $y^2 = x^3 + ax + b$, with $a$ and $b$ public constants, for which $\Delta_E = -16(4a^3 + 27b^2)$ is a square, and at least one of $(-b \pm \sqrt{-3 \Delta_E} / 36)/2$ is a square. This implies that the order of $E$ is either odd, or a multiple of <em>4</em>. If $a=0$, this condition is always fulfilled.<ul>
<li>For <span class="tt">secp256k1</span>, $a=0$ and $b=7.$</li>
</ul>
</li>
<li>Let the function $g(x) = x^3 + ax + b$, so the $E$ curve equation is also $y^2 = g(x).$</li>
<li>Let the function $h(x) = 3x^3 + 4a.$</li>
<li>Define $V$ as the set of solutions $(x_1, x_2, x_3, z)$ to $z^2 = g(x_1)g(x_2)g(x_3).$</li>
<li>Define $S_u$ as the set of solutions $(X, Y)$ to $X^2 + h(u)Y^2 = -g(u)$ and $Y \neq 0.$</li>
<li>$P_u$ is a function from $\mathbb{F}$ to $S_u$ that will be defined below.</li>
<li>$\psi_u$ is a function from $S_u$ to $V$ that will be defined below.</li>
</ul>
<p><b>Note</b>: In the paper:</p><ul>
<li>$F_u$ corresponds to $F_{0,u}$ there.</li>
<li>$P_u(t)$ is called $P$ there.</li>
<li>All $S_u$ sets together correspond to $S$ there.</li>
<li>All $\psi_u$ functions together (operating on elements of $S$) correspond to $\psi$ there.</li>
</ul>
<p>Note that for $V$, the left hand side of the equation $z^2$ is square, and thus the right hand must also be square. As multiplying non-squares results in a square in $\mathbb{F}$, out of the three right-hand side factors an even number must be non-squares. This implies that exactly <em>1</em> or exactly <em>3</em> out of $\{g(x_1), g(x_2), g(x_3)\}$ must be square, and thus that for any $(x_1,x_2,x_3,z) \in V$, at least one of $\{x_1, x_2, x_3\}$ must be a valid x-coordinate on $E.$ There is one exception to this, namely when $z=0$, but even then one of the three values is a valid x-coordinate.</p>
<p><b>Define</b> the decoding function $F_u(t)$ as:</p><ul>
<li>Let $(x_1, x_2, x_3, z) = \psi_u(P_u(t)).$</li>
<li>Return the first element $x$ of $(x_3, x_2, x_1)$ which is a valid x-coordinate on $E$ (i.e., $g(x)$ is square).</li>
</ul>
<p>$P_u(t) = (<a class="el" href="net_8cpp.html#a826edd40636cbaa44266b97c8c6a4fa3">X(u, t)</a>, Y(u, t))$, where:</p>
<p>$$ \begin{array}{lcl} <a class="el" href="net_8cpp.html#a826edd40636cbaa44266b97c8c6a4fa3">X(u, t)</a> &amp; = &amp; \left\{\begin{array}{ll} \dfrac{g(u) - t^2}{2t} &amp; a = 0 \ \dfrac{g(u) + h(u)(Y_0(u) - X_0(u)t)^2}{X_0(u)(1 + h(u)t^2)} &amp; a \neq 0 \end{array}\right. \ Y(u, t) &amp; = &amp; \left\{\begin{array}{ll} \dfrac{<a class="el" href="net_8cpp.html#a826edd40636cbaa44266b97c8c6a4fa3">X(u, t)</a> + t}{u \sqrt{-3}} = \dfrac{g(u) + t^2}{2tu\sqrt{-3}} &amp; a = 0 \ Y_0(u) + t(<a class="el" href="net_8cpp.html#a826edd40636cbaa44266b97c8c6a4fa3">X(u, t)</a> - X_0(u)) &amp; a \neq 0 \end{array}\right. \end{array} $$</p>
<p>$P_u(t)$ is defined:</p><ul>
<li>For $a=0$, unless:<ul>
<li>$u = 0$ or $t = 0$ (division by zero)</li>
<li>$g(u) = -t^2$ (would give $Y=0$).</li>
</ul>
</li>
<li>For $a \neq 0$, unless:<ul>
<li>$X_0(u) = 0$ or $h(u)t^2 = -1$ (division by zero)</li>
<li>$Y_0(u) (1 - h(u)t^2) = 2X_0(u)t$ (would give $Y=0$).</li>
</ul>
</li>
</ul>
<p>The functions $X_0(u)$ and $Y_0(u)$ are defined in Appendix A of the paper, and depend on various properties of $E.$</p>
<p>The function $\psi_u$ is the same for all curves: $\psi_u(X, Y) = (x_1, x_2, x_3, z)$, where:</p>
<p>$$ \begin{array}{lcl} x_1 &amp; = &amp; \dfrac{X}{2Y} - \dfrac{u}{2} &amp;&amp; \ x_2 &amp; = &amp; -\dfrac{X}{2Y} - \dfrac{u}{2} &amp;&amp; \ x_3 &amp; = &amp; u + 4Y^2 &amp;&amp; \ z &amp; = &amp; \dfrac{g(x_3)}{2Y}(u^2 + ux_1 + x_1^2 + a) = \dfrac{-g(u)g(x_3)}{8Y^3} \end{array} $$</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md185"></a>
2.1 Decoding for <span class="tt">secp256k1</span></h2>
<p>Put together and specialized for $a=0$ curves, decoding $(u, t)$ to an x-coordinate is:</p>
<p><b>Define</b> $F_u(t)$ as:</p><ul>
<li>Let $X = \dfrac{u^3 + b - t^2}{2t}.$</li>
<li>Let $Y = \dfrac{X + t}{u\sqrt{-3}}.$</li>
<li>Return the first $x$ in $(u + 4Y^2, \dfrac{-X}{2Y} - \dfrac{u}{2}, \dfrac{X}{2Y} - \dfrac{u}{2})$ for which $g(x)$ is square.</li>
</ul>
<p>To make sure that every input decodes to a valid x-coordinate, we remap the inputs in case $P_u$ is not defined (when $u=0$, $t=0$, or $g(u) = -t^2$):</p>
<p><b>Define</b> $F_u(t)$ as:</p><ul>
<li>Let $u'=u$ if $u \neq 0$; $1$ otherwise (guaranteeing $u' \neq 0$).</li>
<li>Let $t'=t$ if $t \neq 0$; $1$ otherwise (guaranteeing $t' \neq 0$).</li>
<li>Let $t''=t'$ if $g(u') \neq -t'^2$; $2t'$ otherwise (guaranteeing $t'' \neq 0$ and $g(u') \neq -t''^2$).</li>
<li>Let $X = \dfrac{u'^3 + b - t''^2}{2t''}.$</li>
<li>Let $Y = \dfrac{X + t''}{u'\sqrt{-3}}.$</li>
<li>Return the first $x$ in $(u' + 4Y^2, \dfrac{-X}{2Y} - \dfrac{u'}{2}, \dfrac{X}{2Y} - \dfrac{u'}{2})$ for which $x^3 + b$ is square.</li>
</ul>
<p>The choices here are not strictly necessary. Just returning a fixed constant in any of the undefined cases would suffice, but the approach here is simple enough and gives fairly uniform output even in these cases.</p>
<p><b>Note</b>: in the paper these conditions result in $\infty$ as output, due to the use of projective coordinates there. We wish to avoid the need for callers to deal with this special case.</p>
<p>This is implemented in <span class="tt">secp256k1_ellswift_xswiftec_frac_var</span> (which decodes to an x-coordinate represented as a fraction), and in <span class="tt">secp256k1_ellswift_xswiftec_var</span> (which outputs the actual x-coordinate).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md186"></a>
3. The encoding function</h1>
<p>To implement $F_u^{-1}(x)$, the function to find the set of inverses $t$ for which $F_u(t) = x$, we have to reverse the process:</p><ul>
<li>Find all the $(X, Y) \in S_u$ that could have given rise to $x$, through the $x_1$, $x_2$, or $x_3$ formulas in $\psi_u.$</li>
<li>Map those $(X, Y)$ solutions to $t$ values using $P_u^{-1}(X, Y).$</li>
<li>For each of the found $t$ values, verify that $F_u(t) = x.$</li>
<li>Return the remaining $t$ values.</li>
</ul>
<p>The function $P_u^{-1}$, which finds $t$ given $(X, Y) \in S_u$, is significantly simpler than $P_u:$</p>
<p>$$ P_u^{-1}(X, Y) = \left\{\begin{array}{ll} Yu\sqrt{-3} - X &amp; a = 0 \ \dfrac{Y-Y_0(u)}{X-X_0(u)} &amp; a \neq 0 \land X \neq X_0(u) \ \dfrac{-X_0(u)}{h(u)Y_0(u)} &amp; a \neq 0 \land X = X_0(u) \land Y = Y_0(u) \end{array}\right. $$</p>
<p>The third step above, verifying that $F_u(t) = x$, is necessary because for the $(X, Y)$ values found through the $x_1$ and $x_2$ expressions, it is possible that decoding through $\psi_u(X, Y)$ yields a valid $x_3$ on the curve, which would take precedence over the $x_1$ or $x_2$ decoding. These $(X, Y)$ solutions must be rejected.</p>
<p>Since we know that exactly one or exactly three out of $\{x_1, x_2, x_3\}$ are valid x-coordinates for any $t$, the case where either $x_1$ or $x_2$ is valid and in addition also $x_3$ is valid must mean that all three are valid. This means that instead of checking whether $x_3$ is on the curve, it is also possible to check whether the other one out of $x_1$ and $x_2$ is on the curve. This is significantly simpler, as it turns out.</p>
<p>Observe that $\psi_u$ guarantees that $x_1 + x_2 = -u.$ So given either $x = x_1$ or $x = x_2$, the other one of the two can be computed as $-u - x.$ Thus, when encoding $x$ through the $x_1$ or $x_2$ expressions, one can simply check whether $g(-u-x)$ is a square, and if so, not include the corresponding $t$ values in the returned set. As this does not need $X$, $Y$, or $t$, this condition can be determined before those values are computed.</p>
<p>It is not possible that an encoding found through the $x_1$ expression decodes to a different valid x-coordinate using $x_2$ (which would take precedence), for the same reason: if both $x_1$ and $x_2$ decodings were valid, $x_3$ would be valid as well, and thus take precedence over both. Because of this, the $g(-u-x)$ being square test for $x_1$ and $x_2$ is the only test necessary to guarantee the found $t$ values round-trip back to the input $x$ correctly. This is the reason for choosing the $(x_3, x_2, x_1)$ precedence order in the decoder; any order which does not place $x_3$ first requires more complicated round-trip checks in the encoder.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md187"></a>
3.1 Switching to <em>v, w</em> coordinates</h2>
<p>Before working out the formulas for all this, we switch to different variables for $S_u.$ Let $v = (X/Y - u)/2$, and $w = 2Y.$ Or in the other direction, $X = w(u/2 + v)$ and $Y = w/2:$</p><ul>
<li>$S_u'$ becomes the set of $(v, w)$ for which $w^2 (u^2 + uv + v^2 + a) = -g(u)$ and $w \neq 0.$</li>
<li>For $a=0$ curves, $P_u^{-1}$ can be stated for $(v,w)$ as $P_u^{'-1}(v, w) = w\left(\frac{\sqrt{-3}-1}{2}u - v\right).$</li>
<li>$\psi_u$ can be stated for $(v, w)$ as $\psi_u'(v, w) = (x_1, x_2, x_3, z)$, where</li>
</ul>
<p>$$ \begin{array}{lcl} x_1 &amp; = &amp; v \ x_2 &amp; = &amp; -u - v \ x_3 &amp; = &amp; u + w^2 \ z &amp; = &amp; \dfrac{g(x_3)}{w}(u^2 + uv + v^2 + a) = \dfrac{-g(u)g(x_3)}{w^3} \end{array} $$</p>
<p>We can now write the expressions for finding $(v, w)$ given $x$ explicitly, by solving each of the $\{x_1, x_2, x_3\}$ expressions for $v$ or $w$, and using the $S_u'$ equation to find the other variable:</p><ul>
<li>Assuming $x = x_1$, we find $v = x$ and $w = \pm\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).</li>
<li>Assuming $x = x_2$, we find $v = -u-x$ and $w = \pm\sqrt{-g(u)/(u^2 + uv + v^2 + a)}$ (two solutions).</li>
<li>Assuming $x = x_3$, we find $w = \pm\sqrt{x-u}$ and $v = -u/2 \pm \sqrt{-w^2(4g(u) + w^2h(u))}/(2w^2)$ (four solutions).</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md188"></a>
3.2 Avoiding computing all inverses</h2>
<p>The <em>ElligatorSwift</em> algorithm as stated in <a class="el" href="struct_section.html">Section</a> 1 requires the computation of $L = F_u^{-1}(x)$ (the set of all $t$ such that $(u, t)$ decode to $x$) in full. This is unnecessary.</p>
<p>Observe that the procedure of restarting with probability $(1 - \frac{\#L}{8})$ and otherwise returning a uniformly random element from $L$ is actually equivalent to always padding $L$ with $\bot$ values up to length 8, picking a uniformly random element from that, restarting whenever $\bot$ is picked:</p>
<p><b>Define</b> <em>ElligatorSwift(x)</em> as:</p><ul>
<li>Loop:<ul>
<li>Pick a uniformly random field element $u.$</li>
<li>Compute the set $L = F_u^{-1}(x).$</li>
<li>Let $T$ be the 8-element vector consisting of the elements of $L$, plus $8 - \#L$ times $\{\bot\ </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
