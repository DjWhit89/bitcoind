<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: src/secp256k1/include/secp256k1_musig.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('secp256k1__musig_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">secp256k1_musig.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="secp256k1__extrakeys_8h_source.html">secp256k1_extrakeys.h</a>&quot;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div>
<p><a href="secp256k1__musig_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:secp256k1_5Fmusig_5Fkeyagg_5Fcache" id="r_secp256k1_5Fmusig_5Fkeyagg_5Fcache"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a></td></tr>
<tr class="memitem:secp256k1_5Fmusig_5Fsecnonce" id="r_secp256k1_5Fmusig_5Fsecnonce"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a></td></tr>
<tr class="memitem:secp256k1_5Fmusig_5Fpubnonce" id="r_secp256k1_5Fmusig_5Fpubnonce"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a></td></tr>
<tr class="memitem:secp256k1_5Fmusig_5Faggnonce" id="r_secp256k1_5Fmusig_5Faggnonce"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a></td></tr>
<tr class="memitem:secp256k1_5Fmusig_5Fsession" id="r_secp256k1_5Fmusig_5Fsession"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a></td></tr>
<tr class="memitem:secp256k1_5Fmusig_5Fpartial_5Fsig" id="r_secp256k1_5Fmusig_5Fpartial_5Fsig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac649ade872dc56aa2320b74f169f0949" id="r_ac649ade872dc56aa2320b74f169f0949"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_musig_keyagg_cache&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac649ade872dc56aa2320b74f169f0949">secp256k1_musig_keyagg_cache</a></td></tr>
<tr class="memitem:a8d4f988bfccef4b4b0007396f472e018" id="r_a8d4f988bfccef4b4b0007396f472e018"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_musig_secnonce&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4f988bfccef4b4b0007396f472e018">secp256k1_musig_secnonce</a></td></tr>
<tr class="memitem:a840ebbf17cb525df609a556a9b535a5c" id="r_a840ebbf17cb525df609a556a9b535a5c"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_musig_pubnonce&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840ebbf17cb525df609a556a9b535a5c">secp256k1_musig_pubnonce</a></td></tr>
<tr class="memitem:a2770ea8cc9fe29b4ad76f5ef7a046d1e" id="r_a2770ea8cc9fe29b4ad76f5ef7a046d1e"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_musig_aggnonce&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2770ea8cc9fe29b4ad76f5ef7a046d1e">secp256k1_musig_aggnonce</a></td></tr>
<tr class="memitem:a195f9c320f8c373400c5b5c789a35941" id="r_a195f9c320f8c373400c5b5c789a35941"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_musig_session&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a195f9c320f8c373400c5b5c789a35941">secp256k1_musig_session</a></td></tr>
<tr class="memitem:a7958289e96ef90b230e3f31fc8405ea8" id="r_a7958289e96ef90b230e3f31fc8405ea8"><td class="memItemLeft" align="right" valign="top">typedef struct secp256k1_musig_partial_sig&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7958289e96ef90b230e3f31fc8405ea8">secp256k1_musig_partial_sig</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a31ed1d14cfc4aeea471e7949364576d2" id="r_a31ed1d14cfc4aeea471e7949364576d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31ed1d14cfc4aeea471e7949364576d2">secp256k1_musig_pubnonce_parse</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *<a class="el" href="miner__tests_8cpp.html#ad73ee4141a6536b03f4e493b56859e86">nonce</a>, const unsigned char *in66) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:ae80450048d95054d60611dd5cce349b5" id="r_ae80450048d95054d60611dd5cce349b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae80450048d95054d60611dd5cce349b5">secp256k1_musig_pubnonce_serialize</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, unsigned char *out66, const <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *<a class="el" href="miner__tests_8cpp.html#ad73ee4141a6536b03f4e493b56859e86">nonce</a>) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a39e8d9d788986e2305ef44897314a08c" id="r_a39e8d9d788986e2305ef44897314a08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e8d9d788986e2305ef44897314a08c">secp256k1_musig_aggnonce_parse</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *<a class="el" href="miner__tests_8cpp.html#ad73ee4141a6536b03f4e493b56859e86">nonce</a>, const unsigned char *in66) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a12e7b1df6a5c248b0fd2fbd3b181cf4d" id="r_a12e7b1df6a5c248b0fd2fbd3b181cf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e7b1df6a5c248b0fd2fbd3b181cf4d">secp256k1_musig_aggnonce_serialize</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, unsigned char *out66, const <a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *<a class="el" href="miner__tests_8cpp.html#ad73ee4141a6536b03f4e493b56859e86">nonce</a>) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a2a87025c9b2609f636bb3804e619e01d" id="r_a2a87025c9b2609f636bb3804e619e01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a87025c9b2609f636bb3804e619e01d">secp256k1_musig_partial_sig_parse</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *sig, const unsigned char *in32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a828f4076c9b7d44f7b243a6d6df8c962" id="r_a828f4076c9b7d44f7b243a6d6df8c962"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a828f4076c9b7d44f7b243a6d6df8c962">secp256k1_musig_partial_sig_serialize</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, unsigned char *out32, const <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *sig) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:ad0ad82976282fb6cbc20e24994ab6d94" id="r_ad0ad82976282fb6cbc20e24994ab6d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0ad82976282fb6cbc20e24994ab6d94">secp256k1_musig_pubkey_agg</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *agg_pk, <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *const *pubkeys, size_t n_pubkeys) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
<tr class="memitem:a636bae714ad303b3985fb2c3df5c8c39" id="r_a636bae714ad303b3985fb2c3df5c8c39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a636bae714ad303b3985fb2c3df5c8c39">secp256k1_musig_pubkey_get</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *agg_pk, const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:a01eeb0d31dee13d208245a478b777d9c" id="r_a01eeb0d31dee13d208245a478b777d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01eeb0d31dee13d208245a478b777d9c">secp256k1_musig_pubkey_ec_tweak_add</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *output_pubkey, <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const unsigned char *tweak32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
<tr class="memitem:a10a46b293f9744518c660bcbc8775db1" id="r_a10a46b293f9744518c660bcbc8775db1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a46b293f9744518c660bcbc8775db1">secp256k1_musig_pubkey_xonly_tweak_add</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *output_pubkey, <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const unsigned char *tweak32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
<tr class="memitem:a7ec24f575d1e46794f3ce3532a03615b" id="r_a7ec24f575d1e46794f3ce3532a03615b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ec24f575d1e46794f3ce3532a03615b">secp256k1_musig_nonce_gen</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a> *secnonce, <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *pubnonce, unsigned char *session_secrand32, const unsigned char *seckey, const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *pubkey, const unsigned char *msg32, const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const unsigned char *extra_input32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(6)</td></tr>
<tr class="memitem:acf856b8cbcfc932add9d68a6a4e941b7" id="r_acf856b8cbcfc932add9d68a6a4e941b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf856b8cbcfc932add9d68a6a4e941b7">secp256k1_musig_nonce_gen_counter</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a> *secnonce, <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *pubnonce, uint64_t nonrepeating_cnt, const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair, const unsigned char *msg32, const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const unsigned char *extra_input32) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(5)</td></tr>
<tr class="memitem:a32c50c1197c2e1c817893b037cd8d721" id="r_a32c50c1197c2e1c817893b037cd8d721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32c50c1197c2e1c817893b037cd8d721">secp256k1_musig_nonce_agg</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *aggnonce, const <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *const *pubnonces, size_t n_pubnonces) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3)</td></tr>
<tr class="memitem:ae2294b047f341afacce48e9f9a509f11" id="r_ae2294b047f341afacce48e9f9a509f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2294b047f341afacce48e9f9a509f11">secp256k1_musig_nonce_process</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *session, const <a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *aggnonce, const unsigned char *msg32, const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(5)</td></tr>
<tr class="memitem:a37c235ba487df277f97464708c06f98e" id="r_a37c235ba487df277f97464708c06f98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37c235ba487df277f97464708c06f98e">secp256k1_musig_partial_sign</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *partial_sig, <a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a> *secnonce, const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *keypair, const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *session) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(5) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(6)</td></tr>
<tr class="memitem:a94cce9a0b321047ba1f341bc8f3f8ee3" id="r_a94cce9a0b321047ba1f341bc8f3f8ee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94cce9a0b321047ba1f341bc8f3f8ee3">secp256k1_musig_partial_sig_verify</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, const <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *partial_sig, const <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *pubnonce, const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *pubkey, const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *keyagg_cache, const <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *session) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(5) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(6)</td></tr>
<tr class="memitem:aa001ebd3ea7185c01e571e27e736cde1" id="r_aa001ebd3ea7185c01e571e27e736cde1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa001ebd3ea7185c01e571e27e736cde1">secp256k1_musig_partial_sig_agg</a> (const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *ctx, unsigned char *sig64, const <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *session, const <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *const *partial_sigs, size_t n_sigs) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(1) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(2) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(3) <a class="el" href="secp256k1_8h.html#a03c194d8fa91b9b66758b36c91e0b5cb">SECP256K1_ARG_NONNULL</a>(4)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a2770ea8cc9fe29b4ad76f5ef7a046d1e" name="a2770ea8cc9fe29b4ad76f5ef7a046d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2770ea8cc9fe29b4ad76f5ef7a046d1e">&#9670;&#160;</a></span>secp256k1_musig_aggnonce</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_musig_aggnonce secp256k1_musig_aggnonce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds an aggregate public nonce.</p>
<p>Guaranteed to be 132 bytes in size. Serialized and parsed with <span class="tt">musig_aggnonce_serialize</span> and <span class="tt">musig_aggnonce_parse</span>. </p>

</div>
</div>
<a id="ac649ade872dc56aa2320b74f169f0949" name="ac649ade872dc56aa2320b74f169f0949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac649ade872dc56aa2320b74f169f0949">&#9670;&#160;</a></span>secp256k1_musig_keyagg_cache</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_musig_keyagg_cache secp256k1_musig_keyagg_cache</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This module implements BIP 327 "MuSig2 for BIP340-compatible
Multi-Signatures" (<a href="https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki">https://github.com/bitcoin/bips/blob/master/bip-0327.mediawiki</a>) v1.0.0. You can find an example demonstrating the musig module in <a class="el" href="musig_8c.html">examples/musig.c</a>.</p>
<p>The module also supports BIP 341 ("Taproot") public key tweaking.</p>
<p>It is recommended to read the documentation in this include file carefully. Further notes on API usage can be found in <a class="el" href="musig_8md.html">doc/musig.md</a></p>
<p>Since the first version of MuSig is essentially replaced by MuSig2, we use MuSig, musig and MuSig2 synonymously unless noted otherwise. Opaque data structures</p>
<p>The exact representation of data inside the opaque data structures is implementation defined and not guaranteed to be portable between different platforms or versions. With the exception of <span class="tt"><a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a></span>, the data structures can be safely copied/moved. If you need to convert to a format suitable for storage, transmission, or comparison, use the corresponding serialization and parsing functions. Opaque data structure that caches information about public key aggregation.</p>
<p>Guaranteed to be 197 bytes in size. No serialization and parsing functions (yet). </p>

</div>
</div>
<a id="a7958289e96ef90b230e3f31fc8405ea8" name="a7958289e96ef90b230e3f31fc8405ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7958289e96ef90b230e3f31fc8405ea8">&#9670;&#160;</a></span>secp256k1_musig_partial_sig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_musig_partial_sig secp256k1_musig_partial_sig</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds a partial MuSig signature.</p>
<p>Guaranteed to be 36 bytes in size. Serialized and parsed with <span class="tt">musig_partial_sig_serialize</span> and <span class="tt">musig_partial_sig_parse</span>. </p>

</div>
</div>
<a id="a840ebbf17cb525df609a556a9b535a5c" name="a840ebbf17cb525df609a556a9b535a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840ebbf17cb525df609a556a9b535a5c">&#9670;&#160;</a></span>secp256k1_musig_pubnonce</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_musig_pubnonce secp256k1_musig_pubnonce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds a signer's public nonce.</p>
<p>Guaranteed to be 132 bytes in size. Serialized and parsed with <span class="tt">musig_pubnonce_serialize</span> and <span class="tt">musig_pubnonce_parse</span>. </p>

</div>
</div>
<a id="a8d4f988bfccef4b4b0007396f472e018" name="a8d4f988bfccef4b4b0007396f472e018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4f988bfccef4b4b0007396f472e018">&#9670;&#160;</a></span>secp256k1_musig_secnonce</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_musig_secnonce secp256k1_musig_secnonce</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds a signer's <em>secret</em> nonce.</p>
<p>Guaranteed to be 132 bytes in size.</p>
<p>WARNING: This structure MUST NOT be copied or read or written to directly. A signer who is online throughout the whole process and can keep this structure in memory can use the provided API functions for a safe standard workflow.</p>
<p>Copying this data structure can result in nonce reuse which will leak the secret signing key. </p>

</div>
</div>
<a id="a195f9c320f8c373400c5b5c789a35941" name="a195f9c320f8c373400c5b5c789a35941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195f9c320f8c373400c5b5c789a35941">&#9670;&#160;</a></span>secp256k1_musig_session</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct secp256k1_musig_session secp256k1_musig_session</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque data structure that holds a MuSig session.</p>
<p>This structure is not required to be kept secret for the signing protocol to be secure. Guaranteed to be 133 bytes in size. No serialization and parsing functions (yet). </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a39e8d9d788986e2305ef44897314a08c" name="a39e8d9d788986e2305ef44897314a08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e8d9d788986e2305ef44897314a08c">&#9670;&#160;</a></span>secp256k1_musig_aggnonce_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_aggnonce_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>nonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>in66</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse an aggregate public nonce.</p>
<p>Returns: 1 when the nonce could be parsed, 0 otherwise. Args: ctx: pointer to a context object Out: nonce: pointer to a nonce object In: in66: pointer to the 66-byte nonce to be parsed </p>

</div>
</div>
<a id="a12e7b1df6a5c248b0fd2fbd3b181cf4d" name="a12e7b1df6a5c248b0fd2fbd3b181cf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e7b1df6a5c248b0fd2fbd3b181cf4d">&#9670;&#160;</a></span>secp256k1_musig_aggnonce_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_musig_aggnonce_serialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>out66</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>nonce</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize an aggregate public nonce</p>
<p>Returns: 1 always Args: ctx: pointer to a context object Out: out66: pointer to a 66-byte array to store the serialized nonce In: nonce: pointer to the nonce </p>

</div>
</div>
<a id="a32c50c1197c2e1c817893b037cd8d721" name="a32c50c1197c2e1c817893b037cd8d721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c50c1197c2e1c817893b037cd8d721">&#9670;&#160;</a></span>secp256k1_musig_nonce_agg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_musig_nonce_agg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>aggnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *const *</td>          <td class="paramname"><span class="paramname"><em>pubnonces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n_pubnonces</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aggregates the nonces of all signers into a single nonce</p>
<p>This can be done by an untrusted party to reduce the communication between signers. Instead of everyone sending nonces to everyone else, there can be one party receiving all nonces, aggregating the nonces with this function and then sending only the aggregate nonce back to the signers.</p>
<p>If the aggregator does not compute the aggregate nonce correctly, the final signature will be invalid.</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise Args: ctx: pointer to a context object Out: aggnonce: pointer to an aggregate public nonce object for musig_nonce_process In: pubnonces: array of pointers to public nonces sent by the signers n_pubnonces: number of elements in the pubnonces array. Must be greater than 0. </p>

</div>
</div>
<a id="a7ec24f575d1e46794f3ce3532a03615b" name="a7ec24f575d1e46794f3ce3532a03615b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec24f575d1e46794f3ce3532a03615b">&#9670;&#160;</a></span>secp256k1_musig_nonce_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_nonce_gen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>secnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>pubnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>session_secrand32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seckey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>msg32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>extra_input32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a signing session by generating a nonce</p>
<p>This function outputs a secret nonce that will be required for signing and a corresponding public nonce that is intended to be sent to other signers.</p>
<p>MuSig differs from regular Schnorr signing in that implementers <em>must</em> take special care to not reuse a nonce. This can be ensured by following these rules:</p>
<ol type="1">
<li>Each call to this function must have a UNIQUE session_secrand32 that must NOT BE REUSED in subsequent calls to this function and must be KEPT SECRET (even from other signers).</li>
<li>If you already know the seckey, message or aggregate public key cache, they can be optionally provided to derive the nonce and increase misuse-resistance. The extra_input32 argument can be used to provide additional data that does not repeat in normal scenarios, such as the current time.</li>
<li>Avoid copying (or serializing) the secnonce. This reduces the possibility that it is used more than once for signing.</li>
</ol>
<p>If you don't have access to good randomness for session_secrand32, but you have access to a non-repeating counter, then see secp256k1_musig_nonce_gen_counter.</p>
<p>Remember that nonce reuse will leak the secret key! Note that using the same seckey for multiple MuSig sessions is fine.</p>
<p>Returns: 0 if the arguments are invalid and 1 otherwise Args: ctx: pointer to a context object (not secp256k1_context_static) Out: secnonce: pointer to a structure to store the secret nonce pubnonce: pointer to a structure to store the public nonce In/Out: session_secrand32: a 32-byte session_secrand32 as explained above. Must be unique to this call to secp256k1_musig_nonce_gen and must be uniformly random. If the function call is successful, the session_secrand32 buffer is invalidated to prevent reuse. In: seckey: the 32-byte secret key that will later be used for signing, if already known (can be NULL) pubkey: public key of the signer creating the nonce. The secnonce output of this function cannot be used to sign for any other public key. While the public key should correspond to the provided seckey, a mismatch will not cause the function to return 0. msg32: the 32-byte message that will later be signed, if already known (can be NULL) keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate (and potentially tweaked) public key if already known (can be NULL) extra_input32: an optional 32-byte array that is input to the nonce derivation function (can be NULL) </p>

</div>
</div>
<a id="acf856b8cbcfc932add9d68a6a4e941b7" name="acf856b8cbcfc932add9d68a6a4e941b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf856b8cbcfc932add9d68a6a4e941b7">&#9670;&#160;</a></span>secp256k1_musig_nonce_gen_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_nonce_gen_counter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>secnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>pubnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>nonrepeating_cnt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>msg32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>extra_input32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternative way to generate a nonce and start a signing session</p>
<p>This function outputs a secret nonce that will be required for signing and a corresponding public nonce that is intended to be sent to other signers.</p>
<p>This function differs from <span class="tt"><a class="el" href="#a7ec24f575d1e46794f3ce3532a03615b">secp256k1_musig_nonce_gen</a></span> by accepting a non-repeating counter value instead of a secret random value. This requires that a secret key is provided to <span class="tt"><a class="el" href="#acf856b8cbcfc932add9d68a6a4e941b7">secp256k1_musig_nonce_gen_counter</a></span> (through the keypair argument), as opposed to <span class="tt"><a class="el" href="#a7ec24f575d1e46794f3ce3532a03615b">secp256k1_musig_nonce_gen</a></span> where the seckey argument is optional.</p>
<p>MuSig differs from regular Schnorr signing in that implementers <em>must</em> take special care to not reuse a nonce. This can be ensured by following these rules:</p>
<ol type="1">
<li>The nonrepeating_cnt argument must be a counter value that never repeats, i.e., you must never call <span class="tt"><a class="el" href="#acf856b8cbcfc932add9d68a6a4e941b7">secp256k1_musig_nonce_gen_counter</a></span> twice with the same keypair and nonrepeating_cnt value. For example, this implies that if the same keypair is used with <span class="tt"><a class="el" href="#acf856b8cbcfc932add9d68a6a4e941b7">secp256k1_musig_nonce_gen_counter</a></span> on multiple devices, none of the devices should have the same counter value as any other device.</li>
<li>If the seckey, message or aggregate public key cache is already available at this stage, any of these can be optionally provided, in which case they will be used in the derivation of the nonce and increase misuse-resistance. The extra_input32 argument can be used to provide additional data that does not repeat in normal scenarios, such as the current time.</li>
<li>Avoid copying (or serializing) the secnonce. This reduces the possibility that it is used more than once for signing.</li>
</ol>
<p>Remember that nonce reuse will leak the secret key! Note that using the same keypair for multiple MuSig sessions is fine.</p>
<p>Returns: 0 if the arguments are invalid and 1 otherwise Args: ctx: pointer to a context object (not secp256k1_context_static) Out: secnonce: pointer to a structure to store the secret nonce pubnonce: pointer to a structure to store the public nonce In: nonrepeating_cnt: the value of a counter as explained above. Must be unique to this call to secp256k1_musig_nonce_gen. keypair: keypair of the signer creating the nonce. The secnonce output of this function cannot be used to sign for any other keypair. msg32: the 32-byte message that will later be signed, if already known (can be NULL) keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate (and potentially tweaked) public key if already known (can be NULL) extra_input32: an optional 32-byte array that is input to the nonce derivation function (can be NULL) </p>

</div>
</div>
<a id="ae2294b047f341afacce48e9f9a509f11" name="ae2294b047f341afacce48e9f9a509f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2294b047f341afacce48e9f9a509f11">&#9670;&#160;</a></span>secp256k1_musig_nonce_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_nonce_process </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__aggnonce.html">secp256k1_musig_aggnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>aggnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>msg32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes the aggregate nonce and creates a session that is required for signing and verification of partial signatures.</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise Args: ctx: pointer to a context object Out: session: pointer to a struct to store the session In: aggnonce: pointer to an aggregate public nonce object that is the output of musig_nonce_agg msg32: the 32-byte message to sign keyagg_cache: pointer to the keyagg_cache that was used to create the aggregate (and potentially tweaked) pubkey </p>

</div>
</div>
<a id="aa001ebd3ea7185c01e571e27e736cde1" name="aa001ebd3ea7185c01e571e27e736cde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa001ebd3ea7185c01e571e27e736cde1">&#9670;&#160;</a></span>secp256k1_musig_partial_sig_agg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_musig_partial_sig_agg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>sig64</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *const *</td>          <td class="paramname"><span class="paramname"><em>partial_sigs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n_sigs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aggregates partial signatures</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise (which does NOT mean the resulting signature verifies). Args: ctx: pointer to a context object Out: sig64: complete (but possibly invalid) Schnorr signature In: session: pointer to the session that was created with musig_nonce_process partial_sigs: array of pointers to partial signatures to aggregate n_sigs: number of elements in the partial_sigs array. Must be greater than 0. </p>

</div>
</div>
<a id="a2a87025c9b2609f636bb3804e619e01d" name="a2a87025c9b2609f636bb3804e619e01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a87025c9b2609f636bb3804e619e01d">&#9670;&#160;</a></span>secp256k1_musig_partial_sig_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_partial_sig_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>in32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a MuSig partial signature.</p>
<p>Returns: 1 when the signature could be parsed, 0 otherwise. Args: ctx: pointer to a context object Out: sig: pointer to a signature object In: in32: pointer to the 32-byte signature to be parsed </p>

</div>
</div>
<a id="a828f4076c9b7d44f7b243a6d6df8c962" name="a828f4076c9b7d44f7b243a6d6df8c962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828f4076c9b7d44f7b243a6d6df8c962">&#9670;&#160;</a></span>secp256k1_musig_partial_sig_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_musig_partial_sig_serialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>out32</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize a MuSig partial signature</p>
<p>Returns: 1 always Args: ctx: pointer to a context object Out: out32: pointer to a 32-byte array to store the serialized signature In: sig: pointer to the signature </p>

</div>
</div>
<a id="a94cce9a0b321047ba1f341bc8f3f8ee3" name="a94cce9a0b321047ba1f341bc8f3f8ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cce9a0b321047ba1f341bc8f3f8ee3">&#9670;&#160;</a></span>secp256k1_musig_partial_sig_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_partial_sig_verify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *</td>          <td class="paramname"><span class="paramname"><em>partial_sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>pubnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies an individual signer's partial signature</p>
<p>The signature is verified for a specific signing session. In order to avoid accidentally verifying a signature from a different or non-existing signing session, you must ensure the following:</p><ol type="1">
<li>The <span class="tt">keyagg_cache</span> argument is identical to the one used to create the <span class="tt">session</span> with <span class="tt">musig_nonce_process</span>.</li>
<li>The <span class="tt">pubkey</span> argument must be identical to the one sent by the signer before aggregating it with <span class="tt">musig_pubkey_agg</span> to create the <span class="tt">keyagg_cache</span>.</li>
<li>The <span class="tt">pubnonce</span> argument must be identical to the one sent by the signer before aggregating it with <span class="tt">musig_nonce_agg</span> and using the result to create the <span class="tt">session</span> with <span class="tt">musig_nonce_process</span>.</li>
</ol>
<p>It is not required to call this function in regular MuSig sessions, because if any partial signature does not verify, the final signature will not verify either, so the problem will be caught. However, this function provides the ability to identify which specific partial signature fails verification.</p>
<p>Returns: 0 if the arguments are invalid or the partial signature does not verify, 1 otherwise Args ctx: pointer to a context object In: partial_sig: pointer to partial signature to verify, sent by the signer associated with <span class="tt">pubnonce</span> and <span class="tt">pubkey</span> pubnonce: public nonce of the signer in the signing session pubkey: public key of the signer in the signing session keyagg_cache: pointer to the keyagg_cache that was output when the aggregate public key for this signing session session: pointer to the session that was created with <span class="tt">musig_nonce_process</span> </p>

</div>
</div>
<a id="a37c235ba487df277f97464708c06f98e" name="a37c235ba487df277f97464708c06f98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c235ba487df277f97464708c06f98e">&#9670;&#160;</a></span>secp256k1_musig_partial_sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_musig_partial_sign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__partial__sig.html">secp256k1_musig_partial_sig</a> *</td>          <td class="paramname"><span class="paramname"><em>partial_sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__secnonce.html">secp256k1_musig_secnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>secnonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__keypair.html">secp256k1_keypair</a> *</td>          <td class="paramname"><span class="paramname"><em>keypair</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__session.html">secp256k1_musig_session</a> *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produces a partial signature</p>
<p>This function overwrites the given secnonce with zeros and will abort if given a secnonce that is all zeros. This is a best effort attempt to protect against nonce reuse. However, this is of course easily defeated if the secnonce has been copied (or serialized). Remember that nonce reuse will leak the secret key!</p>
<p>For signing to succeed, the secnonce provided to this function must have been generated for the provided keypair. This means that when signing for a keypair consisting of a seckey and pubkey, the secnonce must have been created by calling musig_nonce_gen with that pubkey. Otherwise, the illegal_callback is called.</p>
<p>This function does not verify the output partial signature, deviating from the BIP 327 specification. It is recommended to verify the output partial signature with <span class="tt"><a class="el" href="#a94cce9a0b321047ba1f341bc8f3f8ee3">secp256k1_musig_partial_sig_verify</a></span> to prevent random or adversarially provoked computation errors.</p>
<p>Returns: 0 if the arguments are invalid or the provided secnonce has already been used for signing, 1 otherwise Args: ctx: pointer to a context object Out: partial_sig: pointer to struct to store the partial signature In/Out: secnonce: pointer to the secnonce struct created in musig_nonce_gen that has been never used in a partial_sign call before and has been created for the keypair In: keypair: pointer to keypair to sign the message with keyagg_cache: pointer to the keyagg_cache that was output when the aggregate public key for this session session: pointer to the session that was created with musig_nonce_process </p>

</div>
</div>
<a id="ad0ad82976282fb6cbc20e24994ab6d94" name="ad0ad82976282fb6cbc20e24994ab6d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ad82976282fb6cbc20e24994ab6d94">&#9670;&#160;</a></span>secp256k1_musig_pubkey_agg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_pubkey_agg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__xonly__pubkey.html">secp256k1_xonly_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>agg_pk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *const *</td>          <td class="paramname"><span class="paramname"><em>pubkeys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n_pubkeys</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes an aggregate public key and uses it to initialize a keyagg_cache</p>
<p>Different orders of <span class="tt">pubkeys</span> result in different <span class="tt">agg_pk</span>s.</p>
<p>Before aggregating, the pubkeys can be sorted with <span class="tt"><a class="el" href="secp256k1_8h.html#ace5e4824419ef5e099f920eaa8e7cafb">secp256k1_ec_pubkey_sort</a></span> which ensures the same <span class="tt">agg_pk</span> result for the same multiset of pubkeys. This is useful to do before <span class="tt">pubkey_agg</span>, such that the order of pubkeys does not affect the aggregate public key.</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise Args: ctx: pointer to a context object Out: agg_pk: the MuSig-aggregated x-only public key. If you do not need it, this arg can be NULL. keyagg_cache: if non-NULL, pointer to a musig_keyagg_cache struct that is required for signing (or observing the signing session and verifying partial signatures). In: pubkeys: input array of pointers to public keys to aggregate. The order is important; a different order will result in a different aggregate public key. n_pubkeys: length of pubkeys array. Must be greater than 0. </p>

</div>
</div>
<a id="a01eeb0d31dee13d208245a478b777d9c" name="a01eeb0d31dee13d208245a478b777d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eeb0d31dee13d208245a478b777d9c">&#9670;&#160;</a></span>secp256k1_musig_pubkey_ec_tweak_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_pubkey_ec_tweak_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>output_pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>tweak32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply plain "EC" tweaking to a public key in a given keyagg_cache by adding the generator multiplied with <span class="tt">tweak32</span> to it. This is useful for deriving child keys from an aggregate public key via BIP 32 where <span class="tt">tweak32</span> is set to a hash as defined in BIP 32.</p>
<p>Callers are responsible for deriving <span class="tt">tweak32</span> in a way that does not reduce the security of MuSig (for example, by following BIP 32).</p>
<p>The tweaking method is the same as <span class="tt"><a class="el" href="secp256k1_8h.html#aaac0a0211f7ebfa1af55ab571cd57751">secp256k1_ec_pubkey_tweak_add</a></span>. So after the following pseudocode buf and buf2 have identical contents (absent earlier failures).</p>
<p>secp256k1_musig_pubkey_agg(..., keyagg_cache, pubkeys, ...) secp256k1_musig_pubkey_get(..., agg_pk, keyagg_cache) secp256k1_musig_pubkey_ec_tweak_add(..., output_pk, tweak32, keyagg_cache) secp256k1_ec_pubkey_serialize(..., buf, ..., output_pk, ...) secp256k1_ec_pubkey_tweak_add(..., agg_pk, tweak32) secp256k1_ec_pubkey_serialize(..., buf2, ..., agg_pk, ...)</p>
<p>This function is required if you want to <em>sign</em> for a tweaked aggregate key. If you are only computing a public key but not intending to create a signature for it, use <span class="tt"><a class="el" href="secp256k1_8h.html#aaac0a0211f7ebfa1af55ab571cd57751">secp256k1_ec_pubkey_tweak_add</a></span> instead.</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise Args: ctx: pointer to a context object Out: output_pubkey: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. If you do not need it, this arg can be NULL. In/Out: keyagg_cache: pointer to a <span class="tt">musig_keyagg_cache</span> struct initialized by <span class="tt">musig_pubkey_agg</span> In: tweak32: pointer to a 32-byte tweak. The tweak is valid if it passes <span class="tt"><a class="el" href="secp256k1_8h.html#a366f922fc0c787351e82ff8e3a95f652">secp256k1_ec_seckey_verify</a></span> and is not equal to the secret key corresponding to the public key represented by keyagg_cache or its negation. For uniformly random 32-byte arrays the chance of being invalid is negligible (around 1 in 2^128). </p>

</div>
</div>
<a id="a636bae714ad303b3985fb2c3df5c8c39" name="a636bae714ad303b3985fb2c3df5c8c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636bae714ad303b3985fb2c3df5c8c39">&#9670;&#160;</a></span>secp256k1_musig_pubkey_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_pubkey_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>agg_pk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the aggregate public key from a keyagg_cache.</p>
<p>This is only useful if you need the non-xonly public key, in particular for plain (non-xonly) tweaking or batch-verifying multiple key aggregations (not implemented).</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise Args: ctx: pointer to a context object Out: agg_pk: the MuSig-aggregated public key. In: keyagg_cache: pointer to a <span class="tt">musig_keyagg_cache</span> struct initialized by <span class="tt">musig_pubkey_agg</span> </p>

</div>
</div>
<a id="a10a46b293f9744518c660bcbc8775db1" name="a10a46b293f9744518c660bcbc8775db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a46b293f9744518c660bcbc8775db1">&#9670;&#160;</a></span>secp256k1_musig_pubkey_xonly_tweak_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_pubkey_xonly_tweak_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__pubkey.html">secp256k1_pubkey</a> *</td>          <td class="paramname"><span class="paramname"><em>output_pubkey</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__keyagg__cache.html">secp256k1_musig_keyagg_cache</a> *</td>          <td class="paramname"><span class="paramname"><em>keyagg_cache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>tweak32</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply x-only tweaking to a public key in a given keyagg_cache by adding the generator multiplied with <span class="tt">tweak32</span> to it. This is useful for creating Taproot outputs where <span class="tt">tweak32</span> is set to a TapTweak hash as defined in BIP 341.</p>
<p>Callers are responsible for deriving <span class="tt">tweak32</span> in a way that does not reduce the security of MuSig (for example, by following Taproot BIP 341).</p>
<p>The tweaking method is the same as <span class="tt"><a class="el" href="secp256k1__extrakeys_8h.html#aaf832fa110c2610d69dee6ca74c856e8">secp256k1_xonly_pubkey_tweak_add</a></span>. So in the following pseudocode xonly_pubkey_tweak_add_check (absent earlier failures) returns 1.</p>
<p>secp256k1_musig_pubkey_agg(..., agg_pk, keyagg_cache, pubkeys, ...) secp256k1_musig_pubkey_xonly_tweak_add(..., output_pk, keyagg_cache, tweak32) secp256k1_xonly_pubkey_serialize(..., buf, output_pk) secp256k1_xonly_pubkey_tweak_add_check(..., buf, ..., agg_pk, tweak32)</p>
<p>This function is required if you want to <em>sign</em> for a tweaked aggregate key. If you are only computing a public key but not intending to create a signature for it, use <span class="tt"><a class="el" href="secp256k1__extrakeys_8h.html#aaf832fa110c2610d69dee6ca74c856e8">secp256k1_xonly_pubkey_tweak_add</a></span> instead.</p>
<p>Returns: 0 if the arguments are invalid, 1 otherwise Args: ctx: pointer to a context object Out: output_pubkey: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. If you do not need it, this arg can be NULL. In/Out: keyagg_cache: pointer to a <span class="tt">musig_keyagg_cache</span> struct initialized by <span class="tt">musig_pubkey_agg</span> In: tweak32: pointer to a 32-byte tweak. The tweak is valid if it passes <span class="tt"><a class="el" href="secp256k1_8h.html#a366f922fc0c787351e82ff8e3a95f652">secp256k1_ec_seckey_verify</a></span> and is not equal to the secret key corresponding to the public key represented by keyagg_cache or its negation. For uniformly random 32-byte arrays the chance of being invalid is negligible (around 1 in 2^128). </p>

</div>
</div>
<a id="a31ed1d14cfc4aeea471e7949364576d2" name="a31ed1d14cfc4aeea471e7949364576d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ed1d14cfc4aeea471e7949364576d2">&#9670;&#160;</a></span>secp256k1_musig_pubnonce_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> <a class="el" href="secp256k1_8h.html#aebd5ca8fbfcbb0ba0754a46115143c2c">SECP256K1_WARN_UNUSED_RESULT</a> int secp256k1_musig_pubnonce_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>nonce</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>in66</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a signer's public nonce.</p>
<p>Returns: 1 when the nonce could be parsed, 0 otherwise. Args: ctx: pointer to a context object Out: nonce: pointer to a nonce object In: in66: pointer to the 66-byte nonce to be parsed </p>

</div>
</div>
<a id="ae80450048d95054d60611dd5cce349b5" name="ae80450048d95054d60611dd5cce349b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80450048d95054d60611dd5cce349b5">&#9670;&#160;</a></span>secp256k1_musig_pubnonce_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="secp256k1_8h.html#a3f1967acd0fe26283877c61b3f2694a5">SECP256K1_API</a> int secp256k1_musig_pubnonce_serialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="secp256k1_8h.html#a282ec9e6dfec8c35955c3eb2f7476e5e">secp256k1_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>out66</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsecp256k1__musig__pubnonce.html">secp256k1_musig_pubnonce</a> *</td>          <td class="paramname"><span class="paramname"><em>nonce</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize a signer's public nonce</p>
<p>Returns: 1 always Args: ctx: pointer to a context object Out: out66: pointer to a 66-byte array to store the serialized nonce In: nonce: pointer to the nonce </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="dir_44f34d1e62fda08bdb4ca69ab2d205ae.html">secp256k1</a></li><li class="navelem"><a href="dir_1b4df0b9bba47cf333db333897c5a5a4.html">include</a></li><li class="navelem"><a href="secp256k1__musig_8h.html">secp256k1_musig.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
