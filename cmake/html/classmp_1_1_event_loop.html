<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: EventLoop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classmp_1_1_event_loop.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">EventLoop Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="proxy-io_8h_source.html">proxy-io.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af4e2d623f57fae116fc13c423109871b" id="r_af4e2d623f57fae116fc13c423109871b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4e2d623f57fae116fc13c423109871b">EventLoop</a> (const char *exe_name, <a class="el" href="namespacemp.html#a61ffb74e9f97c3924b3904a35a5f20b2">LogFn</a> log_fn, void *context=nullptr)</td></tr>
<tr class="memdesc:af4e2d623f57fae116fc13c423109871b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct event loop object with default logging options.  <br /></td></tr>
<tr class="memitem:adedf492d5d51065481b58d3020c40840" id="r_adedf492d5d51065481b58d3020c40840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adedf492d5d51065481b58d3020c40840">EventLoop</a> (const char *exe_name, <a class="el" href="structmp_1_1_log_options.html">LogOptions</a> log_opts, void *context=nullptr)</td></tr>
<tr class="memdesc:adedf492d5d51065481b58d3020c40840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct event loop object with specified logging options.  <br /></td></tr>
<tr class="memitem:a97dc677b923c4253bb089b99a4e24e4c" id="r_a97dc677b923c4253bb089b99a4e24e4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97dc677b923c4253bb089b99a4e24e4c">EventLoop</a> (const char *exe_name, std::function&lt; void(bool, std::string)&gt; old_callback, void *context=nullptr)</td></tr>
<tr class="memdesc:a97dc677b923c4253bb089b99a4e24e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backwards-compatible constructor for previous (deprecated) logging callback signature.  <br /></td></tr>
<tr class="memitem:ad39d140230e71b90198d0ed03e0c21f2" id="r_ad39d140230e71b90198d0ed03e0c21f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad39d140230e71b90198d0ed03e0c21f2">~EventLoop</a> ()</td></tr>
<tr class="memitem:afe461d27b9c48d5921c00d521181f12f" id="r_afe461d27b9c48d5921c00d521181f12f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe461d27b9c48d5921c00d521181f12f">loop</a> ()</td></tr>
<tr class="memitem:a4e6f3fba72d4c182f3e7474a2fd76667" id="r_a4e6f3fba72d4c182f3e7474a2fd76667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e6f3fba72d4c182f3e7474a2fd76667">post</a> (kj::Function&lt; void()&gt; fn)</td></tr>
<tr class="memitem:ad322c973d237a8efe56f3c4ffbb3cb0c" id="r_ad322c973d237a8efe56f3c4ffbb3cb0c"><td class="memTemplParams" colspan="2">template&lt;typename Callable&gt; </td></tr>
<tr class="memitem:ad322c973d237a8efe56f3c4ffbb3cb0c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad322c973d237a8efe56f3c4ffbb3cb0c">sync</a> (Callable &amp;&amp;callable)</td></tr>
<tr class="memitem:ae50c7c1f98f078876e3241d909d36da9" id="r_ae50c7c1f98f078876e3241d909d36da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae50c7c1f98f078876e3241d909d36da9">addAsyncCleanup</a> (std::function&lt; void()&gt; fn)</td></tr>
<tr class="memitem:a97b4cd12dc18c9198ee6657c936e9fdd" id="r_a97b4cd12dc18c9198ee6657c936e9fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b4cd12dc18c9198ee6657c936e9fdd">startAsyncThread</a> () <a class="el" href="ipc_2libmultiprocess_2include_2mp_2util_8h.html#a6b530c2b9c91ae9a26983477097f38dd">MP_REQUIRES</a>(<a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a>)</td></tr>
<tr class="memitem:af0c4e1593f96387b1fc05c902f72a509" id="r_af0c4e1593f96387b1fc05c902f72a509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0c4e1593f96387b1fc05c902f72a509">done</a> () const <a class="el" href="ipc_2libmultiprocess_2include_2mp_2util_8h.html#a6b530c2b9c91ae9a26983477097f38dd">MP_REQUIRES</a>(<a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a>)</td></tr>
<tr class="memdesc:af0c4e1593f96387b1fc05c902f72a509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if loop should exit.  <br /></td></tr>
<tr class="memitem:a18e06ab543770b1d48dd06243faa75eb" id="r_a18e06ab543770b1d48dd06243faa75eb"><td class="memItemLeft" align="right" valign="top">kj::Function&lt; void()&gt; *m_post_fn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18e06ab543770b1d48dd06243faa75eb">MP_GUARDED_BY</a> (<a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a>)</td></tr>
<tr class="memdesc:a18e06ab543770b1d48dd06243faa75eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to run on event loop thread during <a class="el" href="#a4e6f3fba72d4c182f3e7474a2fd76667">post()</a> or <a class="el" href="#ad322c973d237a8efe56f3c4ffbb3cb0c">sync()</a> call.  <br /></td></tr>
<tr class="memitem:aaac2885ebd590ea8287845814c6a5b49" id="r_aaac2885ebd590ea8287845814c6a5b49"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacemp.html#aa04bf09245b60eb219c446d213cc0390">CleanupList</a> &gt; m_async_fns&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac2885ebd590ea8287845814c6a5b49">MP_GUARDED_BY</a> (<a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a>)</td></tr>
<tr class="memdesc:aaac2885ebd590ea8287845814c6a5b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback functions to run on async thread.  <br /></td></tr>
<tr class="memitem:a75d54c4047fd429274c790929f4dc23e" id="r_a75d54c4047fd429274c790929f4dc23e"><td class="memItemLeft" align="right" valign="top">int m_num_clients&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d54c4047fd429274c790929f4dc23e">MP_GUARDED_BY</a> (<a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a>)=0</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a2a779802443c51d72db5bd158c31c964" id="r_a2a779802443c51d72db5bd158c31c964"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a779802443c51d72db5bd158c31c964">m_exe_name</a></td></tr>
<tr class="memitem:aaee8fe6bf715daa70d55a732218dcfe5" id="r_aaee8fe6bf715daa70d55a732218dcfe5"><td class="memItemLeft" align="right" valign="top">std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee8fe6bf715daa70d55a732218dcfe5">m_thread_id</a> = std::this_thread::get_id()</td></tr>
<tr class="memdesc:aaee8fe6bf715daa70d55a732218dcfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of the event loop thread.  <br /></td></tr>
<tr class="memitem:a7ff706a17a3571c9b28db11e81dc7585" id="r_a7ff706a17a3571c9b28db11e81dc7585"><td class="memItemLeft" align="right" valign="top">std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ff706a17a3571c9b28db11e81dc7585">m_async_thread</a></td></tr>
<tr class="memitem:a5ca6d7b6e9cca718db8c78de06dde777" id="r_a5ca6d7b6e9cca718db8c78de06dde777"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca6d7b6e9cca718db8c78de06dde777">m_wait_fd</a> = -1</td></tr>
<tr class="memdesc:a5ca6d7b6e9cca718db8c78de06dde777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe read handle used to wake up the event loop thread.  <br /></td></tr>
<tr class="memitem:a59f59d4a0735009e1d98f835eeccdb87" id="r_a59f59d4a0735009e1d98f835eeccdb87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f59d4a0735009e1d98f835eeccdb87">m_post_fd</a> = -1</td></tr>
<tr class="memdesc:a59f59d4a0735009e1d98f835eeccdb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe write handle used to wake up the event loop thread.  <br /></td></tr>
<tr class="memitem:a71aaf23d91d7b7a5611738c4f06e3577" id="r_a71aaf23d91d7b7a5611738c4f06e3577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sync_8h.html#a326d1d46ce05b5316d8ebe2694a10a6e">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a></td></tr>
<tr class="memitem:accca0ab294feb9061406ae9c73a3ceb5" id="r_accca0ab294feb9061406ae9c73a3ceb5"><td class="memItemLeft" align="right" valign="top">std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accca0ab294feb9061406ae9c73a3ceb5">m_cv</a></td></tr>
<tr class="memitem:ae9ed3a7b20562f71d91760034e7100f1" id="r_ae9ed3a7b20562f71d91760034e7100f1"><td class="memItemLeft" align="right" valign="top">kj::AsyncIoContext&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9ed3a7b20562f71d91760034e7100f1">m_io_context</a></td></tr>
<tr class="memdesc:ae9ed3a7b20562f71d91760034e7100f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capnp IO context.  <br /></td></tr>
<tr class="memitem:aa3a0b29328e0fc0ec8b26132feb0fcc5" id="r_aa3a0b29328e0fc0ec8b26132feb0fcc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmp_1_1_logging_error_handler.html">LoggingErrorHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3a0b29328e0fc0ec8b26132feb0fcc5">m_error_handler</a> {*this}</td></tr>
<tr class="memdesc:aa3a0b29328e0fc0ec8b26132feb0fcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capnp error handler. Needs to outlive m_task_set.  <br /></td></tr>
<tr class="memitem:a4867e4e832e2d05e777ed32a795214ad" id="r_a4867e4e832e2d05e777ed32a795214ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; kj::TaskSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4867e4e832e2d05e777ed32a795214ad">m_task_set</a></td></tr>
<tr class="memdesc:a4867e4e832e2d05e777ed32a795214ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capnp list of pending promises.  <br /></td></tr>
<tr class="memitem:ace117e2546e02ad25eb0044315aa4ac9" id="r_ace117e2546e02ad25eb0044315aa4ac9"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classmp_1_1_connection.html">Connection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace117e2546e02ad25eb0044315aa4ac9">m_incoming_connections</a></td></tr>
<tr class="memdesc:ace117e2546e02ad25eb0044315aa4ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of connections.  <br /></td></tr>
<tr class="memitem:ab1f44d16de891fa65b054ee4ead90294" id="r_ab1f44d16de891fa65b054ee4ead90294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmp_1_1_log_options.html">LogOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1f44d16de891fa65b054ee4ead90294">m_log_opts</a></td></tr>
<tr class="memdesc:ab1f44d16de891fa65b054ee4ead90294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging options.  <br /></td></tr>
<tr class="memitem:a92efa486d18e81bd893ff18bc8a22926" id="r_a92efa486d18e81bd893ff18bc8a22926"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92efa486d18e81bd893ff18bc8a22926">m_context</a></td></tr>
<tr class="memdesc:a92efa486d18e81bd893ff18bc8a22926"><td class="mdescLeft">&#160;</td><td class="mdescRight">External context pointer.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Event loop implementation.</p>
<p>Cap'n Proto threading model is very simple: all I/O operations are asynchronous and must be performed on a single thread. This includes:</p>
<ul>
<li>Code starting an asynchronous operation (calling a function that returns a promise object)</li>
<li>Code notifying that an asynchronous operation is complete (code using a fulfiller object)</li>
<li>Code handling a completed operation (code chaining or waiting for a promise)</li>
</ul>
<p>All of this code needs to access shared state, and there is no mutex that can be acquired to lock this state because Cap'n Proto assumes it will only be accessed from one thread. So all this code needs to actually run on one thread, and the <a class="el" href="#afe461d27b9c48d5921c00d521181f12f">EventLoop::loop()</a> method is the entry point for this thread. <a class="el" href="structmp_1_1_proxy_client.html">ProxyClient</a> and <a class="el" href="structmp_1_1_proxy_server.html">ProxyServer</a> objects that use other threads and need to perform I/O operations post to this thread using <a class="el" href="#a4e6f3fba72d4c182f3e7474a2fd76667">EventLoop::post()</a> and <a class="el" href="#ad322c973d237a8efe56f3c4ffbb3cb0c">EventLoop::sync()</a> methods.</p>
<p>Specifically, because <a class="el" href="structmp_1_1_proxy_client.html">ProxyClient</a> methods can be called from arbitrary threads, and <a class="el" href="structmp_1_1_proxy_server.html">ProxyServer</a> methods can run on arbitrary threads, <a class="el" href="structmp_1_1_proxy_client.html">ProxyClient</a> methods use the <a class="el" href="classmp_1_1_event_loop.html">EventLoop</a> thread to send requests, and <a class="el" href="structmp_1_1_proxy_server.html">ProxyServer</a> methods use the thread to return results.</p>
<p>Based on <a href="https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ">https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ</a> </p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af4e2d623f57fae116fc13c423109871b" name="af4e2d623f57fae116fc13c423109871b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2d623f57fae116fc13c423109871b">&#9670;&#160;</a></span>EventLoop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EventLoop </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>exe_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemp.html#a61ffb74e9f97c3924b3904a35a5f20b2">LogFn</a></td>          <td class="paramname"><span class="paramname"><em>log_fn</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct event loop object with default logging options. </p>

</div>
</div>
<a id="adedf492d5d51065481b58d3020c40840" name="adedf492d5d51065481b58d3020c40840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedf492d5d51065481b58d3020c40840">&#9670;&#160;</a></span>EventLoop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EventLoop </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>exe_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmp_1_1_log_options.html">LogOptions</a></td>          <td class="paramname"><span class="paramname"><em>log_opts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct event loop object with specified logging options. </p>

</div>
</div>
<a id="a97dc677b923c4253bb089b99a4e24e4c" name="a97dc677b923c4253bb089b99a4e24e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97dc677b923c4253bb089b99a4e24e4c">&#9670;&#160;</a></span>EventLoop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EventLoop </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>exe_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(bool, std::string)&gt;</td>          <td class="paramname"><span class="paramname"><em>old_callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backwards-compatible constructor for previous (deprecated) logging callback signature. </p>

</div>
</div>
<a id="ad39d140230e71b90198d0ed03e0c21f2" name="ad39d140230e71b90198d0ed03e0c21f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39d140230e71b90198d0ed03e0c21f2">&#9670;&#160;</a></span>~EventLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="#af4e2d623f57fae116fc13c423109871b">EventLoop</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ae50c7c1f98f078876e3241d909d36da9" name="ae50c7c1f98f078876e3241d909d36da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50c7c1f98f078876e3241d909d36da9">&#9670;&#160;</a></span>addAsyncCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addAsyncCleanup </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register cleanup function to run on asynchronous worker thread without blocking the event loop thread. </p>

</div>
</div>
<a id="af0c4e1593f96387b1fc05c902f72a509" name="af0c4e1593f96387b1fc05c902f72a509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c4e1593f96387b1fc05c902f72a509">&#9670;&#160;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool done </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if loop should exit. </p>

</div>
</div>
<a id="afe461d27b9c48d5921c00d521181f12f" name="afe461d27b9c48d5921c00d521181f12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe461d27b9c48d5921c00d521181f12f">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run event loop. Does not return until shutdown. This should only be called once from the m_thread_id thread. This will block until the m_num_clients reference count is 0. </p>

</div>
</div>
<a id="aaac2885ebd590ea8287845814c6a5b49" name="aaac2885ebd590ea8287845814c6a5b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac2885ebd590ea8287845814c6a5b49">&#9670;&#160;</a></span>MP_GUARDED_BY() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="namespacemp.html#aa04bf09245b60eb219c446d213cc0390">CleanupList</a> &gt; m_async_fns MP_GUARDED_BY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback functions to run on async thread. </p>

</div>
</div>
<a id="a18e06ab543770b1d48dd06243faa75eb" name="a18e06ab543770b1d48dd06243faa75eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e06ab543770b1d48dd06243faa75eb">&#9670;&#160;</a></span>MP_GUARDED_BY() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::Function&lt; void()&gt; *m_post_fn MP_GUARDED_BY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to run on event loop thread during <a class="el" href="#a4e6f3fba72d4c182f3e7474a2fd76667">post()</a> or <a class="el" href="#ad322c973d237a8efe56f3c4ffbb3cb0c">sync()</a> call. </p>

</div>
</div>
<a id="a75d54c4047fd429274c790929f4dc23e" name="a75d54c4047fd429274c790929f4dc23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d54c4047fd429274c790929f4dc23e">&#9670;&#160;</a></span>MP_GUARDED_BY() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int m_num_clients MP_GUARDED_BY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a71aaf23d91d7b7a5611738c4f06e3577">m_mutex</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of clients holding references to <a class="el" href="structmp_1_1_proxy_server_base.html">ProxyServerBase</a> objects that reference this event loop. </p>

</div>
</div>
<a id="a4e6f3fba72d4c182f3e7474a2fd76667" name="a4e6f3fba72d4c182f3e7474a2fd76667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f3fba72d4c182f3e7474a2fd76667">&#9670;&#160;</a></span>post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void post </td>
          <td>(</td>
          <td class="paramtype">kj::Function&lt; void()&gt;</td>          <td class="paramname"><span class="paramname"><em>fn</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run function on event loop thread. Does not return until function completes. Must be called while the <a class="el" href="#afe461d27b9c48d5921c00d521181f12f">loop()</a> function is active. </p>

</div>
</div>
<a id="a97b4cd12dc18c9198ee6657c936e9fdd" name="a97b4cd12dc18c9198ee6657c936e9fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b4cd12dc18c9198ee6657c936e9fdd">&#9670;&#160;</a></span>startAsyncThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startAsyncThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start asynchronous worker thread if necessary. This is only done if there are <a class="el" href="structmp_1_1_proxy_server_base.html#a47b0d7e7413d0c7eb592ccf544a24f13">ProxyServerBase::m_impl</a> objects that need to be destroyed asynchronously, without tying up the event loop thread. This can happen when an interface does not declare a destroy() method that would allow the client to wait for the destructor to finish and run it on a dedicated thread. It can also happen whenever this is a broken connection and the client is no longer around to call the destructors and the server objects need to be garbage collected. In both cases, it is important that ProxyServer::m_impl destructors do not run on the eventloop thread because they may need it to do I/O if they perform other IPC calls. </p>

</div>
</div>
<a id="ad322c973d237a8efe56f3c4ffbb3cb0c" name="ad322c973d237a8efe56f3c4ffbb3cb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad322c973d237a8efe56f3c4ffbb3cb0c">&#9670;&#160;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sync </td>
          <td>(</td>
          <td class="paramtype">Callable &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>callable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_wrapper.html">Wrapper</a> around <a class="el" href="#a4e6f3fba72d4c182f3e7474a2fd76667">EventLoop::post</a> that takes advantage of the fact that callable will not go out of scope to avoid requirement that it be copyable. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a7ff706a17a3571c9b28db11e81dc7585" name="a7ff706a17a3571c9b28db11e81dc7585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff706a17a3571c9b28db11e81dc7585">&#9670;&#160;</a></span>m_async_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::thread m_async_thread</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle of an async worker thread. Joined on destruction. Unset if async method has not been called. </p>

</div>
</div>
<a id="a92efa486d18e81bd893ff18bc8a22926" name="a92efa486d18e81bd893ff18bc8a22926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92efa486d18e81bd893ff18bc8a22926">&#9670;&#160;</a></span>m_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* m_context</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External context pointer. </p>

</div>
</div>
<a id="accca0ab294feb9061406ae9c73a3ceb5" name="accca0ab294feb9061406ae9c73a3ceb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accca0ab294feb9061406ae9c73a3ceb5">&#9670;&#160;</a></span>m_cv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::condition_variable m_cv</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3a0b29328e0fc0ec8b26132feb0fcc5" name="aa3a0b29328e0fc0ec8b26132feb0fcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a0b29328e0fc0ec8b26132feb0fcc5">&#9670;&#160;</a></span>m_error_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmp_1_1_logging_error_handler.html">LoggingErrorHandler</a> m_error_handler {*this}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capnp error handler. Needs to outlive m_task_set. </p>

</div>
</div>
<a id="a2a779802443c51d72db5bd158c31c964" name="a2a779802443c51d72db5bd158c31c964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a779802443c51d72db5bd158c31c964">&#9670;&#160;</a></span>m_exe_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* m_exe_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process name included in thread names so combined debug output from multiple processes is easier to understand. </p>

</div>
</div>
<a id="ace117e2546e02ad25eb0044315aa4ac9" name="ace117e2546e02ad25eb0044315aa4ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace117e2546e02ad25eb0044315aa4ac9">&#9670;&#160;</a></span>m_incoming_connections</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classmp_1_1_connection.html">Connection</a>&gt; m_incoming_connections</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of connections. </p>

</div>
</div>
<a id="ae9ed3a7b20562f71d91760034e7100f1" name="ae9ed3a7b20562f71d91760034e7100f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ed3a7b20562f71d91760034e7100f1">&#9670;&#160;</a></span>m_io_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kj::AsyncIoContext m_io_context</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capnp IO context. </p>

</div>
</div>
<a id="ab1f44d16de891fa65b054ee4ead90294" name="ab1f44d16de891fa65b054ee4ead90294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f44d16de891fa65b054ee4ead90294">&#9670;&#160;</a></span>m_log_opts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmp_1_1_log_options.html">LogOptions</a> m_log_opts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logging options. </p>

</div>
</div>
<a id="a71aaf23d91d7b7a5611738c4f06e3577" name="a71aaf23d91d7b7a5611738c4f06e3577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71aaf23d91d7b7a5611738c4f06e3577">&#9670;&#160;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sync_8h.html#a326d1d46ce05b5316d8ebe2694a10a6e">Mutex</a> m_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="sync_8h.html#a326d1d46ce05b5316d8ebe2694a10a6e">Mutex</a> and condition variable used to post tasks to event loop and async thread. </p>

</div>
</div>
<a id="a59f59d4a0735009e1d98f835eeccdb87" name="a59f59d4a0735009e1d98f835eeccdb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f59d4a0735009e1d98f835eeccdb87">&#9670;&#160;</a></span>m_post_fd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int m_post_fd = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe write handle used to wake up the event loop thread. </p>

</div>
</div>
<a id="a4867e4e832e2d05e777ed32a795214ad" name="a4867e4e832e2d05e777ed32a795214ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4867e4e832e2d05e777ed32a795214ad">&#9670;&#160;</a></span>m_task_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;kj::TaskSet&gt; m_task_set</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Capnp list of pending promises. </p>

</div>
</div>
<a id="aaee8fe6bf715daa70d55a732218dcfe5" name="aaee8fe6bf715daa70d55a732218dcfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee8fe6bf715daa70d55a732218dcfe5">&#9670;&#160;</a></span>m_thread_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::thread::id m_thread_id = std::this_thread::get_id()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ID of the event loop thread. </p>

</div>
</div>
<a id="a5ca6d7b6e9cca718db8c78de06dde777" name="a5ca6d7b6e9cca718db8c78de06dde777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca6d7b6e9cca718db8c78de06dde777">&#9670;&#160;</a></span>m_wait_fd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int m_wait_fd = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe read handle used to wake up the event loop thread. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/ipc/libmultiprocess/include/mp/<a class="el" href="proxy-io_8h_source.html">proxy-io.h</a></li>
<li>src/ipc/libmultiprocess/src/mp/<a class="el" href="proxy_8cpp.html">proxy.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacemp.html">mp</a></li><li class="navelem"><a href="classmp_1_1_event_loop.html">EventLoop</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
