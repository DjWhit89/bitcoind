<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: ThreadContext Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('structmp_1_1_thread_context.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ThreadContext Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="proxy-io_8h_source.html">proxy-io.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c938bed0c537f793043396cf41dfeab" id="r_a9c938bed0c537f793043396cf41dfeab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemp.html#a5176f804f9aaad2c96c46ac53c5bd28b">ConnThreads</a> callback_threads&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c938bed0c537f793043396cf41dfeab">MP_GUARDED_BY</a> (<a class="el" href="#ab283ccca525d24f19bd1860fa2836783">waiter</a>-&gt;m_mutex)</td></tr>
<tr class="memitem:ad7d4449836b9c614cb977a93f75c4290" id="r_ad7d4449836b9c614cb977a93f75c4290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemp.html#a5176f804f9aaad2c96c46ac53c5bd28b">ConnThreads</a> request_threads&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7d4449836b9c614cb977a93f75c4290">MP_GUARDED_BY</a> (<a class="el" href="#ab283ccca525d24f19bd1860fa2836783">waiter</a>-&gt;m_mutex)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:af22159ec9e33831372abc5e43e4944f9" id="r_af22159ec9e33831372abc5e43e4944f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af22159ec9e33831372abc5e43e4944f9">thread_name</a></td></tr>
<tr class="memdesc:af22159ec9e33831372abc5e43e4944f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifying string for debug.  <br /></td></tr>
<tr class="memitem:ab283ccca525d24f19bd1860fa2836783" id="r_ab283ccca525d24f19bd1860fa2836783"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="structmp_1_1_waiter.html">Waiter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab283ccca525d24f19bd1860fa2836783">waiter</a> = nullptr</td></tr>
<tr class="memitem:a370e26772b89031ea6428652997e3c91" id="r_a370e26772b89031ea6428652997e3c91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a370e26772b89031ea6428652997e3c91">loop_thread</a> = false</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The thread_local <a class="el" href="structmp_1_1_thread_context.html">ThreadContext</a> g_thread_context struct provides information about individual threads and a way of communicating between them. Because it's a thread local struct, each <a class="el" href="structmp_1_1_thread_context.html">ThreadContext</a> instance is initialized by the thread that owns it.</p>
<p><a class="el" href="structmp_1_1_thread_context.html">ThreadContext</a> is used for any client threads created externally which make IPC calls, and for server threads created by <a class="el" href="structmp_1_1_proxy_server_3_01_thread_map_01_4.html#a9019e0dfdcbbdf27a37291c74ee5da21">ProxyServer&lt;ThreadMap&gt;::makeThread()</a> which execute IPC calls for clients.</p>
<p>In both cases, the struct holds information like the thread name, and a <a class="el" href="structmp_1_1_waiter.html">Waiter</a> object where the <a class="el" href="classmp_1_1_event_loop.html">EventLoop</a> can post incoming IPC requests to execute on the thread. The struct also holds <a class="el" href="namespacemp.html#a4c23514105673e30f7c1f46afc594ece">ConnThread</a> maps associating the thread with local and remote <a class="el" href="structmp_1_1_proxy_client_3_01_thread_01_4.html">ProxyClient&lt;Thread&gt;</a> objects. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ad7d4449836b9c614cb977a93f75c4290" name="ad7d4449836b9c614cb977a93f75c4290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d4449836b9c614cb977a93f75c4290">&#9670;&#160;</a></span>MP_GUARDED_BY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemp.html#a5176f804f9aaad2c96c46ac53c5bd28b">ConnThreads</a> request_threads MP_GUARDED_BY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab283ccca525d24f19bd1860fa2836783">waiter</a>-&gt;</td>          <td class="paramname"><span class="paramname"><em>m_mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When client is making a request to a server, this is the <span class="tt">thread</span> argument it passes in the request, used to control which thread on server will be responsible for executing it. If client call is being made from a local thread, this will be a remote thread object returned by makeThread. If a client call is being made from a thread currently handling a server request, this will be set to the <span class="tt">callbackThread</span> request thread argument passed in that request.</p>
<p>Synchronization note: callback_threads note applies here as well. </p>

</div>
</div>
<a id="a9c938bed0c537f793043396cf41dfeab" name="a9c938bed0c537f793043396cf41dfeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c938bed0c537f793043396cf41dfeab">&#9670;&#160;</a></span>MP_GUARDED_BY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemp.html#a5176f804f9aaad2c96c46ac53c5bd28b">ConnThreads</a> callback_threads MP_GUARDED_BY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab283ccca525d24f19bd1860fa2836783">waiter</a>-&gt;</td>          <td class="paramname"><span class="paramname"><em>m_mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When client is making a request to a server, this is the <span class="tt">callbackThread</span> argument it passes in the request, used by the server in case it needs to make callbacks into the client that need to execute while the client is waiting. This will be set to a local thread object.</p>
<p>Synchronization note: The callback_thread and request_thread maps are only ever accessed internally by this thread's destructor and externally by Cap'n Proto event loop threads. Since it's possible for IPC client threads to make calls over different connections that could have different event loops, these maps are guarded by <a class="el" href="structmp_1_1_waiter.html#a71aaf23d91d7b7a5611738c4f06e3577">Waiter::m_mutex</a> in case different event loop threads add or remove map entries simultaneously. However, individual <a class="el" href="structmp_1_1_proxy_client_3_01_thread_01_4.html">ProxyClient&lt;Thread&gt;</a> objects in the maps will only be associated with one event loop and guarded by <a class="el" href="classmp_1_1_event_loop.html#a71aaf23d91d7b7a5611738c4f06e3577">EventLoop::m_mutex</a>. So <a class="el" href="structmp_1_1_waiter.html#a71aaf23d91d7b7a5611738c4f06e3577">Waiter::m_mutex</a> does not need to be held while accessing individual <a class="el" href="structmp_1_1_proxy_client_3_01_thread_01_4.html">ProxyClient&lt;Thread&gt;</a> instances, and may even need to be released to respect lock order and avoid locking <a class="el" href="structmp_1_1_waiter.html#a71aaf23d91d7b7a5611738c4f06e3577">Waiter::m_mutex</a> before <a class="el" href="classmp_1_1_event_loop.html#a71aaf23d91d7b7a5611738c4f06e3577">EventLoop::m_mutex</a>. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a370e26772b89031ea6428652997e3c91" name="a370e26772b89031ea6428652997e3c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370e26772b89031ea6428652997e3c91">&#9670;&#160;</a></span>loop_thread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loop_thread = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether this thread is a capnp event loop thread. Not really used except to assert false if there's an attempt to execute a blocking operation which could deadlock the thread. </p>

</div>
</div>
<a id="af22159ec9e33831372abc5e43e4944f9" name="af22159ec9e33831372abc5e43e4944f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22159ec9e33831372abc5e43e4944f9">&#9670;&#160;</a></span>thread_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string thread_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifying string for debug. </p>

</div>
</div>
<a id="ab283ccca525d24f19bd1860fa2836783" name="ab283ccca525d24f19bd1860fa2836783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab283ccca525d24f19bd1860fa2836783">&#9670;&#160;</a></span>waiter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="structmp_1_1_waiter.html">Waiter</a>&gt; waiter = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structmp_1_1_waiter.html">Waiter</a> object used to allow remote clients to execute code on this thread. For server threads created by <a class="el" href="structmp_1_1_proxy_server_3_01_thread_map_01_4.html#a9019e0dfdcbbdf27a37291c74ee5da21">ProxyServer&lt;ThreadMap&gt;::makeThread()</a>, this is initialized in that function. Otherwise, for client threads created externally, this is initialized the first time the thread tries to make an IPC call. Having a waiter is necessary for threads making IPC calls in case a server they are calling expects them to execute a callback during the call, before it sends a response.</p>
<p>For IPC client threads, the <a class="el" href="structmp_1_1_waiter.html">Waiter</a> pointer is never cleared and the <a class="el" href="structmp_1_1_waiter.html">Waiter</a> just gets destroyed when the thread does. For server threads created by makeThread(), this pointer is set to null in the ~ProxyServer&lt;Thread&gt; as a signal for the thread to exit and destroy itself. In both cases, the same <a class="el" href="structmp_1_1_waiter.html">Waiter</a> object is used across different calls and only created and destroyed once for the lifetime of the thread. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/ipc/libmultiprocess/include/mp/<a class="el" href="proxy-io_8h_source.html">proxy-io.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespacemp.html">mp</a></li><li class="navelem"><a href="structmp_1_1_thread_context.html">ThreadContext</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
