<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: ankerl::nanobench Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceankerl_1_1nanobench.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ankerl::nanobench Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:templates" id="r_templates"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench_1_1templates.html">templates</a></td></tr>
<tr class="memitem:detail" id="r_detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench_1_1detail.html">detail</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:Config" id="r_Config"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structankerl_1_1nanobench_1_1_config.html">Config</a></td></tr>
<tr class="memitem:Result" id="r_Result"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a></td></tr>
<tr class="memitem:Rng" id="r_Rng"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_rng.html">Rng</a></td></tr>
<tr class="memitem:Bench" id="r_Bench"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main entry point to nanobench's benchmarking facility.  <a href="classankerl_1_1nanobench_1_1_bench.html#details">More...</a><br /></td></tr>
<tr class="memitem:BigO" id="r_BigO"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">BigO</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a75c517a490cc337babc53b6c5008cdb5" id="r_a75c517a490cc337babc53b6c5008cdb5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75c517a490cc337babc53b6c5008cdb5">Clock</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8b83321afa5228fa13d67157ad8657e" id="r_aa8b83321afa5228fa13d67157ad8657e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8b83321afa5228fa13d67157ad8657e">render</a> (char const *mustacheTemplate, <a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;bench, std::ostream &amp;out)</td></tr>
<tr class="memdesc:aa8b83321afa5228fa13d67157ad8657e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders output from a mustache-like template and benchmark results.  <br /></td></tr>
<tr class="memitem:aa1dec992ac1ca3b7f809b19f80731e5b" id="r_aa1dec992ac1ca3b7f809b19f80731e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1dec992ac1ca3b7f809b19f80731e5b">render</a> (std::string const &amp;mustacheTemplate, <a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;bench, std::ostream &amp;out)</td></tr>
<tr class="memitem:a2ceb04bb3be4bfefdb350794d870c601" id="r_a2ceb04bb3be4bfefdb350794d870c601"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceb04bb3be4bfefdb350794d870c601">render</a> (char const *mustacheTemplate, std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;results, std::ostream &amp;out)</td></tr>
<tr class="memitem:a01eed06f15c6b472a066041a45bf5ce8" id="r_a01eed06f15c6b472a066041a45bf5ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01eed06f15c6b472a066041a45bf5ce8">render</a> (std::string const &amp;mustacheTemplate, std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;results, std::ostream &amp;out)</td></tr>
<tr class="memitem:a3212d2fb3075373651a84b10c6e27f5a" id="r_a3212d2fb3075373651a84b10c6e27f5a"><td class="memTemplParams" colspan="2">template&lt;typename Arg&gt; </td></tr>
<tr class="memitem:a3212d2fb3075373651a84b10c6e27f5a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3212d2fb3075373651a84b10c6e27f5a">doNotOptimizeAway</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a3212d2fb3075373651a84b10c6e27f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure none of the given arguments are optimized away by the compiler.  <br /></td></tr>
<tr class="memitem:ac6dfa99fbb0ccc7e9057b5fccef501d8" id="r_ac6dfa99fbb0ccc7e9057b5fccef501d8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6dfa99fbb0ccc7e9057b5fccef501d8">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">BigO</a> const &amp;bigO)</td></tr>
<tr class="memitem:a3f1e3dca5735b98bda904a5bb78fff2c" id="r_a3f1e3dca5735b98bda904a5bb78fff2c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f1e3dca5735b98bda904a5bb78fff2c">operator&lt;&lt;</a> (std::ostream &amp;os, std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">ankerl::nanobench::BigO</a> &gt; const &amp;bigOs)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a75c517a490cc337babc53b6c5008cdb5" name="a75c517a490cc337babc53b6c5008cdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c517a490cc337babc53b6c5008cdb5">&#9670;&#160;</a></span>Clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a75c517a490cc337babc53b6c5008cdb5">Clock</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> std::conditional&lt;std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock,</div>
<div class="line">                               std::chrono::steady_clock&gt;::type</div>
</div><!-- fragment -->
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a3212d2fb3075373651a84b10c6e27f5a" name="a3212d2fb3075373651a84b10c6e27f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3212d2fb3075373651a84b10c6e27f5a">&#9670;&#160;</a></span>doNotOptimizeAway()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void doNotOptimizeAway </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes sure none of the given arguments are optimized away by the compiler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Type of the argument that shouldn't be optimized away. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The input that we mark as being used, even though we don't do anything with it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6dfa99fbb0ccc7e9057b5fccef501d8" name="ac6dfa99fbb0ccc7e9057b5fccef501d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dfa99fbb0ccc7e9057b5fccef501d8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">BigO</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>bigO</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f1e3dca5735b98bda904a5bb78fff2c" name="a3f1e3dca5735b98bda904a5bb78fff2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1e3dca5735b98bda904a5bb78fff2c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">ankerl::nanobench::BigO</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>bigOs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8b83321afa5228fa13d67157ad8657e" name="aa8b83321afa5228fa13d67157ad8657e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b83321afa5228fa13d67157ad8657e">&#9670;&#160;</a></span>render() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void render </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>mustacheTemplate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>bench</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders output from a mustache-like template and benchmark results. </p>
<p>The templating facility here is heavily inspired by <a href="https://mustache.github.io/">mustache - logic-less templates</a>. It adds a few more features that are necessary to get all of the captured data out of nanobench. Please read the excellent <a href="https://mustache.github.io/mustache.5.html">mustache manual</a> to see what this is all about.</p>
<p>nanobench output has two nested layers, <em>result</em> and <em>measurement</em>. Here is a hierarchy of the allowed tags:</p>
<ul>
<li><p class="startli"><span class="tt">{{#result}}</span> Marks the begin of the result layer. Whatever comes after this will be instantiated as often as a benchmark result is available. Within it, you can use these tags:</p><ul>
<li><span class="tt">{{title}}</span> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a4e7209cd88a09e1e2278f0d506dd3aa3" title="Title of the benchmark, will be shown in the table header. Changing the title will start a new markdo...">Bench::title</a>.</li>
<li><span class="tt">{{<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>}}</span> Benchmark name, usually directly provided with <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#ae0f1d3ec977f3733d457b759b1f08e9e" title="Repeatedly calls op() based on the configuration, and performs measurements.">Bench::run</a>, but can also be set with <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a8a87b6c0978c4d69179ee249beb86c0c" title="Gets the title of the benchmark.">Bench::name</a>.</li>
<li><span class="tt">{{unit}}</span> Unit, e.g. <span class="tt">byte</span>. Defaults to <span class="tt">op</span>, see <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a7fada6f805f9af86b8508e8ef028d936" title="Sets the operation unit.">Bench::unit</a>.</li>
<li><span class="tt">{{batch}}</span> Batch size, see <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a37d376bc0b00680fc13656e4761f8168" title="Sets the batch size.">Bench::batch</a>.</li>
<li><span class="tt">{{complexityN}}</span> Value used for asymptotic complexity calculation. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a4c2fa1375c3a79a88cfb8532b4017f69">Bench::complexityN</a>.</li>
<li><span class="tt">{{epochs}}</span> Number of epochs, see <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a2aace9b04e1962c6490d7b2bbcbf0269" title="Controls number of epochs, the number of measurements to perform.">Bench::epochs</a>.</li>
<li><span class="tt">{{clockResolution}}</span> Accuracy of the clock, i.e. what's the smallest time possible to measure with the clock. For modern systems, this can be around 20 ns. This value is automatically determined by nanobench at the first benchmark that is run, and used as a static variable throughout the application's runtime.</li>
<li><span class="tt">{{clockResolutionMultiple}}</span> Configuration multiplier for <span class="tt">clockResolution</span>. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a92b3a1e3050c61c1e24e42a116b92a87">Bench::clockResolutionMultiple</a>. This is the target runtime for each measurement (epoch). That means the more accurate your clock is, the faster will be the benchmark. Basing the measurement's runtime on the clock resolution is the main reason why nanobench is so fast.</li>
<li><span class="tt">{{maxEpochTime}}</span> Configuration for a maximum time each measurement (epoch) is allowed to take. Note that at least a single iteration will be performed, even when that takes longer than maxEpochTime. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#abb7e4067323a8d7569e9867b03a35b39" title="Upper limit for the runtime of each epoch.">Bench::maxEpochTime</a>.</li>
<li><span class="tt">{{minEpochTime}}</span> Minimum epoch time, defaults to 1ms. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#aa6b15573e7e0c48f1290e1842fd21edf" title="Minimum time each epoch should take.">Bench::minEpochTime</a>.</li>
<li><span class="tt">{{minEpochIterations}}</span> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#aab73759486903f243d9664e3c3208034" title="Sets the minimum number of iterations each epoch should take.">Bench::minEpochIterations</a>.</li>
<li><span class="tt">{{epochIterations}}</span> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#ae084f501a2a3c61c1d128a519d4a38ae">Bench::epochIterations</a>.</li>
<li><span class="tt">{{warmup}}</span> Number of iterations used before measuring starts. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#ae48156567cac1e76706ac0ce076894b7" title="Sets a number of iterations that are initially performed without any measurements.">Bench::warmup</a>.</li>
<li><span class="tt">{{relative}}</span> True or false, depending on the setting you have used. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a2b35462c62dcf9e55bf31618dd8008e0" title="Marks the next run as the baseline.">Bench::relative</a>.</li>
<li><span class="tt">{{context(variableName)}}</span> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a6c5c13becb6edb48ef7d02cc8caab1bb" title="Set context information.">Bench::context</a>.</li>
</ul>
<p class="startli">Apart from these tags, it is also possible to use some mathematical operations on the measurement data. The operations are of the form <span class="tt">{{<a class="el" href="bitcoin-wallet_8cpp.html#a64b0c5844a38fc862dcb5b4e30b1ca49">command(name)</a>}}</span>. Currently <span class="tt"><a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a></span> can be one of <span class="tt">elapsed</span>, <span class="tt">iterations</span>. If performance counters are available (currently only on current Linux systems), you also have <span class="tt">pagefaults</span>, <span class="tt">cpucycles</span>, <span class="tt">contextswitches</span>, <span class="tt">instructions</span>, <span class="tt">branchinstructions</span>, and <span class="tt">branchmisses</span>. All the measures (except <span class="tt">iterations</span>) are provided for a single iteration (so <span class="tt">elapsed</span> is the time a single iteration took). The following tags are available:</p><ul>
<li><span class="tt">{{median(&lt;<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>&gt;)}}</span> Calculate median of a measurement data set, e.g. <span class="tt">{{median(elapsed)}}</span>.</li>
<li><span class="tt">{{average(&lt;<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>&gt;)}}</span> Average (mean) calculation.</li>
<li><p class="startli"><span class="tt">{{medianAbsolutePercentError(&lt;<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>&gt;)}}</span> Calculates MdAPE, the Median Absolute Percentage Error. The MdAPE is an excellent metric for the variation of measurements. It is more robust to outliers than the <a href="https://en.wikipedia.org/wiki/Mean_absolute_percentage_error">Mean absolute percentage error (M-APE)</a>.   </p><p class="formulaDsp">
<picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[      \mathrm{MdAPE}(e) = \mathrm{med}\{| \frac{e_i - \mathrm{med}\{e\}}{e_i}| \}
\&zwj;]" src="form_0.png"/></picture>
</p>
<p> E.g. for <em>elapsed</em>: First, <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \mathrm{med}\{e\} $" src="form_1.png"/></picture> calculates the median by sorting and then taking the middle element of all <em>elapsed</em> measurements. This is used to calculate the absolute percentage error to this median for each measurement, as in <picture><source srcset="form_2_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ | \frac{e_i - \mathrm{med}\{e\}}{e_i}| $" src="form_2.png"/></picture>. All these results are sorted, and the middle value is chosen as the median absolute percent error.</p>
<p class="startli">This measurement is a bit hard to interpret, but it is very robust against outliers. E.g. a value of 5% means that half of the measurements deviate less than 5% from the median, and the other deviate more than 5% from the median.</p>
</li>
<li><span class="tt">{{<a class="el" href="examples_8cpp.html#a936f4b586a8f869a9d0d197cc5110653">sum</a>(&lt;<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>&gt;)}}</span> Sum of all the measurements. E.g. <span class="tt">{{<a class="el" href="examples_8cpp.html#a936f4b586a8f869a9d0d197cc5110653">sum(iterations)</a>}}</span> will give you the total number of iterations measured in this benchmark.</li>
<li><span class="tt">{{minimum(&lt;<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>&gt;)}}</span> Minimum of all measurements.</li>
<li><span class="tt">{{maximum(&lt;<a class="el" href="rest_8cpp.html#a8f8f80d37794cde9472343e4487ba3eb">name</a>&gt;)}}</span> Maximum of all measurements.</li>
<li><span class="tt">{{sumProduct(&lt;first&gt;, &lt;second&gt;)}}</span> Calculates the sum of the products of corresponding measures:   <p class="formulaDsp">
<picture><source srcset="form_3_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[         \mathrm{sumProduct}(a,b) = \sum_{i=1}^{n}a_i\cdot b_i
\&zwj;]" src="form_3.png"/></picture>
</p>
 E.g. to calculate total runtime of the benchmark, you multiply iterations with elapsed time for each measurement, and sum these results up: <span class="tt">{{sumProduct(iterations, elapsed)}}</span>.</li>
<li><span class="tt">{{#measurement}}</span> To access individual measurement results, open the begin tag for measurements.<ul>
<li><span class="tt">{{elapsed}}</span> Average elapsed wall clock time per iteration, in seconds.</li>
<li><span class="tt">{{iterations}}</span> Number of iterations in the measurement. The number of iterations will fluctuate due to some applied randomness, to enhance accuracy.</li>
<li><span class="tt">{{pagefaults}}</span> Average number of pagefaults per iteration.</li>
<li><span class="tt">{{cpucycles}}</span> Average number of CPU cycles processed per iteration.</li>
<li><span class="tt">{{contextswitches}}</span> Average number of context switches per iteration.</li>
<li><span class="tt">{{instructions}}</span> Average number of retired instructions per iteration.</li>
<li><span class="tt">{{branchinstructions}}</span> Average number of branches executed per iteration.</li>
<li><span class="tt">{{branchmisses}}</span> Average number of branches that were missed per iteration.</li>
</ul>
</li>
<li><span class="tt">{{/measurement}}</span> Ends the measurement tag.</li>
</ul>
</li>
<li><p class="startli"><span class="tt">{{/result}}</span> Marks the end of the result layer. This is the end marker for the template part that will be instantiated for each benchmark result.</p>
<p class="startli">For the layer tags <em>result</em> and <em>measurement</em> you additionally can use these special markers:</p><ul>
<li><span class="tt">{{#-first}}</span> - Begin marker of a template that will be instantiated <em>only for the first</em> entry in the layer. Use is only allowed between the begin and end marker of the layer. So between <span class="tt">{{#result}}</span> and <span class="tt">{{/result}}</span>, or between <span class="tt">{{#measurement}}</span> and <span class="tt">{{/measurement}}</span>. Finish the template with <span class="tt">{{/-first}}</span>.</li>
<li><span class="tt">{{^-first}}</span> - Begin marker of a template that will be instantiated <em>for each except the first</em> entry in the layer. This, this is basically the inversion of <span class="tt">{{#-first}}</span>. Use is only allowed between the begin and end marker of the layer. So between <span class="tt">{{#result}}</span> and <span class="tt">{{/result}}</span>, or between <span class="tt">{{#measurement}}</span> and <span class="tt">{{/measurement}}</span>.</li>
<li><span class="tt">{{/-first}}</span> - End marker for either <span class="tt">{{#-first}}</span> or <span class="tt">{{^-first}}</span>.</li>
<li><span class="tt">{{#-last}}</span> - Begin marker of a template that will be instantiated <em>only for the last</em> entry in the layer. Use is only allowed between the begin and end marker of the layer. So between <span class="tt">{{#result}}</span> and <span class="tt">{{/result}}</span>, or between <span class="tt">{{#measurement}}</span> and <span class="tt">{{/measurement}}</span>. Finish the template with <span class="tt">{{/-last}}</span>.</li>
<li><span class="tt">{{^-last}}</span> - Begin marker of a template that will be instantiated <em>for each except the last</em> entry in the layer. This, this is basically the inversion of <span class="tt">{{#-last}}</span>. Use is only allowed between the begin and end marker of the layer. So between <span class="tt">{{#result}}</span> and <span class="tt">{{/result}}</span>, or between <span class="tt">{{#measurement}}</span> and <span class="tt">{{/measurement}}</span>.</li>
<li><span class="tt">{{/-last}}</span> - End marker for either <span class="tt">{{#-last}}</span> or <span class="tt">{{^-last}}</span>.</li>
</ul>
</li>
</ul>
<pre class="fragment">embed:rst

For an overview of all the possible data you can get out of nanobench, please see the tutorial at :ref:`tutorial-template-json`.

The templates that ship with nanobench are:

* :cpp:func:`templates::csv() &lt;ankerl::nanobench::templates::csv()&gt;`
* :cpp:func:`templates::json() &lt;ankerl::nanobench::templates::json()&gt;`
* :cpp:func:`templates::htmlBoxplot() &lt;ankerl::nanobench::templates::htmlBoxplot()&gt;`
* :cpp:func:`templates::pyperf() &lt;ankerl::nanobench::templates::pyperf()&gt;`
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mustacheTemplate</td><td>The template. </td></tr>
    <tr><td class="paramname">bench</td><td>Benchmark, containing all the results. </td></tr>
    <tr><td class="paramname">out</td><td>Output for the generated output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceb04bb3be4bfefdb350794d870c601" name="a2ceb04bb3be4bfefdb350794d870c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceb04bb3be4bfefdb350794d870c601">&#9670;&#160;</a></span>render() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void render </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>mustacheTemplate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#aa8b83321afa5228fa13d67157ad8657e" title="Renders output from a mustache-like template and benchmark results.">render(char const* mustacheTemplate, Bench const&amp; bench, std::ostream&amp; out)</a>, but for when you only have results available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mustacheTemplate</td><td>The template. </td></tr>
    <tr><td class="paramname">results</td><td>All the results to be used for rendering. </td></tr>
    <tr><td class="paramname">out</td><td>Output for the generated output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1dec992ac1ca3b7f809b19f80731e5b" name="aa1dec992ac1ca3b7f809b19f80731e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dec992ac1ca3b7f809b19f80731e5b">&#9670;&#160;</a></span>render() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void render </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>mustacheTemplate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>bench</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01eed06f15c6b472a066041a45bf5ce8" name="a01eed06f15c6b472a066041a45bf5ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eed06f15c6b472a066041a45bf5ce8">&#9670;&#160;</a></span>render() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void render </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;</td>          <td class="paramname"><span class="paramname"><em>mustacheTemplate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceankerl.html">ankerl</a></li><li class="navelem"><a href="namespaceankerl_1_1nanobench.html">nanobench</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
