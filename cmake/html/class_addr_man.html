<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: AddrMan Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_addr_man.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">AddrMan Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="addrman_8h_source.html">addrman.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AddrMan:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_addr_man.png" usemap="#AddrMan_map" alt=""/>
  <map id="AddrMan_map" name="AddrMan_map">
<area href="class_addr_man_deterministic.html" alt="AddrManDeterministic" shape="rect" coords="0,56,137,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b6cb9872d13a1e3d821f9b17a8b6db6" id="r_a4b6cb9872d13a1e3d821f9b17a8b6db6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b6cb9872d13a1e3d821f9b17a8b6db6">AddrMan</a> (const <a class="el" href="class_net_group_manager.html">NetGroupManager</a> &amp;netgroupman, bool deterministic, int32_t consistency_check_ratio)</td></tr>
<tr class="memitem:ae269a6c335d01a48a541f6d7e3b0ecbf" id="r_ae269a6c335d01a48a541f6d7e3b0ecbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae269a6c335d01a48a541f6d7e3b0ecbf">~AddrMan</a> ()</td></tr>
<tr class="memitem:ae7b340a1417273fa5fb4dd89b68e90a5" id="r_ae7b340a1417273fa5fb4dd89b68e90a5"><td class="memTemplParams" colspan="2">template&lt;typename Stream&gt; </td></tr>
<tr class="memitem:ae7b340a1417273fa5fb4dd89b68e90a5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b340a1417273fa5fb4dd89b68e90a5">Serialize</a> (Stream &amp;s_) const</td></tr>
<tr class="memitem:ab646bc9d141d8c4971fa522a73677586" id="r_ab646bc9d141d8c4971fa522a73677586"><td class="memTemplParams" colspan="2">template&lt;typename Stream&gt; </td></tr>
<tr class="memitem:ab646bc9d141d8c4971fa522a73677586 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab646bc9d141d8c4971fa522a73677586">Unserialize</a> (Stream &amp;s_)</td></tr>
<tr class="memitem:ad14483585857cd4336e052ecdea6eb92" id="r_ad14483585857cd4336e052ecdea6eb92"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad14483585857cd4336e052ecdea6eb92">Size</a> (std::optional&lt; <a class="el" href="netaddress_8h.html#acc9a38c714afe79b5035cb36f560dac3">Network</a> &gt; net=std::nullopt, std::optional&lt; bool &gt; in_new=std::nullopt) const</td></tr>
<tr class="memitem:af0acda4d7598ebd2cb76c8ee97ee845f" id="r_af0acda4d7598ebd2cb76c8ee97ee845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0acda4d7598ebd2cb76c8ee97ee845f">Add</a> (const std::vector&lt; <a class="el" href="class_c_address.html">CAddress</a> &gt; &amp;vAddr, const <a class="el" href="class_c_net_addr.html">CNetAddr</a> &amp;source, std::chrono::seconds time_penalty=0s)</td></tr>
<tr class="memitem:a706c1c1b34e109a4c2e5310b15a72c4d" id="r_a706c1c1b34e109a4c2e5310b15a72c4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a706c1c1b34e109a4c2e5310b15a72c4d">Good</a> (const <a class="el" href="class_c_service.html">CService</a> &amp;addr, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> time=<a class="el" href="util_2time_8h.html#a7a4e7e09a41ff922cf1eb6fdaae4b3ba">Now</a>&lt; <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt;())</td></tr>
<tr class="memitem:af610ed4d0bc8631426d628c08c392585" id="r_af610ed4d0bc8631426d628c08c392585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af610ed4d0bc8631426d628c08c392585">Attempt</a> (const <a class="el" href="class_c_service.html">CService</a> &amp;addr, bool fCountFailure, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> time=<a class="el" href="util_2time_8h.html#a7a4e7e09a41ff922cf1eb6fdaae4b3ba">Now</a>&lt; <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt;())</td></tr>
<tr class="memdesc:af610ed4d0bc8631426d628c08c392585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark an entry as connection attempted to.  <br /></td></tr>
<tr class="memitem:a15574032976f63a21b1781d0ed08d75b" id="r_a15574032976f63a21b1781d0ed08d75b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15574032976f63a21b1781d0ed08d75b">ResolveCollisions</a> ()</td></tr>
<tr class="memdesc:a15574032976f63a21b1781d0ed08d75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.  <br /></td></tr>
<tr class="memitem:af0fc23fd56fa4cfc1327991984fb9389" id="r_af0fc23fd56fa4cfc1327991984fb9389"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_c_address.html">CAddress</a>, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0fc23fd56fa4cfc1327991984fb9389">SelectTriedCollision</a> ()</td></tr>
<tr class="memitem:aef855c09bfa93ccd88508eaf73d5bc74" id="r_aef855c09bfa93ccd88508eaf73d5bc74"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="class_c_address.html">CAddress</a>, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef855c09bfa93ccd88508eaf73d5bc74">Select</a> (bool new_only=false, const std::unordered_set&lt; <a class="el" href="netaddress_8h.html#acc9a38c714afe79b5035cb36f560dac3">Network</a> &gt; &amp;networks={}) const</td></tr>
<tr class="memitem:ab64d634410f099e19c2f2b6b83876118" id="r_ab64d634410f099e19c2f2b6b83876118"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_c_address.html">CAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab64d634410f099e19c2f2b6b83876118">GetAddr</a> (size_t max_addresses, size_t max_pct, std::optional&lt; <a class="el" href="netaddress_8h.html#acc9a38c714afe79b5035cb36f560dac3">Network</a> &gt; network, const bool filtered=true) const</td></tr>
<tr class="memitem:ae18710a592d984080a6b29c9965b7418" id="r_ae18710a592d984080a6b29c9965b7418"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="class_addr_info.html">AddrInfo</a>, <a class="el" href="struct_address_position.html">AddressPosition</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae18710a592d984080a6b29c9965b7418">GetEntries</a> (bool from_tried) const</td></tr>
<tr class="memitem:a5db77c65bd764c01b128936f2dcca9ef" id="r_a5db77c65bd764c01b128936f2dcca9ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5db77c65bd764c01b128936f2dcca9ef">Connected</a> (const <a class="el" href="class_c_service.html">CService</a> &amp;addr, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> time=<a class="el" href="util_2time_8h.html#a7a4e7e09a41ff922cf1eb6fdaae4b3ba">Now</a>&lt; <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt;())</td></tr>
<tr class="memitem:a0b0d0a32c294a075972d91681ed918fb" id="r_a0b0d0a32c294a075972d91681ed918fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b0d0a32c294a075972d91681ed918fb">SetServices</a> (const <a class="el" href="class_c_service.html">CService</a> &amp;addr, <a class="el" href="protocol_8h.html#ad131f3177584caea787cdbf6f85a9537">ServiceFlags</a> nServices)</td></tr>
<tr class="memdesc:a0b0d0a32c294a075972d91681ed918fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update an entry's service bits.  <br /></td></tr>
<tr class="memitem:ae6f01245c5edff531298e93e6ed69d42" id="r_ae6f01245c5edff531298e93e6ed69d42"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="struct_address_position.html">AddressPosition</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6f01245c5edff531298e93e6ed69d42">FindAddressEntry</a> (const <a class="el" href="class_c_address.html">CAddress</a> &amp;addr)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a810d1e6cf5525f90041da212f6189e89" id="r_a810d1e6cf5525f90041da212f6189e89"><td class="memItemLeft" align="right" valign="top">const std::unique_ptr&lt; <a class="el" href="class_addr_man_impl.html">AddrManImpl</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a810d1e6cf5525f90041da212f6189e89">m_impl</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stochastic address manager</p>
<p>Design goals:</p><ul>
<li>Keep the address tables in-memory, and asynchronously dump the entire table to peers.dat.</li>
<li>Make sure no (localized) attacker can fill the entire table with his nodes/addresses.</li>
</ul>
<p>To that end:</p><ul>
<li>Addresses are organized into buckets that can each store up to 64 entries.<ul>
<li>Addresses to which our node has not successfully connected go into 1024 "new" buckets.<ul>
<li>Based on the address range (/16 for IPv4) of the source of information, or if an asmap is provided, the AS it belongs to (for IPv4/IPv6), 64 buckets are selected at random.</li>
<li>The actual bucket is chosen from one of these, based on the range in which the address itself is located.</li>
<li>The position in the bucket is chosen based on the full address.</li>
<li>One single address can occur in up to 8 different buckets to increase selection chances for addresses that are seen frequently. The chance for increasing this multiplicity decreases exponentially.</li>
<li>When adding a new address to an occupied position of a bucket, it will not replace the existing entry unless that address is also stored in another bucket or it doesn't meet one of several quality criteria (see IsTerrible for exact criteria).</li>
</ul>
</li>
<li>Addresses of nodes that are known to be accessible go into 256 "tried" buckets.<ul>
<li>Each address range selects at random 8 of these buckets.</li>
<li>The actual bucket is chosen from one of these, based on the full address.</li>
<li>When adding a new good address to an occupied position of a bucket, a FEELER connection to the old address is attempted. The old entry is only replaced and moved back to the "new" buckets if this attempt was unsuccessful.</li>
</ul>
</li>
<li>Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not be observable by adversaries.</li>
<li>Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman configuration option will introduce (expensive) consistency checks for the entire data structure. </li>
</ul>
</li>
</ul>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b6cb9872d13a1e3d821f9b17a8b6db6" name="a4b6cb9872d13a1e3d821f9b17a8b6db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6cb9872d13a1e3d821f9b17a8b6db6">&#9670;&#160;</a></span>AddrMan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_addr_man.html">AddrMan</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_net_group_manager.html">NetGroupManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>netgroupman</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deterministic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>consistency_check_ratio</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae269a6c335d01a48a541f6d7e3b0ecbf" name="ae269a6c335d01a48a541f6d7e3b0ecbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae269a6c335d01a48a541f6d7e3b0ecbf">&#9670;&#160;</a></span>~AddrMan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_addr_man.html">AddrMan</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="af0acda4d7598ebd2cb76c8ee97ee845f" name="af0acda4d7598ebd2cb76c8ee97ee845f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0acda4d7598ebd2cb76c8ee97ee845f">&#9670;&#160;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_c_address.html">CAddress</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vAddr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_net_addr.html">CNetAddr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::seconds</td>          <td class="paramname"><span class="paramname"><em>time_penalty</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0s</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to add one or more addresses to addrman's new table. If an address already exists in addrman, the existing entry may be updated (e.g. adding additional service flags). If the existing entry is in the new table, it may be added to more buckets, improving the probability of selection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vAddr</td><td>Address records to attempt to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The address of the node that sent us these addr records. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_penalty</td><td>A "time penalty" to apply to the address record's nTime. If a peer sends us an address record with nTime=n, then we'll add it to our addrman with nTime=(n - time_penalty). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one address is successfully added, or added to an additional bucket. Unaffected by updates. </dd></dl>

</div>
</div>
<a id="af610ed4d0bc8631426d628c08c392585" name="af610ed4d0bc8631426d628c08c392585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af610ed4d0bc8631426d628c08c392585">&#9670;&#160;</a></span>Attempt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Attempt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_service.html">CService</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fCountFailure</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="util_2time_8h.html#a7a4e7e09a41ff922cf1eb6fdaae4b3ba">Now</a>&lt;<a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a>&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark an entry as connection attempted to. </p>

</div>
</div>
<a id="a5db77c65bd764c01b128936f2dcca9ef" name="a5db77c65bd764c01b128936f2dcca9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db77c65bd764c01b128936f2dcca9ef">&#9670;&#160;</a></span>Connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_service.html">CService</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="util_2time_8h.html#a7a4e7e09a41ff922cf1eb6fdaae4b3ba">Now</a>&lt;<a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a>&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have successfully connected to this peer. Calling this function updates the <a class="el" href="class_c_address.html">CAddress</a>'s nTime, which is used in our IsTerrible() decisions and gossiped to peers. Callers should be careful that updating this information doesn't leak topology information to network spies.</p>
<p>net_processing calls this function when it <em>disconnects</em> from a peer to not leak information about currently connected peers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address of the peer we were connected to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time that we were last connected to this peer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f01245c5edff531298e93e6ed69d42" name="ae6f01245c5edff531298e93e6ed69d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f01245c5edff531298e93e6ed69d42">&#9670;&#160;</a></span>FindAddressEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="struct_address_position.html">AddressPosition</a> &gt; FindAddressEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_address.html">CAddress</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test-only function Find the address record in <a class="el" href="class_addr_man.html">AddrMan</a> and return information about its position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The address record to look up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about the address record in <a class="el" href="class_addr_man.html">AddrMan</a> or nullopt if address is not found. </dd></dl>

</div>
</div>
<a id="ab64d634410f099e19c2f2b6b83876118" name="ab64d634410f099e19c2f2b6b83876118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64d634410f099e19c2f2b6b83876118">&#9670;&#160;</a></span>GetAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_c_address.html">CAddress</a> &gt; GetAddr </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_addresses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_pct</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="netaddress_8h.html#acc9a38c714afe79b5035cb36f560dac3">Network</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>network</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>filtered</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return all or many randomly selected addresses, optionally by network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_addresses</td><td>Maximum number of addresses to return (0 = all). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_pct</td><td>Maximum percentage of addresses to return (0 = all). Value must be from 0 to 100. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">network</td><td>Select only addresses of this network (nullopt = all). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filtered</td><td>Select only addresses that are considered good quality (false = all).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of randomly selected addresses from vRandom. </dd></dl>

</div>
</div>
<a id="ae18710a592d984080a6b29c9965b7418" name="ae18710a592d984080a6b29c9965b7418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18710a592d984080a6b29c9965b7418">&#9670;&#160;</a></span>GetEntries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="class_addr_info.html">AddrInfo</a>, <a class="el" href="struct_address_position.html">AddressPosition</a> &gt; &gt; GetEntries </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>from_tried</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an information-location pair for all addresses in the selected addrman table. If an address appears multiple times in the new table, an information-location pair is returned for each occurrence. Addresses only ever appear once in the tried table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_tried</td><td>Selects which table to return entries from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector consisting of pairs of <a class="el" href="class_addr_info.html">AddrInfo</a> and <a class="el" href="struct_address_position.html">AddressPosition</a>. </dd></dl>

</div>
</div>
<a id="a706c1c1b34e109a4c2e5310b15a72c4d" name="a706c1c1b34e109a4c2e5310b15a72c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706c1c1b34e109a4c2e5310b15a72c4d">&#9670;&#160;</a></span>Good()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Good </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_service.html">CService</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="util_2time_8h.html#a7a4e7e09a41ff922cf1eb6fdaae4b3ba">Now</a>&lt;<a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a>&gt;()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark an address record as accessible and attempt to move it to addrman's tried table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address record to attempt to move to tried table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time</td><td>The time that we were last connected to this peer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the address is successfully moved from the new table to the tried table. </dd></dl>

</div>
</div>
<a id="a15574032976f63a21b1781d0ed08d75b" name="a15574032976f63a21b1781d0ed08d75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15574032976f63a21b1781d0ed08d75b">&#9670;&#160;</a></span>ResolveCollisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ResolveCollisions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if any to-be-evicted tried table entries have been tested and if so resolve the collisions. </p>

</div>
</div>
<a id="aef855c09bfa93ccd88508eaf73d5bc74" name="aef855c09bfa93ccd88508eaf73d5bc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef855c09bfa93ccd88508eaf73d5bc74">&#9670;&#160;</a></span>Select()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_address.html">CAddress</a>, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt; Select </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; <a class="el" href="netaddress_8h.html#acc9a38c714afe79b5035cb36f560dac3">Network</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>networks</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose an address to connect to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_only</td><td>Whether to only select addresses from the new table. Passing <span class="tt">true</span> returns an address from the new table or an empty pair. Passing <span class="tt">false</span> will return an empty pair or an address from either the new or tried table (it does not guarantee a tried entry). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">networks</td><td>Select only addresses of these networks (empty = all). Passing networks may slow down the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_c_address.html">CAddress</a> The record for the selected peer. seconds The last time we attempted to connect to that peer. </dd></dl>

</div>
</div>
<a id="af0fc23fd56fa4cfc1327991984fb9389" name="af0fc23fd56fa4cfc1327991984fb9389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fc23fd56fa4cfc1327991984fb9389">&#9670;&#160;</a></span>SelectTriedCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="class_c_address.html">CAddress</a>, <a class="el" href="util_2time_8h.html#a8f3f2401a7990dfdbcf694471e95fb1e">NodeSeconds</a> &gt; SelectTriedCollision </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Randomly select an address in the tried table that another address is attempting to evict.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_c_address.html">CAddress</a> The record for the selected tried peer. seconds The last time we attempted to connect to that peer. </dd></dl>

</div>
</div>
<a id="ae7b340a1417273fa5fb4dd89b68e90a5" name="ae7b340a1417273fa5fb4dd89b68e90a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b340a1417273fa5fb4dd89b68e90a5">&#9670;&#160;</a></span>Serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void Serialize </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;</td>          <td class="paramname"><span class="paramname"><em>s_</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b0d0a32c294a075972d91681ed918fb" name="a0b0d0a32c294a075972d91681ed918fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0d0a32c294a075972d91681ed918fb">&#9670;&#160;</a></span>SetServices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetServices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_service.html">CService</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="protocol_8h.html#ad131f3177584caea787cdbf6f85a9537">ServiceFlags</a></td>          <td class="paramname"><span class="paramname"><em>nServices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update an entry's service bits. </p>

</div>
</div>
<a id="ad14483585857cd4336e052ecdea6eb92" name="ad14483585857cd4336e052ecdea6eb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14483585857cd4336e052ecdea6eb92">&#9670;&#160;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Size </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; <a class="el" href="netaddress_8h.html#acc9a38c714afe79b5035cb36f560dac3">Network</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>net</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; bool &gt;</td>          <td class="paramname"><span class="paramname"><em>in_new</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::nullopt</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return size information about addrman.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">net</td><td>Select addresses only from specified network (nullopt = all) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_new</td><td>Select addresses only from one table (true = new, false = tried, nullopt = both) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unique addresses that match specified options. </dd></dl>

</div>
</div>
<a id="ab646bc9d141d8c4971fa522a73677586" name="ab646bc9d141d8c4971fa522a73677586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab646bc9d141d8c4971fa522a73677586">&#9670;&#160;</a></span>Unserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stream&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void Unserialize </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;</td>          <td class="paramname"><span class="paramname"><em>s_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a810d1e6cf5525f90041da212f6189e89" name="a810d1e6cf5525f90041da212f6189e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810d1e6cf5525f90041da212f6189e89">&#9670;&#160;</a></span>m_impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unique_ptr&lt;<a class="el" href="class_addr_man_impl.html">AddrManImpl</a>&gt; m_impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="addrman_8h_source.html">addrman.h</a></li>
<li>src/<a class="el" href="addrman_8cpp.html">addrman.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_addr_man.html">AddrMan</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
