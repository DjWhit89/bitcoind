<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bitcoind: HeadersSyncState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="bitcoin.ico"/></td>
  <td id="projectalign">
   <div id="projectname">bitcoind<span id="projectnumber">&#160;2.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_headers_sync_state.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">HeadersSyncState Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="headerssync_8h_source.html">headerssync.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for HeadersSyncState:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_headers_sync_state.png" usemap="#HeadersSyncState_map" alt=""/>
  <map id="HeadersSyncState_map" name="HeadersSyncState_map">
<area href="class_fuzzed_headers_sync_state.html" alt="FuzzedHeadersSyncState" shape="rect" coords="0,56,158,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:ProcessingResult" id="r_ProcessingResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_headers_sync_state_1_1_processing_result.html">ProcessingResult</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5d74787dedbc4e11c1ab15bf487e61f8" id="r_a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> { <a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8ac7b4faed4767142023121f8faacef9fa">PRESYNC</a>
, <a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8acc314a5a286af9c5faefcdd8fa5f8a1f">REDOWNLOAD</a>
, <a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8a6c8361dc2036c0559376fe4957699f69">FINAL</a>
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aead457f323e9312e44673a1837abf705" id="r_aead457f323e9312e44673a1837abf705"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead457f323e9312e44673a1837abf705">~HeadersSyncState</a> ()=default</td></tr>
<tr class="memitem:affcd8c8b4f9cd82f29ce903bee82d622" id="r_affcd8c8b4f9cd82f29ce903bee82d622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcd8c8b4f9cd82f29ce903bee82d622">GetState</a> () const</td></tr>
<tr class="memitem:a57884de72372d959f39a3110123e419f" id="r_a57884de72372d959f39a3110123e419f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57884de72372d959f39a3110123e419f">GetPresyncHeight</a> () const</td></tr>
<tr class="memitem:ae696375936b0658e352ebcb824b91ae5" id="r_ae696375936b0658e352ebcb824b91ae5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae696375936b0658e352ebcb824b91ae5">GetPresyncTime</a> () const</td></tr>
<tr class="memitem:a1bcb794b07d97b08d45420e40589e5b4" id="r_a1bcb794b07d97b08d45420e40589e5b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarith__uint256.html">arith_uint256</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bcb794b07d97b08d45420e40589e5b4">GetPresyncWork</a> () const</td></tr>
<tr class="memitem:a9ef34f87a3e2aa8d73b928fa9f3b1911" id="r_a9ef34f87a3e2aa8d73b928fa9f3b1911"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ef34f87a3e2aa8d73b928fa9f3b1911">HeadersSyncState</a> (<a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a> id, const <a class="el" href="struct_consensus_1_1_params.html">Consensus::Params</a> &amp;consensus_params, const <a class="el" href="struct_headers_sync_params.html">HeadersSyncParams</a> &amp;params, const <a class="el" href="class_c_block_index.html">CBlockIndex</a> *chain_start, const <a class="el" href="classarith__uint256.html">arith_uint256</a> &amp;minimum_required_work)</td></tr>
<tr class="memitem:a0e12375af6318f0729742c2fde2e7294" id="r_a0e12375af6318f0729742c2fde2e7294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_headers_sync_state_1_1_processing_result.html">ProcessingResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e12375af6318f0729742c2fde2e7294">ProcessNextHeaders</a> (std::span&lt; const <a class="el" href="class_c_block_header.html">CBlockHeader</a> &gt; received_headers, bool full_headers_message)</td></tr>
<tr class="memitem:ac7f7cda8eb56d220ef54951c6cebcb2e" id="r_ac7f7cda8eb56d220ef54951c6cebcb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_c_block_locator.html">CBlockLocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f7cda8eb56d220ef54951c6cebcb2e">NextHeadersRequestLocator</a> () const</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a840e4da6e13976dfabe46b044e3b1738" id="r_a840e4da6e13976dfabe46b044e3b1738"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840e4da6e13976dfabe46b044e3b1738">m_commit_offset</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_headers_sync_state.html">HeadersSyncState</a>:</p>
<p>We wish to download a peer's headers chain in a DoS-resistant way.</p>
<p>The Bitcoin protocol does not offer an easy way to determine the work on a peer's chain. Currently, we can query a peer's headers by using a GETHEADERS message, and our peer can return a set of up to 2000 headers that connect to something we know. If a peer's chain has more than 2000 blocks, then we need a way to verify that the chain actually has enough work on it to be useful to us &ndash; by being above our anti-DoS minimum-chain-work threshold &ndash; before we commit to storing those headers in memory. Otherwise, it would be cheap for an attacker to waste all our memory by serving us low-work headers (particularly for a new node coming online for the first time).</p>
<p>To prevent memory-DoS with low-work headers, while still always being able to reorg to whatever the most-work chain is, we require that a chain meet a work threshold before committing it to memory. We can do this by downloading a peer's headers twice, whenever we are not sure that the chain has sufficient work:</p>
<ul>
<li>In the first download phase, called pre-synchronization, we can calculate the work on the chain as we go (just by checking the nBits value on each header, and validating the proof-of-work).</li>
<li>Once we have reached a header where the cumulative chain work is sufficient, we switch to downloading the headers a second time, this time processing them fully, and possibly storing them in memory.</li>
</ul>
<p>To prevent an attacker from using (eg) the honest chain to convince us that they have a high-work chain, but then feeding us an alternate set of low-difficulty headers in the second phase, we store commitments to the chain we see in the first download phase that we check in the second phase, as follows:</p>
<ul>
<li>In phase 1 (presync), store 1 bit (using a salted hash function) for every N headers that we see. With a reasonable choice of N, this uses relatively little memory even for a very long chain.</li>
<li>In phase 2 (redownload), keep a lookahead buffer and only accept headers from that buffer into the block index (permanent memory usage) once they have some target number of verified commitments on top of them. With this parametrization, we can achieve a given security target for potential permanent memory usage, while choosing N to minimize memory use during the sync (temporary, per-peer storage). </li>
</ul>
</div><a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a5d74787dedbc4e11c1ab15bf487e61f8" name="a5d74787dedbc4e11c1ab15bf487e61f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d74787dedbc4e11c1ab15bf487e61f8">&#9670;&#160;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8">State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8ac7b4faed4767142023121f8faacef9fa" name="a5d74787dedbc4e11c1ab15bf487e61f8ac7b4faed4767142023121f8faacef9fa"></a>PRESYNC&#160;</td><td class="fielddoc"><p>PRESYNC means the peer has not yet demonstrated their chain has sufficient work and we're only building commitments to the chain they serve us. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8acc314a5a286af9c5faefcdd8fa5f8a1f" name="a5d74787dedbc4e11c1ab15bf487e61f8acc314a5a286af9c5faefcdd8fa5f8a1f"></a>REDOWNLOAD&#160;</td><td class="fielddoc"><p>REDOWNLOAD means the peer has given us a high-enough-work chain, and now we're redownloading the headers we saw before and trying to accept them </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a6c8361dc2036c0559376fe4957699f69" name="a5d74787dedbc4e11c1ab15bf487e61f8a6c8361dc2036c0559376fe4957699f69"></a>FINAL&#160;</td><td class="fielddoc"><p>We're done syncing with this peer and can discard any remaining state </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aead457f323e9312e44673a1837abf705" name="aead457f323e9312e44673a1837abf705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead457f323e9312e44673a1837abf705">&#9670;&#160;</a></span>~HeadersSyncState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_headers_sync_state.html">HeadersSyncState</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ef34f87a3e2aa8d73b928fa9f3b1911" name="a9ef34f87a3e2aa8d73b928fa9f3b1911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef34f87a3e2aa8d73b928fa9f3b1911">&#9670;&#160;</a></span>HeadersSyncState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_headers_sync_state.html">HeadersSyncState</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="net_8h.html#aa637b11e18b77724b35db2229cd12788">NodeId</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_consensus_1_1_params.html">Consensus::Params</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>consensus_params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_headers_sync_params.html">HeadersSyncParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_block_index.html">CBlockIndex</a> *</td>          <td class="paramname"><span class="paramname"><em>chain_start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classarith__uint256.html">arith_uint256</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>minimum_required_work</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="class_headers_sync_state.html">HeadersSyncState</a> object representing a headers sync via this download-twice mechanism).</p>
<p>id: node id (for logging) consensus_params: parameters needed for difficulty adjustment validation chain_start: best known fork point that the peer's headers branch from minimum_required_work: amount of chain work required to accept the chain </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a57884de72372d959f39a3110123e419f" name="a57884de72372d959f39a3110123e419f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57884de72372d959f39a3110123e419f">&#9670;&#160;</a></span>GetPresyncHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t GetPresyncHeight </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the height reached during the PRESYNC phase </p>

</div>
</div>
<a id="ae696375936b0658e352ebcb824b91ae5" name="ae696375936b0658e352ebcb824b91ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae696375936b0658e352ebcb824b91ae5">&#9670;&#160;</a></span>GetPresyncTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t GetPresyncTime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the block timestamp of the last header received during the PRESYNC phase. </p>

</div>
</div>
<a id="a1bcb794b07d97b08d45420e40589e5b4" name="a1bcb794b07d97b08d45420e40589e5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bcb794b07d97b08d45420e40589e5b4">&#9670;&#160;</a></span>GetPresyncWork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarith__uint256.html">arith_uint256</a> GetPresyncWork </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the amount of work in the chain received during the PRESYNC phase. </p>

</div>
</div>
<a id="affcd8c8b4f9cd82f29ce903bee82d622" name="affcd8c8b4f9cd82f29ce903bee82d622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcd8c8b4f9cd82f29ce903bee82d622">&#9670;&#160;</a></span>GetState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> GetState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the current state of our download </p>

</div>
</div>
<a id="ac7f7cda8eb56d220ef54951c6cebcb2e" name="ac7f7cda8eb56d220ef54951c6cebcb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f7cda8eb56d220ef54951c6cebcb2e">&#9670;&#160;</a></span>NextHeadersRequestLocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_c_block_locator.html">CBlockLocator</a> NextHeadersRequestLocator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issue the next GETHEADERS message to our peer.</p>
<p>This will return a locator appropriate for the current sync object, to continue the synchronization phase it is in. </p>

</div>
</div>
<a id="a0e12375af6318f0729742c2fde2e7294" name="a0e12375af6318f0729742c2fde2e7294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e12375af6318f0729742c2fde2e7294">&#9670;&#160;</a></span>ProcessNextHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_headers_sync_state_1_1_processing_result.html">HeadersSyncState::ProcessingResult</a> ProcessNextHeaders </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; const <a class="el" href="class_c_block_header.html">CBlockHeader</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>received_headers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>full_headers_message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a batch of headers, once a sync via this mechanism has started</p>
<p>received_headers: headers that were received over the network for processing. Assumes the caller has already verified the headers are continuous, and has checked that each header satisfies the proof-of-work target included in the header (but not necessarily verified that the proof-of-work target is correct and passes consensus rules). full_headers_message: true if the message was at max capacity, indicating more headers may be available <a class="el" href="struct_headers_sync_state_1_1_processing_result.html#a9c35a329ec17ebcbece028b7cc1e9d1e">ProcessingResult.pow_validated_headers</a>: will be filled in with any headers that the caller can fully process and validate now (because these returned headers are on a chain with sufficient work) <a class="el" href="struct_headers_sync_state_1_1_processing_result.html#a7960f9c558f9ee2c3d4a8fdea096fb56">ProcessingResult.success</a>: set to false if an error is detected and the sync is aborted; true otherwise. <a class="el" href="struct_headers_sync_state_1_1_processing_result.html#a360c8f164bde96ae04a0106b65ab4a3f">ProcessingResult.request_more</a>: if true, the caller is suggested to call NextHeadersRequestLocator and send a getheaders message using it.</p>
<p>Process the next batch of headers received from our peer. Validate and store commitments, and compare total chainwork to our target to see if we can switch to REDOWNLOAD mode. </p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a840e4da6e13976dfabe46b044e3b1738" name="a840e4da6e13976dfabe46b044e3b1738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840e4da6e13976dfabe46b044e3b1738">&#9670;&#160;</a></span>m_commit_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t m_commit_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (secret) offset on the heights for which to create commitments.</p>
<p>m_header_commitments entries are created at any height h for which (h % m_params.commitment_period) == m_commit_offset. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="headerssync_8h_source.html">headerssync.h</a></li>
<li>src/<a class="el" href="headerssync_8cpp.html">headerssync.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="class_headers_sync_state.html">HeadersSyncState</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
