\doxysection{Dyn\+Sock Class Reference}
\label{class_dyn_sock}\index{DynSock@{DynSock}}


{\ttfamily \#include $<$net.\+h$>$}

Inheritance diagram for Dyn\+Sock\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_dyn_sock}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Pipe}
\item 
struct \textbf{ Pipes}
\item 
class \textbf{ Queue}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Dyn\+Sock} (std\+::shared\+\_\+ptr$<$ \textbf{ Pipes} $>$ pipes, std\+::shared\+\_\+ptr$<$ \textbf{ Queue} $>$ accept\+\_\+sockets)
\item 
\textbf{ $\sim$\+Dyn\+Sock} ()
\item 
ssize\+\_\+t \textbf{ Recv} (void $\ast$buf, size\+\_\+t len, int \textbf{ flags}) const override
\item 
ssize\+\_\+t \textbf{ Send} (const void $\ast$buf, size\+\_\+t len, int) const override
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ \textbf{ Accept} (sockaddr $\ast$addr, socklen\+\_\+t $\ast$addr\+\_\+len) const override
\item 
bool \textbf{ Wait} (std\+::chrono\+::milliseconds timeout, \textbf{ Event} requested, \textbf{ Event} $\ast$occurred=nullptr) const override
\item 
bool \textbf{ Wait\+Many} (std\+::chrono\+::milliseconds timeout, \textbf{ Events\+Per\+Sock} \&events\+\_\+per\+\_\+sock) const override
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Zero\+Sock}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Zero\+Sock} ()
\item 
\textbf{ $\sim$\+Zero\+Sock} () override
\item 
ssize\+\_\+t \textbf{ Send} (const void $\ast$, size\+\_\+t len, int) const override
\item 
ssize\+\_\+t \textbf{ Recv} (void $\ast$buf, size\+\_\+t len, int \textbf{ flags}) const override
\item 
int \textbf{ Connect} (const sockaddr $\ast$, socklen\+\_\+t) const override
\item 
int \textbf{ Bind} (const sockaddr $\ast$, socklen\+\_\+t) const override
\item 
int \textbf{ Listen} (int) const override
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ \textbf{ Accept} (sockaddr $\ast$addr, socklen\+\_\+t $\ast$addr\+\_\+len) const override
\item 
int \textbf{ Get\+Sock\+Opt} (int level, int opt\+\_\+name, void $\ast$opt\+\_\+val, socklen\+\_\+t $\ast$opt\+\_\+len) const override
\item 
int \textbf{ Set\+Sock\+Opt} (int, int, const void $\ast$, socklen\+\_\+t) const override
\item 
int \textbf{ Get\+Sock\+Name} (sockaddr $\ast$\textbf{ name}, socklen\+\_\+t $\ast$name\+\_\+len) const override
\item 
bool \textbf{ Set\+Non\+Blocking} () const override
\item 
bool \textbf{ Is\+Selectable} () const override
\item 
bool \textbf{ Wait} (std\+::chrono\+::milliseconds timeout, \textbf{ Event} requested, \textbf{ Event} $\ast$occurred=nullptr) const override
\item 
bool \textbf{ Wait\+Many} (std\+::chrono\+::milliseconds timeout, \textbf{ Events\+Per\+Sock} \&events\+\_\+per\+\_\+sock) const override
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Sock} ()=delete
\item 
\textbf{ Sock} (\textbf{ SOCKET} s)
\item 
\textbf{ Sock} (const \textbf{ Sock} \&)=delete
\item 
\textbf{ Sock} (\textbf{ Sock} \&\&other)
\item 
virtual \textbf{ $\sim$\+Sock} ()
\item 
\textbf{ Sock} \& \textbf{ operator=} (const \textbf{ Sock} \&)=delete
\item 
virtual void \textbf{ Send\+Complete} (std\+::span$<$ const unsigned char $>$ data, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt) const
\item 
virtual void \textbf{ Send\+Complete} (std\+::span$<$ const char $>$ data, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt) const
\item 
virtual std\+::string \textbf{ Recv\+Until\+Terminator} (uint8\+\_\+t terminator, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt, size\+\_\+t max\+\_\+data) const
\item 
virtual bool \textbf{ Is\+Connected} (std\+::string \&errmsg) const
\item 
bool \textbf{ operator==} (\textbf{ SOCKET} s) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Event} = uint8\+\_\+t
\item 
using \textbf{ Events\+Per\+Sock} = std\+::unordered\+\_\+map$<$std\+::shared\+\_\+ptr$<$const \textbf{ Sock}$>$, \textbf{ Events}, \textbf{ Hash\+Shared\+Ptr\+Sock}, \textbf{ Equal\+Shared\+Ptr\+Sock}$>$
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
static constexpr \textbf{ Event} \textbf{ RECV} = 0b001
\item 
static constexpr \textbf{ Event} \textbf{ SEND} = 0b010
\item 
static constexpr \textbf{ Event} \textbf{ ERR} = 0b100
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
\textbf{ SOCKET} \textbf{ m\+\_\+socket}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A mocked \doxyref{Sock}{p.}{class_sock} alternative that allows providing the data to be returned by \doxyref{Recv()}{p.}{class_dyn_sock_acc57da900d09bf26675b155ff9f4ac89} and inspecting the data that has been supplied to \doxyref{Send()}{p.}{class_dyn_sock_a91f43a08763aa3988637e9242bc1219f}. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{DynSock@{DynSock}!DynSock@{DynSock}}
\index{DynSock@{DynSock}!DynSock@{DynSock}}
\doxysubsubsection{DynSock()}
{\footnotesize\ttfamily \label{class_dyn_sock_a4eb9d1799da10d0a13739c7b98b62559} 
\textbf{ Dyn\+Sock} (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \textbf{ Pipes} $>$}]{pipes}{, }\item[{std\+::shared\+\_\+ptr$<$ \textbf{ Queue} $>$}]{accept\+\_\+sockets}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

Create a new mocked sock. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em pipes} & Send/recv pipes used by the \doxyref{Send()}{p.}{class_dyn_sock_a91f43a08763aa3988637e9242bc1219f} and \doxyref{Recv()}{p.}{class_dyn_sock_acc57da900d09bf26675b155ff9f4ac89} methods. \\
\hline
\mbox{\texttt{in}}  & {\em accept\+\_\+sockets} & Sockets to return by the \doxyref{Accept()}{p.}{class_dyn_sock_a36b4abe351193181c883d465020aa101} method. \\
\hline
\end{DoxyParams}
\index{DynSock@{DynSock}!````~DynSock@{$\sim$DynSock}}
\index{````~DynSock@{$\sim$DynSock}!DynSock@{DynSock}}
\doxysubsubsection{$\sim$DynSock()}
{\footnotesize\ttfamily \label{class_dyn_sock_add4890d12ff2543da388315428c23f7f} 
$\sim$\textbf{ Dyn\+Sock} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{DynSock@{DynSock}!Accept@{Accept}}
\index{Accept@{Accept}!DynSock@{DynSock}}
\doxysubsubsection{Accept()}
{\footnotesize\ttfamily \label{class_dyn_sock_a36b4abe351193181c883d465020aa101} 
std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ Accept (\begin{DoxyParamCaption}\item[{sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t $\ast$}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

accept(2) wrapper. Equivalent to {\ttfamily std\+::make\+\_\+unique$<$\doxyref{Sock}{p.}{class_sock}$>$(accept(m\+\_\+socket, addr, addr\+\_\+len))}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. The returned unique\+\_\+ptr is empty if {\ttfamily accept()} failed in which case errno will be set. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a0478fe1f85686563dafce68f30878fa6}.

\index{DynSock@{DynSock}!Recv@{Recv}}
\index{Recv@{Recv}!DynSock@{DynSock}}
\doxysubsubsection{Recv()}
{\footnotesize\ttfamily \label{class_dyn_sock_acc57da900d09bf26675b155ff9f4ac89} 
ssize\+\_\+t Recv (\begin{DoxyParamCaption}\item[{void $\ast$}]{buf}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

recv(2) wrapper. Equivalent to {\ttfamily recv(m\+\_\+socket, buf, len, flags);}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_ad5d478226aba69810d73757744e13317}.

\index{DynSock@{DynSock}!Send@{Send}}
\index{Send@{Send}!DynSock@{DynSock}}
\doxysubsubsection{Send()}
{\footnotesize\ttfamily \label{class_dyn_sock_a91f43a08763aa3988637e9242bc1219f} 
ssize\+\_\+t Send (\begin{DoxyParamCaption}\item[{const void $\ast$}]{data}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

send(2) wrapper. Equivalent to {\ttfamily send(m\+\_\+socket, data, len, flags);}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_ad50f4b43d2b968d64162193e9254d6b5}.

\index{DynSock@{DynSock}!Wait@{Wait}}
\index{Wait@{Wait}!DynSock@{DynSock}}
\doxysubsubsection{Wait()}
{\footnotesize\ttfamily \label{class_dyn_sock_aa9d44903b57505d9f8765404cb04f35f} 
bool Wait (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ Event}}]{requested}{, }\item[{\textbf{ Event} $\ast$}]{occurred}{ = {\ttfamily nullptr}}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Wait for readiness for input (recv) or output (send). 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em timeout} & Wait this much for at least one of the requested events to occur. \\
\hline
\mbox{\texttt{in}}  & {\em requested} & Wait for those events, bitwise-\/or of {\ttfamily \doxyref{RECV}{p.}{class_sock_ae15d539512bccb6583fc75310b0d2f86}} and {\ttfamily \doxyref{SEND}{p.}{class_sock_ac739f9398eaa67718961a5ac331fba4a}}. \\
\hline
\mbox{\texttt{out}}  & {\em occurred} & If not nullptr and the function returns {\ttfamily true}, then this indicates which of the requested events occurred ({\ttfamily \doxyref{ERR}{p.}{class_sock_a2d9bf7f3d9855e98e28b9224cab3920e}} will be added, even if not requested, if an exceptional event occurs on the socket). A timeout is indicated by return value of {\ttfamily true} and {\ttfamily occurred} being set to 0. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success (or timeout, if {\ttfamily occurred} of 0 is returned), false otherwise 
\end{DoxyReturn}


Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a851a09613d347a157da032137020065a}.

\index{DynSock@{DynSock}!WaitMany@{WaitMany}}
\index{WaitMany@{WaitMany}!DynSock@{DynSock}}
\doxysubsubsection{WaitMany()}
{\footnotesize\ttfamily \label{class_dyn_sock_af35a7663942bba32c947f387114bc068} 
bool Wait\+Many (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ Events\+Per\+Sock} \&}]{events\+\_\+per\+\_\+sock}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Same as {\ttfamily \doxyref{Wait()}{p.}{class_dyn_sock_aa9d44903b57505d9f8765404cb04f35f}}, but wait on many sockets within the same timeout. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em timeout} & Wait this long for at least one of the requested events to occur. \\
\hline
\mbox{\texttt{in,out}}  & {\em events\+\_\+per\+\_\+sock} & Wait for the requested events on these sockets and set {\ttfamily occurred} for the events that actually occurred. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success (or timeout, if all {\ttfamily what[].occurred} are returned as 0), false otherwise 
\end{DoxyReturn}


Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a6ec7a34cbf87594ed9b7eac590cf965f}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/test/util/\textbf{ net.\+h}\item 
src/test/util/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
