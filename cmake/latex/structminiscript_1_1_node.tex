\doxysection{Node$<$ Key $>$ Struct Template Reference}
\label{structminiscript_1_1_node}\index{Node$<$ Key $>$@{Node$<$ Key $>$}}


A node in a miniscript expression.  




{\ttfamily \#include $<$miniscript.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ $\sim$\+Node} ()
\item 
\textbf{ Node\+Ref}$<$ Key $>$ \textbf{ Clone} () const
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ CScript} \textbf{ To\+Script} (const Ctx \&ctx) const
\item 
{\footnotesize template$<$typename CTx$>$ }\\std\+::optional$<$ std\+::string $>$ \textbf{ To\+String} (const CTx \&ctx) const
\item 
{\footnotesize template$<$typename Ctx$>$ }\\void \textbf{ Duplicate\+Key\+Check} (const Ctx \&ctx) const
\item 
size\+\_\+t \textbf{ Script\+Size} () const
\begin{DoxyCompactList}\small\item\em Return the size of the script for this expression (faster than \doxyref{To\+Script()}{p.}{structminiscript_1_1_node_ab2938b96153475bc06ad4a5c4e0e697f}.size()). \end{DoxyCompactList}\item 
std\+::optional$<$ uint32\+\_\+t $>$ \textbf{ Get\+Ops} () const
\begin{DoxyCompactList}\small\item\em Return the maximum number of ops needed to satisfy this script non-\/malleably. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ Get\+Static\+Ops} () const
\begin{DoxyCompactList}\small\item\em Return the number of ops in the script (not counting the dynamic ones that depend on execution). \end{DoxyCompactList}\item 
bool \textbf{ Check\+Ops\+Limit} () const
\begin{DoxyCompactList}\small\item\em Check the ops limit of this script against the consensus limit. \end{DoxyCompactList}\item 
bool \textbf{ Is\+BKW} () const
\item 
std\+::optional$<$ uint32\+\_\+t $>$ \textbf{ Get\+Stack\+Size} () const
\item 
std\+::optional$<$ uint32\+\_\+t $>$ \textbf{ Get\+Exec\+Stack\+Size} () const
\begin{DoxyCompactList}\small\item\em Return the maximum size of the stack during execution of this script. \end{DoxyCompactList}\item 
bool \textbf{ Check\+Stack\+Size} () const
\begin{DoxyCompactList}\small\item\em Check the maximum stack size for this script against the policy limit. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Not\+Satisfiable} () const
\begin{DoxyCompactList}\small\item\em Whether no satisfaction exists for this node. \end{DoxyCompactList}\item 
std\+::optional$<$ uint32\+\_\+t $>$ \textbf{ Get\+Witness\+Size} () const
\item 
\textbf{ Type} \textbf{ Get\+Type} () const
\begin{DoxyCompactList}\small\item\em Return the expression type. \end{DoxyCompactList}\item 
\textbf{ Miniscript\+Context} \textbf{ Get\+Ms\+Ctx} () const
\begin{DoxyCompactList}\small\item\em Return the script context for this node. \end{DoxyCompactList}\item 
const \textbf{ Node} $\ast$ \textbf{ Find\+Insane\+Sub} () const
\begin{DoxyCompactList}\small\item\em Find an insane subnode which has no insane children. Nullptr if there is none. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F$>$ }\\bool \textbf{ Is\+Satisfiable} (F fn) const
\item 
bool \textbf{ Is\+Valid} () const
\begin{DoxyCompactList}\small\item\em Check whether this node is valid at all. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Valid\+Top\+Level} () const
\begin{DoxyCompactList}\small\item\em Check whether this node is valid as a script on its own. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Non\+Malleable} () const
\begin{DoxyCompactList}\small\item\em Check whether this script can always be satisfied in a non-\/malleable way. \end{DoxyCompactList}\item 
bool \textbf{ Needs\+Signature} () const
\begin{DoxyCompactList}\small\item\em Check whether this script always needs a signature. \end{DoxyCompactList}\item 
bool \textbf{ Check\+Time\+Locks\+Mix} () const
\begin{DoxyCompactList}\small\item\em Check whether there is no satisfaction path that contains both timelocks and heightlocks. \end{DoxyCompactList}\item 
bool \textbf{ Check\+Duplicate\+Key} () const
\begin{DoxyCompactList}\small\item\em Check whether there is no duplicate key across this fragment and all its sub-\/fragments. \end{DoxyCompactList}\item 
bool \textbf{ Valid\+Satisfactions} () const
\begin{DoxyCompactList}\small\item\em Whether successful non-\/malleable satisfactions are guaranteed to be valid. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Sane\+Subexpression} () const
\begin{DoxyCompactList}\small\item\em Whether the apparent policy of this node matches its script semantics. Doesn\textquotesingle{}t guarantee it is a safe script on its own. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Sane} () const
\begin{DoxyCompactList}\small\item\em Check whether this node is safe as a script on its own. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Availability} \textbf{ Satisfy} (const Ctx \&ctx, std\+::vector$<$ std\+::vector$<$ unsigned char $>$ $>$ \&stack, bool nonmalleable=true) const
\item 
bool \textbf{ operator==} (const \textbf{ Node}$<$ Key $>$ \&arg) const
\begin{DoxyCompactList}\small\item\em Equality testing. \end{DoxyCompactList}\item 
\textbf{ Node} (\textbf{ internal\+::\+No\+Dup\+Check}, \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ sub, std\+::vector$<$ unsigned char $>$ arg, uint32\+\_\+t val=0)
\item 
\textbf{ Node} (\textbf{ internal\+::\+No\+Dup\+Check}, \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ unsigned char $>$ arg, uint32\+\_\+t val=0)
\item 
\textbf{ Node} (\textbf{ internal\+::\+No\+Dup\+Check}, \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ sub, std\+::vector$<$ Key $>$ key, uint32\+\_\+t val=0)
\item 
\textbf{ Node} (\textbf{ internal\+::\+No\+Dup\+Check}, \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ Key $>$ key, uint32\+\_\+t val=0)
\item 
\textbf{ Node} (\textbf{ internal\+::\+No\+Dup\+Check}, \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ sub, uint32\+\_\+t val=0)
\item 
\textbf{ Node} (\textbf{ internal\+::\+No\+Dup\+Check}, \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, uint32\+\_\+t val=0)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node} (const Ctx \&ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ sub, std\+::vector$<$ unsigned char $>$ arg, uint32\+\_\+t val=0)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node} (const Ctx \&ctx, \textbf{ Fragment} nt, std\+::vector$<$ unsigned char $>$ arg, uint32\+\_\+t val=0)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node} (const Ctx \&ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ sub, std\+::vector$<$ Key $>$ key, uint32\+\_\+t val=0)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node} (const Ctx \&ctx, \textbf{ Fragment} nt, std\+::vector$<$ Key $>$ key, uint32\+\_\+t val=0)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node} (const Ctx \&ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ sub, uint32\+\_\+t val=0)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node} (const Ctx \&ctx, \textbf{ Fragment} nt, uint32\+\_\+t val=0)
\item 
\textbf{ Node} (const \textbf{ Node} \&)=delete
\item 
\textbf{ Node} \& \textbf{ operator=} (const \textbf{ Node} \&)=delete
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
const \textbf{ Fragment} \textbf{ fragment}
\begin{DoxyCompactList}\small\item\em What node type this node is. \end{DoxyCompactList}\item 
const uint32\+\_\+t \textbf{ k} = 0
\begin{DoxyCompactList}\small\item\em The k parameter (time for OLDER/\+AFTER, threshold for THRESH(\+\_\+\+M)). \end{DoxyCompactList}\item 
const std\+::vector$<$ Key $>$ \textbf{ keys}
\begin{DoxyCompactList}\small\item\em The keys used by this expression (only for PK\+\_\+\+K/\+PK\+\_\+\+H/\+MULTI). \end{DoxyCompactList}\item 
const std\+::vector$<$ unsigned char $>$ \textbf{ data}
\begin{DoxyCompactList}\small\item\em The data bytes in this expression (only for HASH160/\+HASH256/\+SHA256/\+RIPEMD10). \end{DoxyCompactList}\item 
std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ \textbf{ subs}
\begin{DoxyCompactList}\small\item\em Subexpressions (for WRAP\+\_\+$\ast$/\+AND\+\_\+$\ast$/\+OR\+\_\+$\ast$/\+ANDOR/\+THRESH). \end{DoxyCompactList}\item 
const \textbf{ Miniscript\+Context} \textbf{ m\+\_\+script\+\_\+ctx}
\begin{DoxyCompactList}\small\item\em The Script context for this node. Either P2\+WSH or Tapscript. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
int \textbf{ Compare} (const \textbf{ Node}$<$ Key $>$ \&node1, const \textbf{ Node}$<$ Key $>$ \&node2)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Key$>$\newline
struct miniscript\+::\+Node$<$ Key $>$}
A node in a miniscript expression. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Node$<$ Key $>$@{Node$<$ Key $>$}!````~Node@{$\sim$Node}}
\index{````~Node@{$\sim$Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{$\sim$Node()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a6fa6bf60f34f1e3efb0e59333428c9c8} 
template$<$typename Key$>$ \\
$\sim$\textbf{ Node} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [1/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a4b219c2e5ae5d34b12c591f201c26666} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{\textbf{ internal\+::\+No\+Dup\+Check}}]{}{, }\item[{\textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$}]{sub}{, }\item[{std\+::vector$<$ unsigned char $>$}]{arg}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [2/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ada7ba7f1e5e2c249c2944c9038809b0e} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{\textbf{ internal\+::\+No\+Dup\+Check}}]{}{, }\item[{\textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ unsigned char $>$}]{arg}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [3/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a1d2101a7a6a3e7b1fe49484ab964ea1d} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{\textbf{ internal\+::\+No\+Dup\+Check}}]{}{, }\item[{\textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$}]{sub}{, }\item[{std\+::vector$<$ Key $>$}]{key}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [4/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a3589858681304d34a704a44f597f68da} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{\textbf{ internal\+::\+No\+Dup\+Check}}]{}{, }\item[{\textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ Key $>$}]{key}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [5/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_afdab698c542d8359d5782c041259a537} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{\textbf{ internal\+::\+No\+Dup\+Check}}]{}{, }\item[{\textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$}]{sub}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [6/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a3f393a04424c1f73ed019a3bd1d84f08} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{\textbf{ internal\+::\+No\+Dup\+Check}}]{}{, }\item[{\textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [7/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a7c8af86a3885be191605336a433d3633} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$}]{sub}{, }\item[{std\+::vector$<$ unsigned char $>$}]{arg}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [8/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a82325fbac5e2fd3bb77f61e932daae2b} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ unsigned char $>$}]{arg}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [9/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a63387a1865e9253238f8cca61459ea2e} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$}]{sub}{, }\item[{std\+::vector$<$ Key $>$}]{key}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [10/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a5952dffa9ec541686643255300c30817} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ Key $>$}]{key}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [11/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a6e3a3154d9c69fc824194f005a7c59f3} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$}]{sub}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [12/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a3c310186fbba5e3e1012733ee763e49b} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{uint32\+\_\+t}]{val}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Node@{Node}}
\index{Node@{Node}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Node()\hspace{0.1cm}{\footnotesize\ttfamily [13/13]}}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a7eb6a9efa23e5f6f7fc53b5aa3759dff} 
template$<$typename Key$>$ \\
\textbf{ Node} (\begin{DoxyParamCaption}\item[{const \textbf{ Node}$<$ Key $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Node$<$ Key $>$@{Node$<$ Key $>$}!CheckDuplicateKey@{CheckDuplicateKey}}
\index{CheckDuplicateKey@{CheckDuplicateKey}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{CheckDuplicateKey()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a1638ccf52cbf03e69b5514a7d104cbc7} 
template$<$typename Key$>$ \\
bool Check\+Duplicate\+Key (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether there is no duplicate key across this fragment and all its sub-\/fragments. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!CheckOpsLimit@{CheckOpsLimit}}
\index{CheckOpsLimit@{CheckOpsLimit}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{CheckOpsLimit()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ac28a25665bd3969c7b1fade97a270ee4} 
template$<$typename Key$>$ \\
bool Check\+Ops\+Limit (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check the ops limit of this script against the consensus limit. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!CheckStackSize@{CheckStackSize}}
\index{CheckStackSize@{CheckStackSize}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{CheckStackSize()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a2c231d36817bd48bfb901a1ff2a8722f} 
template$<$typename Key$>$ \\
bool Check\+Stack\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check the maximum stack size for this script against the policy limit. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!CheckTimeLocksMix@{CheckTimeLocksMix}}
\index{CheckTimeLocksMix@{CheckTimeLocksMix}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{CheckTimeLocksMix()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a10e307578d2fd7d5e5fc182c6e184d49} 
template$<$typename Key$>$ \\
bool Check\+Time\+Locks\+Mix (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether there is no satisfaction path that contains both timelocks and heightlocks. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Clone@{Clone}}
\index{Clone@{Clone}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Clone()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a4408fb6a013e623a65bf533ed279c911} 
template$<$typename Key$>$ \\
\textbf{ Node\+Ref}$<$ Key $>$ Clone (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!DuplicateKeyCheck@{DuplicateKeyCheck}}
\index{DuplicateKeyCheck@{DuplicateKeyCheck}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{DuplicateKeyCheck()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a87339e026ad95c0b6eb21191dd9dfb90} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
void Duplicate\+Key\+Check (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Update duplicate key information in this \doxyref{Node}{p.}{structminiscript_1_1_node}.

This uses a custom key comparator provided by the context in order to still detect duplicates for more complicated types. \index{Node$<$ Key $>$@{Node$<$ Key $>$}!FindInsaneSub@{FindInsaneSub}}
\index{FindInsaneSub@{FindInsaneSub}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{FindInsaneSub()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a6dda2d73e4c81693560b0633350036b9} 
template$<$typename Key$>$ \\
const \textbf{ Node} $\ast$ Find\+Insane\+Sub (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Find an insane subnode which has no insane children. Nullptr if there is none. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetExecStackSize@{GetExecStackSize}}
\index{GetExecStackSize@{GetExecStackSize}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetExecStackSize()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a0bf56491026bfdbc156ce2e57ada57f9} 
template$<$typename Key$>$ \\
std\+::optional$<$ uint32\+\_\+t $>$ Get\+Exec\+Stack\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the maximum size of the stack during execution of this script. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetMsCtx@{GetMsCtx}}
\index{GetMsCtx@{GetMsCtx}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetMsCtx()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_abe8ef4d2999f892a0d870c57b534c055} 
template$<$typename Key$>$ \\
\textbf{ Miniscript\+Context} Get\+Ms\+Ctx (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the script context for this node. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetOps@{GetOps}}
\index{GetOps@{GetOps}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetOps()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a0a9db6592b82f9d69d4acb127410d609} 
template$<$typename Key$>$ \\
std\+::optional$<$ uint32\+\_\+t $>$ Get\+Ops (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the maximum number of ops needed to satisfy this script non-\/malleably. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetStackSize@{GetStackSize}}
\index{GetStackSize@{GetStackSize}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetStackSize()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a3789e80ac03925f25fd9e50863c77bdd} 
template$<$typename Key$>$ \\
std\+::optional$<$ uint32\+\_\+t $>$ Get\+Stack\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the maximum number of stack elements needed to satisfy this script non-\/malleably. \index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetStaticOps@{GetStaticOps}}
\index{GetStaticOps@{GetStaticOps}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetStaticOps()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ab063e6df9a865bebb9d0628dcc76ec6a} 
template$<$typename Key$>$ \\
uint32\+\_\+t Get\+Static\+Ops (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the number of ops in the script (not counting the dynamic ones that depend on execution). 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetType@{GetType}}
\index{GetType@{GetType}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetType()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a485decc00facb0972f8775a8a20851fa} 
template$<$typename Key$>$ \\
\textbf{ Type} Get\+Type (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the expression type. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!GetWitnessSize@{GetWitnessSize}}
\index{GetWitnessSize@{GetWitnessSize}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{GetWitnessSize()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_aa9f0388debbfa11172ac42063d26297e} 
template$<$typename Key$>$ \\
std\+::optional$<$ uint32\+\_\+t $>$ Get\+Witness\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the maximum size in bytes of a witness to satisfy this script non-\/malleably. Note this does not include the witness script push. \index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsBKW@{IsBKW}}
\index{IsBKW@{IsBKW}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsBKW()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a0c91af5704a6091119d93693f4bbb572} 
template$<$typename Key$>$ \\
bool Is\+BKW (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Whether this node is of type B, K or W. (That is, anything but V.) \index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsNonMalleable@{IsNonMalleable}}
\index{IsNonMalleable@{IsNonMalleable}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsNonMalleable()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_af3a29df350c041720c4383e911da4d77} 
template$<$typename Key$>$ \\
bool Is\+Non\+Malleable (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this script can always be satisfied in a non-\/malleable way. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsNotSatisfiable@{IsNotSatisfiable}}
\index{IsNotSatisfiable@{IsNotSatisfiable}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsNotSatisfiable()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_abac82e23c16bac172fd6a7641b1395b7} 
template$<$typename Key$>$ \\
bool Is\+Not\+Satisfiable (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Whether no satisfaction exists for this node. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsSane@{IsSane}}
\index{IsSane@{IsSane}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsSane()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_abc827be9cac583b83a1d379fe41961a9} 
template$<$typename Key$>$ \\
bool Is\+Sane (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this node is safe as a script on its own. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsSaneSubexpression@{IsSaneSubexpression}}
\index{IsSaneSubexpression@{IsSaneSubexpression}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsSaneSubexpression()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a8fe15bc71b77e0d1db3aa44ebea984b3} 
template$<$typename Key$>$ \\
bool Is\+Sane\+Subexpression (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Whether the apparent policy of this node matches its script semantics. Doesn\textquotesingle{}t guarantee it is a safe script on its own. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsSatisfiable@{IsSatisfiable}}
\index{IsSatisfiable@{IsSatisfiable}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsSatisfiable()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a2e63e2fb7fd702cd2caa25e3acd5f710} 
template$<$typename Key$>$ \\
template$<$typename F$>$ \\
bool Is\+Satisfiable (\begin{DoxyParamCaption}\item[{F}]{fn}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Determine whether a Miniscript node is satisfiable. fn(node) will be invoked for all key, time, and hashing nodes, and should return their satisfiability. \index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsValid@{IsValid}}
\index{IsValid@{IsValid}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsValid()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ac532c4b500b1a85ea22217f2c65a70ed} 
template$<$typename Key$>$ \\
bool Is\+Valid (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this node is valid at all. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!IsValidTopLevel@{IsValidTopLevel}}
\index{IsValidTopLevel@{IsValidTopLevel}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{IsValidTopLevel()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ab28fd5991856fc7bd9d4488e4de3cd51} 
template$<$typename Key$>$ \\
bool Is\+Valid\+Top\+Level (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this node is valid as a script on its own. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!NeedsSignature@{NeedsSignature}}
\index{NeedsSignature@{NeedsSignature}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{NeedsSignature()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ad6219f380116b9533707e4a98e3b0d45} 
template$<$typename Key$>$ \\
bool Needs\+Signature (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this script always needs a signature. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!operator=@{operator=}}
\index{operator=@{operator=}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{operator=()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a7e12a390c13d283fc06cafbbfef7eba7} 
template$<$typename Key$>$ \\
\textbf{ Node} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Node}$<$ Key $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!operator==@{operator==}}
\index{operator==@{operator==}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{operator==()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a24a7741aa027a0963e5e500666ee57b0} 
template$<$typename Key$>$ \\
bool operator== (\begin{DoxyParamCaption}\item[{const \textbf{ Node}$<$ Key $>$ \&}]{arg}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Equality testing. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Satisfy@{Satisfy}}
\index{Satisfy@{Satisfy}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Satisfy()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a4e1981fc3db490ab49f24933beb7904a} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ Availability} Satisfy (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{, }\item[{std\+::vector$<$ std\+::vector$<$ unsigned char $>$ $>$ \&}]{stack}{, }\item[{bool}]{nonmalleable}{ = {\ttfamily true}}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Produce a witness for this script, if possible and given the information available in the context. The non-\/malleable satisfaction is guaranteed to be valid if it exists, and Valid\+Satisfaction() is true. If \doxyref{Is\+Sane()}{p.}{structminiscript_1_1_node_abc827be9cac583b83a1d379fe41961a9} holds, this satisfaction is guaranteed to succeed in case the node\textquotesingle{}s conditions are satisfied (private keys and hash preimages available, locktimes satisfied). \index{Node$<$ Key $>$@{Node$<$ Key $>$}!ScriptSize@{ScriptSize}}
\index{ScriptSize@{ScriptSize}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{ScriptSize()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a55b584550b6e72dbd5a06f2e183b2a4f} 
template$<$typename Key$>$ \\
size\+\_\+t Script\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the size of the script for this expression (faster than \doxyref{To\+Script()}{p.}{structminiscript_1_1_node_ab2938b96153475bc06ad4a5c4e0e697f}.size()). 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!ToScript@{ToScript}}
\index{ToScript@{ToScript}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{ToScript()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ab2938b96153475bc06ad4a5c4e0e697f} 
template$<$typename Key$>$ \\
template$<$typename Ctx$>$ \\
\textbf{ CScript} To\+Script (\begin{DoxyParamCaption}\item[{const Ctx \&}]{ctx}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!ToString@{ToString}}
\index{ToString@{ToString}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{ToString()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a43f54215cb700a32daecb550683202f4} 
template$<$typename Key$>$ \\
template$<$typename CTx$>$ \\
std\+::optional$<$ std\+::string $>$ To\+String (\begin{DoxyParamCaption}\item[{const CTx \&}]{ctx}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!ValidSatisfactions@{ValidSatisfactions}}
\index{ValidSatisfactions@{ValidSatisfactions}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{ValidSatisfactions()}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a6cb356eee2d1451d8a36b08bac99da1b} 
template$<$typename Key$>$ \\
bool Valid\+Satisfactions (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Whether successful non-\/malleable satisfactions are guaranteed to be valid. 



\label{doc-related-members}
\doxysubsection{Friends And Related Symbol Documentation}
\index{Node$<$ Key $>$@{Node$<$ Key $>$}!Compare@{Compare}}
\index{Compare@{Compare}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{Compare}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a3358e2e0551eb183c799b73519674df4} 
template$<$typename Key$>$ \\
int Compare (\begin{DoxyParamCaption}\item[{const \textbf{ Node}$<$ Key $>$ \&}]{node1}{, }\item[{const \textbf{ Node}$<$ Key $>$ \&}]{node2}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Compare two miniscript subtrees, using a non-\/recursive algorithm. 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{Node$<$ Key $>$@{Node$<$ Key $>$}!data@{data}}
\index{data@{data}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{data}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a49104a2a3e0232285ff8439288b2514e} 
template$<$typename Key$>$ \\
const std\+::vector$<$unsigned char$>$ data}



The data bytes in this expression (only for HASH160/\+HASH256/\+SHA256/\+RIPEMD10). 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!fragment@{fragment}}
\index{fragment@{fragment}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{fragment}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_a550b705b76cf7102d8690701547d0f0f} 
template$<$typename Key$>$ \\
const \textbf{ Fragment} fragment}



What node type this node is. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!k@{k}}
\index{k@{k}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{k}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_af2549a085abac72c4e84e5e78d4fdd74} 
template$<$typename Key$>$ \\
const uint32\+\_\+t k = 0}



The k parameter (time for OLDER/\+AFTER, threshold for THRESH(\+\_\+\+M)). 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!keys@{keys}}
\index{keys@{keys}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{keys}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_aaf2d60b2299e9fdac89de165a213a09b} 
template$<$typename Key$>$ \\
const std\+::vector$<$Key$>$ keys}



The keys used by this expression (only for PK\+\_\+\+K/\+PK\+\_\+\+H/\+MULTI). 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!m\_script\_ctx@{m\_script\_ctx}}
\index{m\_script\_ctx@{m\_script\_ctx}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{m\_script\_ctx}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ac3e0ca24aedfe770b4b27b38fa9bacc1} 
template$<$typename Key$>$ \\
const \textbf{ Miniscript\+Context} m\+\_\+script\+\_\+ctx}



The Script context for this node. Either P2\+WSH or Tapscript. 

\index{Node$<$ Key $>$@{Node$<$ Key $>$}!subs@{subs}}
\index{subs@{subs}!Node$<$ Key $>$@{Node$<$ Key $>$}}
\doxysubsubsection{subs}
{\footnotesize\ttfamily \label{structminiscript_1_1_node_ae86e2484d5826a318fd81f6195b50fbd} 
template$<$typename Key$>$ \\
std\+::vector$<$\textbf{ Node\+Ref}$<$Key$>$ $>$ subs\hspace{0.3cm}{\ttfamily [mutable]}}



Subexpressions (for WRAP\+\_\+$\ast$/\+AND\+\_\+$\ast$/\+OR\+\_\+$\ast$/\+ANDOR/\+THRESH). 



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/script/\textbf{ miniscript.\+h}\end{DoxyCompactItemize}
