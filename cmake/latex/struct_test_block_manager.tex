\doxysection{Test\+Block\+Manager Struct Reference}
\label{struct_test_block_manager}\index{TestBlockManager@{TestBlockManager}}


{\ttfamily \#include $<$validation.\+h$>$}

Inheritance diagram for Test\+Block\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{struct_test_block_manager}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Cleanup\+For\+Fuzzing} ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Block\+Manager}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Block\+Manager} (const \textbf{ util\+::\+Signal\+Interrupt} \&interrupt, \textbf{ Options}\textbf{ Options} opts)
\item 
\textbf{ Block\+Map} m\+\_\+block\+\_\+index \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+main})
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Block\+Tree\+DB} $>$ m\+\_\+block\+\_\+tree\+\_\+db \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
\textbf{ CBlock\+Index} $\ast$ \textbf{ Insert\+Block\+Index} (const \textbf{ uint256} \&hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Prune\+One\+Block\+File} (const int file\+Number) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\begin{DoxyCompactList}\small\item\em Mark one block file as pruned (modify associated database entries). \end{DoxyCompactList}\item 
\textbf{ CBlock\+Index} $\ast$ \textbf{ Lookup\+Block\+Index} (const \textbf{ uint256} \&hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
const \textbf{ CBlock\+Index} $\ast$ \textbf{ Lookup\+Block\+Index} (const \textbf{ uint256} \&hash) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
\textbf{ CBlock\+File\+Info} $\ast$ \textbf{ Get\+Block\+File\+Info} (size\+\_\+t n)
\item 
void \textbf{ Update\+Block\+Info} (const \textbf{ CBlock} \&block, unsigned int \textbf{ n\+Height}, const \textbf{ Flat\+File\+Pos} \&pos)
\item 
bool \textbf{ Is\+Prune\+Mode} () const
\item 
uint64\+\_\+t \textbf{ Get\+Prune\+Target} () const
\item 
bool \textbf{ Loading\+Blocks} () const
\item 
uint64\+\_\+t \textbf{ Calculate\+Current\+Usage} ()
\item 
\textbf{ fs\+::path} \textbf{ Get\+Block\+Pos\+Filename} (const \textbf{ Flat\+File\+Pos} \&pos) const
\item 
void \textbf{ Unlink\+Pruned\+Files} (const std\+::set$<$ int $>$ \&set\+Files\+To\+Prune) const
\item 
bool \textbf{ Read\+Block} (\textbf{ CBlock} \&block, const \textbf{ Flat\+File\+Pos} \&pos, const std\+::optional$<$ \textbf{ uint256} $>$ \&expected\+\_\+hash) const
\item 
bool \textbf{ Read\+Block} (\textbf{ CBlock} \&block, const \textbf{ CBlock\+Index} \&index) const
\item 
\textbf{ Read\+Raw\+Block\+Result} \textbf{ Read\+Raw\+Block} (const \textbf{ Flat\+File\+Pos} \&pos, std\+::optional$<$ std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$ $>$ block\+\_\+part=std\+::nullopt) const
\item 
bool \textbf{ Read\+Block\+Undo} (\textbf{ CBlock\+Undo} \&blockundo, const \textbf{ CBlock\+Index} \&index) const
\item 
void \textbf{ Cleanup\+Block\+Rev\+Files} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Block\+Manager}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Options} = \textbf{ kernel\+::\+Block\+Manager\+Opts}
\item 
using \textbf{ Read\+Raw\+Block\+Result} = \textbf{ util\+::\+Expected}$<$std\+::vector$<$std\+::byte$>$, \textbf{ Read\+Raw\+Error}$>$
\end{DoxyCompactItemize}
\doxysubsection*{Data Fields inherited from \textbf{ Block\+Manager}}
\begin{DoxyCompactItemize}
\item 
const \textbf{ util\+::\+Signal\+Interrupt} \& \textbf{ m\+\_\+interrupt}
\item 
std\+::atomic$<$ bool $>$ \textbf{ m\+\_\+importing} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ m\+\_\+blockfiles\+\_\+indexed} \{true\}
\item 
std\+::optional$<$ int $>$ \textbf{ m\+\_\+snapshot\+\_\+height}
\item 
std\+::vector$<$ \textbf{ CBlock\+Index} $\ast$ $>$ Get\+All\+Block\+Indices() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::multimap$<$ \textbf{ CBlock\+Index} $\ast$, \textbf{ CBlock\+Index} $\ast$ $>$ \textbf{ m\+\_\+blocks\+\_\+unlinked}
\item 
void Write\+Block\+Index\+DB() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Load\+Block\+Index\+DB(const std\+::optional$<$ \textbf{ uint256} $>$ \&snapshot\+\_\+blockhash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Scan\+And\+Unlink\+Already\+Pruned\+Files() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ CBlock\+Index} \textbf{ Add\+To\+Block\+Index} )(const \textbf{ CBlock\+Header} \&block, \textbf{ CBlock\+Index} $\ast$\&best\+\_\+header) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool Write\+Block\+Undo(const \textbf{ CBlock\+Undo} \&blockundo, \textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} \&block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(Flat\+File\+Po \textbf{ Write\+Block} )(const \textbf{ CBlock} \&block, int \textbf{ n\+Height})
\item 
bool \textbf{ Check\+Block\+Data\+Availability}(const \textbf{ CBlock\+Index} \&upper\+\_\+block, const \textbf{ CBlock\+Index} \&lower\+\_\+block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(const \textbf{ CBlock\+Index} \&Get\+First\+Block(const \textbf{ CBlock\+Index} \&upper\+\_\+block \textbf{ LIFETIMEBOUND}, uint32\+\_\+t status\+\_\+mask, const \textbf{ CBlock\+Index} $\ast$lower\+\_\+block \textbf{ LIFETIMEBOUND}=nullptr) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(boo \textbf{ m\+\_\+have\+\_\+pruned} ) = false
\begin{DoxyCompactList}\small\item\em Returns the earliest block with specified {\ttfamily status\+\_\+mask} flags set after the latest block {\itshape not} having those flags. \end{DoxyCompactList}\item 
bool Is\+Block\+Pruned(const \textbf{ CBlock\+Index} \&block) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Update\+Prune\+Lock(const std\+::string \&\textbf{ name}, const \textbf{ Prune\+Lock\+Info} \&lock\+\_\+info) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(Auto\+Fil \textbf{ Open\+Block\+File} )(const \textbf{ Flat\+File\+Pos} \&pos, bool f\+Read\+Only) const
\begin{DoxyCompactList}\small\item\em Check whether the block associated with this index entry is pruned or not. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \textbf{ Block\+Manager}}
\begin{DoxyCompactItemize}
\item 
static constexpr auto \textbf{ PRUNE\+\_\+\+TARGET\+\_\+\+MANUAL} \{std\+::numeric\+\_\+limits$<$uint64\+\_\+t$>$\+::max()\}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \textbf{ Block\+Manager}}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \textbf{ CBlock\+File\+Info} $>$ \textbf{ m\+\_\+blockfile\+\_\+info}
\item 
std\+::set$<$ \textbf{ CBlock\+Index} $\ast$ $>$ \textbf{ m\+\_\+dirty\+\_\+blockindex}
\item 
std\+::set$<$ int $>$ \textbf{ m\+\_\+dirty\+\_\+fileinfo}
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{TestBlockManager@{TestBlockManager}!CleanupForFuzzing@{CleanupForFuzzing}}
\index{CleanupForFuzzing@{CleanupForFuzzing}!TestBlockManager@{TestBlockManager}}
\doxysubsubsection{CleanupForFuzzing()}
{\footnotesize\ttfamily \label{struct_test_block_manager_a78235d9eddeb1626eeaba6148c8cce2e} 
void Cleanup\+For\+Fuzzing (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Test-\/only method to clear internal state for fuzzing 

The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/test/util/\textbf{ validation.\+h}\item 
src/test/util/\textbf{ validation.\+cpp}\end{DoxyCompactItemize}
