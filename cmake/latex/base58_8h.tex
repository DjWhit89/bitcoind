\doxysection{src/base58.h File Reference}
\label{base58_8h}\index{src/base58.h@{src/base58.h}}
{\ttfamily \#include $<$span.\+h$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ Encode\+Base58} (std\+::span$<$ const unsigned char $>$ input)
\item 
bool \textbf{ Decode\+Base58} (const std\+::string \&str, std\+::vector$<$ unsigned char $>$ \&vch\+Ret, int max\+\_\+ret\+\_\+len)
\item 
std\+::string \textbf{ Encode\+Base58\+Check} (std\+::span$<$ const unsigned char $>$ input)
\item 
bool \textbf{ Decode\+Base58\+Check} (const std\+::string \&str, std\+::vector$<$ unsigned char $>$ \&vch\+Ret, int max\+\_\+ret\+\_\+len)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{base58.h@{base58.h}!DecodeBase58@{DecodeBase58}}
\index{DecodeBase58@{DecodeBase58}!base58.h@{base58.h}}
\doxysubsubsection{DecodeBase58()}
{\footnotesize\ttfamily \label{base58_8h_a3769d56c7b21e040116f8f2f611d87f1} 
bool Decode\+Base58 (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str}{, }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Ret}{, }\item[{int}]{max\+\_\+ret\+\_\+len}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

Decode a base58-\/encoded string (str) into a byte vector (vch\+Ret). return true if decoding is successful. \index{base58.h@{base58.h}!DecodeBase58Check@{DecodeBase58Check}}
\index{DecodeBase58Check@{DecodeBase58Check}!base58.h@{base58.h}}
\doxysubsubsection{DecodeBase58Check()}
{\footnotesize\ttfamily \label{base58_8h_a94849f930b2534bacf5199b9142bd359} 
bool Decode\+Base58\+Check (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str}{, }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Ret}{, }\item[{int}]{max\+\_\+ret\+\_\+len}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

Decode a base58-\/encoded string (str) that includes a checksum into a byte vector (vch\+Ret), return true if decoding is successful \index{base58.h@{base58.h}!EncodeBase58@{EncodeBase58}}
\index{EncodeBase58@{EncodeBase58}!base58.h@{base58.h}}
\doxysubsubsection{EncodeBase58()}
{\footnotesize\ttfamily \label{base58_8h_a4db96a92603c762f9b33fa0915a31b5d} 
std\+::string Encode\+Base58 (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{input}{}\end{DoxyParamCaption})}

Why base-\/58 instead of standard base-\/64 encoding?
\begin{DoxyItemize}
\item Don\textquotesingle{}t want 0OIl characters that look the same in some fonts and could be used to create visually identical looking data.
\item A string with non-\/alphanumeric characters is not as easily accepted as input.
\item E-\/mail usually won\textquotesingle{}t line-\/break if there\textquotesingle{}s no punctuation to break at.
\item Double-\/clicking selects the whole string as one word if it\textquotesingle{}s all alphanumeric. Encode a byte span as a base58-\/encoded string 
\end{DoxyItemize}\index{base58.h@{base58.h}!EncodeBase58Check@{EncodeBase58Check}}
\index{EncodeBase58Check@{EncodeBase58Check}!base58.h@{base58.h}}
\doxysubsubsection{EncodeBase58Check()}
{\footnotesize\ttfamily \label{base58_8h_acab2cee7e990ecb0a5cd12c26c06dff2} 
std\+::string Encode\+Base58\+Check (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{input}{}\end{DoxyParamCaption})}

Encode a byte span into a base58-\/encoded string, including checksum 