\doxysection{Proxy\+Server\+Base$<$ Interface\+\_\+, Impl\+\_\+ $>$ Struct Template Reference}
\label{structmp_1_1_proxy_server_base}\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}


{\ttfamily \#include $<$proxy.\+h$>$}

Inheritance diagram for Proxy\+Server\+Base$<$ Interface\+\_\+, Impl\+\_\+ $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{structmp_1_1_proxy_server_base}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Interface} = Interface\+\_\+
\item 
using \textbf{ Impl} = Impl\+\_\+
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Proxy\+Server\+Base} (std\+::shared\+\_\+ptr$<$ \textbf{ Impl} $>$ impl, \textbf{ Connection} \&connection)
\item 
virtual \textbf{ $\sim$\+Proxy\+Server\+Base} ()
\item 
void \textbf{ invoke\+Destroy} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
std\+::shared\+\_\+ptr$<$ \textbf{ Impl} $>$ \textbf{ m\+\_\+impl}
\item 
\textbf{ Proxy\+Context} \textbf{ m\+\_\+context}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Interface\+\_\+, typename Impl\+\_\+$>$\newline
struct mp\+::\+Proxy\+Server\+Base$<$ Interface\+\_\+, Impl\+\_\+ $>$}
\doxyref{Base}{p.}{class_base} class for generated \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} classes that implement capnp server methods and forward calls to a wrapped c++ implementation class. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!Impl@{Impl}}
\index{Impl@{Impl}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{Impl}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_aa5c2e2f388eaba65ab01f79b1ae9ea32} 
template$<$typename Interface\+\_\+, typename Impl\+\_\+$>$ \\
using \textbf{ Impl} = Impl\+\_\+}

\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!Interface@{Interface}}
\index{Interface@{Interface}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{Interface}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_ac56f24b044e98752160b4a0a14514e76} 
template$<$typename Interface\+\_\+, typename Impl\+\_\+$>$ \\
using \textbf{ Interface} = Interface\+\_\+}



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!ProxyServerBase@{ProxyServerBase}}
\index{ProxyServerBase@{ProxyServerBase}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{ProxyServerBase()}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_afe79a96d9eb6ad4ff906a7f6a5b858b4} 
template$<$typename \textbf{ Interface}, typename \textbf{ Impl}$>$ \\
Proxy\+Server\+Base (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \textbf{ Impl} $>$}]{impl}{, }\item[{\textbf{ Connection} \&}]{connection}{}\end{DoxyParamCaption})}

\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!````~ProxyServerBase@{$\sim$ProxyServerBase}}
\index{````~ProxyServerBase@{$\sim$ProxyServerBase}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{$\sim$ProxyServerBase()}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_a90a9c3ed54e1726a854d4fbf1eb1d379} 
template$<$typename \textbf{ Interface}, typename \textbf{ Impl}$>$ \\
$\sim$\textbf{ Proxy\+Server\+Base} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

\doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} destructor, called from the \doxyref{Event\+Loop}{p.}{classmp_1_1_event_loop} thread by Cap\textquotesingle{}n Proto garbage collection code after there are no more references to this object. This will typically happen when the corresponding \doxyref{Proxy\+Client}{p.}{structmp_1_1_proxy_client} object on the other side of the connection is destroyed. It can also happen earlier if the connection is broken or destroyed. In the latter case this destructor will typically be called inside m\+\_\+rpc\+\_\+system.\+reset() call in the $\sim$\+Connection destructor while the \doxyref{Connection}{p.}{classmp_1_1_connection} object still exists. However, because \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} objects are refcounted, and the \doxyref{Connection}{p.}{classmp_1_1_connection} object could be destroyed while asynchronous IPC calls are still in-\/flight, it\textquotesingle{}s possible for this destructor to be called after the \doxyref{Connection}{p.}{classmp_1_1_connection} object no longer exists, so it is NOT valid to dereference the m\+\_\+context.\+connection pointer from this function. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!invokeDestroy@{invokeDestroy}}
\index{invokeDestroy@{invokeDestroy}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{invokeDestroy()}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_a337a3c890fad394953330b47eb4aafb2} 
template$<$typename \textbf{ Interface}, typename \textbf{ Impl}$>$ \\
void invoke\+Destroy (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

If the capnp interface defined a special "{}destroy"{} method, as described the \doxyref{Proxy\+Client\+Base}{p.}{classmp_1_1_proxy_client_base} class, this method will be called and synchronously destroy m\+\_\+impl before returning to the client.

If the capnp interface does not define a "{}destroy"{} method, this will never be called and the $\sim$\+Proxy\+Server\+Base destructor will be responsible for deleting m\+\_\+impl asynchronously, whenever the \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} object gets garbage collected by Cap\textquotesingle{}n Proto.

This method is called in the same way other proxy server methods are called, via the server\+Invoke function. Basically server\+Invoke just calls this as a substitute for a non-\/existent m\+\_\+impl-\/$>$destroy() method. If the destroy method has any parameters or return values they will be handled in the normal way by Pass\+Field/\+Read\+Field/\+Build\+Field functions. Particularly if a Context.\+thread parameter was passed, this method will run on the worker thread specified by the client. Otherwise it will run on the \doxyref{Event\+Loop}{p.}{classmp_1_1_event_loop} thread, like other server methods without an assigned thread. 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!m\_context@{m\_context}}
\index{m\_context@{m\_context}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{m\_context}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_af910ca1c8fc9a191f85d16b71819c033} 
template$<$typename Interface\+\_\+, typename Impl\+\_\+$>$ \\
\textbf{ Proxy\+Context} m\+\_\+context}

\index{ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}!m\_impl@{m\_impl}}
\index{m\_impl@{m\_impl}!ProxyServerBase$<$ Interface\_, Impl\_ $>$@{ProxyServerBase$<$ Interface\_, Impl\_ $>$}}
\doxysubsubsection{m\_impl}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_server_base_a47b0d7e7413d0c7eb592ccf544a24f13} 
template$<$typename Interface\+\_\+, typename Impl\+\_\+$>$ \\
std\+::shared\+\_\+ptr$<$\textbf{ Impl}$>$ m\+\_\+impl}

Implementation pointer that may or may not be owned and deleted when this capnp server goes out of scope. It is owned for servers created to wrap unique\+\_\+ptr$<$\+Impl$>$ method arguments, but unowned for servers created to wrap \doxyref{Impl}{p.}{structmp_1_1_proxy_server_base_aa5c2e2f388eaba65ab01f79b1ae9ea32}\& method arguments.

In the case of \doxyref{Impl}{p.}{structmp_1_1_proxy_server_base_aa5c2e2f388eaba65ab01f79b1ae9ea32}\& arguments, custom code is required on other side of the connection to delete the capnp client \& server objects since native code on that side of the connection will just be taking a plain reference rather than a pointer, so won\textquotesingle{}t be able to do its own cleanup. Right now this is implemented with add\+Close\+Hook callbacks to delete clients at appropriate times depending on semantics of the particular method being wrapped. 

The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/ipc/libmultiprocess/include/mp/\textbf{ proxy.\+h}\item 
src/ipc/libmultiprocess/include/mp/\textbf{ proxy-\/io.\+h}\end{DoxyCompactItemize}
