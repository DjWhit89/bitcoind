\doxysection{Locked\+Pool Class Reference}
\label{class_locked_pool}\index{LockedPool@{LockedPool}}


{\ttfamily \#include $<$lockedpool.\+h$>$}

Inheritance diagram for Locked\+Pool\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_locked_pool}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Stats}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef bool($\ast$ \textbf{ Locking\+Failed\+\_\+\+Callback}) ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Locked\+Pool} (std\+::unique\+\_\+ptr$<$ \textbf{ Locked\+Page\+Allocator} $>$ allocator, \textbf{ Locking\+Failed\+\_\+\+Callback} lf\+\_\+cb\+\_\+in=nullptr)
\item 
\textbf{ $\sim$\+Locked\+Pool} ()
\item 
\textbf{ Locked\+Pool} (const \textbf{ Locked\+Pool} \&other)=delete
\item 
\textbf{ Locked\+Pool} \& \textbf{ operator=} (const \textbf{ Locked\+Pool} \&)=delete
\item 
void $\ast$ \textbf{ alloc} (size\+\_\+t size)
\item 
void \textbf{ free} (void $\ast$ptr)
\item 
\textbf{ Stats} \textbf{ stats} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const size\+\_\+t \textbf{ ARENA\+\_\+\+SIZE} = 256$\ast$1024
\item 
static const size\+\_\+t \textbf{ ARENA\+\_\+\+ALIGN} = 16
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Pool for locked memory chunks.

To avoid sensitive key data from being swapped to disk, the memory in this pool is locked/pinned.

An arena manages a contiguous region of memory. The pool starts out with one arena but can grow to multiple arenas if the need arises.

Unlike a normal C heap, the administrative structures are separate from the managed memory. This has been done as the sizes and bases of objects are not in themselves sensitive information, as to conserve precious locked memory. In some operating systems the amount of memory that can be locked is small. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{LockedPool@{LockedPool}!LockingFailed\_Callback@{LockingFailed\_Callback}}
\index{LockingFailed\_Callback@{LockingFailed\_Callback}!LockedPool@{LockedPool}}
\doxysubsubsection{LockingFailed\_Callback}
{\footnotesize\ttfamily \label{class_locked_pool_a0a363c0e967bd7d2361e59e69f42cc1c} 
typedef bool($\ast$ Locking\+Failed\+\_\+\+Callback) ()}

Callback when allocation succeeds but locking fails. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{LockedPool@{LockedPool}!LockedPool@{LockedPool}}
\index{LockedPool@{LockedPool}!LockedPool@{LockedPool}}
\doxysubsubsection{LockedPool()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_locked_pool_a8f257d90bc4769394c59f5b09b58e218} 
\textbf{ Locked\+Pool} (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \textbf{ Locked\+Page\+Allocator} $>$}]{allocator}{, }\item[{\textbf{ Locking\+Failed\+\_\+\+Callback}}]{lf\+\_\+cb\+\_\+in}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

Create a new \doxyref{Locked\+Pool}{p.}{class_locked_pool}. This takes ownership of the Memory\+Page\+Locker, you can only instantiate this with \doxyref{Locked\+Pool(std\+::move(...))}{p.}{class_locked_pool}.

The second argument is an optional callback when locking a newly allocated arena failed. If this callback is provided and returns false, the allocation fails (hard fail), if it returns true the allocation proceeds, but it could warn. \index{LockedPool@{LockedPool}!````~LockedPool@{$\sim$LockedPool}}
\index{````~LockedPool@{$\sim$LockedPool}!LockedPool@{LockedPool}}
\doxysubsubsection{$\sim$LockedPool()}
{\footnotesize\ttfamily \label{class_locked_pool_ac675de71591052255b109b0044aab17d} 
$\sim$\textbf{ Locked\+Pool} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

\index{LockedPool@{LockedPool}!LockedPool@{LockedPool}}
\index{LockedPool@{LockedPool}!LockedPool@{LockedPool}}
\doxysubsubsection{LockedPool()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_locked_pool_a2bc444d05ebbb08095ff58bf0ea49963} 
\textbf{ Locked\+Pool} (\begin{DoxyParamCaption}\item[{const \textbf{ Locked\+Pool} \&}]{other}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{LockedPool@{LockedPool}!alloc@{alloc}}
\index{alloc@{alloc}!LockedPool@{LockedPool}}
\doxysubsubsection{alloc()}
{\footnotesize\ttfamily \label{class_locked_pool_a0997a6135a02d99f2efb706b1f654586} 
void $\ast$ alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})}

Allocate size bytes from this arena. Returns pointer on success, or 0 if memory is full or the application tried to allocate 0 bytes. \index{LockedPool@{LockedPool}!free@{free}}
\index{free@{free}!LockedPool@{LockedPool}}
\doxysubsubsection{free()}
{\footnotesize\ttfamily \label{class_locked_pool_afbedc913aa4651b3c3b4b3aecd9b4711} 
void free (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr}{}\end{DoxyParamCaption})}

Free a previously allocated chunk of memory. Freeing the zero pointer has no effect. Raises std\+::runtime\+\_\+error in case of error. \index{LockedPool@{LockedPool}!operator=@{operator=}}
\index{operator=@{operator=}!LockedPool@{LockedPool}}
\doxysubsubsection{operator=()}
{\footnotesize\ttfamily \label{class_locked_pool_a3481ac7f538386f75a79e3e055cf9285} 
\textbf{ Locked\+Pool} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Locked\+Pool} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{LockedPool@{LockedPool}!stats@{stats}}
\index{stats@{stats}!LockedPool@{LockedPool}}
\doxysubsubsection{stats()}
{\footnotesize\ttfamily \label{class_locked_pool_aab51b3c20c7110b582259ad406fbb546} 
\textbf{ Locked\+Pool\+::\+Stats} stats (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Get pool usage statistics 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{LockedPool@{LockedPool}!ARENA\_ALIGN@{ARENA\_ALIGN}}
\index{ARENA\_ALIGN@{ARENA\_ALIGN}!LockedPool@{LockedPool}}
\doxysubsubsection{ARENA\_ALIGN}
{\footnotesize\ttfamily \label{class_locked_pool_a8f01c0574ee8207fdf147a2c6d34a51e} 
const size\+\_\+t ARENA\+\_\+\+ALIGN = 16\hspace{0.3cm}{\ttfamily [static]}}

Chunk alignment. Another compromise. Setting this too high will waste memory, setting it too low will facilitate fragmentation. \index{LockedPool@{LockedPool}!ARENA\_SIZE@{ARENA\_SIZE}}
\index{ARENA\_SIZE@{ARENA\_SIZE}!LockedPool@{LockedPool}}
\doxysubsubsection{ARENA\_SIZE}
{\footnotesize\ttfamily \label{class_locked_pool_ae57b6b68ba3adf557404e02034ab2b48} 
const size\+\_\+t ARENA\+\_\+\+SIZE = 256$\ast$1024\hspace{0.3cm}{\ttfamily [static]}}

Size of one arena of locked memory. This is a compromise. Do not set this too low, as managing many arenas will increase allocation and deallocation overhead. Setting it too high allocates more locked memory from the OS than strictly necessary. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/support/\textbf{ lockedpool.\+h}\item 
src/support/\textbf{ lockedpool.\+cpp}\end{DoxyCompactItemize}
