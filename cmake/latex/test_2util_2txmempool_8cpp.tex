\doxysection{src/test/util/txmempool.cpp File Reference}
\label{test_2util_2txmempool_8cpp}\index{src/test/util/txmempool.cpp@{src/test/util/txmempool.cpp}}
{\ttfamily \#include $<$test/util/txmempool.\+h$>$}\newline
{\ttfamily \#include $<$chainparams.\+h$>$}\newline
{\ttfamily \#include $<$node/context.\+h$>$}\newline
{\ttfamily \#include $<$node/mempool\+\_\+args.\+h$>$}\newline
{\ttfamily \#include $<$policy/rbf.\+h$>$}\newline
{\ttfamily \#include $<$policy/truc\+\_\+policy.\+h$>$}\newline
{\ttfamily \#include $<$test/util/transaction\+\_\+utils.\+h$>$}\newline
{\ttfamily \#include $<$util/check.\+h$>$}\newline
{\ttfamily \#include $<$util/time.\+h$>$}\newline
{\ttfamily \#include $<$util/translation.\+h$>$}\newline
{\ttfamily \#include $<$validation.\+h$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CTx\+Mem\+Pool\+::\+Options} \textbf{ Mem\+Pool\+Options\+For\+Test} (const \textbf{ Node\+Context} \&\textbf{ node})
\item 
std\+::optional$<$ std\+::string $>$ \textbf{ Check\+Package\+Mempool\+Accept\+Result} (const \textbf{ Package} \&txns, const \textbf{ Package\+Mempool\+Accept\+Result} \&result, bool expect\+\_\+valid, const \textbf{ CTx\+Mem\+Pool} $\ast$mempool)
\item 
void \textbf{ Check\+Mempool\+Ephemeral\+Invariants} (const \textbf{ CTx\+Mem\+Pool} \&tx\+\_\+pool)
\item 
void \textbf{ Check\+Mempool\+TRUCInvariants} (const \textbf{ CTx\+Mem\+Pool} \&tx\+\_\+pool)
\item 
void \textbf{ Try\+Add\+To\+Mempool} (\textbf{ CTx\+Mem\+Pool} \&tx\+\_\+pool, const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry)
\item 
void \textbf{ Mock\+Mempool\+Min\+Fee} (const \textbf{ CFee\+Rate} \&target\+\_\+feerate, \textbf{ CTx\+Mem\+Pool} \&mempool)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{txmempool.cpp@{txmempool.cpp}!CheckMempoolEphemeralInvariants@{CheckMempoolEphemeralInvariants}}
\index{CheckMempoolEphemeralInvariants@{CheckMempoolEphemeralInvariants}!txmempool.cpp@{txmempool.cpp}}
\doxysubsubsection{CheckMempoolEphemeralInvariants()}
{\footnotesize\ttfamily \label{test_2util_2txmempool_8cpp_ab388327157d3652cc6706dd8182dce69} 
void Check\+Mempool\+Ephemeral\+Invariants (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool} \&}]{tx\+\_\+pool}{}\end{DoxyParamCaption})}

Check that we never get into a state where an ephemeral dust transaction would be mined without the spend of the dust also being mined. This assumes standardness checks are being enforced. \index{txmempool.cpp@{txmempool.cpp}!CheckMempoolTRUCInvariants@{CheckMempoolTRUCInvariants}}
\index{CheckMempoolTRUCInvariants@{CheckMempoolTRUCInvariants}!txmempool.cpp@{txmempool.cpp}}
\doxysubsubsection{CheckMempoolTRUCInvariants()}
{\footnotesize\ttfamily \label{test_2util_2txmempool_8cpp_a510d61afe1c2654572e80df2239f816f} 
void Check\+Mempool\+TRUCInvariants (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool} \&}]{tx\+\_\+pool}{}\end{DoxyParamCaption})}

For every transaction in tx\+\_\+pool, check TRUC invariants\+:
\begin{DoxyItemize}
\item a TRUC tx\textquotesingle{}s ancestor count must be within TRUC\+\_\+\+ANCESTOR\+\_\+\+LIMIT
\item a TRUC tx\textquotesingle{}s descendant count must be within TRUC\+\_\+\+DESCENDANT\+\_\+\+LIMIT
\item if a TRUC tx has ancestors, its sigop-\/adjusted vsize must be within TRUC\+\_\+\+CHILD\+\_\+\+MAX\+\_\+\+VSIZE
\item any non-\/\+TRUC tx must only have non-\/\+TRUC parents
\item any TRUC tx must only have TRUC parents 
\end{DoxyItemize}\index{txmempool.cpp@{txmempool.cpp}!CheckPackageMempoolAcceptResult@{CheckPackageMempoolAcceptResult}}
\index{CheckPackageMempoolAcceptResult@{CheckPackageMempoolAcceptResult}!txmempool.cpp@{txmempool.cpp}}
\doxysubsubsection{CheckPackageMempoolAcceptResult()}
{\footnotesize\ttfamily \label{test_2util_2txmempool_8cpp_aa9b0781f7a2b0c0e0c4eb906dd951d43} 
std\+::optional$<$ std\+::string $>$ Check\+Package\+Mempool\+Accept\+Result (\begin{DoxyParamCaption}\item[{const \textbf{ Package} \&}]{txns}{, }\item[{const \textbf{ Package\+Mempool\+Accept\+Result} \&}]{result}{, }\item[{bool}]{expect\+\_\+valid}{, }\item[{const \textbf{ CTx\+Mem\+Pool} $\ast$}]{mempool}{}\end{DoxyParamCaption})}

Check expected properties for every \doxyref{Package\+Mempool\+Accept\+Result}{p.}{struct_package_mempool_accept_result}, regardless of value. Returns a string if an error occurs with error populated, nullopt otherwise. If mempool is provided, checks that the expected transactions are in mempool (this should be set to nullptr for a test\+\_\+accept). \index{txmempool.cpp@{txmempool.cpp}!MemPoolOptionsForTest@{MemPoolOptionsForTest}}
\index{MemPoolOptionsForTest@{MemPoolOptionsForTest}!txmempool.cpp@{txmempool.cpp}}
\doxysubsubsection{MemPoolOptionsForTest()}
{\footnotesize\ttfamily \label{test_2util_2txmempool_8cpp_a72ec6430ddda7dc377edf13944e25df4} 
\textbf{ CTx\+Mem\+Pool\+::\+Options} Mem\+Pool\+Options\+For\+Test (\begin{DoxyParamCaption}\item[{const \textbf{ Node\+Context} \&}]{node}{}\end{DoxyParamCaption})}

\index{txmempool.cpp@{txmempool.cpp}!MockMempoolMinFee@{MockMempoolMinFee}}
\index{MockMempoolMinFee@{MockMempoolMinFee}!txmempool.cpp@{txmempool.cpp}}
\doxysubsubsection{MockMempoolMinFee()}
{\footnotesize\ttfamily \label{test_2util_2txmempool_8cpp_ae86b44318ee26ef570fc822bb2972197} 
void Mock\+Mempool\+Min\+Fee (\begin{DoxyParamCaption}\item[{const \textbf{ CFee\+Rate} \&}]{target\+\_\+feerate}{, }\item[{\textbf{ CTx\+Mem\+Pool} \&}]{mempool}{}\end{DoxyParamCaption})}

Mock the mempool minimum feerate by adding a transaction and calling Trim\+To\+Size(0), simulating the mempool "{}reaching capacity"{} and evicting by descendant feerate. Note that this clears the mempool, and the new minimum feerate will depend on the maximum feerate of transactions removed, so this must be called while the mempool is empty.


\begin{DoxyParams}{Parameters}
{\em target\+\_\+feerate} & The new mempool minimum feerate after this function returns. Must be above max(incremental feerate, min relay feerate), or 1sat/vB with default settings. \\
\hline
{\em mempool} & The mempool to mock the minimum feerate for. Must be empty when called. \\
\hline
\end{DoxyParams}
\index{txmempool.cpp@{txmempool.cpp}!TryAddToMempool@{TryAddToMempool}}
\index{TryAddToMempool@{TryAddToMempool}!txmempool.cpp@{txmempool.cpp}}
\doxysubsubsection{TryAddToMempool()}
{\footnotesize\ttfamily \label{test_2util_2txmempool_8cpp_ab3a262a83fb943d95fd8670b26f8ccbc} 
void Try\+Add\+To\+Mempool (\begin{DoxyParamCaption}\item[{\textbf{ CTx\+Mem\+Pool} \&}]{tx\+\_\+pool}{, }\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{}\end{DoxyParamCaption})}

One-\/line wrapper for creating a mempool changeset with a single transaction and applying it if the policy limits are respected. 