\doxysection{CCoins\+View\+Cache Class Reference}
\label{class_c_coins_view_cache}\index{CCoinsViewCache@{CCoinsViewCache}}


{\ttfamily \#include $<$coins.\+h$>$}

Inheritance diagram for CCoins\+View\+Cache\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_c_coins_view_cache}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCoins\+View\+Cache} (\textbf{ CCoins\+View} $\ast$base\+In, bool deterministic=false)
\item 
\textbf{ CCoins\+View\+Cache} (const \textbf{ CCoins\+View\+Cache} \&)=delete
\item 
std\+::optional$<$ \textbf{ Coin} $>$ \textbf{ Get\+Coin} (const \textbf{ COut\+Point} \&outpoint) const override
\begin{DoxyCompactList}\small\item\em Retrieve the \doxyref{Coin}{p.}{class_coin} (unspent transaction output) for a given outpoint. \end{DoxyCompactList}\item 
bool \textbf{ Have\+Coin} (const \textbf{ COut\+Point} \&outpoint) const override
\begin{DoxyCompactList}\small\item\em Just check whether a given outpoint is unspent. \end{DoxyCompactList}\item 
\textbf{ uint256} \textbf{ Get\+Best\+Block} () const override
\begin{DoxyCompactList}\small\item\em Retrieve the block hash whose state this \doxyref{CCoins\+View}{p.}{class_c_coins_view} currently represents. \end{DoxyCompactList}\item 
void \textbf{ Set\+Best\+Block} (const \textbf{ uint256} \&\textbf{ hash\+Block})
\item 
bool \textbf{ Batch\+Write} (\textbf{ Coins\+View\+Cache\+Cursor} \&cursor, const \textbf{ uint256} \&\textbf{ hash\+Block}) override
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ CCoins\+View\+Cursor} $>$ \textbf{ Cursor} () const override
\begin{DoxyCompactList}\small\item\em Get a cursor to iterate over the whole state. \end{DoxyCompactList}\item 
bool \textbf{ Have\+Coin\+In\+Cache} (const \textbf{ COut\+Point} \&outpoint) const
\item 
const \textbf{ Coin} \& \textbf{ Access\+Coin} (const \textbf{ COut\+Point} \&output) const
\item 
void \textbf{ Add\+Coin} (const \textbf{ COut\+Point} \&outpoint, \textbf{ Coin} \&\&coin, bool possible\+\_\+overwrite)
\item 
void \textbf{ Emplace\+Coin\+Internal\+DANGER} (\textbf{ COut\+Point} \&\&outpoint, \textbf{ Coin} \&\&coin)
\item 
bool \textbf{ Spend\+Coin} (const \textbf{ COut\+Point} \&outpoint, \textbf{ Coin} $\ast$moveto=nullptr)
\item 
bool \textbf{ Flush} (bool will\+\_\+reuse\+\_\+cache=true)
\item 
bool \textbf{ Sync} ()
\item 
void \textbf{ Uncache} (const \textbf{ COut\+Point} \&outpoint)
\item 
unsigned int \textbf{ Get\+Cache\+Size} () const
\begin{DoxyCompactList}\small\item\em Calculate the size of the cache (in number of transaction outputs). \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Dynamic\+Memory\+Usage} () const
\begin{DoxyCompactList}\small\item\em Calculate the size of the cache (in bytes). \end{DoxyCompactList}\item 
bool \textbf{ Have\+Inputs} (const \textbf{ CTransaction} \&tx) const
\begin{DoxyCompactList}\small\item\em Check whether all prevouts of the transaction are present in the UTXO set represented by this view. \end{DoxyCompactList}\item 
void \textbf{ Reallocate\+Cache} ()
\item 
void \textbf{ Sanity\+Check} () const
\begin{DoxyCompactList}\small\item\em Run an internal sanity check on the cache data structure. $\ast$/. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ CCoins\+View\+Backed}}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCoins\+View\+Backed} (\textbf{ CCoins\+View} $\ast$view\+In)
\item 
std\+::vector$<$ \textbf{ uint256} $>$ \textbf{ Get\+Head\+Blocks} () const override
\item 
void \textbf{ Set\+Backend} (\textbf{ CCoins\+View} \&view\+In)
\item 
size\+\_\+t \textbf{ Estimate\+Size} () const override
\begin{DoxyCompactList}\small\item\em Estimate database size (0 if not implemented). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ CCoins\+View}}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+CCoins\+View} ()=default
\begin{DoxyCompactList}\small\item\em As we use CCoins\+Views polymorphically, have a virtual destructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ uint256} \textbf{ hash\+Block}
\item 
\textbf{ CCoins\+Map\+Memory\+Resource} \textbf{ m\+\_\+cache\+\_\+coins\+\_\+memory\+\_\+resource} \{\}
\item 
\textbf{ Coins\+Cache\+Pair} \textbf{ m\+\_\+sentinel}
\item 
\textbf{ CCoins\+Map} \textbf{ cache\+Coins}
\item 
size\+\_\+t \textbf{ cached\+Coins\+Usage} \{0\}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \textbf{ CCoins\+View\+Backed}}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCoins\+View} $\ast$ \textbf{ base}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxyref{CCoins\+View}{p.}{class_c_coins_view} that adds a memory cache for transactions to another \doxyref{CCoins\+View}{p.}{class_c_coins_view} 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CCoinsViewCache@{CCoinsViewCache}!CCoinsViewCache@{CCoinsViewCache}}
\index{CCoinsViewCache@{CCoinsViewCache}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{CCoinsViewCache()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_aebec811b4bad5edf5477ad47ce70799b} 
\textbf{ CCoins\+View\+Cache} (\begin{DoxyParamCaption}\item[{\textbf{ CCoins\+View} $\ast$}]{base\+In}{, }\item[{bool}]{deterministic}{ = {\ttfamily false}}\end{DoxyParamCaption})}

\index{CCoinsViewCache@{CCoinsViewCache}!CCoinsViewCache@{CCoinsViewCache}}
\index{CCoinsViewCache@{CCoinsViewCache}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{CCoinsViewCache()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a6bba8b6f9e01b6a968d1486ce6aaba70} 
\textbf{ CCoins\+View\+Cache} (\begin{DoxyParamCaption}\item[{const \textbf{ CCoins\+View\+Cache} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

By deleting the copy constructor, we prevent accidentally using it when one intends to create a cache on top of a base cache. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CCoinsViewCache@{CCoinsViewCache}!AccessCoin@{AccessCoin}}
\index{AccessCoin@{AccessCoin}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{AccessCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a87f1f2449e10859291ddbdc1d090cba3} 
const \textbf{ Coin} \& Access\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{output}{}\end{DoxyParamCaption}) const}

Return a reference to \doxyref{Coin}{p.}{class_coin} in the cache, or coin\+Empty if not found. This is more efficient than Get\+Coin.

Generally, do not hold the reference returned for more than a short scope. While the current implementation allows for modifications to the contents of the cache while holding the reference, this behavior should not be relied on! To be safe, best to not hold the returned reference through any other calls to this cache. \index{CCoinsViewCache@{CCoinsViewCache}!AddCoin@{AddCoin}}
\index{AddCoin@{AddCoin}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{AddCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a0fe5f056188a32c5ae94aa19e1351698} 
void Add\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{, }\item[{\textbf{ Coin} \&\&}]{coin}{, }\item[{bool}]{possible\+\_\+overwrite}{}\end{DoxyParamCaption})}

Add a coin. Set possible\+\_\+overwrite to true if an unspent version may already exist in the cache. \index{CCoinsViewCache@{CCoinsViewCache}!BatchWrite@{BatchWrite}}
\index{BatchWrite@{BatchWrite}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{BatchWrite()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a56d539fa8b1427ee21191bd0690b96d7} 
bool Batch\+Write (\begin{DoxyParamCaption}\item[{\textbf{ Coins\+View\+Cache\+Cursor} \&}]{cursor}{, }\item[{const \textbf{ uint256} \&}]{hash\+Block}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Do a bulk modification (multiple \doxyref{Coin}{p.}{class_coin} changes + Best\+Block change). The passed cursor is used to iterate through the coins. 

Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a56d539fa8b1427ee21191bd0690b96d7}.

\index{CCoinsViewCache@{CCoinsViewCache}!Cursor@{Cursor}}
\index{Cursor@{Cursor}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{Cursor()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a8c25e928c7d604e75e3bb5913a41613f} 
std\+::unique\+\_\+ptr$<$ \textbf{ CCoins\+View\+Cursor} $>$ Cursor (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Get a cursor to iterate over the whole state. 



Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a8c25e928c7d604e75e3bb5913a41613f}.

\index{CCoinsViewCache@{CCoinsViewCache}!DynamicMemoryUsage@{DynamicMemoryUsage}}
\index{DynamicMemoryUsage@{DynamicMemoryUsage}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{DynamicMemoryUsage()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_afcc22204abc15aeefd5d1f7396e909a4} 
size\+\_\+t Dynamic\+Memory\+Usage (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Calculate the size of the cache (in bytes). 

\index{CCoinsViewCache@{CCoinsViewCache}!EmplaceCoinInternalDANGER@{EmplaceCoinInternalDANGER}}
\index{EmplaceCoinInternalDANGER@{EmplaceCoinInternalDANGER}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{EmplaceCoinInternalDANGER()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_afc256d69d7ad6be668f44626db665929} 
void Emplace\+Coin\+Internal\+DANGER (\begin{DoxyParamCaption}\item[{\textbf{ COut\+Point} \&\&}]{outpoint}{, }\item[{\textbf{ Coin} \&\&}]{coin}{}\end{DoxyParamCaption})}

Emplace a coin into cache\+Coins without performing any checks, marking the emplaced coin as dirty.

NOT FOR GENERAL USE. Used only when loading coins from a UTXO snapshot. \begin{DoxySeeAlso}{See also}
Chainstate\+Manager\+::\+Populate\+And\+Validate\+Snapshot() 
\end{DoxySeeAlso}
\index{CCoinsViewCache@{CCoinsViewCache}!Flush@{Flush}}
\index{Flush@{Flush}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{Flush()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a166e3b1951caaaf582e7b67c5be762ce} 
bool Flush (\begin{DoxyParamCaption}\item[{bool}]{will\+\_\+reuse\+\_\+cache}{ = {\ttfamily true}}\end{DoxyParamCaption})}

Push the modifications applied to this cache to its base and wipe local state. Failure to call this method or \doxyref{Sync()}{p.}{class_c_coins_view_cache_a071d010e76ac762ffab420fcf90656a4} before destruction will cause the changes to be forgotten. If will\+\_\+reuse\+\_\+cache is false, the cache will retain the same memory footprint after flushing and should be destroyed to deallocate. If false is returned, the state of this cache (and its backing view) will be undefined. \index{CCoinsViewCache@{CCoinsViewCache}!GetBestBlock@{GetBestBlock}}
\index{GetBestBlock@{GetBestBlock}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{GetBestBlock()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a357197e89d0c22e33f9e58b3dac685ff} 
\textbf{ uint256} Get\+Best\+Block (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Retrieve the block hash whose state this \doxyref{CCoins\+View}{p.}{class_c_coins_view} currently represents. 



Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a357197e89d0c22e33f9e58b3dac685ff}.

\index{CCoinsViewCache@{CCoinsViewCache}!GetCacheSize@{GetCacheSize}}
\index{GetCacheSize@{GetCacheSize}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{GetCacheSize()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_af787027ef08bdf3db72110265cc4f055} 
unsigned int Get\+Cache\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Calculate the size of the cache (in number of transaction outputs). 

\index{CCoinsViewCache@{CCoinsViewCache}!GetCoin@{GetCoin}}
\index{GetCoin@{GetCoin}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{GetCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a053700fd896babb8aa62fc7c53dd27f6} 
std\+::optional$<$ \textbf{ Coin} $>$ Get\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Retrieve the \doxyref{Coin}{p.}{class_coin} (unspent transaction output) for a given outpoint. 



Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a053700fd896babb8aa62fc7c53dd27f6}.

\index{CCoinsViewCache@{CCoinsViewCache}!HaveCoin@{HaveCoin}}
\index{HaveCoin@{HaveCoin}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{HaveCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a57c7063d0b2cb3900509d8a9e91a8459} 
bool Have\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Just check whether a given outpoint is unspent. 



Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a57c7063d0b2cb3900509d8a9e91a8459}.

\index{CCoinsViewCache@{CCoinsViewCache}!HaveCoinInCache@{HaveCoinInCache}}
\index{HaveCoinInCache@{HaveCoinInCache}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{HaveCoinInCache()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a546edde7d3db81c9fa65e8ad55195f7e} 
bool Have\+Coin\+In\+Cache (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const}

Check if we have the given utxo already loaded in this cache. The semantics are the same as \doxyref{Have\+Coin()}{p.}{class_c_coins_view_cache_a57c7063d0b2cb3900509d8a9e91a8459}, but no calls to the backing \doxyref{CCoins\+View}{p.}{class_c_coins_view} are made. \index{CCoinsViewCache@{CCoinsViewCache}!HaveInputs@{HaveInputs}}
\index{HaveInputs@{HaveInputs}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{HaveInputs()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_aed3ee6fa10e37a5f22862b45e8abb3b4} 
bool Have\+Inputs (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction} \&}]{tx}{}\end{DoxyParamCaption}) const}



Check whether all prevouts of the transaction are present in the UTXO set represented by this view. 

\index{CCoinsViewCache@{CCoinsViewCache}!ReallocateCache@{ReallocateCache}}
\index{ReallocateCache@{ReallocateCache}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{ReallocateCache()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a63f689c5d5987ded578ddb4874f08a63} 
void Reallocate\+Cache (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Force a reallocation of the cache map. This is required when downsizing the cache because the map\textquotesingle{}s allocator may be hanging onto a lot of memory despite having called .\doxyref{clear()}{p.}{uint256__tests_8cpp_a4f5d99a6821ae59423c189b1f657369c}.

See\+: {\texttt{https\+://stackoverflow.\+com/questions/42114044/how-\/to-\/release-\/unordered-\/map-\/memory}} \index{CCoinsViewCache@{CCoinsViewCache}!SanityCheck@{SanityCheck}}
\index{SanityCheck@{SanityCheck}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{SanityCheck()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a234d9f2765fec4cf82214f30a06813aa} 
void Sanity\+Check (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Run an internal sanity check on the cache data structure. $\ast$/. 

\index{CCoinsViewCache@{CCoinsViewCache}!SetBestBlock@{SetBestBlock}}
\index{SetBestBlock@{SetBestBlock}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{SetBestBlock()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_ae3eca32d352e35141dee0a90d5d29b09} 
void Set\+Best\+Block (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash\+Block}{}\end{DoxyParamCaption})}

\index{CCoinsViewCache@{CCoinsViewCache}!SpendCoin@{SpendCoin}}
\index{SpendCoin@{SpendCoin}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{SpendCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_af5547d7b4e71fcf9319ab7a12f7f20e0} 
bool Spend\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{, }\item[{\textbf{ Coin} $\ast$}]{moveto}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Spend a coin. Pass moveto in order to get the deleted data. If no unspent output exists for the passed outpoint, this call has no effect. \index{CCoinsViewCache@{CCoinsViewCache}!Sync@{Sync}}
\index{Sync@{Sync}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{Sync()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a071d010e76ac762ffab420fcf90656a4} 
bool Sync (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Push the modifications applied to this cache to its base while retaining the contents of this cache (except for spent coins, which we erase). Failure to call this method or \doxyref{Flush()}{p.}{class_c_coins_view_cache_a166e3b1951caaaf582e7b67c5be762ce} before destruction will cause the changes to be forgotten. If false is returned, the state of this cache (and its backing view) will be undefined. \index{CCoinsViewCache@{CCoinsViewCache}!Uncache@{Uncache}}
\index{Uncache@{Uncache}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{Uncache()}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_ad79839a8f70a58de19104ac6bfbb5ae8} 
void Uncache (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption})}

Removes the UTXO with the given outpoint from the cache, if it is not modified. 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CCoinsViewCache@{CCoinsViewCache}!cacheCoins@{cacheCoins}}
\index{cacheCoins@{cacheCoins}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{cacheCoins}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a7923587df4fa5cc22ab7b68c34f74c94} 
\textbf{ CCoins\+Map} cache\+Coins\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [protected]}}

\index{CCoinsViewCache@{CCoinsViewCache}!cachedCoinsUsage@{cachedCoinsUsage}}
\index{cachedCoinsUsage@{cachedCoinsUsage}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{cachedCoinsUsage}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a8c1d785094f8ac4c2ace4dee99bcbe37} 
size\+\_\+t cached\+Coins\+Usage \{0\}\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [protected]}}

\index{CCoinsViewCache@{CCoinsViewCache}!hashBlock@{hashBlock}}
\index{hashBlock@{hashBlock}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{hashBlock}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_ac39f229fd16f40a5743453adc110dfb4} 
\textbf{ uint256} hash\+Block\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [protected]}}

Make mutable so that we can "{}fill the cache"{} even from Get-\/methods declared as "{}const"{}. \index{CCoinsViewCache@{CCoinsViewCache}!m\_cache\_coins\_memory\_resource@{m\_cache\_coins\_memory\_resource}}
\index{m\_cache\_coins\_memory\_resource@{m\_cache\_coins\_memory\_resource}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{m\_cache\_coins\_memory\_resource}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a1bba2e27d1155e615224665ac117e1f2} 
\textbf{ CCoins\+Map\+Memory\+Resource} m\+\_\+cache\+\_\+coins\+\_\+memory\+\_\+resource \{\}\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [protected]}}

\index{CCoinsViewCache@{CCoinsViewCache}!m\_sentinel@{m\_sentinel}}
\index{m\_sentinel@{m\_sentinel}!CCoinsViewCache@{CCoinsViewCache}}
\doxysubsubsection{m\_sentinel}
{\footnotesize\ttfamily \label{class_c_coins_view_cache_a6a970d45d413eb7695ee5c862c57a542} 
\textbf{ Coins\+Cache\+Pair} m\+\_\+sentinel\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [protected]}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ coins.\+h}\item 
src/\textbf{ coins.\+cpp}\end{DoxyCompactItemize}
