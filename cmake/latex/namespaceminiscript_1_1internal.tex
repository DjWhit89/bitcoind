\doxysection{miniscript\+::internal Namespace Reference}
\label{namespaceminiscript_1_1internal}\index{miniscript::internal@{miniscript::internal}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Input\+Stack}
\begin{DoxyCompactList}\small\item\em An object representing a sequence of witness stack elements. \end{DoxyCompactList}\item 
struct \textbf{ Input\+Result}
\begin{DoxyCompactList}\small\item\em A pair of a satisfaction and a dissatisfaction \doxyref{Input\+Stack}{p.}{structminiscript_1_1internal_1_1_input_stack}. \end{DoxyCompactList}\item 
struct \textbf{ Max\+Int}
\begin{DoxyCompactList}\small\item\em Class whose objects represent the maximum of a list of integers. \end{DoxyCompactList}\item 
struct \textbf{ Ops}
\item 
struct \textbf{ Sat\+Info}
\item 
struct \textbf{ Stack\+Size}
\item 
struct \textbf{ Witness\+Size}
\item 
struct \textbf{ No\+Dup\+Check}
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Parse\+Context} \{ \newline
\textbf{ WRAPPED\+\_\+\+EXPR}
, \textbf{ EXPR}
, \textbf{ SWAP}
, \textbf{ ALT}
, \newline
\textbf{ CHECK}
, \textbf{ DUP\+\_\+\+IF}
, \textbf{ VERIFY}
, \textbf{ NON\+\_\+\+ZERO}
, \newline
\textbf{ ZERO\+\_\+\+NOTEQUAL}
, \textbf{ WRAP\+\_\+U}
, \textbf{ WRAP\+\_\+T}
, \textbf{ AND\+\_\+N}
, \newline
\textbf{ AND\+\_\+V}
, \textbf{ AND\+\_\+B}
, \textbf{ ANDOR}
, \textbf{ OR\+\_\+B}
, \newline
\textbf{ OR\+\_\+C}
, \textbf{ OR\+\_\+D}
, \textbf{ OR\+\_\+I}
, \textbf{ THRESH}
, \newline
\textbf{ COMMA}
, \textbf{ CLOSE\+\_\+\+BRACKET}
 \}
\item 
enum class \textbf{ Decode\+Context} \{ \newline
\textbf{ SINGLE\+\_\+\+BKV\+\_\+\+EXPR}
, \textbf{ BKV\+\_\+\+EXPR}
, \textbf{ W\+\_\+\+EXPR}
, \textbf{ SWAP}
, \newline
\textbf{ ALT}
, \textbf{ CHECK}
, \textbf{ DUP\+\_\+\+IF}
, \textbf{ VERIFY}
, \newline
\textbf{ NON\+\_\+\+ZERO}
, \textbf{ ZERO\+\_\+\+NOTEQUAL}
, \textbf{ MAYBE\+\_\+\+AND\+\_\+V}
, \textbf{ AND\+\_\+V}
, \newline
\textbf{ AND\+\_\+B}
, \textbf{ ANDOR}
, \textbf{ OR\+\_\+B}
, \textbf{ OR\+\_\+C}
, \newline
\textbf{ OR\+\_\+D}
, \textbf{ THRESH\+\_\+W}
, \textbf{ THRESH\+\_\+E}
, \textbf{ ENDIF}
, \newline
\textbf{ ENDIF\+\_\+\+NOTIF}
, \textbf{ ENDIF\+\_\+\+ELSE}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Type} \textbf{ Sanitize\+Type} (\textbf{ Type} x)
\begin{DoxyCompactList}\small\item\em A helper sanitizer/checker for the output of Calc\+Type. \end{DoxyCompactList}\item 
\textbf{ Type} \textbf{ Compute\+Type} (\textbf{ Fragment} fragment, \textbf{ Type} x, \textbf{ Type} y, \textbf{ Type} z, const std\+::vector$<$ \textbf{ Type} $>$ \&sub\+\_\+types, uint32\+\_\+t k, size\+\_\+t data\+\_\+size, size\+\_\+t n\+\_\+subs, size\+\_\+t n\+\_\+keys, \textbf{ Miniscript\+Context} ms\+\_\+ctx)
\begin{DoxyCompactList}\small\item\em Helper function for Node\+::\+Calc\+Type. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Compute\+Script\+Len} (\textbf{ Fragment} fragment, \textbf{ Type} sub0typ, size\+\_\+t subsize, uint32\+\_\+t k, size\+\_\+t n\+\_\+subs, size\+\_\+t n\+\_\+keys, \textbf{ Miniscript\+Context} ms\+\_\+ctx)
\begin{DoxyCompactList}\small\item\em Helper function for Node\+::\+Calc\+Script\+Len. \end{DoxyCompactList}\item 
\textbf{ Input\+Stack} \textbf{ operator+} (\textbf{ Input\+Stack} a, \textbf{ Input\+Stack} b)
\item 
\textbf{ Input\+Stack} \textbf{ operator$\vert$} (\textbf{ Input\+Stack} a, \textbf{ Input\+Stack} b)
\item 
std\+::optional$<$ std\+::vector$<$ \textbf{ Opcode} $>$ $>$ \textbf{ Decompose\+Script} (const \textbf{ CScript} \&\textbf{ script})
\item 
std\+::optional$<$ int64\+\_\+t $>$ \textbf{ Parse\+Script\+Number} (const \textbf{ Opcode} \&in)
\item 
int \textbf{ Find\+Next\+Char} (std\+::span$<$ const char $>$ sp, const char m)
\item 
constexpr uint32\+\_\+t \textbf{ Max\+Script\+Size} (\textbf{ Miniscript\+Context} ms\+\_\+ctx)
\item 
{\footnotesize template$<$typename Key, typename Ctx$>$ }\\std\+::optional$<$ std\+::pair$<$ Key, int $>$ $>$ \textbf{ Parse\+Key\+End} (std\+::span$<$ const char $>$ in, const Ctx \&ctx)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\std\+::optional$<$ std\+::pair$<$ std\+::vector$<$ unsigned char $>$, int $>$ $>$ \textbf{ Parse\+Hex\+Str\+End} (std\+::span$<$ const char $>$ in, const size\+\_\+t expected\+\_\+size, const Ctx \&ctx)
\item 
{\footnotesize template$<$typename Key$>$ }\\void \textbf{ Build\+Back} (const \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ \&constructed, const bool reverse=false)
\item 
{\footnotesize template$<$typename Key, typename Ctx$>$ }\\\textbf{ Node\+Ref}$<$ Key $>$ \textbf{ Parse} (std\+::span$<$ const char $>$ in, const Ctx \&ctx)
\item 
{\footnotesize template$<$typename Key, typename Ctx, typename I$>$ }\\\textbf{ Node\+Ref}$<$ Key $>$ \textbf{ Decode\+Script} (I \&in, I last, const Ctx \&ctx)
\begin{DoxyCompactList}\small\item\em Parse a miniscript from a bitcoin script. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr uint32\+\_\+t \textbf{ TX\+\_\+\+OVERHEAD} \{4 + 4\}
\begin{DoxyCompactList}\small\item\em version + n\+Lock\+Time \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ TXIN\+\_\+\+BYTES\+\_\+\+NO\+\_\+\+WITNESS} \{36 + 4 + 1\}
\begin{DoxyCompactList}\small\item\em prevout + n\+Sequence + script\+Sig \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ P2\+WSH\+\_\+\+TXOUT\+\_\+\+BYTES} \{8 + 1 + 1 + 33\}
\begin{DoxyCompactList}\small\item\em n\+Value + script len + OP\+\_\+0 + pushdata 32. \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ TX\+\_\+\+BODY\+\_\+\+LEEWAY\+\_\+\+WEIGHT} \{(\textbf{ TX\+\_\+\+OVERHEAD} + \textbf{ Get\+Size\+Of\+Compact\+Size}(1) + \textbf{ TXIN\+\_\+\+BYTES\+\_\+\+NO\+\_\+\+WITNESS} + \textbf{ Get\+Size\+Of\+Compact\+Size}(1) + \textbf{ P2\+WSH\+\_\+\+TXOUT\+\_\+\+BYTES}) $\ast$ WITNESS\+\_\+\+SCALE\+\_\+\+FACTOR + 2\}
\begin{DoxyCompactList}\small\item\em Data other than the witness in a transaction. Overhead + vin count + one vin + vout count + one vout + segwit marker. \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ MAX\+\_\+\+TAPSCRIPT\+\_\+\+SAT\+\_\+\+SIZE} \{\textbf{ Get\+Size\+Of\+Compact\+Size}(MAX\+\_\+\+STACK\+\_\+\+SIZE) + (\textbf{ Get\+Size\+Of\+Compact\+Size}(MAX\+\_\+\+TAPMINISCRIPT\+\_\+\+STACK\+\_\+\+ELEM\+\_\+\+SIZE) + MAX\+\_\+\+TAPMINISCRIPT\+\_\+\+STACK\+\_\+\+ELEM\+\_\+\+SIZE) $\ast$ MAX\+\_\+\+STACK\+\_\+\+SIZE + \textbf{ Get\+Size\+Of\+Compact\+Size}(TAPROOT\+\_\+\+CONTROL\+\_\+\+MAX\+\_\+\+SIZE) + TAPROOT\+\_\+\+CONTROL\+\_\+\+MAX\+\_\+\+SIZE\}
\begin{DoxyCompactList}\small\item\em Maximum possible stack size to spend a Taproot output (excluding the script itself). \end{DoxyCompactList}\end{DoxyCompactItemize}


\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{miniscript::internal@{miniscript::internal}!DecodeContext@{DecodeContext}}
\index{DecodeContext@{DecodeContext}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{DecodeContext}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120} 
enum class \textbf{ Decode\+Context}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{SINGLE\_BKV\_EXPR@{SINGLE\_BKV\_EXPR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!SINGLE\_BKV\_EXPR@{SINGLE\_BKV\_EXPR}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a0bb08feb8e58dee36b47e7f69dbdd071} 
SINGLE\+\_\+\+BKV\+\_\+\+EXPR&A single expression of type B, K, or V. Specifically, this can\textquotesingle{}t be an and\+\_\+v or an expression of type W (a\+: and s\+: wrappers). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{BKV\_EXPR@{BKV\_EXPR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!BKV\_EXPR@{BKV\_EXPR}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a283aa64734688ae72214a692b743e135} 
BKV\+\_\+\+EXPR&Potentially multiple SINGLE\+\_\+\+BKV\+\_\+\+EXPRs as children of (potentially multiple) and\+\_\+v expressions. Syntactic sugar for MAYBE\+\_\+\+AND\+\_\+V + SINGLE\+\_\+\+BKV\+\_\+\+EXPR. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{W\_EXPR@{W\_EXPR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!W\_EXPR@{W\_EXPR}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a501b4566de4741021ed321a1312b8911} 
W\+\_\+\+EXPR&An expression of type W (a\+: or s\+: wrappers). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SWAP@{SWAP}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!SWAP@{SWAP}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a46fc23bc4e4d57e5469a39658a6dd3e8} 
SWAP&SWAP expects the next element to be OP\+\_\+\+SWAP (inside a W-\/type expression that didn\textquotesingle{}t end with FROMALTSTACK), and wraps the top of the constructed stack with s\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ALT@{ALT}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ALT@{ALT}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120adfbfc9cc7a235560f04cb1a5faf1ec3e} 
ALT&ALT expects the next element to be TOALTSTACK (we must have already read a FROMALTSTACK earlier), and wraps the top of the constructed stack with a\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{CHECK@{CHECK}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!CHECK@{CHECK}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a8c46d8d9d3402788403e2f6911153089} 
CHECK&CHECK wraps the top constructed node with c\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{DUP\_IF@{DUP\_IF}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!DUP\_IF@{DUP\_IF}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a9362f0ff4871b693667ba2e4732c02da} 
DUP\+\_\+\+IF&DUP\+\_\+\+IF wraps the top constructed node with d\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{VERIFY@{VERIFY}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!VERIFY@{VERIFY}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a0b4c12d7e0a73840c1c4f148fda3b037} 
VERIFY&VERIFY wraps the top constructed node with v\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NON\_ZERO@{NON\_ZERO}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!NON\_ZERO@{NON\_ZERO}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120ab565263de845e66aad41844b7f3c4946} 
NON\+\_\+\+ZERO&NON\+\_\+\+ZERO wraps the top constructed node with j\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ZERO\_NOTEQUAL@{ZERO\_NOTEQUAL}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ZERO\_NOTEQUAL@{ZERO\_NOTEQUAL}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120ab531e0f2f7d3b2585765c1fcb46462e5} 
ZERO\+\_\+\+NOTEQUAL&ZERO\+\_\+\+NOTEQUAL wraps the top constructed node with n\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MAYBE\_AND\_V@{MAYBE\_AND\_V}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!MAYBE\_AND\_V@{MAYBE\_AND\_V}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a399cf171174343d572acc28659acd09e} 
MAYBE\+\_\+\+AND\+\_\+V&MAYBE\+\_\+\+AND\+\_\+V will check if the next part of the script could be a valid miniscript sub-\/expression, and if so it will push AND\+\_\+V and SINGLE\+\_\+\+BKV\+\_\+\+EXPR to decode it and construct the and\+\_\+v node. This is recursive, to deal with multiple and\+\_\+v nodes inside each other. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{AND\_V@{AND\_V}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!AND\_V@{AND\_V}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a7a76c8357af82c1900d6308d7855220a} 
AND\+\_\+V&AND\+\_\+V will construct an and\+\_\+v node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{AND\_B@{AND\_B}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!AND\_B@{AND\_B}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120acac3917c66dfcb0b806a572de3534a11} 
AND\+\_\+B&AND\+\_\+B will construct an and\+\_\+b node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ANDOR@{ANDOR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ANDOR@{ANDOR}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a477cb9f7a7b9acbe7f0fe8e68e42baec} 
ANDOR&ANDOR will construct an andor node from the last three constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_B@{OR\_B}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_B@{OR\_B}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a1f1d97cb213675b7c8a6254f9870aa1b} 
OR\+\_\+B&OR\+\_\+B will construct an or\+\_\+b node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_C@{OR\_C}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_C@{OR\_C}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a9b76909336a0f900ad3ed00af720918f} 
OR\+\_\+C&OR\+\_\+C will construct an or\+\_\+c node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_D@{OR\_D}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_D@{OR\_D}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120ac50198187f55e66b8b20e3dcee6e0d38} 
OR\+\_\+D&OR\+\_\+D will construct an or\+\_\+d node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{THRESH\_W@{THRESH\_W}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!THRESH\_W@{THRESH\_W}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120ae3f116998858d227c947a282e13cd48c} 
THRESH\+\_\+W&In a thresh expression, all sub-\/expressions other than the first are W-\/type, and end in OP\+\_\+\+ADD. THRESH\+\_\+W will check for this OP\+\_\+\+ADD and either push a W\+\_\+\+EXPR or a SINGLE\+\_\+\+BKV\+\_\+\+EXPR and jump to THRESH\+\_\+E accordingly. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{THRESH\_E@{THRESH\_E}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!THRESH\_E@{THRESH\_E}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a813c9a61374c1fd0ee094cad52707059} 
THRESH\+\_\+E&THRESH\+\_\+E constructs a thresh node from the appropriate number of constructed children. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ENDIF@{ENDIF}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ENDIF@{ENDIF}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120aa7edf885402c37993bf4581db4a4615c} 
ENDIF&ENDIF signals that we are inside some sort of OP\+\_\+\+IF structure, which could be or\+\_\+d, or\+\_\+c, or\+\_\+i, andor, d\+:, or j\+: wrapper, depending on what follows. We read a BKV\+\_\+\+EXPR and then deal with the next opcode case-\/by-\/case. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ENDIF\_NOTIF@{ENDIF\_NOTIF}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ENDIF\_NOTIF@{ENDIF\_NOTIF}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a21b3adcdd2d9ae386725d2ad703bcc62} 
ENDIF\+\_\+\+NOTIF&If, inside an ENDIF context, we find an OP\+\_\+\+NOTIF before finding an OP\+\_\+\+ELSE, we could either be in an or\+\_\+d or an or\+\_\+c node. We then check for IFDUP to distinguish these cases. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ENDIF\_ELSE@{ENDIF\_ELSE}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ENDIF\_ELSE@{ENDIF\_ELSE}}}\label{namespaceminiscript_1_1internal_a662e0956f5f3efaa37e9d39516998120a3589f9f38556db84215ee9037f5cf84c} 
ENDIF\+\_\+\+ELSE&If, inside an ENDIF context, we find an OP\+\_\+\+ELSE, then we could be in either an or\+\_\+i or an andor node. Read the next BKV\+\_\+\+EXPR and find either an OP\+\_\+\+IF or an OP\+\_\+\+NOTIF. \\
\hline

\end{DoxyEnumFields}
\index{miniscript::internal@{miniscript::internal}!ParseContext@{ParseContext}}
\index{ParseContext@{ParseContext}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{ParseContext}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797} 
enum class \textbf{ Parse\+Context}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{WRAPPED\_EXPR@{WRAPPED\_EXPR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!WRAPPED\_EXPR@{WRAPPED\_EXPR}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797affdbf66764570d272af5ad31f0b40c14} 
WRAPPED\+\_\+\+EXPR&An expression which may be begin with wrappers followed by a colon. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{EXPR@{EXPR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!EXPR@{EXPR}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797ab0cd8af157ed30eaa1980da18b07a38d} 
EXPR&A miniscript expression which does not begin with wrappers. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SWAP@{SWAP}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!SWAP@{SWAP}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a46fc23bc4e4d57e5469a39658a6dd3e8} 
SWAP&SWAP wraps the top constructed node with s\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ALT@{ALT}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ALT@{ALT}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797adfbfc9cc7a235560f04cb1a5faf1ec3e} 
ALT&ALT wraps the top constructed node with a\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{CHECK@{CHECK}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!CHECK@{CHECK}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a8c46d8d9d3402788403e2f6911153089} 
CHECK&CHECK wraps the top constructed node with c\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{DUP\_IF@{DUP\_IF}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!DUP\_IF@{DUP\_IF}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a9362f0ff4871b693667ba2e4732c02da} 
DUP\+\_\+\+IF&DUP\+\_\+\+IF wraps the top constructed node with d\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{VERIFY@{VERIFY}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!VERIFY@{VERIFY}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a0b4c12d7e0a73840c1c4f148fda3b037} 
VERIFY&VERIFY wraps the top constructed node with v\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NON\_ZERO@{NON\_ZERO}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!NON\_ZERO@{NON\_ZERO}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797ab565263de845e66aad41844b7f3c4946} 
NON\+\_\+\+ZERO&NON\+\_\+\+ZERO wraps the top constructed node with j\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ZERO\_NOTEQUAL@{ZERO\_NOTEQUAL}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ZERO\_NOTEQUAL@{ZERO\_NOTEQUAL}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797ab531e0f2f7d3b2585765c1fcb46462e5} 
ZERO\+\_\+\+NOTEQUAL&ZERO\+\_\+\+NOTEQUAL wraps the top constructed node with n\+: \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{WRAP\_U@{WRAP\_U}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!WRAP\_U@{WRAP\_U}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797af77bef471d90e08efe428179052325ee} 
WRAP\+\_\+U&WRAP\+\_\+U will construct an or\+\_\+i(\+X,0) node from the top constructed node. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{WRAP\_T@{WRAP\_T}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!WRAP\_T@{WRAP\_T}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797ab7432d88778de12539fbb0b52e51cb3c} 
WRAP\+\_\+T&WRAP\+\_\+T will construct an and\+\_\+v(\+X,1) node from the top constructed node. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{AND\_N@{AND\_N}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!AND\_N@{AND\_N}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a2cfc97e25f98c2a4c4d7502e282d0339} 
AND\+\_\+N&AND\+\_\+N will construct an andor(\+X,\+Y,0) node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{AND\_V@{AND\_V}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!AND\_V@{AND\_V}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a7a76c8357af82c1900d6308d7855220a} 
AND\+\_\+V&AND\+\_\+V will construct an and\+\_\+v node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{AND\_B@{AND\_B}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!AND\_B@{AND\_B}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797acac3917c66dfcb0b806a572de3534a11} 
AND\+\_\+B&AND\+\_\+B will construct an and\+\_\+b node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ANDOR@{ANDOR}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!ANDOR@{ANDOR}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a477cb9f7a7b9acbe7f0fe8e68e42baec} 
ANDOR&ANDOR will construct an andor node from the last three constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_B@{OR\_B}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_B@{OR\_B}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a1f1d97cb213675b7c8a6254f9870aa1b} 
OR\+\_\+B&OR\+\_\+B will construct an or\+\_\+b node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_C@{OR\_C}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_C@{OR\_C}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a9b76909336a0f900ad3ed00af720918f} 
OR\+\_\+C&OR\+\_\+C will construct an or\+\_\+c node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_D@{OR\_D}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_D@{OR\_D}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797ac50198187f55e66b8b20e3dcee6e0d38} 
OR\+\_\+D&OR\+\_\+D will construct an or\+\_\+d node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OR\_I@{OR\_I}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!OR\_I@{OR\_I}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a00d71ec48b4f106004f0d1e2b521da37} 
OR\+\_\+I&OR\+\_\+I will construct an or\+\_\+i node from the last two constructed nodes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{THRESH@{THRESH}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!THRESH@{THRESH}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a486f207345522dfc69492f029d832ee8} 
THRESH&THRESH will read a wrapped expression, and then look for a COMMA. If no comma follows, it will construct a thresh node from the appropriate number of constructed children. Otherwise, it will recurse with another THRESH. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COMMA@{COMMA}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!COMMA@{COMMA}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a4d9b3e9fc12849d060371eb65154c751} 
COMMA&COMMA expects the next element to be \textquotesingle{},\textquotesingle{} and fails if not. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{CLOSE\_BRACKET@{CLOSE\_BRACKET}!miniscript::internal@{miniscript::internal}}\index{miniscript::internal@{miniscript::internal}!CLOSE\_BRACKET@{CLOSE\_BRACKET}}}\label{namespaceminiscript_1_1internal_a818d8c9fb081152823a5b0c172a24797a260494f9a3c7deb9951abcb79b25d9cd} 
CLOSE\+\_\+\+BRACKET&CLOSE\+\_\+\+BRACKET expects the next element to be \textquotesingle{})\textquotesingle{} and fails if not. \\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{miniscript::internal@{miniscript::internal}!BuildBack@{BuildBack}}
\index{BuildBack@{BuildBack}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{BuildBack()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a580ea2b864383986772d0a1916961ad8} 
template$<$typename Key$>$ \\
void Build\+Back (\begin{DoxyParamCaption}\item[{const \textbf{ Miniscript\+Context}}]{script\+\_\+ctx}{, }\item[{\textbf{ Fragment}}]{nt}{, }\item[{std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ \&}]{constructed}{, }\item[{const bool}]{reverse}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Build\+Back pops the last two elements off {\ttfamily constructed} and wraps them in the specified \doxyref{Fragment}{p.}{namespaceminiscript_a02db2bde67db0cee6704064a541c67f8} \index{miniscript::internal@{miniscript::internal}!ComputeScriptLen@{ComputeScriptLen}}
\index{ComputeScriptLen@{ComputeScriptLen}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{ComputeScriptLen()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_ae9c0cb5830356826ee6c21d660a0b2d8} 
size\+\_\+t Compute\+Script\+Len (\begin{DoxyParamCaption}\item[{\textbf{ Fragment}}]{fragment}{, }\item[{\textbf{ Type}}]{sub0typ}{, }\item[{size\+\_\+t}]{subsize}{, }\item[{uint32\+\_\+t}]{k}{, }\item[{size\+\_\+t}]{n\+\_\+subs}{, }\item[{size\+\_\+t}]{n\+\_\+keys}{, }\item[{\textbf{ Miniscript\+Context}}]{ms\+\_\+ctx}{}\end{DoxyParamCaption})}



Helper function for Node\+::\+Calc\+Script\+Len. 

\index{miniscript::internal@{miniscript::internal}!ComputeType@{ComputeType}}
\index{ComputeType@{ComputeType}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{ComputeType()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_afd3834c03c09b76fef4206cf2ac9832a} 
\textbf{ Type} Compute\+Type (\begin{DoxyParamCaption}\item[{\textbf{ Fragment}}]{fragment}{, }\item[{\textbf{ Type}}]{x}{, }\item[{\textbf{ Type}}]{y}{, }\item[{\textbf{ Type}}]{z}{, }\item[{const std\+::vector$<$ \textbf{ Type} $>$ \&}]{sub\+\_\+types}{, }\item[{uint32\+\_\+t}]{k}{, }\item[{size\+\_\+t}]{data\+\_\+size}{, }\item[{size\+\_\+t}]{n\+\_\+subs}{, }\item[{size\+\_\+t}]{n\+\_\+keys}{, }\item[{\textbf{ Miniscript\+Context}}]{ms\+\_\+ctx}{}\end{DoxyParamCaption})}



Helper function for Node\+::\+Calc\+Type. 

\index{miniscript::internal@{miniscript::internal}!DecodeScript@{DecodeScript}}
\index{DecodeScript@{DecodeScript}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{DecodeScript()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a19befff2813793a5dd5dbc5a2d691888} 
template$<$typename Key, typename Ctx, typename I$>$ \\
\textbf{ Node\+Ref}$<$ Key $>$ Decode\+Script (\begin{DoxyParamCaption}\item[{I \&}]{in}{, }\item[{I}]{last}{, }\item[{const Ctx \&}]{ctx}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Parse a miniscript from a bitcoin script. 

In the following wrappers, we only need to push SINGLE\+\_\+\+BKV\+\_\+\+EXPR rather than BKV\+\_\+\+EXPR, because and\+\_\+v commutes with these wrappers. For example, c\+:and\+\_\+v(\+X,\+Y) produces the same script as and\+\_\+v(\+X,c\+:\+Y).

In and\+\_\+b and or\+\_\+b nodes, we only look for SINGLE\+\_\+\+BKV\+\_\+\+EXPR, because or\+\_\+b(and\+\_\+v(\+X,\+Y),\+Z) has script [X] [Y] [Z] OP\+\_\+\+BOOLOR, the same as and\+\_\+v(\+X,or\+\_\+b(\+Y,\+Z)). In this example, the former of these is invalid as miniscript, while the latter is valid. So we leave the and\+\_\+v "{}outside"{} while decoding.\index{miniscript::internal@{miniscript::internal}!DecomposeScript@{DecomposeScript}}
\index{DecomposeScript@{DecomposeScript}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{DecomposeScript()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a45e054ec7e9dc5a8a4916e3d429f0a09} 
std\+::optional$<$ std\+::vector$<$ \textbf{ Opcode} $>$ $>$ Decompose\+Script (\begin{DoxyParamCaption}\item[{const \textbf{ CScript} \&}]{script}{}\end{DoxyParamCaption})}

Decode a script into opcode/push pairs.

Construct a vector with one element per opcode in the script, in reverse order. Each element is a pair consisting of the opcode, as well as the data pushed by the opcode (including OP\+\_\+n), if any. OP\+\_\+\+CHECKSIGVERIFY, OP\+\_\+\+CHECKMULTISIGVERIFY, OP\+\_\+\+NUMEQUALVERIFY and OP\+\_\+\+EQUALVERIFY are decomposed into OP\+\_\+\+CHECKSIG, OP\+\_\+\+CHECKMULTISIG, OP\+\_\+\+EQUAL and OP\+\_\+\+NUMEQUAL respectively, plus OP\+\_\+\+VERIFY. \index{miniscript::internal@{miniscript::internal}!FindNextChar@{FindNextChar}}
\index{FindNextChar@{FindNextChar}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{FindNextChar()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a48c96686b2bb4f946e85ab992906df82} 
int Find\+Next\+Char (\begin{DoxyParamCaption}\item[{std\+::span$<$ const char $>$}]{sp}{, }\item[{const char}]{m}{}\end{DoxyParamCaption})}

\index{miniscript::internal@{miniscript::internal}!MaxScriptSize@{MaxScriptSize}}
\index{MaxScriptSize@{MaxScriptSize}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{MaxScriptSize()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a0f146e7f191b495aa49d8004ee6bc6c0} 
uint32\+\_\+t Max\+Script\+Size (\begin{DoxyParamCaption}\item[{\textbf{ Miniscript\+Context}}]{ms\+\_\+ctx}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}

The maximum size of a script depending on the context. \index{miniscript::internal@{miniscript::internal}!operator+@{operator+}}
\index{operator+@{operator+}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{operator+()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a2527309fc564f01a8c0f44c517a70c1b} 
\textbf{ Input\+Stack} operator+ (\begin{DoxyParamCaption}\item[{\textbf{ Input\+Stack}}]{a}{, }\item[{\textbf{ Input\+Stack}}]{b}{}\end{DoxyParamCaption})}

\index{miniscript::internal@{miniscript::internal}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{operator\texttt{"|}()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a1be38e45874ee0171f2e2348dee43224} 
\textbf{ Input\+Stack} operator$\vert$ (\begin{DoxyParamCaption}\item[{\textbf{ Input\+Stack}}]{a}{, }\item[{\textbf{ Input\+Stack}}]{b}{}\end{DoxyParamCaption})}

\index{miniscript::internal@{miniscript::internal}!Parse@{Parse}}
\index{Parse@{Parse}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{Parse()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_acd3fd7352ca25025425ba3750883d99b} 
template$<$typename Key, typename Ctx$>$ \\
\textbf{ Node\+Ref}$<$ Key $>$ Parse (\begin{DoxyParamCaption}\item[{std\+::span$<$ const char $>$}]{in}{, }\item[{const Ctx \&}]{ctx}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Parse a miniscript from its textual descriptor form. This does not check whether the script is valid, let alone sane. The caller is expected to use the {\ttfamily Is\+Valid\+Top\+Level()} and {\ttfamily Is\+Sane\+Top\+Level()} to check for these properties on the node. \index{miniscript::internal@{miniscript::internal}!ParseHexStrEnd@{ParseHexStrEnd}}
\index{ParseHexStrEnd@{ParseHexStrEnd}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{ParseHexStrEnd()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a3cf348a8b6d27e520e49a0650dd4293b} 
template$<$typename Ctx$>$ \\
std\+::optional$<$ std\+::pair$<$ std\+::vector$<$ unsigned char $>$, int $>$ $>$ Parse\+Hex\+Str\+End (\begin{DoxyParamCaption}\item[{std\+::span$<$ const char $>$}]{in}{, }\item[{const size\+\_\+t}]{expected\+\_\+size}{, }\item[{const Ctx \&}]{ctx}{}\end{DoxyParamCaption})}

Parse a hex string ending at the end of the fragment\textquotesingle{}s text representation. \index{miniscript::internal@{miniscript::internal}!ParseKeyEnd@{ParseKeyEnd}}
\index{ParseKeyEnd@{ParseKeyEnd}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{ParseKeyEnd()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a3d2bae5ee8cc452fa1bb61ba930230a4} 
template$<$typename Key, typename Ctx$>$ \\
std\+::optional$<$ std\+::pair$<$ Key, int $>$ $>$ Parse\+Key\+End (\begin{DoxyParamCaption}\item[{std\+::span$<$ const char $>$}]{in}{, }\item[{const Ctx \&}]{ctx}{}\end{DoxyParamCaption})}

Parse a key string ending at the end of the fragment\textquotesingle{}s text representation. \index{miniscript::internal@{miniscript::internal}!ParseScriptNumber@{ParseScriptNumber}}
\index{ParseScriptNumber@{ParseScriptNumber}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{ParseScriptNumber()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a8fd863aeff13a9b9cb1ba5f4bb80d64a} 
std\+::optional$<$ int64\+\_\+t $>$ Parse\+Script\+Number (\begin{DoxyParamCaption}\item[{const \textbf{ Opcode} \&}]{in}{}\end{DoxyParamCaption})}

Determine whether the passed pair (created by Decompose\+Script) is pushing a number. \index{miniscript::internal@{miniscript::internal}!SanitizeType@{SanitizeType}}
\index{SanitizeType@{SanitizeType}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{SanitizeType()}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a1fed685d02fc4884793f8741d0e6b7fa} 
\textbf{ Type} Sanitize\+Type (\begin{DoxyParamCaption}\item[{\textbf{ Type}}]{e}{}\end{DoxyParamCaption})}



A helper sanitizer/checker for the output of Calc\+Type. 



\label{doc-var-members}
\doxysubsection{Variable Documentation}
\index{miniscript::internal@{miniscript::internal}!MAX\_TAPSCRIPT\_SAT\_SIZE@{MAX\_TAPSCRIPT\_SAT\_SIZE}}
\index{MAX\_TAPSCRIPT\_SAT\_SIZE@{MAX\_TAPSCRIPT\_SAT\_SIZE}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{MAX\_TAPSCRIPT\_SAT\_SIZE}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_aa226c9e93b1157c353529298a3bd527e} 
uint32\+\_\+t MAX\+\_\+\+TAPSCRIPT\+\_\+\+SAT\+\_\+\+SIZE \{\textbf{ Get\+Size\+Of\+Compact\+Size}(MAX\+\_\+\+STACK\+\_\+\+SIZE) + (\textbf{ Get\+Size\+Of\+Compact\+Size}(MAX\+\_\+\+TAPMINISCRIPT\+\_\+\+STACK\+\_\+\+ELEM\+\_\+\+SIZE) + MAX\+\_\+\+TAPMINISCRIPT\+\_\+\+STACK\+\_\+\+ELEM\+\_\+\+SIZE) $\ast$ MAX\+\_\+\+STACK\+\_\+\+SIZE + \textbf{ Get\+Size\+Of\+Compact\+Size}(TAPROOT\+\_\+\+CONTROL\+\_\+\+MAX\+\_\+\+SIZE) + TAPROOT\+\_\+\+CONTROL\+\_\+\+MAX\+\_\+\+SIZE\}\hspace{0.3cm}{\ttfamily [constexpr]}}



Maximum possible stack size to spend a Taproot output (excluding the script itself). 

\index{miniscript::internal@{miniscript::internal}!P2WSH\_TXOUT\_BYTES@{P2WSH\_TXOUT\_BYTES}}
\index{P2WSH\_TXOUT\_BYTES@{P2WSH\_TXOUT\_BYTES}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{P2WSH\_TXOUT\_BYTES}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_aa85394e8d5ea4494250ed2fb6599817c} 
uint32\+\_\+t P2\+WSH\+\_\+\+TXOUT\+\_\+\+BYTES \{8 + 1 + 1 + 33\}\hspace{0.3cm}{\ttfamily [constexpr]}}



n\+Value + script len + OP\+\_\+0 + pushdata 32. 

\index{miniscript::internal@{miniscript::internal}!TX\_BODY\_LEEWAY\_WEIGHT@{TX\_BODY\_LEEWAY\_WEIGHT}}
\index{TX\_BODY\_LEEWAY\_WEIGHT@{TX\_BODY\_LEEWAY\_WEIGHT}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{TX\_BODY\_LEEWAY\_WEIGHT}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_aa9b8628beb4eac08bad4c6bdd679f881} 
uint32\+\_\+t TX\+\_\+\+BODY\+\_\+\+LEEWAY\+\_\+\+WEIGHT \{(\textbf{ TX\+\_\+\+OVERHEAD} + \textbf{ Get\+Size\+Of\+Compact\+Size}(1) + \textbf{ TXIN\+\_\+\+BYTES\+\_\+\+NO\+\_\+\+WITNESS} + \textbf{ Get\+Size\+Of\+Compact\+Size}(1) + \textbf{ P2\+WSH\+\_\+\+TXOUT\+\_\+\+BYTES}) $\ast$ WITNESS\+\_\+\+SCALE\+\_\+\+FACTOR + 2\}\hspace{0.3cm}{\ttfamily [constexpr]}}



Data other than the witness in a transaction. Overhead + vin count + one vin + vout count + one vout + segwit marker. 

\index{miniscript::internal@{miniscript::internal}!TX\_OVERHEAD@{TX\_OVERHEAD}}
\index{TX\_OVERHEAD@{TX\_OVERHEAD}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{TX\_OVERHEAD}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_a65e769dad36af5863e82900834035fd8} 
uint32\+\_\+t TX\+\_\+\+OVERHEAD \{4 + 4\}\hspace{0.3cm}{\ttfamily [constexpr]}}



version + n\+Lock\+Time 

\index{miniscript::internal@{miniscript::internal}!TXIN\_BYTES\_NO\_WITNESS@{TXIN\_BYTES\_NO\_WITNESS}}
\index{TXIN\_BYTES\_NO\_WITNESS@{TXIN\_BYTES\_NO\_WITNESS}!miniscript::internal@{miniscript::internal}}
\doxysubsubsection{TXIN\_BYTES\_NO\_WITNESS}
{\footnotesize\ttfamily \label{namespaceminiscript_1_1internal_acf16aac084d691145181a6a43004e92c} 
uint32\+\_\+t TXIN\+\_\+\+BYTES\+\_\+\+NO\+\_\+\+WITNESS \{36 + 4 + 1\}\hspace{0.3cm}{\ttfamily [constexpr]}}



prevout + n\+Sequence + script\+Sig 

