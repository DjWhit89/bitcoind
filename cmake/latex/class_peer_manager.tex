\doxysection{Peer\+Manager Class Reference}
\label{class_peer_manager}\index{PeerManager@{PeerManager}}


{\ttfamily \#include $<$net\+\_\+processing.\+h$>$}

Inheritance diagram for Peer\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_peer_manager}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Options}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+Peer\+Manager} ()=default
\item 
virtual \textbf{ util\+::\+Expected}$<$ void, std\+::string $>$ \textbf{ Fetch\+Block} (\textbf{ Node\+Id} peer\+\_\+id, const \textbf{ CBlock\+Index} \&block\+\_\+index)=0
\item 
virtual void \textbf{ Start\+Scheduled\+Tasks} (\textbf{ CScheduler} \&scheduler)=0
\item 
virtual bool \textbf{ Get\+Node\+State\+Stats} (\textbf{ Node\+Id} nodeid, \textbf{ CNode\+State\+Stats} \&stats) const =0
\item 
virtual std\+::vector$<$ \textbf{ node\+::\+Tx\+Orphanage\+::\+Orphan\+Info} $>$ \textbf{ Get\+Orphan\+Transactions} ()=0
\item 
virtual \textbf{ Peer\+Manager\+Info} \textbf{ Get\+Info} () const =0
\item 
virtual void \textbf{ Relay\+Transaction} (const \textbf{ Txid} \&txid, const \textbf{ Wtxid} \&wtxid)=0
\item 
virtual void \textbf{ Send\+Pings} ()=0
\item 
virtual void \textbf{ Set\+Best\+Block} (int height, std\+::chrono\+::seconds time)=0
\item 
virtual void \textbf{ Unit\+Test\+Misbehaving} (\textbf{ Node\+Id} peer\+\_\+id)=0
\item 
virtual void \textbf{ Check\+For\+Stale\+Tip\+And\+Evict\+Peers} ()=0
\item 
virtual void \textbf{ Process\+Message} (\textbf{ CNode} \&pfrom, const std\+::string \&msg\+\_\+type, \textbf{ Data\+Stream} \&v\+Recv, const std\+::chrono\+::microseconds time\+\_\+received, const std\+::atomic$<$ bool $>$ \&interrupt\+Msg\+Proc) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ g\+\_\+msgproc\+\_\+mutex})=0
\item 
virtual void \textbf{ Update\+Last\+Block\+Announce\+Time} (\textbf{ Node\+Id} \textbf{ node}, int64\+\_\+t time\+\_\+in\+\_\+seconds)=0
\item 
virtual \textbf{ Service\+Flags} \textbf{ Get\+Desirable\+Service\+Flags} (\textbf{ Service\+Flags} services) const =0
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Net\+Events\+Interface}}
\begin{DoxyCompactItemize}
\item 
virtual void \textbf{ Initialize\+Node} (const \textbf{ CNode} \&\textbf{ node}, \textbf{ Service\+Flags} our\+\_\+services)=0
\item 
virtual void \textbf{ Finalize\+Node} (const \textbf{ CNode} \&\textbf{ node})=0
\item 
virtual bool \textbf{ Has\+All\+Desirable\+Service\+Flags} (\textbf{ Service\+Flags} services) const =0
\item 
virtual bool \textbf{ Process\+Messages} (\textbf{ CNode} $\ast$pnode, std\+::atomic$<$ bool $>$ \&interrupt) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ g\+\_\+msgproc\+\_\+mutex})=0
\item 
virtual bool \textbf{ Send\+Messages} (\textbf{ CNode} $\ast$pnode) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ g\+\_\+msgproc\+\_\+mutex})=0
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::unique\+\_\+ptr$<$ \textbf{ Peer\+Manager} $>$ \textbf{ make} (\textbf{ CConnman} \&connman, \textbf{ Addr\+Man} \&addrman, \textbf{ Ban\+Man} $\ast$banman, \textbf{ Chainstate\+Manager} \&chainman, \textbf{ CTx\+Mem\+Pool} \&pool, \textbf{ node\+::\+Warnings} \&warnings, \textbf{ Options} opts)
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Static Public Attributes inherited from \textbf{ Net\+Events\+Interface}}
\begin{DoxyCompactItemize}
\item 
static \textbf{ Mutex} \textbf{ g\+\_\+msgproc\+\_\+mutex}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \textbf{ CValidation\+Interface}}
\begin{DoxyCompactItemize}
\item 
\textbf{ $\sim$\+CValidation\+Interface} ()=default
\item 
virtual void \textbf{ Updated\+Block\+Tip} (const \textbf{ CBlock\+Index} $\ast$pindex\+New, const \textbf{ CBlock\+Index} $\ast$pindex\+Fork, bool f\+Initial\+Download)
\item 
virtual void \textbf{ Active\+Tip\+Change} (const \textbf{ CBlock\+Index} \&new\+\_\+tip, bool is\+\_\+ibd)
\item 
virtual void \textbf{ Transaction\+Added\+To\+Mempool} (const \textbf{ New\+Mempool\+Transaction\+Info} \&tx, uint64\+\_\+t mempool\+\_\+sequence)
\item 
virtual void \textbf{ Transaction\+Removed\+From\+Mempool} (const \textbf{ CTransaction\+Ref} \&tx, \textbf{ Mem\+Pool\+Removal\+Reason} reason, uint64\+\_\+t mempool\+\_\+sequence)
\item 
virtual void \textbf{ Mempool\+Transactions\+Removed\+For\+Block} (const std\+::vector$<$ \textbf{ Removed\+Mempool\+Transaction\+Info} $>$ \&txs\+\_\+removed\+\_\+for\+\_\+block, unsigned int n\+Block\+Height)
\item 
virtual void \textbf{ Block\+Connected} (const \textbf{ kernel\+::\+Chainstate\+Role} \&role, const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block, const \textbf{ CBlock\+Index} $\ast$pindex)
\item 
virtual void \textbf{ Block\+Disconnected} (const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block, const \textbf{ CBlock\+Index} $\ast$pindex)
\item 
virtual void \textbf{ Chain\+State\+Flushed} (const \textbf{ kernel\+::\+Chainstate\+Role} \&role, const \textbf{ CBlock\+Locator} \&locator)
\item 
virtual void \textbf{ Block\+Checked} (const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&, const \textbf{ Block\+Validation\+State} \&)
\item 
virtual void \textbf{ New\+Po\+WValid\+Block} (const \textbf{ CBlock\+Index} $\ast$pindex, const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \textbf{ Net\+Events\+Interface}}
\begin{DoxyCompactItemize}
\item 
\textbf{ $\sim$\+Net\+Events\+Interface} ()=default
\end{DoxyCompactItemize}


\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{PeerManager@{PeerManager}!````~PeerManager@{$\sim$PeerManager}}
\index{````~PeerManager@{$\sim$PeerManager}!PeerManager@{PeerManager}}
\doxysubsubsection{$\sim$PeerManager()}
{\footnotesize\ttfamily \label{class_peer_manager_ab191021c40d824d5b59934fe57edf727} 
virtual $\sim$\textbf{ Peer\+Manager} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{PeerManager@{PeerManager}!CheckForStaleTipAndEvictPeers@{CheckForStaleTipAndEvictPeers}}
\index{CheckForStaleTipAndEvictPeers@{CheckForStaleTipAndEvictPeers}!PeerManager@{PeerManager}}
\doxysubsubsection{CheckForStaleTipAndEvictPeers()}
{\footnotesize\ttfamily \label{class_peer_manager_ac0c70b84d12d79139bf57a1902433c71} 
virtual void Check\+For\+Stale\+Tip\+And\+Evict\+Peers (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound. Public for unit testing. \index{PeerManager@{PeerManager}!FetchBlock@{FetchBlock}}
\index{FetchBlock@{FetchBlock}!PeerManager@{PeerManager}}
\doxysubsubsection{FetchBlock()}
{\footnotesize\ttfamily \label{class_peer_manager_a03d7d69a9ddfb5f9f1b88c898a100f7c} 
virtual \textbf{ util\+::\+Expected}$<$ void, std\+::string $>$ Fetch\+Block (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{peer\+\_\+id}{, }\item[{const \textbf{ CBlock\+Index} \&}]{block\+\_\+index}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Attempt to manually fetch block from a given peer. We must already have the header.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em peer\+\_\+id} & The peer id \\
\hline
\mbox{\texttt{in}}  & {\em block\+\_\+index} & The blockindex \\
\hline
\end{DoxyParams}
\index{PeerManager@{PeerManager}!GetDesirableServiceFlags@{GetDesirableServiceFlags}}
\index{GetDesirableServiceFlags@{GetDesirableServiceFlags}!PeerManager@{PeerManager}}
\doxysubsubsection{GetDesirableServiceFlags()}
{\footnotesize\ttfamily \label{class_peer_manager_a8ae23db0fe06993a981413fc44cda731} 
virtual \textbf{ Service\+Flags} Get\+Desirable\+Service\+Flags (\begin{DoxyParamCaption}\item[{\textbf{ Service\+Flags}}]{services}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Gets the set of service flags which are "{}desirable"{} for a given peer.

These are the flags which are required for a peer to support for them to be "{}interesting"{} to us, ie for us to wish to use one of our few outbound connection slots for or for us to wish to prioritize keeping their connection around.

Relevant service flags may be peer-\/ and state-\/specific in that the version of the peer may determine which flags are required (eg in the case of NODE\+\_\+\+NETWORK\+\_\+\+LIMITED where we seek out NODE\+\_\+\+NETWORK peers unless they set NODE\+\_\+\+NETWORK\+\_\+\+LIMITED and we are out of IBD, in which case NODE\+\_\+\+NETWORK\+\_\+\+LIMITED suffices).

Thus, generally, avoid calling with \textquotesingle{}services\textquotesingle{} == NODE\+\_\+\+NONE, unless state-\/specific flags must absolutely be avoided. When called with \textquotesingle{}services\textquotesingle{} == NODE\+\_\+\+NONE, the returned desirable service flags are guaranteed to not change dependent on state -\/ ie they are suitable for use when describing peers which we know to be desirable, but for which we do not have a confirmed set of service flags. \index{PeerManager@{PeerManager}!GetInfo@{GetInfo}}
\index{GetInfo@{GetInfo}!PeerManager@{PeerManager}}
\doxysubsubsection{GetInfo()}
{\footnotesize\ttfamily \label{class_peer_manager_a652b885b735d84bcdc54aee50f0991d3} 
virtual \textbf{ Peer\+Manager\+Info} Get\+Info (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get peer manager info. \index{PeerManager@{PeerManager}!GetNodeStateStats@{GetNodeStateStats}}
\index{GetNodeStateStats@{GetNodeStateStats}!PeerManager@{PeerManager}}
\doxysubsubsection{GetNodeStateStats()}
{\footnotesize\ttfamily \label{class_peer_manager_a0a2c0b5d5bdbe570534c723ac8ed40d2} 
virtual bool Get\+Node\+State\+Stats (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{nodeid}{, }\item[{\textbf{ CNode\+State\+Stats} \&}]{stats}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get statistics from node state \index{PeerManager@{PeerManager}!GetOrphanTransactions@{GetOrphanTransactions}}
\index{GetOrphanTransactions@{GetOrphanTransactions}!PeerManager@{PeerManager}}
\doxysubsubsection{GetOrphanTransactions()}
{\footnotesize\ttfamily \label{class_peer_manager_a7e198e6b8d5a55d6d207d8a4ec276c51} 
virtual std\+::vector$<$ \textbf{ node\+::\+Tx\+Orphanage\+::\+Orphan\+Info} $>$ Get\+Orphan\+Transactions (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

\index{PeerManager@{PeerManager}!make@{make}}
\index{make@{make}!PeerManager@{PeerManager}}
\doxysubsubsection{make()}
{\footnotesize\ttfamily \label{class_peer_manager_a9d86f722d4111fed4e14deca63b5841e} 
std\+::unique\+\_\+ptr$<$ \textbf{ Peer\+Manager} $>$ make (\begin{DoxyParamCaption}\item[{\textbf{ CConnman} \&}]{connman}{, }\item[{\textbf{ Addr\+Man} \&}]{addrman}{, }\item[{\textbf{ Ban\+Man} $\ast$}]{banman}{, }\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{\textbf{ CTx\+Mem\+Pool} \&}]{pool}{, }\item[{\textbf{ node\+::\+Warnings} \&}]{warnings}{, }\item[{\textbf{ Options}}]{opts}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\index{PeerManager@{PeerManager}!ProcessMessage@{ProcessMessage}}
\index{ProcessMessage@{ProcessMessage}!PeerManager@{PeerManager}}
\doxysubsubsection{ProcessMessage()}
{\footnotesize\ttfamily \label{class_peer_manager_a653998b8d3ba41d665cbd602da0321b2} 
virtual void Process\+Message (\begin{DoxyParamCaption}\item[{\textbf{ CNode} \&}]{pfrom}{, }\item[{const std\+::string \&}]{msg\+\_\+type}{, }\item[{\textbf{ Data\+Stream} \&}]{v\+Recv}{, }\item[{const std\+::chrono\+::microseconds}]{time\+\_\+received}{, }\item[{const std\+::atomic$<$ bool $>$ \&}]{interrupt\+Msg\+Proc}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Process a single message from a peer. Public for fuzz testing \index{PeerManager@{PeerManager}!RelayTransaction@{RelayTransaction}}
\index{RelayTransaction@{RelayTransaction}!PeerManager@{PeerManager}}
\doxysubsubsection{RelayTransaction()}
{\footnotesize\ttfamily \label{class_peer_manager_a3d6eb79f1a9e830a7f5086286e982259} 
virtual void Relay\+Transaction (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{, }\item[{const \textbf{ Wtxid} \&}]{wtxid}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Relay transaction to all peers. \index{PeerManager@{PeerManager}!SendPings@{SendPings}}
\index{SendPings@{SendPings}!PeerManager@{PeerManager}}
\doxysubsubsection{SendPings()}
{\footnotesize\ttfamily \label{class_peer_manager_a50e4ddcdfd605bb67a7186dc668c0179} 
virtual void Send\+Pings (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Send ping message to all peers \index{PeerManager@{PeerManager}!SetBestBlock@{SetBestBlock}}
\index{SetBestBlock@{SetBestBlock}!PeerManager@{PeerManager}}
\doxysubsubsection{SetBestBlock()}
{\footnotesize\ttfamily \label{class_peer_manager_a1d90a213df9fa07bcb96f09786c231b0} 
virtual void Set\+Best\+Block (\begin{DoxyParamCaption}\item[{int}]{height}{, }\item[{std\+::chrono\+::seconds}]{time}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Set the height of the best block and its time (seconds since epoch). \index{PeerManager@{PeerManager}!StartScheduledTasks@{StartScheduledTasks}}
\index{StartScheduledTasks@{StartScheduledTasks}!PeerManager@{PeerManager}}
\doxysubsubsection{StartScheduledTasks()}
{\footnotesize\ttfamily \label{class_peer_manager_af5d0d4c330e511186664ccc6cbde45b4} 
virtual void Start\+Scheduled\+Tasks (\begin{DoxyParamCaption}\item[{\textbf{ CScheduler} \&}]{scheduler}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Begin running background tasks, should only be called once \index{PeerManager@{PeerManager}!UnitTestMisbehaving@{UnitTestMisbehaving}}
\index{UnitTestMisbehaving@{UnitTestMisbehaving}!PeerManager@{PeerManager}}
\doxysubsubsection{UnitTestMisbehaving()}
{\footnotesize\ttfamily \label{class_peer_manager_a431851144bf8d5bbde4879140958afe0} 
virtual void Unit\+Test\+Misbehaving (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{peer\+\_\+id}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

\index{PeerManager@{PeerManager}!UpdateLastBlockAnnounceTime@{UpdateLastBlockAnnounceTime}}
\index{UpdateLastBlockAnnounceTime@{UpdateLastBlockAnnounceTime}!PeerManager@{PeerManager}}
\doxysubsubsection{UpdateLastBlockAnnounceTime()}
{\footnotesize\ttfamily \label{class_peer_manager_aba301fc2c683ebc30d8b1cc0c24072fb} 
virtual void Update\+Last\+Block\+Announce\+Time (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{node}{, }\item[{int64\+\_\+t}]{time\+\_\+in\+\_\+seconds}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

This function is used for testing the stale tip eviction logic, see \doxyref{denialofservice\+\_\+tests.\+cpp}{p.}{denialofservice__tests_8cpp} 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ net\+\_\+processing.\+h}\item 
src/\textbf{ net\+\_\+processing.\+cpp}\end{DoxyCompactItemize}
