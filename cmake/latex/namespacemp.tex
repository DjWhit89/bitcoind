\doxysection{mp Namespace Reference}
\label{namespacemp}\index{mp@{mp}}


Functions to serialize / deserialize common bitcoin types.  


\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ test}
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Invoke\+Context}
\item 
struct \textbf{ Client\+Invoke\+Context}
\item 
struct \textbf{ Server\+Invoke\+Context}
\item 
struct \textbf{ Proxy\+Client$<$ Thread $>$}
\item 
struct \textbf{ Proxy\+Server$<$ Thread $>$}
\item 
class \textbf{ Logging\+Error\+Handler}
\begin{DoxyCompactList}\small\item\em \doxyref{Handler}{p.}{class_handler} for kj\+::\+Task\+Set failed task events. \end{DoxyCompactList}\item 
struct \textbf{ Log\+Message}
\item 
struct \textbf{ Log\+Options}
\item 
class \textbf{ Logger}
\item 
class \textbf{ Event\+Loop}
\item 
struct \textbf{ Waiter}
\item 
class \textbf{ Connection}
\item 
struct \textbf{ Server\+Vat\+Id}
\item 
struct \textbf{ Thread\+Context}
\item 
class \textbf{ Value\+Field}
\item 
struct \textbf{ Struct\+Field}
\item 
struct \textbf{ Read\+Dest\+Emplace}
\item 
struct \textbf{ Read\+Dest\+Update}
\item 
struct \textbf{ List\+Output}
\item 
struct \textbf{ List\+Output$<$\+::capnp\+::\+List$<$ T, kind $>$ $>$}
\item 
struct \textbf{ Iterate\+Fields\+Helper}
\item 
struct \textbf{ Iterate\+Fields}
\item 
struct \textbf{ Client\+Exception}
\item 
struct \textbf{ Client\+Param}
\item 
struct \textbf{ Server\+Call}
\item 
struct \textbf{ Server\+Destroy}
\item 
struct \textbf{ Server\+Ret}
\item 
struct \textbf{ Server\+Except}
\item 
struct \textbf{ Server\+Field}
\item 
struct \textbf{ Cap\+Request\+Traits}
\item 
struct \textbf{ Cap\+Request\+Traits$<$\+::capnp\+::\+Request$<$ \+\_\+\+Params, \+\_\+\+Results $>$ $>$}
\item 
struct \textbf{ Proxy\+Type\+Register}
\item 
struct \textbf{ Proxy\+Client}
\item 
struct \textbf{ Proxy\+Server}
\item 
struct \textbf{ Proxy\+Method}
\begin{DoxyCompactList}\small\item\em Mapping from capnp method params type to method traits (specializations are generated by proxy-\/codegen.\+cpp). \end{DoxyCompactList}\item 
struct \textbf{ Proxy\+Struct}
\begin{DoxyCompactList}\small\item\em Mapping from capnp struct type to struct traits (specializations are generated by proxy-\/codegen.\+cpp). \end{DoxyCompactList}\item 
struct \textbf{ Proxy\+Type}
\begin{DoxyCompactList}\small\item\em Mapping from local c++ type to capnp type and traits (specializations are generated by proxy-\/codegen.\+cpp). \end{DoxyCompactList}\item 
class \textbf{ Event\+Loop\+Ref}
\item 
struct \textbf{ Proxy\+Context}
\begin{DoxyCompactList}\small\item\em Context data associated with proxy client and server classes. \end{DoxyCompactList}\item 
class \textbf{ Proxy\+Client\+Base}
\item 
class \textbf{ Proxy\+Client\+Custom}
\item 
struct \textbf{ Proxy\+Server\+Base}
\item 
struct \textbf{ Proxy\+Server\+Custom}
\item 
struct \textbf{ Function\+Traits}
\item 
struct \textbf{ Function\+Traits$<$ \+\_\+\+Result(\+\_\+\+Class\+::$\ast$const)(\+\_\+\+Params...)$>$}
\item 
struct \textbf{ Proxy\+Method\+Traits}
\item 
struct \textbf{ Proxy\+Method\+Traits$<$ Method\+Params, Require$<$ decltype(\+Proxy\+Method$<$ Method\+Params $>$\+::impl)$>$ $>$}
\item 
struct \textbf{ Proxy\+Client\+Method\+Traits}
\item 
struct \textbf{ Proxy\+Server\+Method\+Traits}
\item 
struct \textbf{ Accessor}
\begin{DoxyCompactList}\small\item\em \doxyref{Accessor}{p.}{structmp_1_1_accessor} type holding flags that determine how to access a message field. \end{DoxyCompactList}\item 
class \textbf{ Proxy\+Callback}
\begin{DoxyCompactList}\small\item\em \doxyref{Wrapper}{p.}{class_wrapper} around std\+::function for passing std\+::function objects between client and servers. \end{DoxyCompactList}\item 
class \textbf{ Proxy\+Callback$<$ std\+::function$<$ Result(\+Args...)$>$ $>$}
\begin{DoxyCompactList}\small\item\em Specialization of above to separate Result and Arg types. \end{DoxyCompactList}\item 
class \textbf{ Proxy\+Callback\+Impl}
\begin{DoxyCompactList}\small\item\em Adapter to convert \doxyref{Proxy\+Callback}{p.}{classmp_1_1_proxy_callback} object call to function object call. \end{DoxyCompactList}\item 
struct \textbf{ Proxy\+Call\+Fn}
\item 
struct \textbf{ Proxy\+Server$<$ Thread\+Map $>$}
\item 
struct \textbf{ Type\+List}
\begin{DoxyCompactList}\small\item\em Generic utility functions used by capnp code. \end{DoxyCompactList}\item 
struct \textbf{ Split}
\item 
struct \textbf{ Split$<$ 0, \+\_\+\+Second, \+\_\+\+First, true $>$}
\begin{DoxyCompactList}\small\item\em Specialization of above (base case). \end{DoxyCompactList}\item 
struct \textbf{ Split$<$ index, Type\+List$<$ Type, \+\_\+\+Second... $>$, Type\+List$<$ \+\_\+\+First... $>$, false $>$}
\begin{DoxyCompactList}\small\item\em Specialization of above (recursive case). \end{DoxyCompactList}\item 
struct \textbf{ \+\_\+\+Require}
\begin{DoxyCompactList}\small\item\em SFINAE helper, see using \doxyref{Require}{p.}{namespacemp_ac29fd06630f0d8696d1c55dc964dcb9a} below. \end{DoxyCompactList}\item 
struct \textbf{ Priority}
\item 
struct \textbf{ Priority$<$ 0 $>$}
\begin{DoxyCompactList}\small\item\em Specialization of above (base case). \end{DoxyCompactList}\item 
struct \textbf{ Ptr\+Or\+Value}
\begin{DoxyCompactList}\small\item\em Convenient wrapper around std\+::variant$<$\+T$\ast$, T$>$. \end{DoxyCompactList}\item 
class \textbf{ Lock}
\item 
struct \textbf{ Guarded\+Ref}
\item 
struct \textbf{ Unlock\+Guard}
\begin{DoxyCompactList}\small\item\em Analog to std\+::lock\+\_\+guard that unlocks instead of locks. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Concepts}
\begin{DoxyCompactItemize}
\item 
concept \textbf{ Is\+Span\+Of}
\item 
concept \textbf{ Is\+Byte\+Span}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Interface, typename \textbf{ Params}, typename Results$>$ }\\using \textbf{ Server\+Context} = \textbf{ Server\+Invoke\+Context}$<$\textbf{ Proxy\+Server}$<$Interface$>$, \+::capnp\+::\+Call\+Context$<$\textbf{ Params}, Results$>$$>$
\item 
using \textbf{ Log\+Fn} = std\+::function$<$void(\textbf{ Log\+Message})$>$
\item 
using \textbf{ Conn\+Threads} = std\+::map$<$\textbf{ Connection}$\ast$, std\+::optional$<$\textbf{ Proxy\+Client}$<$Thread$>$$>$$>$
\item 
using \textbf{ Conn\+Thread} = Conn\+Threads\+::iterator
\item 
using \textbf{ Cleanup\+List} = std\+::list$<$std\+::function$<$void()$>$$>$
\item 
using \textbf{ Cleanup\+It} = typename Cleanup\+List\+::iterator
\item 
{\footnotesize template$<$typename Callable$>$ }\\using \textbf{ Result\+Of} = decltype(std\+::declval$<$Callable$>$()())
\begin{DoxyCompactList}\small\item\em Type helper giving return type of a callable type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\using \textbf{ Remove\+Cv\+Ref} = std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$\textbf{ T}$>$$>$
\begin{DoxyCompactList}\small\item\em Substitutue for std\+::remove\+\_\+cvref\+\_\+t. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\using \textbf{ Decay} = std\+::decay\+\_\+t$<$\textbf{ T}$>$
\begin{DoxyCompactList}\small\item\em Type helper abbreviating std\+::decay. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Sfinae\+Expr, typename Result = void$>$ }\\using \textbf{ Require} = typename \textbf{ \+\_\+\+Require}$<$Sfinae\+Expr, Result$>$\+::\+Result
\begin{DoxyCompactList}\small\item\em SFINAE helper, basically the same as to C++17\textquotesingle{}s void\+\_\+t, but allowing types other than void to be returned. \end{DoxyCompactList}\item 
using \textbf{ Fd\+To\+Args\+Fn} = std\+::function$<$std\+::vector$<$std\+::string$>$(int fd)$>$
\begin{DoxyCompactList}\small\item\em Callback type used by Spawn\+Process below. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Log} \{ \newline
\textbf{ Trace} = 0
, \textbf{ Debug}
, \textbf{ Info}
, \textbf{ Warning}
, \newline
\textbf{ Error}
, \textbf{ Raise}
 \}
\begin{DoxyCompactList}\small\item\em Log flags. Update stringify function if changed! \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ \newline
requires \textbf{ Serializable}$<$Local\+Type, \textbf{ Data\+Stream}$>$ \&\& std\+::is\+\_\+same\+\_\+v$<$Local\+Type, std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$Local\+Type$>$$>$$>$}\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \newline
requires \textbf{ Unserializable}$<$Local\+Type, \textbf{ Data\+Stream}$>$ \&\& (!\textbf{ ipc\+::capnp\+::\+Deserializable}$<$Local\+Type$>$)}\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \newline
requires \textbf{ ipc\+::capnp\+::\+Deserializable}$<$Local\+Type$>$}\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ \textbf{ Uni\+Value} $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ \textbf{ Uni\+Value} $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
kj\+::\+String\+Ptr \textbf{ KJ\+\_\+\+STRINGIFY} (\textbf{ Log} \textbf{ flags})
\item 
std\+::string \textbf{ Long\+Thread\+Name} (const char $\ast$exe\+\_\+name)
\item 
std\+::tuple$<$ \textbf{ Conn\+Thread}, bool $>$ \textbf{ Set\+Thread} (\textbf{ Guarded\+Ref}$<$ \textbf{ Conn\+Threads} $>$ threads, \textbf{ Connection} $\ast$connection, const std\+::function$<$ Thread\+::\+Client()$>$ \&make\+\_\+thread)
\item 
{\footnotesize template$<$typename Init\+Interface$>$ }\\std\+::unique\+\_\+ptr$<$ \textbf{ Proxy\+Client}$<$ Init\+Interface $>$ $>$ \textbf{ Connect\+Stream} (\textbf{ Event\+Loop} \&loop, int fd)
\item 
{\footnotesize template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ }\\void \textbf{ \+\_\+\+Serve} (\textbf{ Event\+Loop} \&loop, kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \&\&stream, \textbf{ Init\+Impl} \&\textbf{ init})
\item 
{\footnotesize template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ }\\void \textbf{ \+\_\+\+Listen} (\textbf{ Event\+Loop} \&loop, kj\+::\+Own$<$ kj\+::\+Connection\+Receiver $>$ \&\&listener, \textbf{ Init\+Impl} \&\textbf{ init})
\item 
{\footnotesize template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ }\\void \textbf{ Serve\+Stream} (\textbf{ Event\+Loop} \&loop, int fd, \textbf{ Init\+Impl} \&\textbf{ init})
\item 
{\footnotesize template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ }\\void \textbf{ Listen\+Connections} (\textbf{ Event\+Loop} \&loop, int fd, \textbf{ Init\+Impl} \&\textbf{ init})
\item 
{\footnotesize template$<$typename Local\+Type$>$ }\\auto \textbf{ Read\+Dest\+Temp} ()
\item 
{\footnotesize template$<$typename... Local\+Types, typename... Args$>$ }\\decltype(auto) \textbf{ Read\+Field} (\textbf{ Type\+List}$<$ Local\+Types... $>$, Args \&\&... \textbf{ args})
\item 
{\footnotesize template$<$typename Local\+Type, typename Input$>$ }\\void \textbf{ Throw\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input)
\item 
{\footnotesize template$<$typename Input$>$ }\\void \textbf{ Throw\+Field} (\textbf{ Type\+List}$<$ std\+::exception $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input)
\item 
{\footnotesize template$<$typename... Values$>$ }\\bool \textbf{ Custom\+Has\+Value} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const Values \&... value)
\item 
{\footnotesize template$<$typename... Local\+Types, typename Context, typename... Values, typename Output$>$ }\\void \textbf{ Build\+Field} (\textbf{ Type\+List}$<$ Local\+Types... $>$, Context \&context, Output \&\&output, Values \&\&... values)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 0 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename Local\+Type, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ }\\auto \textbf{ Pass\+Field} (\textbf{ Priority}$<$ 1 $>$, \textbf{ Type\+List}$<$ Local\+Type \& $>$, \textbf{ Server\+Context} \&server\+\_\+context, Fn \&\&fn, Args \&\&... \textbf{ args}) -\/$>$ \textbf{ Require}$<$ typename decltype(Accessor\+::get(server\+\_\+context.\+call\+\_\+context.\+get\+Params()))\+::\+Calls $>$
\begin{DoxyCompactList}\small\item\em Pass\+Field override for callable interface reference arguments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\void \textbf{ Maybe\+Build\+Field} (std\+::true\+\_\+type, Args \&\&... \textbf{ args})
\item 
{\footnotesize template$<$typename... Args$>$ }\\void \textbf{ Maybe\+Build\+Field} (std\+::false\+\_\+type, Args \&\&...)
\item 
{\footnotesize template$<$typename... Args$>$ }\\void \textbf{ Maybe\+Read\+Field} (std\+::true\+\_\+type, Args \&\&... \textbf{ args})
\item 
{\footnotesize template$<$typename... Args$>$ }\\void \textbf{ Maybe\+Read\+Field} (std\+::false\+\_\+type, Args \&\&...)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Maybe\+Set\+Want} (\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$, \textbf{ Priority}$<$ 1 $>$, const Value \&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Types, typename... Args$>$ }\\void \textbf{ Maybe\+Set\+Want} (Local\+Types, \textbf{ Priority}$<$ 0 $>$, const Args \&...)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename Local\+Type, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ }\\void \textbf{ Pass\+Field} (\textbf{ Priority}$<$ 0 $>$, \textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Server\+Context} \&server\+\_\+context, Fn \&\&fn, Args \&\&... \textbf{ args})
\begin{DoxyCompactList}\small\item\em Default Pass\+Field implementation calling Maybe\+Read\+Field/\+Maybe\+Build\+Field. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ }\\void \textbf{ Pass\+Field} (\textbf{ Priority}$<$ 0 $>$, \textbf{ Type\+List}$<$$>$, \textbf{ Server\+Context} \&server\+\_\+context, const Fn \&fn, Args \&\&... \textbf{ args})
\begin{DoxyCompactList}\small\item\em Default Pass\+Field implementation for count(0) arguments, calling Read\+Field/\+Build\+Field. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename... Types$>$ }\\\textbf{ Client\+Param}$<$ \textbf{ Accessor}, Types... $>$ \textbf{ Make\+Client\+Param} (Types \&\&... values)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename Message$>$ }\\decltype(auto) \textbf{ Maybe\+Get} (Message \&\&message, decltype(Accessor\+::get(message)) $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}$>$ }\\\+::capnp\+::\+Void \textbf{ Maybe\+Get} (...)
\item 
{\footnotesize template$<$class \textbf{ Accessor}$>$ }\\void \textbf{ Custom\+Pass\+Field} ()
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename... Args$>$ }\\auto \textbf{ Pass\+Field} (\textbf{ Priority}$<$ 2 $>$, Args \&\&... \textbf{ args}) -\/$>$ decltype(\textbf{ Custom\+Pass\+Field}$<$ \textbf{ Accessor} $>$(std\+::forward$<$ Args $>$(\textbf{ args})...))
\item 
{\footnotesize template$<$int argc, typename \textbf{ Accessor}, typename Parent$>$ }\\\textbf{ Server\+Field}$<$ argc, \textbf{ Accessor}, Parent $>$ \textbf{ Make\+Server\+Field} (Parent parent)
\item 
{\footnotesize template$<$typename Client$>$ }\\void \textbf{ client\+Destroy} (Client \&client)
\item 
{\footnotesize template$<$typename Server$>$ }\\void \textbf{ server\+Destroy} (Server \&server)
\item 
{\footnotesize template$<$typename \textbf{ Proxy\+Client}, typename Get\+Request, typename... Field\+Objs$>$ }\\void \textbf{ client\+Invoke} (\textbf{ Proxy\+Client} \&proxy\+\_\+client, const Get\+Request \&get\+\_\+request, Field\+Objs \&\&... fields)
\item 
{\footnotesize template$<$typename Fn, typename Ret$>$ }\\auto \textbf{ Replace\+Void} (Fn \&\&fn, Ret \&\&\textbf{ ret})
\item 
{\footnotesize template$<$typename Server, typename Call\+Context, typename Fn$>$ }\\kj\+::\+Promise$<$ void $>$ \textbf{ server\+Invoke} (Server \&server, Call\+Context \&call\+\_\+context, Fn fn)
\item 
void \textbf{ Cleanup\+Run} (\textbf{ Cleanup\+List} \&fns)
\item 
{\footnotesize template$<$typename Output, size\+\_\+t size$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ const unsigned char $\ast$ $>$, \textbf{ Priority}$<$ 3 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, const unsigned char(\&value)[size], Output \&\&output)
\item 
{\footnotesize template$<$size\+\_\+t size, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ unsigned char[size]$>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$class Rep, class Period, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::chrono\+::duration$<$ Rep, Period $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$class Rep, class Period, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::chrono\+::duration$<$ Rep, Period $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$$>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Client\+Invoke\+Context} \&invoke\+\_\+context, Output \&\&output, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(output.\+get()), Context\+::\+Builder $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ }\\auto \textbf{ Pass\+Field} (\textbf{ Priority}$<$ 1 $>$, \textbf{ Type\+List}$<$$>$, \textbf{ Server\+Context} \&server\+\_\+context, const Fn \&fn, Args \&\&... \textbf{ args}) -\/$>$ typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(Accessor\+::get(server\+\_\+context.\+call\+\_\+context.\+get\+Params())), Context\+::\+Reader $>$\+::value, kj\+::\+Promise$<$ typename \textbf{ Server\+Context\+::\+Call\+Context} $>$ $>$\+::type
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ \newline
requires (std\+::is\+\_\+same\+\_\+v$<$decltype(output.\+get()), \+::capnp\+::\+Data\+::\+Builder$>$ \&\& Is\+Byte\+Span$<$Local\+Type$>$)}\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 2 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \newline
requires (std\+::is\+\_\+same\+\_\+v$<$decltype(input.\+get()), \+::capnp\+::\+Data\+::\+Reader$>$ \&\& Is\+Byte\+Span$<$Local\+Type$>$)}\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 2 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ const Local\+Type $>$, \textbf{ Priority}$<$ 0 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type \& $>$, \textbf{ Priority}$<$ 0 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type \&\& $>$, \textbf{ Priority}$<$ 0 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::exception $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, const std\+::exception \&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Value, typename FnR, typename... Fn\+Params, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::function$<$ FnR(Fn\+Params...)$>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename FnR, typename... Fn\+Params, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::function$<$ FnR(Fn\+Params...)$>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Interface, typename Impl$>$ }\\kj\+::\+Own$<$ typename Interface\+::\+Server $>$ \textbf{ Make\+Proxy\+Server} (\textbf{ Invoke\+Context} \&context, std\+::shared\+\_\+ptr$<$ Impl $>$ impl)
\item 
{\footnotesize template$<$typename Interface, typename Impl$>$ }\\kj\+::\+Own$<$ typename Interface\+::\+Server $>$ \textbf{ Custom\+Make\+Proxy\+Server} (\textbf{ Invoke\+Context} \&context, std\+::shared\+\_\+ptr$<$ Impl $>$ \&\&impl)
\item 
{\footnotesize template$<$typename Impl, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::unique\+\_\+ptr$<$ Impl $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output, typename \textbf{ Decay}$<$ decltype(output.\+get())$>$\+::\+Calls $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Impl, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Impl $>$ $>$, \textbf{ Priority}$<$ 2 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output, typename \textbf{ Decay}$<$ decltype(output.\+get())$>$\+::\+Calls $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Impl, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Impl \& $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Impl \&value, Output \&\&output, typename decltype(output.\+get())\+::\+Calls $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Interface, typename Impl$>$ }\\std\+::unique\+\_\+ptr$<$ Impl $>$ \textbf{ Make\+Proxy\+Client} (\textbf{ Invoke\+Context} \&context, typename Interface\+::\+Client \&\&client)
\item 
{\footnotesize template$<$typename Interface, typename Impl$>$ }\\std\+::unique\+\_\+ptr$<$ Impl $>$ \textbf{ Custom\+Make\+Proxy\+Client} (\textbf{ Invoke\+Context} \&context, typename Interface\+::\+Client \&\&client)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::unique\+\_\+ptr$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest, typename \textbf{ Decay}$<$ decltype(input.\+get())$>$\+::\+Calls $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest, typename \textbf{ Decay}$<$ decltype(input.\+get())$>$\+::\+Calls $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::map$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::map$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 2 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output, decltype(\textbf{ Custom\+Build\+Message}(invoke\+\_\+context, value, std\+::move(output.\+get()))) $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Reader, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 2 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Reader \&\&reader, Read\+Dest \&\&read\+\_\+dest, decltype(\textbf{ Custom\+Read\+Message}(invoke\+\_\+context, reader.\+get(), std\+::declval$<$ Local\+Type \& $>$())) $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename Message$>$ }\\decltype(auto) \textbf{ Maybe\+Init} (Message \&\&message, decltype(Accessor\+::get(message)) $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}$>$ }\\\+::capnp\+::\+Void \textbf{ Maybe\+Init} (...)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename... Local\+Types, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ }\\auto \textbf{ Custom\+Pass\+Field} (\textbf{ Type\+List}$<$ Local\+Types... $>$, \textbf{ Server\+Context} \&server\+\_\+context, Fn \&\&fn, Args \&\&... \textbf{ args}) -\/$>$ decltype(\textbf{ Custom\+Pass\+Message}(server\+\_\+context, \textbf{ Maybe\+Get}$<$ \textbf{ Accessor} $>$(server\+\_\+context.\+call\+\_\+context.\+get\+Params()), \textbf{ Maybe\+Get}$<$ \textbf{ Accessor} $>$(server\+\_\+context.\+call\+\_\+context.\+get\+Results()), nullptr))
\item 
{\footnotesize template$<$typename Local\+Type, typename Value$>$ }\\Local\+Type \textbf{ Build\+Primitive} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const Value \&value, \textbf{ Type\+List}$<$ Local\+Type $>$, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+enum$<$ Value $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value$>$ }\\Local\+Type \textbf{ Build\+Primitive} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const Value \&value, \textbf{ Type\+List}$<$ Local\+Type $>$, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+integral$<$ Value $>$\+::value, int $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value$>$ }\\Local\+Type \textbf{ Build\+Primitive} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const Value \&value, \textbf{ Type\+List}$<$ Local\+Type $>$, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+floating\+\_\+point$<$ Value $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+enum$<$ Local\+Type $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+integral$<$ Local\+Type $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+floating\+\_\+point$<$ Local\+Type $>$\+::value $>$\+::type $\ast$enable=0)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::optional$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::optional$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::pair$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::pair$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$, \textbf{ Priority}$<$ 3 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 0 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ const Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename \textbf{ Accessor}, typename Local\+Type, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ }\\void \textbf{ Pass\+Field} (\textbf{ Priority}$<$ 1 $>$, \textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$, \textbf{ Server\+Context} \&server\+\_\+context, const Fn \&fn, Args \&\&... \textbf{ args})
\begin{DoxyCompactList}\small\item\em Pass\+Field override for C++ pointer arguments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::set$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::set$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::string $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::string $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$size\+\_\+t index, typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Build\+One} (\textbf{ Type\+List}$<$ Local\+Type $>$ param, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Output \&\&output, Value \&\&value, typename std\+::enable\+\_\+if$<$ index$<$ \textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$size\+\_\+t index, typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Build\+One} (\textbf{ Type\+List}$<$ Local\+Type $>$ param, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Output \&\&output, Value \&\&value, typename std\+::enable\+\_\+if$<$ index==\textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$ local\+\_\+type, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output, typename \textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::\+Struct $\ast$enable=nullptr)
\item 
{\footnotesize template$<$size\+\_\+t index, typename Local\+Type, typename Input, typename Value$>$ }\\void \textbf{ Read\+One} (\textbf{ Type\+List}$<$ Local\+Type $>$ param, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Value \&\&value, typename std\+::enable\+\_\+if$<$ index !=\textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$size\+\_\+t index, typename Local\+Type, typename Input, typename Value$>$ }\\void \textbf{ Read\+One} (\textbf{ Type\+List}$<$ Local\+Type $>$ param, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&input, Value \&value, typename std\+::enable\+\_\+if$<$ index==\textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$ param, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest, typename \textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::\+Struct $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$$>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Output \&\&output, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(output.\+get()), Thread\+Map\+::\+Client $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Input$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$$>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(input.\+get()), Thread\+Map\+::\+Client $>$\+::value $>$\+::type $\ast$enable=nullptr)
\item 
{\footnotesize template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::tuple$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::tuple$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Local\+Type, typename Value, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ std\+::vector$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&value, Output \&\&output)
\item 
{\footnotesize template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::vector$<$ Local\+Type $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Input, typename Read\+Dest$>$ }\\decltype(auto) \textbf{ Custom\+Read\+Field} (\textbf{ Type\+List}$<$ std\+::vector$<$ bool $>$ $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, Input \&\&input, Read\+Dest \&\&read\+\_\+dest)
\item 
{\footnotesize template$<$typename Value$>$ }\\\+::capnp\+::\+Void \textbf{ Build\+Primitive} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, Value \&\&, \textbf{ Type\+List}$<$\+::capnp\+::\+Void $>$)
\item 
{\footnotesize template$<$typename Local\+Type, typename Output$>$ }\\void \textbf{ Custom\+Build\+Field} (\textbf{ Type\+List}$<$ Local\+Type $>$, \textbf{ Priority}$<$ 1 $>$, \textbf{ Invoke\+Context} \&invoke\+\_\+context, \+::capnp\+::\+Void, Output \&\&output)
\item 
{\footnotesize template$<$template$<$ typename... $>$ class Class, typename... Types, typename... Args$>$ }\\Class$<$ Types..., std\+::remove\+\_\+reference\+\_\+t$<$ Args $>$... $>$ \textbf{ Make} (Args \&\&... \textbf{ args})
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\const char $\ast$ \textbf{ Type\+Name} ()
\begin{DoxyCompactList}\small\item\em Return capnp type name with filename prefix removed. \end{DoxyCompactList}\item 
class \textbf{ MP\+\_\+\+CAPABILITY} ("{}mutex"{}) \textbf{ Mutex}
\item 
{\footnotesize template$<$class U$>$ }\\\textbf{ Guarded\+Ref} (\textbf{ Mutex} \&, U \&) -\/$>$ Guarded\+Ref$<$ U $>$
\item 
{\footnotesize template$<$typename \textbf{ Lock}, typename Callback$>$ }\\void \textbf{ Unlock} (\textbf{ Lock} \&lock, Callback \&\&callback)
\item 
std\+::string \textbf{ Thread\+Name} (const char $\ast$exe\+\_\+name)
\begin{DoxyCompactList}\small\item\em \doxyref{Format}{p.}{struct_format} current thread name as "{}\{exe\+\_\+name\}-\/\{\$pid\}/\{thread\+\_\+name\}-\/\{\$tid\}"{}. \end{DoxyCompactList}\item 
std\+::string \textbf{ Log\+Escape} (const kj\+::\+String\+Tree \&string, size\+\_\+t max\+\_\+size)
\item 
int \textbf{ Spawn\+Process} (int \&pid, \textbf{ Fd\+To\+Args\+Fn} \&\&fd\+\_\+to\+\_\+args)
\item 
void \textbf{ Exec\+Process} (const std\+::vector$<$ std\+::string $>$ \&\textbf{ args})
\begin{DoxyCompactList}\small\item\em Call execvp with vector args. \end{DoxyCompactList}\item 
int \textbf{ Wait\+Process} (int pid)
\begin{DoxyCompactList}\small\item\em Wait for a process to exit and return its exit code. \end{DoxyCompactList}\item 
char $\ast$ \textbf{ Char\+Cast} (char $\ast$c)
\item 
char $\ast$ \textbf{ Char\+Cast} (unsigned char $\ast$c)
\item 
const char $\ast$ \textbf{ Char\+Cast} (const char $\ast$c)
\item 
const char $\ast$ \textbf{ Char\+Cast} (const unsigned char $\ast$c)
\item 
void \textbf{ Custom\+Build\+Message} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const \textbf{ test\+::\+Foo\+Message} \&src, test\+::messages\+::\+Foo\+Message\+::\+Builder \&\&builder)
\item 
void \textbf{ Custom\+Read\+Message} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const test\+::messages\+::\+Foo\+Message\+::\+Reader \&reader, \textbf{ test\+::\+Foo\+Message} \&dest)
\item 
void \textbf{ Custom\+Build\+Message} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const \textbf{ test\+::\+Foo\+Mutable} \&src, test\+::messages\+::\+Foo\+Mutable\+::\+Builder \&\&builder)
\item 
void \textbf{ Custom\+Read\+Message} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const test\+::messages\+::\+Foo\+Mutable\+::\+Reader \&reader, \textbf{ test\+::\+Foo\+Mutable} \&dest)
\item 
void \textbf{ Custom\+Pass\+Message} (\textbf{ Invoke\+Context} \&invoke\+\_\+context, const test\+::messages\+::\+Foo\+Mutable\+::\+Reader \&reader, test\+::messages\+::\+Foo\+Mutable\+::\+Builder builder, std\+::function$<$ void(\textbf{ test\+::\+Foo\+Mutable} \&)$>$ \&\&fn)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\textbf{ Thread\+Context} \textbf{ g\+\_\+thread\+\_\+context}
\item 
std\+::atomic$<$ int $>$ \textbf{ server\+\_\+reqs} \{0\}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Functions to serialize / deserialize common bitcoin types. 

\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{mp@{mp}!CleanupIt@{CleanupIt}}
\index{CleanupIt@{CleanupIt}!mp@{mp}}
\doxysubsubsection{CleanupIt}
{\footnotesize\ttfamily \label{namespacemp_a5922c1e79ba82f5eb46c5cd0bfc69966} 
using \textbf{ Cleanup\+It} = typename Cleanup\+List\+::iterator}

\index{mp@{mp}!CleanupList@{CleanupList}}
\index{CleanupList@{CleanupList}!mp@{mp}}
\doxysubsubsection{CleanupList}
{\footnotesize\ttfamily \label{namespacemp_aa04bf09245b60eb219c446d213cc0390} 
using \textbf{ Cleanup\+List} = std\+::list$<$std\+::function$<$void()$>$$>$}

\index{mp@{mp}!ConnThread@{ConnThread}}
\index{ConnThread@{ConnThread}!mp@{mp}}
\doxysubsubsection{ConnThread}
{\footnotesize\ttfamily \label{namespacemp_a4c23514105673e30f7c1f46afc594ece} 
using \textbf{ Conn\+Thread} = Conn\+Threads\+::iterator}

\index{mp@{mp}!ConnThreads@{ConnThreads}}
\index{ConnThreads@{ConnThreads}!mp@{mp}}
\doxysubsubsection{ConnThreads}
{\footnotesize\ttfamily \label{namespacemp_a5176f804f9aaad2c96c46ac53c5bd28b} 
using \textbf{ Conn\+Threads} = std\+::map$<$\textbf{ Connection}$\ast$, std\+::optional$<$\textbf{ Proxy\+Client}$<$Thread$>$$>$$>$}

Map from \doxyref{Connection}{p.}{classmp_1_1_connection} to local or remote thread handle which will be used over that connection. This map will typically only contain one entry, but can contain multiple if a single thread makes IPC calls over multiple connections. A std\+::optional value type is used to avoid the map needing to be locked while \doxyref{Proxy\+Client$<$\+Thread$>$}{p.}{structmp_1_1_proxy_client_3_01_thread_01_4} objects are constructed, see \doxyref{Thread\+Context}{p.}{structmp_1_1_thread_context} "{}\+Synchronization note"{} below. \index{mp@{mp}!Decay@{Decay}}
\index{Decay@{Decay}!mp@{mp}}
\doxysubsubsection{Decay}
{\footnotesize\ttfamily \label{namespacemp_a060008b21d2ce84d4a724b355c0fc780} 
template$<$typename \textbf{ T}$>$ \\
using \textbf{ Decay} = std\+::decay\+\_\+t$<$\textbf{ T}$>$}



Type helper abbreviating std\+::decay. 

\index{mp@{mp}!FdToArgsFn@{FdToArgsFn}}
\index{FdToArgsFn@{FdToArgsFn}!mp@{mp}}
\doxysubsubsection{FdToArgsFn}
{\footnotesize\ttfamily \label{namespacemp_a4da031796f36e5032144a3e4ad8d29ba} 
using \textbf{ Fd\+To\+Args\+Fn} = std\+::function$<$std\+::vector$<$std\+::string$>$(int fd)$>$}



Callback type used by Spawn\+Process below. 

\index{mp@{mp}!LogFn@{LogFn}}
\index{LogFn@{LogFn}!mp@{mp}}
\doxysubsubsection{LogFn}
{\footnotesize\ttfamily \label{namespacemp_a61ffb74e9f97c3924b3904a35a5f20b2} 
using \textbf{ Log\+Fn} = std\+::function$<$void(\textbf{ Log\+Message})$>$}

\index{mp@{mp}!RemoveCvRef@{RemoveCvRef}}
\index{RemoveCvRef@{RemoveCvRef}!mp@{mp}}
\doxysubsubsection{RemoveCvRef}
{\footnotesize\ttfamily \label{namespacemp_af59e069abff4e13e628ecde364b9d485} 
template$<$typename \textbf{ T}$>$ \\
using \textbf{ Remove\+Cv\+Ref} = std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$\textbf{ T}$>$$>$}



Substitutue for std\+::remove\+\_\+cvref\+\_\+t. 

\index{mp@{mp}!Require@{Require}}
\index{Require@{Require}!mp@{mp}}
\doxysubsubsection{Require}
{\footnotesize\ttfamily \label{namespacemp_ac29fd06630f0d8696d1c55dc964dcb9a} 
template$<$typename Sfinae\+Expr, typename Result = void$>$ \\
using \textbf{ Require} = typename \textbf{ \+\_\+\+Require}$<$Sfinae\+Expr, Result$>$\+::\+Result}



SFINAE helper, basically the same as to C++17\textquotesingle{}s void\+\_\+t, but allowing types other than void to be returned. 

\index{mp@{mp}!ResultOf@{ResultOf}}
\index{ResultOf@{ResultOf}!mp@{mp}}
\doxysubsubsection{ResultOf}
{\footnotesize\ttfamily \label{namespacemp_a31afc22b8bf0e8c98d4a0c2b0f787467} 
template$<$typename Callable$>$ \\
using \textbf{ Result\+Of} = decltype(std\+::declval$<$Callable$>$()())}



Type helper giving return type of a callable type. 

\index{mp@{mp}!ServerContext@{ServerContext}}
\index{ServerContext@{ServerContext}!mp@{mp}}
\doxysubsubsection{ServerContext}
{\footnotesize\ttfamily \label{namespacemp_a9642495258151af079da6df81b8dbb0c} 
template$<$typename Interface, typename \textbf{ Params}, typename Results$>$ \\
using \textbf{ Server\+Context} = \textbf{ Server\+Invoke\+Context}$<$\textbf{ Proxy\+Server}$<$Interface$>$, \+::capnp\+::\+Call\+Context$<$\textbf{ Params}, Results$>$$>$}



\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{mp@{mp}!Log@{Log}}
\index{Log@{Log}!mp@{mp}}
\doxysubsubsection{Log}
{\footnotesize\ttfamily \label{namespacemp_af31ef15863cb3c9383790dc16c3f2304} 
enum class \textbf{ Log}\hspace{0.3cm}{\ttfamily [strong]}}



\doxyref{Log}{p.}{namespacemp_af31ef15863cb3c9383790dc16c3f2304} flags. Update stringify function if changed! 

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Trace@{Trace}!mp@{mp}}\index{mp@{mp}!Trace@{Trace}}}\label{namespacemp_af31ef15863cb3c9383790dc16c3f2304add4ec0ac4e58f7c32a01244ae91150b1} 
Trace&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Debug@{Debug}!mp@{mp}}\index{mp@{mp}!Debug@{Debug}}}\label{namespacemp_af31ef15863cb3c9383790dc16c3f2304aa603905470e2a5b8c13e96b579ef0dba} 
Debug&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Info@{Info}!mp@{mp}}\index{mp@{mp}!Info@{Info}}}\label{namespacemp_af31ef15863cb3c9383790dc16c3f2304a4059b0251f66a18cb56f544728796875} 
Info&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Warning@{Warning}!mp@{mp}}\index{mp@{mp}!Warning@{Warning}}}\label{namespacemp_af31ef15863cb3c9383790dc16c3f2304a0eaadb4fcb48a0a0ed7bc9868be9fbaa} 
Warning&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Error@{Error}!mp@{mp}}\index{mp@{mp}!Error@{Error}}}\label{namespacemp_af31ef15863cb3c9383790dc16c3f2304a902b0d55fddef6f8d651fe1035b7d4bd} 
Error&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Raise@{Raise}!mp@{mp}}\index{mp@{mp}!Raise@{Raise}}}\label{namespacemp_af31ef15863cb3c9383790dc16c3f2304a36ec8dc76bf55896199b1276242944af} 
Raise&\\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{mp@{mp}!\_Listen@{\_Listen}}
\index{\_Listen@{\_Listen}!mp@{mp}}
\doxysubsubsection{\_Listen()}
{\footnotesize\ttfamily \label{namespacemp_a9589786aff435d101ca76ab5233f5970} 
template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ \\
void \+\_\+\+Listen (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{kj\+::\+Own$<$ kj\+::\+Connection\+Receiver $>$ \&\&}]{listener}{, }\item[{\textbf{ Init\+Impl} \&}]{init}{}\end{DoxyParamCaption})}

Given connection receiver and an init object, handle incoming connections by calling \+\_\+\+Serve, to create \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} objects and forward requests to the init object. \index{mp@{mp}!\_Serve@{\_Serve}}
\index{\_Serve@{\_Serve}!mp@{mp}}
\doxysubsubsection{\_Serve()}
{\footnotesize\ttfamily \label{namespacemp_ae822a91aab465661b35be2e1d348cf11} 
template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ \\
void \+\_\+\+Serve (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \&\&}]{stream}{, }\item[{\textbf{ Init\+Impl} \&}]{init}{}\end{DoxyParamCaption})}

Given stream and init objects, construct a new \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} object that handles requests from the stream by calling the init object. Embed the \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} in a \doxyref{Connection}{p.}{classmp_1_1_connection} object that is stored and erased if disconnected. This should be called from the event loop thread. \index{mp@{mp}!BuildField@{BuildField}}
\index{BuildField@{BuildField}!mp@{mp}}
\doxysubsubsection{BuildField()}
{\footnotesize\ttfamily \label{namespacemp_a0a6d5b0c15daacdc12c803270cd09559} 
template$<$typename... Local\+Types, typename Context, typename... Values, typename Output$>$ \\
void Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Types... $>$}]{}{, }\item[{Context \&}]{context}{, }\item[{Output \&\&}]{output}{, }\item[{Values \&\&...}]{values}{}\end{DoxyParamCaption})}

\index{mp@{mp}!BuildOne@{BuildOne}}
\index{BuildOne@{BuildOne}!mp@{mp}}
\doxysubsubsection{BuildOne()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_ae85e4c869582f23700c243ea625f80b5} 
template$<$size\+\_\+t index, typename Local\+Type, typename Value, typename Output$>$ \\
void Build\+One (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{param}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Output \&\&}]{output}{, }\item[{Value \&\&}]{value}{}\end{DoxyParamCaption})}

\index{mp@{mp}!BuildOne@{BuildOne}}
\index{BuildOne@{BuildOne}!mp@{mp}}
\doxysubsubsection{BuildOne()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_ac3cb6bc37b6d63e45482dea99b6b1efe} 
template$<$size\+\_\+t index, typename Local\+Type, typename Value, typename Output$>$ \\
void Build\+One (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{param}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Output \&\&}]{output}{, }\item[{Value \&\&}]{value}{, }\item[{typename std\+::enable\+\_\+if$<$ index==\textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!BuildPrimitive@{BuildPrimitive}}
\index{BuildPrimitive@{BuildPrimitive}!mp@{mp}}
\doxysubsubsection{BuildPrimitive()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{namespacemp_a10ac01898841ca9299adbbdd31442fbe} 
template$<$typename Local\+Type, typename Value$>$ \\
Local\+Type Build\+Primitive (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const Value \&}]{value}{, }\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+enum$<$ Value $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!BuildPrimitive@{BuildPrimitive}}
\index{BuildPrimitive@{BuildPrimitive}!mp@{mp}}
\doxysubsubsection{BuildPrimitive()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{namespacemp_acd2a0cdcf38776c21062df97ef8a8c6b} 
template$<$typename Local\+Type, typename Value$>$ \\
Local\+Type Build\+Primitive (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const Value \&}]{value}{, }\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+floating\+\_\+point$<$ Value $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!BuildPrimitive@{BuildPrimitive}}
\index{BuildPrimitive@{BuildPrimitive}!mp@{mp}}
\doxysubsubsection{BuildPrimitive()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{namespacemp_ab9773c6a48328b3e19c8a32c9fc237bf} 
template$<$typename Local\+Type, typename Value$>$ \\
Local\+Type Build\+Primitive (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const Value \&}]{value}{, }\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+integral$<$ Value $>$\+::value, int $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!BuildPrimitive@{BuildPrimitive}}
\index{BuildPrimitive@{BuildPrimitive}!mp@{mp}}
\doxysubsubsection{BuildPrimitive()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{namespacemp_ae2b4b5b95c27b02042a940fafb744ff0} 
template$<$typename Value$>$ \\
\+::capnp\+::\+Void Build\+Primitive (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{}{, }\item[{\textbf{ Type\+List}$<$\+::capnp\+::\+Void $>$}]{}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CharCast@{CharCast}}
\index{CharCast@{CharCast}!mp@{mp}}
\doxysubsubsection{CharCast()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{namespacemp_a6b971c968e7f80ce855b859086ca8d0e} 
char $\ast$ Char\+Cast (\begin{DoxyParamCaption}\item[{char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CharCast@{CharCast}}
\index{CharCast@{CharCast}!mp@{mp}}
\doxysubsubsection{CharCast()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{namespacemp_a09ff3b0768a2215e6f16b991d3205786} 
const char $\ast$ Char\+Cast (\begin{DoxyParamCaption}\item[{const char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CharCast@{CharCast}}
\index{CharCast@{CharCast}!mp@{mp}}
\doxysubsubsection{CharCast()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{namespacemp_af3e46fd77453384e5994921245f819fa} 
const char $\ast$ Char\+Cast (\begin{DoxyParamCaption}\item[{const unsigned char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CharCast@{CharCast}}
\index{CharCast@{CharCast}!mp@{mp}}
\doxysubsubsection{CharCast()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{namespacemp_a1dcea4c9ef62dce206e0424fe6749bcb} 
char $\ast$ Char\+Cast (\begin{DoxyParamCaption}\item[{unsigned char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CleanupRun@{CleanupRun}}
\index{CleanupRun@{CleanupRun}!mp@{mp}}
\doxysubsubsection{CleanupRun()}
{\footnotesize\ttfamily \label{namespacemp_a6fbc82e48f1bf8f39a4635c31bece459} 
void Cleanup\+Run (\begin{DoxyParamCaption}\item[{\textbf{ Cleanup\+List} \&}]{fns}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!clientDestroy@{clientDestroy}}
\index{clientDestroy@{clientDestroy}!mp@{mp}}
\doxysubsubsection{clientDestroy()}
{\footnotesize\ttfamily \label{namespacemp_a24db2e1968907f628e03c7761734bd18} 
template$<$typename Client$>$ \\
void client\+Destroy (\begin{DoxyParamCaption}\item[{Client \&}]{client}{}\end{DoxyParamCaption})}

Entry point called by all generated \doxyref{Proxy\+Client}{p.}{structmp_1_1_proxy_client} destructors. This only logs the object destruction. The actual cleanup happens in the \doxyref{Proxy\+Client}{p.}{structmp_1_1_proxy_client} base destructor. \index{mp@{mp}!clientInvoke@{clientInvoke}}
\index{clientInvoke@{clientInvoke}!mp@{mp}}
\doxysubsubsection{clientInvoke()}
{\footnotesize\ttfamily \label{namespacemp_aca8da90b8751a6f8f408028f9b93d85e} 
template$<$typename \textbf{ Proxy\+Client}, typename Get\+Request, typename... Field\+Objs$>$ \\
void client\+Invoke (\begin{DoxyParamCaption}\item[{\textbf{ Proxy\+Client} \&}]{proxy\+\_\+client}{, }\item[{const Get\+Request \&}]{get\+\_\+request}{, }\item[{Field\+Objs \&\&...}]{fields}{}\end{DoxyParamCaption})}

Entry point called by generated client code that looks like\+:

Proxy\+Client$<$\+Class\+Name$>$\+::\+M0\+::\+Result Proxy\+Client$<$\+Class\+Name$>$\+::method\+Name(\+M0\+::\+Param$<$0$>$ arg0, M0\+::\+Param$<$1$>$ arg1) \{ typename M0\+::\+Result result; client\+Invoke($\ast$this, \&Interface\+Name\+::\+Client\+::method\+Name\+Request, Make\+Client\+Param$<$...$>$(\+M0\+::\+Fwd$<$0$>$(arg0)), Make\+Client\+Param$<$...$>$(\+M0\+::\+Fwd$<$1$>$(arg1)), Make\+Client\+Param$<$...$>$(result)); return result; \}

Ellipses above are where generated \doxyref{Accessor$<$$>$}{p.}{structmp_1_1_accessor} type declarations are inserted. \index{mp@{mp}!ConnectStream@{ConnectStream}}
\index{ConnectStream@{ConnectStream}!mp@{mp}}
\doxysubsubsection{ConnectStream()}
{\footnotesize\ttfamily \label{namespacemp_a05705160ee9ed1819a6f59fdb8bd9fb1} 
template$<$typename Init\+Interface$>$ \\
std\+::unique\+\_\+ptr$<$ \textbf{ Proxy\+Client}$<$ Init\+Interface $>$ $>$ Connect\+Stream (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{int}]{fd}{}\end{DoxyParamCaption})}

Given stream file descriptor, make a new \doxyref{Proxy\+Client}{p.}{structmp_1_1_proxy_client} object to send requests over the stream. Also create a new \doxyref{Connection}{p.}{classmp_1_1_connection} object embedded in the client that is freed when the client is closed. \index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [1/28]}}
{\footnotesize\ttfamily \label{namespacemp_a64833534a417863a4634539f1aee68ae} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ const Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [2/28]}}
{\footnotesize\ttfamily \label{namespacemp_a24cab9f9ef1cd4af6e3a01c37add3936} 
template$<$typename Output, size\+\_\+t size$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ const unsigned char $\ast$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 3 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const unsigned char(\&)}]{value}{[size], }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [3/28]}}
{\footnotesize\ttfamily \label{namespacemp_a12627667e90b3ea4adce19df6bfff039} 
template$<$typename Impl, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Impl \& $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Impl \&}]{value}{, }\item[{Output \&\&}]{output}{, }\item[{typename decltype(output.\+get())\+::\+Calls $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [4/28]}}
{\footnotesize\ttfamily \label{namespacemp_abf4652d5544549a3d61f44bebc5ede25} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type \& $>$}]{}{, }\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [5/28]}}
{\footnotesize\ttfamily \label{namespacemp_a730455060a8c9e60b55159e945221b3b} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type \&\& $>$}]{}{, }\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [6/28]}}
{\footnotesize\ttfamily \label{namespacemp_a7928a4aacdec34533a923a7ae7409f37} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 3 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [7/28]}}
{\footnotesize\ttfamily \label{namespacemp_a3839245e915b6ecaebfe5cdefda553a8} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{local\+\_\+type}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{, }\item[{typename \textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::\+Struct $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [8/28]}}
{\footnotesize\ttfamily \label{namespacemp_aa200e66f2838d7068cf7fea9cac2daf5} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [9/28]}}
{\footnotesize\ttfamily \label{namespacemp_acbcaed989a04ddff182cce9ecbeab4c3} 
template$<$typename Local\+Type, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{\+::capnp\+::\+Void}]{}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [10/28]}}
{\footnotesize\ttfamily \label{namespacemp_abe4db4675ce871383fc5794969c7458d} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \newline
requires \textbf{ Serializable}$<$Local\+Type, \textbf{ Data\+Stream}$>$ \&\& std\+::is\+\_\+same\+\_\+v$<$Local\+Type, std\+::remove\+\_\+cv\+\_\+t$<$std\+::remove\+\_\+reference\+\_\+t$<$Local\+Type$>$$>$$>$\\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

Overload multiprocess library\textquotesingle{}s Custom\+Build\+Field hook to allow any serializable object to be stored in a capnproto Data field or passed to a capnproto interface. Use \doxyref{Priority$<$1$>$}{p.}{structmp_1_1_priority} so this hook has medium priority, and higher priority hooks could take precedence over this one. \index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [11/28]}}
{\footnotesize\ttfamily \label{namespacemp_a03b82937cca36650e832bbce87433e8c} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \newline
requires (std\+::is\+\_\+same\+\_\+v$<$decltype(output.\+get()), \+::capnp\+::\+Data\+::\+Builder$>$ \&\& Is\+Byte\+Span$<$Local\+Type$>$)\\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 2 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

Generic \+::capnp\+::\+Data field builder for any C++ type that can be converted to a span of bytes, like std\+::vector$<$char$>$ or std\+::array$<$uint8\+\_\+t$>$, or custom blob types like \doxyref{uint256}{p.}{classuint256} or \doxyref{PKHash}{p.}{struct_p_k_hash} with data() and size() methods pointing to bytes. \index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [12/28]}}
{\footnotesize\ttfamily \label{namespacemp_a23668182b3329d28f3129392109ff82f} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 2 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{, }\item[{decltype(\textbf{ Custom\+Build\+Message}(invoke\+\_\+context, value, std\+::move(output.\+get()))) $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Overload Custom\+Build\+Field to serialize objects that have Custom\+Build\+Message overloads. Defining a Custom\+Build\+Message overload is simpler than defining a Custom\+Build\+Field overload because it only requires defining a normal function, not a template function, but less flexible. \index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [13/28]}}
{\footnotesize\ttfamily \label{namespacemp_a90a1c9930cc3e53cf453297ce1569bbe} 
template$<$class Rep, class Period, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::chrono\+::duration$<$ Rep, Period $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

Overload Custom\+Build\+Field and Custom\+Read\+Field to serialize std\+::chrono parameters and return values as numbers. \index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [14/28]}}
{\footnotesize\ttfamily \label{namespacemp_ae9cfef4fe755e19c23bd059906d6cfb7} 
template$<$typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::exception $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const std\+::exception \&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [15/28]}}
{\footnotesize\ttfamily \label{namespacemp_a001e607d6e1c00f1f1f8f0a17c20e480} 
template$<$typename Value, typename FnR, typename... Fn\+Params, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::function$<$ FnR(Fn\+Params...)$>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [16/28]}}
{\footnotesize\ttfamily \label{namespacemp_a39ea0566d44fb8b951da454b9096f585} 
template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::map$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [17/28]}}
{\footnotesize\ttfamily \label{namespacemp_aa6a4ef7f78d963a8f956effcc8d1e264} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::optional$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [18/28]}}
{\footnotesize\ttfamily \label{namespacemp_a62ef11392610387a85fc1d6f90f6f2ec} 
template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::pair$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [19/28]}}
{\footnotesize\ttfamily \label{namespacemp_ad833c12ba1eb6ad4fc841fe6f6e07690} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::set$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [20/28]}}
{\footnotesize\ttfamily \label{namespacemp_a90a59c6d928278427f0341d783c80672} 
template$<$typename Impl, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Impl $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 2 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{, }\item[{typename \textbf{ Decay}$<$ decltype(output.\+get())$>$\+::\+Calls $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [21/28]}}
{\footnotesize\ttfamily \label{namespacemp_a080aec99fc500632f1f07183a22d3501} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [22/28]}}
{\footnotesize\ttfamily \label{namespacemp_aa79c4e7109d1181c985afb6054c6eca6} 
template$<$typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::string $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [23/28]}}
{\footnotesize\ttfamily \label{namespacemp_a56c0b568338f3b75e9addebb9af00262} 
template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::tuple$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [24/28]}}
{\footnotesize\ttfamily \label{namespacemp_a5e5e25db1f96faf66ab24fb0a5fcaff7} 
template$<$typename Impl, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::unique\+\_\+ptr$<$ Impl $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{, }\item[{typename \textbf{ Decay}$<$ decltype(output.\+get())$>$\+::\+Calls $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [25/28]}}
{\footnotesize\ttfamily \label{namespacemp_a3c6e22284dac7c8266701b645137a6db} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::vector$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [26/28]}}
{\footnotesize\ttfamily \label{namespacemp_a8eb7dc384d82375bba62e564e675824d} 
template$<$typename Value, typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ \textbf{ Uni\+Value} $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Value \&\&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

Overload Custom\+Build\+Field and Custom\+Read\+Field to serialize \doxyref{Uni\+Value}{p.}{class_uni_value} parameters and return values as JSON strings. \index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [27/28]}}
{\footnotesize\ttfamily \label{namespacemp_a5acc06b8688f4b6ee2c72749dc165ab1} 
template$<$typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$$>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Client\+Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Output \&\&}]{output}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(output.\+get()), Context\+::\+Builder $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildField@{CustomBuildField}}
\index{CustomBuildField@{CustomBuildField}!mp@{mp}}
\doxysubsubsection{CustomBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [28/28]}}
{\footnotesize\ttfamily \label{namespacemp_a7d452f33910d9f4256e1a06a443d4535} 
template$<$typename Output$>$ \\
void Custom\+Build\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$$>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Output \&\&}]{output}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(output.\+get()), Thread\+Map\+::\+Client $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomBuildMessage@{CustomBuildMessage}}
\index{CustomBuildMessage@{CustomBuildMessage}!mp@{mp}}
\doxysubsubsection{CustomBuildMessage()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a173202029072e6149c914392fc622ef4} 
void Custom\+Build\+Message (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const \textbf{ test\+::\+Foo\+Message} \&}]{src}{, }\item[{test\+::messages\+::\+Foo\+Message\+::\+Builder \&\&}]{builder}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CustomBuildMessage@{CustomBuildMessage}}
\index{CustomBuildMessage@{CustomBuildMessage}!mp@{mp}}
\doxysubsubsection{CustomBuildMessage()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_ae8e0d9220d1920a72ab6901940ecc0cd} 
void Custom\+Build\+Message (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const \textbf{ test\+::\+Foo\+Mutable} \&}]{src}{, }\item[{test\+::messages\+::\+Foo\+Mutable\+::\+Builder \&\&}]{builder}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CustomHasValue@{CustomHasValue}}
\index{CustomHasValue@{CustomHasValue}!mp@{mp}}
\doxysubsubsection{CustomHasValue()}
{\footnotesize\ttfamily \label{namespacemp_abe77a9e8285b02902384ef6b489fe696} 
template$<$typename... Values$>$ \\
bool Custom\+Has\+Value (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const Values \&...}]{value}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomMakeProxyClient@{CustomMakeProxyClient}}
\index{CustomMakeProxyClient@{CustomMakeProxyClient}!mp@{mp}}
\doxysubsubsection{CustomMakeProxyClient()}
{\footnotesize\ttfamily \label{namespacemp_a5c6682f9c7c8df447bb918a5bba2b791} 
template$<$typename Interface, typename Impl$>$ \\
std\+::unique\+\_\+ptr$<$ Impl $>$ Custom\+Make\+Proxy\+Client (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{context}{, }\item[{typename Interface\+::\+Client \&\&}]{client}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomMakeProxyServer@{CustomMakeProxyServer}}
\index{CustomMakeProxyServer@{CustomMakeProxyServer}!mp@{mp}}
\doxysubsubsection{CustomMakeProxyServer()}
{\footnotesize\ttfamily \label{namespacemp_a3171aa60b966cb66360fa1f1b6e8cac9} 
template$<$typename Interface, typename Impl$>$ \\
kj\+::\+Own$<$ typename Interface\+::\+Server $>$ Custom\+Make\+Proxy\+Server (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{context}{, }\item[{std\+::shared\+\_\+ptr$<$ Impl $>$ \&\&}]{impl}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomPassField@{CustomPassField}}
\index{CustomPassField@{CustomPassField}!mp@{mp}}
\doxysubsubsection{CustomPassField()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a82b11c36426fa4b2650669be0b10f08a} 
template$<$class \textbf{ Accessor}$>$ \\
void Custom\+Pass\+Field (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomPassField@{CustomPassField}}
\index{CustomPassField@{CustomPassField}!mp@{mp}}
\doxysubsubsection{CustomPassField()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_a6abaf7f9430c640b26e6a34963b9c3ee} 
template$<$typename \textbf{ Accessor}, typename... Local\+Types, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ \\
auto Custom\+Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Types... $>$}]{}{, }\item[{\textbf{ Server\+Context} \&}]{server\+\_\+context}{, }\item[{Fn \&\&}]{fn}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})-\/$>$decltype(\textbf{ Custom\+Pass\+Message}(server\+\_\+context, \textbf{ Maybe\+Get}$<$ \textbf{ Accessor} $>$(server\+\_\+context.\+call\+\_\+context.\+get\+Params()), \textbf{ Maybe\+Get}$<$ \textbf{ Accessor} $>$(server\+\_\+context.\+call\+\_\+context.\+get\+Results()), nullptr))}

Overload Custom\+Pass\+Field to serialize objects that have Custom\+Pass\+Message overloads. Defining a Custom\+Pass\+Message overload is simpler than defining a Custom\+Pass\+Field overload because it only requires defining a normal function, not a template function, but less flexible. \index{mp@{mp}!CustomPassMessage@{CustomPassMessage}}
\index{CustomPassMessage@{CustomPassMessage}!mp@{mp}}
\doxysubsubsection{CustomPassMessage()}
{\footnotesize\ttfamily \label{namespacemp_acf0b2956938a9df9bb4e955f7eaedddd} 
void Custom\+Pass\+Message (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const test\+::messages\+::\+Foo\+Mutable\+::\+Reader \&}]{reader}{, }\item[{test\+::messages\+::\+Foo\+Mutable\+::\+Builder}]{builder}{, }\item[{std\+::function$<$ void(\textbf{ test\+::\+Foo\+Mutable} \&)$>$ \&\&}]{fn}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [1/26]}}
{\footnotesize\ttfamily \label{namespacemp_abb577249276f2ad83587cba5d0bbeada} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [2/26]}}
{\footnotesize\ttfamily \label{namespacemp_abe41e02db47a3380038503fec9f49dbd} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{param}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{typename \textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::\+Struct $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [3/26]}}
{\footnotesize\ttfamily \label{namespacemp_a5c72413694a0b142a7f7143a0eed8775} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \newline
requires \textbf{ ipc\+::capnp\+::\+Deserializable}$<$Local\+Type$>$\\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

Overload multiprocess library\textquotesingle{}s Custom\+Read\+Field hook to allow any object with a deserialize constructor to be read from a capnproto Data field or returned from capnproto interface. Use \doxyref{Priority$<$1$>$}{p.}{structmp_1_1_priority} so this hook has medium priority, and higher priority hooks could take precedence over this one. \index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [4/26]}}
{\footnotesize\ttfamily \label{namespacemp_a283ede424a5b1e3b5c29ee6973f31802} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \newline
requires \textbf{ Unserializable}$<$Local\+Type, \textbf{ Data\+Stream}$>$ \&\& (!\textbf{ ipc\+::capnp\+::\+Deserializable}$<$Local\+Type$>$)\\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

Overload multiprocess library\textquotesingle{}s Custom\+Read\+Field hook to allow any object with an Unserialize method to be read from a capnproto Data field or returned from capnproto interface. Use \doxyref{Priority$<$1$>$}{p.}{structmp_1_1_priority} so this hook has medium priority, and higher priority hooks could take precedence over this one. \index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [5/26]}}
{\footnotesize\ttfamily \label{namespacemp_a68317aabcc5676c7e942610a2ab91e4b} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+enum$<$ Local\+Type $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [6/26]}}
{\footnotesize\ttfamily \label{namespacemp_a69d6d27ae4c06debd7359702ab5e00df} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+floating\+\_\+point$<$ Local\+Type $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [7/26]}}
{\footnotesize\ttfamily \label{namespacemp_a1543fd7919023f37cc55b70d383422f4} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+integral$<$ Local\+Type $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [8/26]}}
{\footnotesize\ttfamily \label{namespacemp_a42ca2bb9fc420c2a4d10a47f5aaa9833} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \newline
requires (std\+::is\+\_\+same\+\_\+v$<$decltype(input.\+get()), \+::capnp\+::\+Data\+::\+Reader$>$ \&\& Is\+Byte\+Span$<$Local\+Type$>$)\\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 2 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [9/26]}}
{\footnotesize\ttfamily \label{namespacemp_affe7b6b3a5c4fceaa0be4709c632f7ca} 
template$<$typename Local\+Type, typename Reader, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Priority}$<$ 2 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Reader \&\&}]{reader}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{decltype(\textbf{ Custom\+Read\+Message}(invoke\+\_\+context, reader.\+get(), std\+::declval$<$ Local\+Type \& $>$())) $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Overload Custom\+Read\+Field to serialize objects that have Custom\+Read\+Message overloads. Defining a Custom\+Read\+Message overload is simpler than defining a Custom\+Read\+Field overload because it only requires defining a normal function, not a template function, but less flexible. \index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [10/26]}}
{\footnotesize\ttfamily \label{namespacemp_a7446b723d4ac661a7e448712449d44f7} 
template$<$class Rep, class Period, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::chrono\+::duration$<$ Rep, Period $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [11/26]}}
{\footnotesize\ttfamily \label{namespacemp_a7608a417baf3ed59f5c9814054bd6a04} 
template$<$typename FnR, typename... Fn\+Params, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::function$<$ FnR(Fn\+Params...)$>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [12/26]}}
{\footnotesize\ttfamily \label{namespacemp_aaf1aa9861cf6dd3c0ebc5ae259c4208f} 
template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::map$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [13/26]}}
{\footnotesize\ttfamily \label{namespacemp_affc0d05dce5f90964813da4779ea19be} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::optional$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [14/26]}}
{\footnotesize\ttfamily \label{namespacemp_aa77fbfc0a3d6c138f29d768c1f982b12} 
template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::pair$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [15/26]}}
{\footnotesize\ttfamily \label{namespacemp_ab07cd94eac8ec75e125c10fe3a986238} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::set$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [16/26]}}
{\footnotesize\ttfamily \label{namespacemp_a97afbbdcc082110ae57c4ee6d7504596} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ const Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [17/26]}}
{\footnotesize\ttfamily \label{namespacemp_afbb4137f6dc2200aca520d6d7546c201} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [18/26]}}
{\footnotesize\ttfamily \label{namespacemp_a3981c4e23b556460889260a8e55e8e9d} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::shared\+\_\+ptr$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{typename \textbf{ Decay}$<$ decltype(input.\+get())$>$\+::\+Calls $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [19/26]}}
{\footnotesize\ttfamily \label{namespacemp_a0852a043bf2a4cbcc851310d0161b57e} 
template$<$typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::string $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [20/26]}}
{\footnotesize\ttfamily \label{namespacemp_a73f04960c0265edc2fc560e8ddf16859} 
template$<$typename Key\+Local\+Type, typename Value\+Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::tuple$<$ Key\+Local\+Type, Value\+Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [21/26]}}
{\footnotesize\ttfamily \label{namespacemp_a5737c5ac4c9885211a8254b018682db2} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::unique\+\_\+ptr$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{, }\item[{typename \textbf{ Decay}$<$ decltype(input.\+get())$>$\+::\+Calls $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [22/26]}}
{\footnotesize\ttfamily \label{namespacemp_a70c5c0378bee2707a330c4e2e9c8e9f2} 
template$<$typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::vector$<$ bool $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [23/26]}}
{\footnotesize\ttfamily \label{namespacemp_a38819e71ab53405930caef593d551423} 
template$<$typename Local\+Type, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::vector$<$ Local\+Type $>$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [24/26]}}
{\footnotesize\ttfamily \label{namespacemp_a1d246b0cc4fad2fc41423940f78e9d6e} 
template$<$typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ \textbf{ Uni\+Value} $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [25/26]}}
{\footnotesize\ttfamily \label{namespacemp_a90124512e4c5a81f25acf873559cde7f} 
template$<$size\+\_\+t size, typename Input, typename Read\+Dest$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ unsigned char[size]$>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Read\+Dest \&\&}]{read\+\_\+dest}{}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadField@{CustomReadField}}
\index{CustomReadField@{CustomReadField}!mp@{mp}}
\doxysubsubsection{CustomReadField()\hspace{0.1cm}{\footnotesize\ttfamily [26/26]}}
{\footnotesize\ttfamily \label{namespacemp_aea32c278d867d32dfb1470bcff49b15f} 
template$<$typename Input$>$ \\
decltype(auto) Custom\+Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$$>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{typename std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(input.\+get()), Thread\+Map\+::\+Client $>$\+::value $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!CustomReadMessage@{CustomReadMessage}}
\index{CustomReadMessage@{CustomReadMessage}!mp@{mp}}
\doxysubsubsection{CustomReadMessage()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a454237a729afd551c1bc8593c9a36d00} 
void Custom\+Read\+Message (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const test\+::messages\+::\+Foo\+Message\+::\+Reader \&}]{reader}{, }\item[{\textbf{ test\+::\+Foo\+Message} \&}]{dest}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!CustomReadMessage@{CustomReadMessage}}
\index{CustomReadMessage@{CustomReadMessage}!mp@{mp}}
\doxysubsubsection{CustomReadMessage()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_ae7c8525cd6007460faa2ad693dae7a8b} 
void Custom\+Read\+Message (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{const test\+::messages\+::\+Foo\+Mutable\+::\+Reader \&}]{reader}{, }\item[{\textbf{ test\+::\+Foo\+Mutable} \&}]{dest}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{mp@{mp}!ExecProcess@{ExecProcess}}
\index{ExecProcess@{ExecProcess}!mp@{mp}}
\doxysubsubsection{ExecProcess()}
{\footnotesize\ttfamily \label{namespacemp_a1d5b846a17625b9e9c2b5a6913916d16} 
void Exec\+Process (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::string $>$ \&}]{args}{}\end{DoxyParamCaption})}



Call execvp with vector args. 

\index{mp@{mp}!GuardedRef@{GuardedRef}}
\index{GuardedRef@{GuardedRef}!mp@{mp}}
\doxysubsubsection{GuardedRef()}
{\footnotesize\ttfamily \label{namespacemp_ac318e5c3e48710a840b27710c5e1e9c9} 
template$<$class U$>$ \\
Guarded\+Ref (\begin{DoxyParamCaption}\item[{\textbf{ Mutex} \&}]{}{, }\item[{U \&}]{}{}\end{DoxyParamCaption})-\/$>$Guarded\+Ref$<$ U $>$}

\index{mp@{mp}!KJ\_STRINGIFY@{KJ\_STRINGIFY}}
\index{KJ\_STRINGIFY@{KJ\_STRINGIFY}!mp@{mp}}
\doxysubsubsection{KJ\_STRINGIFY()}
{\footnotesize\ttfamily \label{namespacemp_a620d42de001d14996c71608f6f52b5e3} 
kj\+::\+String\+Ptr KJ\+\_\+\+STRINGIFY (\begin{DoxyParamCaption}\item[{\textbf{ Log}}]{flags}{}\end{DoxyParamCaption})}

\index{mp@{mp}!ListenConnections@{ListenConnections}}
\index{ListenConnections@{ListenConnections}!mp@{mp}}
\doxysubsubsection{ListenConnections()}
{\footnotesize\ttfamily \label{namespacemp_ac32d169bba43387dec219a91d4539435} 
template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ \\
void Listen\+Connections (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{int}]{fd}{, }\item[{\textbf{ Init\+Impl} \&}]{init}{}\end{DoxyParamCaption})}

Given listening socket file descriptor and an init object, handle incoming connections and requests by calling methods on the \doxyref{Init}{p.}{class_init} object. \index{mp@{mp}!LogEscape@{LogEscape}}
\index{LogEscape@{LogEscape}!mp@{mp}}
\doxysubsubsection{LogEscape()}
{\footnotesize\ttfamily \label{namespacemp_a6a2a2065349af9766eb784fcf9139964} 
std\+::string Log\+Escape (\begin{DoxyParamCaption}\item[{const kj\+::\+String\+Tree \&}]{string}{, }\item[{size\+\_\+t}]{max\+\_\+size}{}\end{DoxyParamCaption})}

Escape binary string for use in log so it doesn\textquotesingle{}t trigger unicode decode errors in python unit tests. \index{mp@{mp}!LongThreadName@{LongThreadName}}
\index{LongThreadName@{LongThreadName}!mp@{mp}}
\doxysubsubsection{LongThreadName()}
{\footnotesize\ttfamily \label{namespacemp_aa2d3754fdd40a5ee179789009a316e08} 
std\+::string Long\+Thread\+Name (\begin{DoxyParamCaption}\item[{const char $\ast$}]{exe\+\_\+name}{}\end{DoxyParamCaption})}

\index{mp@{mp}!Make@{Make}}
\index{Make@{Make}!mp@{mp}}
\doxysubsubsection{Make()}
{\footnotesize\ttfamily \label{namespacemp_a1630f2d1b19603bee24bf60f7d287d72} 
template$<$template$<$ typename... $>$ class Class, typename... Types, typename... Args$>$ \\
Class$<$ Types..., std\+::remove\+\_\+reference\+\_\+t$<$ Args $>$... $>$ Make (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}

Construct a template class value by deducing template arguments from the types of constructor arguments, so they don\textquotesingle{}t need to be specified manually.

Uses of this can go away with class template deduction in C++17 ({\texttt{https\+://en.\+cppreference.\+com/w/cpp/language/class\+\_\+template\+\_\+argument\+\_\+deduction}})

Example\+: Make$<$std\+::pair$>$(5, true) // Constructs std\+::pair$<$int, bool$>$(5, true); \index{mp@{mp}!MakeClientParam@{MakeClientParam}}
\index{MakeClientParam@{MakeClientParam}!mp@{mp}}
\doxysubsubsection{MakeClientParam()}
{\footnotesize\ttfamily \label{namespacemp_a1cc27604a11d37fda2acffa2dec33a07} 
template$<$typename \textbf{ Accessor}, typename... Types$>$ \\
\textbf{ Client\+Param}$<$ \textbf{ Accessor}, Types... $>$ Make\+Client\+Param (\begin{DoxyParamCaption}\item[{Types \&\&...}]{values}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MakeProxyClient@{MakeProxyClient}}
\index{MakeProxyClient@{MakeProxyClient}!mp@{mp}}
\doxysubsubsection{MakeProxyClient()}
{\footnotesize\ttfamily \label{namespacemp_a45d7bf941d6b28ff64ab83bf8ef5962b} 
template$<$typename Interface, typename Impl$>$ \\
std\+::unique\+\_\+ptr$<$ Impl $>$ Make\+Proxy\+Client (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{context}{, }\item[{typename Interface\+::\+Client \&\&}]{client}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MakeProxyServer@{MakeProxyServer}}
\index{MakeProxyServer@{MakeProxyServer}!mp@{mp}}
\doxysubsubsection{MakeProxyServer()}
{\footnotesize\ttfamily \label{namespacemp_a3f2bd5f719c20ebeb8c8cfdf2d97d97f} 
template$<$typename Interface, typename Impl$>$ \\
kj\+::\+Own$<$ typename Interface\+::\+Server $>$ Make\+Proxy\+Server (\begin{DoxyParamCaption}\item[{\textbf{ Invoke\+Context} \&}]{context}{, }\item[{std\+::shared\+\_\+ptr$<$ Impl $>$}]{impl}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MakeServerField@{MakeServerField}}
\index{MakeServerField@{MakeServerField}!mp@{mp}}
\doxysubsubsection{MakeServerField()}
{\footnotesize\ttfamily \label{namespacemp_a5910f357e7d39274ca454dadf3cff864} 
template$<$int argc, typename \textbf{ Accessor}, typename Parent$>$ \\
\textbf{ Server\+Field}$<$ argc, \textbf{ Accessor}, Parent $>$ Make\+Server\+Field (\begin{DoxyParamCaption}\item[{Parent}]{parent}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeBuildField@{MaybeBuildField}}
\index{MaybeBuildField@{MaybeBuildField}!mp@{mp}}
\doxysubsubsection{MaybeBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a9de0a13f57b0c9997e6d2d716cd30ee7} 
template$<$typename... Args$>$ \\
void Maybe\+Build\+Field (\begin{DoxyParamCaption}\item[{std\+::false\+\_\+type}]{}{, }\item[{Args \&\&}]{...}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeBuildField@{MaybeBuildField}}
\index{MaybeBuildField@{MaybeBuildField}!mp@{mp}}
\doxysubsubsection{MaybeBuildField()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_a3b4e574c7459b1cbbe92aad9af146039} 
template$<$typename... Args$>$ \\
void Maybe\+Build\+Field (\begin{DoxyParamCaption}\item[{std\+::true\+\_\+type}]{}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeGet@{MaybeGet}}
\index{MaybeGet@{MaybeGet}!mp@{mp}}
\doxysubsubsection{MaybeGet()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a6950c46e6d80cd67785d6d7b91e82f6e} 
template$<$typename \textbf{ Accessor}$>$ \\
\+::capnp\+::\+Void Maybe\+Get (\begin{DoxyParamCaption}\item[{}]{...}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeGet@{MaybeGet}}
\index{MaybeGet@{MaybeGet}!mp@{mp}}
\doxysubsubsection{MaybeGet()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_acad4865d3a78e3e66c6d30a5b212ecfe} 
template$<$typename \textbf{ Accessor}, typename Message$>$ \\
decltype(auto) Maybe\+Get (\begin{DoxyParamCaption}\item[{Message \&\&}]{message}{, }\item[{decltype(Accessor\+::get(message)) $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Helper for Custom\+Pass\+Field below. Call Accessor\+::get method if it has one, otherwise return capnp\+::\+Void. \index{mp@{mp}!MaybeInit@{MaybeInit}}
\index{MaybeInit@{MaybeInit}!mp@{mp}}
\doxysubsubsection{MaybeInit()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_affe8cccff51c76aa6d1a49bbcd366fd1} 
template$<$typename \textbf{ Accessor}$>$ \\
\+::capnp\+::\+Void Maybe\+Init (\begin{DoxyParamCaption}\item[{}]{...}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeInit@{MaybeInit}}
\index{MaybeInit@{MaybeInit}!mp@{mp}}
\doxysubsubsection{MaybeInit()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_a981aaadb41234b62f8bf171bfab6459e} 
template$<$typename \textbf{ Accessor}, typename Message$>$ \\
decltype(auto) Maybe\+Init (\begin{DoxyParamCaption}\item[{Message \&\&}]{message}{, }\item[{decltype(Accessor\+::get(message)) $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Helper for Custom\+Pass\+Field below. Call Accessor\+::init method if it has one, otherwise do nothing. \index{mp@{mp}!MaybeReadField@{MaybeReadField}}
\index{MaybeReadField@{MaybeReadField}!mp@{mp}}
\doxysubsubsection{MaybeReadField()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_aadea7dc92be717854e770c5140d4fd2a} 
template$<$typename... Args$>$ \\
void Maybe\+Read\+Field (\begin{DoxyParamCaption}\item[{std\+::false\+\_\+type}]{}{, }\item[{Args \&\&}]{...}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeReadField@{MaybeReadField}}
\index{MaybeReadField@{MaybeReadField}!mp@{mp}}
\doxysubsubsection{MaybeReadField()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_ac0f3090684e164019cfc5bf26ae82484} 
template$<$typename... Args$>$ \\
void Maybe\+Read\+Field (\begin{DoxyParamCaption}\item[{std\+::true\+\_\+type}]{}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeSetWant@{MaybeSetWant}}
\index{MaybeSetWant@{MaybeSetWant}!mp@{mp}}
\doxysubsubsection{MaybeSetWant()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a1b28ad2c9021cf3124a5b6340decd988} 
template$<$typename Local\+Types, typename... Args$>$ \\
void Maybe\+Set\+Want (\begin{DoxyParamCaption}\item[{Local\+Types}]{}{, }\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{const Args \&}]{...}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MaybeSetWant@{MaybeSetWant}}
\index{MaybeSetWant@{MaybeSetWant}!mp@{mp}}
\doxysubsubsection{MaybeSetWant()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_ae2ea9ecba7ea274c30529f64dcc7f6ac} 
template$<$typename Local\+Type, typename Value, typename Output$>$ \\
void Maybe\+Set\+Want (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$}]{}{, }\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{const Value \&}]{value}{, }\item[{Output \&\&}]{output}{}\end{DoxyParamCaption})}

\index{mp@{mp}!MP\_CAPABILITY@{MP\_CAPABILITY}}
\index{MP\_CAPABILITY@{MP\_CAPABILITY}!mp@{mp}}
\doxysubsubsection{MP\_CAPABILITY()}
{\footnotesize\ttfamily \label{namespacemp_a985fe0cbdbe24f45a410db93c0e89bdb} 
class MP\+\_\+\+CAPABILITY (\begin{DoxyParamCaption}\item[{"{}mutex"{}}]{}{}\end{DoxyParamCaption})}

\index{mp@{mp}!PassField@{PassField}}
\index{PassField@{PassField}!mp@{mp}}
\doxysubsubsection{PassField()\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \label{namespacemp_a184a372c73e3e46154335263a496302f} 
template$<$typename \textbf{ Accessor}, typename Local\+Type, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ \\
void Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Server\+Context} \&}]{server\+\_\+context}{, }\item[{Fn \&\&}]{fn}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}



Default Pass\+Field implementation calling Maybe\+Read\+Field/\+Maybe\+Build\+Field. 

\index{mp@{mp}!PassField@{PassField}}
\index{PassField@{PassField}!mp@{mp}}
\doxysubsubsection{PassField()\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \label{namespacemp_a0a96b15b95f05d92a6bc6254a9fc0143} 
template$<$typename \textbf{ Accessor}, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ \\
void Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Priority}$<$ 0 $>$}]{}{, }\item[{\textbf{ Type\+List}$<$$>$}]{}{, }\item[{\textbf{ Server\+Context} \&}]{server\+\_\+context}{, }\item[{const Fn \&}]{fn}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}



Default Pass\+Field implementation for count(0) arguments, calling Read\+Field/\+Build\+Field. 

\index{mp@{mp}!PassField@{PassField}}
\index{PassField@{PassField}!mp@{mp}}
\doxysubsubsection{PassField()\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \label{namespacemp_ac561505e806b6ba98ebe557b13ab1385} 
template$<$typename \textbf{ Accessor}, typename Local\+Type, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ \\
auto Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Type\+List}$<$ Local\+Type \& $>$}]{}{, }\item[{\textbf{ Server\+Context} \&}]{server\+\_\+context}{, }\item[{Fn \&\&}]{fn}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})-\/$>$\textbf{ Require}$<$ typenamedecltype(Accessor\+::get(server\+\_\+context.\+call\+\_\+context.\+get\+Params()))\+::\+Calls $>$}



Pass\+Field override for callable interface reference arguments. 

\index{mp@{mp}!PassField@{PassField}}
\index{PassField@{PassField}!mp@{mp}}
\doxysubsubsection{PassField()\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \label{namespacemp_a5619b878293bc4f10e27154d3f7518ba} 
template$<$typename \textbf{ Accessor}, typename Local\+Type, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ \\
void Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Type\+List}$<$ Local\+Type $\ast$ $>$}]{}{, }\item[{\textbf{ Server\+Context} \&}]{server\+\_\+context}{, }\item[{const Fn \&}]{fn}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}



Pass\+Field override for C++ pointer arguments. 

\index{mp@{mp}!PassField@{PassField}}
\index{PassField@{PassField}!mp@{mp}}
\doxysubsubsection{PassField()\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \label{namespacemp_acc8493744cf49685ae16f38f0c511a1f} 
template$<$typename \textbf{ Accessor}, typename \textbf{ Server\+Context}, typename Fn, typename... Args$>$ \\
auto Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Priority}$<$ 1 $>$}]{}{, }\item[{\textbf{ Type\+List}$<$$>$}]{}{, }\item[{\textbf{ Server\+Context} \&}]{server\+\_\+context}{, }\item[{const Fn \&}]{fn}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})-\/$>$typenamestd\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ decltype(Accessor\+::get(server\+\_\+context.\+call\+\_\+context.\+get\+Params())), Context\+::\+Reader $>$\+::value, kj\+::\+Promise$<$ typename\+Server\+Context\+::\+Call\+Context $>$ $>$\+::type}

Pass\+Field override for mp.\+Context arguments. Return asynchronously and call function on other thread found in context. \index{mp@{mp}!PassField@{PassField}}
\index{PassField@{PassField}!mp@{mp}}
\doxysubsubsection{PassField()\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \label{namespacemp_a45fbe88a7151d6d87d1e3c3dbd51826e} 
template$<$typename \textbf{ Accessor}, typename... Args$>$ \\
auto Pass\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Priority}$<$ 2 $>$}]{}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})-\/$>$decltype(\textbf{ Custom\+Pass\+Field}$<$ \textbf{ Accessor} $>$(std\+::forward$<$ Args $>$(\textbf{ args})...))}

Pass\+Field override calling Custom\+Pass\+Field function, if it exists. Defining a Custom\+Pass\+Field or Custom\+Pass\+Message overload is useful for input/output parameters. If an overload is not defined these parameters will just be deserialized on the server side with Read\+Field into a temporary variable, then the server method will be called passing the temporary variable as a parameter, then the temporary variable will be serialized and sent back to the client with Build\+Field. But if a Pass\+Field or Pass\+Message overload is defined, the overload is called with a callback to invoke and pass parameters to the server side function, and run arbitrary code before and after invoking the function. \index{mp@{mp}!ReadDestTemp@{ReadDestTemp}}
\index{ReadDestTemp@{ReadDestTemp}!mp@{mp}}
\doxysubsubsection{ReadDestTemp()}
{\footnotesize\ttfamily \label{namespacemp_a1ebe29dfac344a7401485f1190fa9662} 
template$<$typename Local\+Type$>$ \\
auto Read\+Dest\+Temp (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Helper function to create a \doxyref{Read\+Dest\+Emplace}{p.}{structmp_1_1_read_dest_emplace} object that constructs a temporary, Read\+Field can return. \index{mp@{mp}!ReadField@{ReadField}}
\index{ReadField@{ReadField}!mp@{mp}}
\doxysubsubsection{ReadField()}
{\footnotesize\ttfamily \label{namespacemp_abaca5f1e886aadc79ca14e933b351e9a} 
template$<$typename... Local\+Types, typename... Args$>$ \\
decltype(auto) Read\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Types... $>$}]{}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})}

\index{mp@{mp}!ReadOne@{ReadOne}}
\index{ReadOne@{ReadOne}!mp@{mp}}
\doxysubsubsection{ReadOne()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a3dbc0f8ad81f5d74a0bbba5454dd4375} 
template$<$size\+\_\+t index, typename Local\+Type, typename Input, typename Value$>$ \\
void Read\+One (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{param}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{, }\item[{Value \&\&}]{value}{, }\item[{typename std\+::enable\+\_\+if$<$ index !=\textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!ReadOne@{ReadOne}}
\index{ReadOne@{ReadOne}!mp@{mp}}
\doxysubsubsection{ReadOne()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_a3343bd35fc0b77c0cac72f13109fec85} 
template$<$size\+\_\+t index, typename Local\+Type, typename Input, typename Value$>$ \\
void Read\+One (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{param}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&}]{input}{, }\item[{Value \&}]{value}{, }\item[{typename std\+::enable\+\_\+if$<$ index==\textbf{ Proxy\+Type}$<$ Local\+Type $>$\+::fields $>$\+::type $\ast$}]{enable}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

\index{mp@{mp}!ReplaceVoid@{ReplaceVoid}}
\index{ReplaceVoid@{ReplaceVoid}!mp@{mp}}
\doxysubsubsection{ReplaceVoid()}
{\footnotesize\ttfamily \label{namespacemp_a8579a169208941d4258dfb46d784d328} 
template$<$typename Fn, typename Ret$>$ \\
auto Replace\+Void (\begin{DoxyParamCaption}\item[{Fn \&\&}]{fn}{, }\item[{Ret \&\&}]{ret}{}\end{DoxyParamCaption})}

Invoke callable {\ttfamily fn()} that may return void. If it does return void, replace return value with value of {\ttfamily \doxyref{ret()}{p.}{bitcoin-cli_8cpp_a339672ff94e6199019102f50d317c3d7}}. This is useful for avoiding code duplication and branching in generic code that forwards calls to functions. \index{mp@{mp}!serverDestroy@{serverDestroy}}
\index{serverDestroy@{serverDestroy}!mp@{mp}}
\doxysubsubsection{serverDestroy()}
{\footnotesize\ttfamily \label{namespacemp_acd17d6b5f4048badec756795493ceda8} 
template$<$typename Server$>$ \\
void server\+Destroy (\begin{DoxyParamCaption}\item[{Server \&}]{server}{}\end{DoxyParamCaption})}

\index{mp@{mp}!serverInvoke@{serverInvoke}}
\index{serverInvoke@{serverInvoke}!mp@{mp}}
\doxysubsubsection{serverInvoke()}
{\footnotesize\ttfamily \label{namespacemp_a85c3a50860030b3b5be3f5febdcad20a} 
template$<$typename Server, typename Call\+Context, typename Fn$>$ \\
kj\+::\+Promise$<$ void $>$ server\+Invoke (\begin{DoxyParamCaption}\item[{Server \&}]{server}{, }\item[{Call\+Context \&}]{call\+\_\+context}{, }\item[{Fn}]{fn}{}\end{DoxyParamCaption})}

Entry point called by generated server code that looks like\+:

kj\+::\+Promise$<$void$>$ Proxy\+Server$<$\+Interface\+Name$>$\+::method\+Name(\+Call\+Context call\+\_\+context) \{ return server\+Invoke($\ast$this, call\+\_\+context, Make\+Server\+Field$<$0, ...$>$(Make\+Server\+Field$<$1, ...$>$(Make$<$\+Server\+Ret, ...$>$(\+Server\+Call())))); \}

Ellipses above are where generated \doxyref{Accessor$<$$>$}{p.}{structmp_1_1_accessor} type declarations are inserted. \index{mp@{mp}!ServeStream@{ServeStream}}
\index{ServeStream@{ServeStream}!mp@{mp}}
\doxysubsubsection{ServeStream()}
{\footnotesize\ttfamily \label{namespacemp_a4bf39784f1a721e61fb9da94711ba444} 
template$<$typename Init\+Interface, typename \textbf{ Init\+Impl}$>$ \\
void Serve\+Stream (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{int}]{fd}{, }\item[{\textbf{ Init\+Impl} \&}]{init}{}\end{DoxyParamCaption})}

Given stream file descriptor and an init object, handle requests on the stream by calling methods on the \doxyref{Init}{p.}{class_init} object. \index{mp@{mp}!SetThread@{SetThread}}
\index{SetThread@{SetThread}!mp@{mp}}
\doxysubsubsection{SetThread()}
{\footnotesize\ttfamily \label{namespacemp_a48933e17f4fac720326ae1737bf53764} 
std\+::tuple$<$ \textbf{ Conn\+Thread}, bool $>$ Set\+Thread (\begin{DoxyParamCaption}\item[{\textbf{ Guarded\+Ref}$<$ \textbf{ Conn\+Threads} $>$}]{threads}{, }\item[{\textbf{ Connection} $\ast$}]{connection}{, }\item[{const std\+::function$<$ Thread\+::\+Client()$>$ \&}]{make\+\_\+thread}{}\end{DoxyParamCaption})}

\index{mp@{mp}!SpawnProcess@{SpawnProcess}}
\index{SpawnProcess@{SpawnProcess}!mp@{mp}}
\doxysubsubsection{SpawnProcess()}
{\footnotesize\ttfamily \label{namespacemp_a95d94f19c8b5bd4a18f09c3c87156b4b} 
int Spawn\+Process (\begin{DoxyParamCaption}\item[{int \&}]{pid}{, }\item[{\textbf{ Fd\+To\+Args\+Fn} \&\&}]{fd\+\_\+to\+\_\+args}{}\end{DoxyParamCaption})}

Spawn a new process that communicates with the current process over a socket pair. Returns pid through an output argument, and file descriptor for the local side of the socket. Invokes fd\+\_\+to\+\_\+args callback with the remote file descriptor number which returns the command line arguments that should be used to execute the process, and which should have the remote file descriptor embedded in whatever format the child process expects. \index{mp@{mp}!ThreadName@{ThreadName}}
\index{ThreadName@{ThreadName}!mp@{mp}}
\doxysubsubsection{ThreadName()}
{\footnotesize\ttfamily \label{namespacemp_ac5b6bf220a6572e3a713a6f6c154f6ad} 
std\+::string Thread\+Name (\begin{DoxyParamCaption}\item[{const char $\ast$}]{exe\+\_\+name}{}\end{DoxyParamCaption})}



\doxyref{Format}{p.}{struct_format} current thread name as "{}\{exe\+\_\+name\}-\/\{\$pid\}/\{thread\+\_\+name\}-\/\{\$tid\}"{}. 

\index{mp@{mp}!ThrowField@{ThrowField}}
\index{ThrowField@{ThrowField}!mp@{mp}}
\doxysubsubsection{ThrowField()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacemp_a304271303fa44f013fd91eb7e7ff8532} 
template$<$typename Local\+Type, typename Input$>$ \\
void Throw\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ Local\+Type $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{}\end{DoxyParamCaption})}

\index{mp@{mp}!ThrowField@{ThrowField}}
\index{ThrowField@{ThrowField}!mp@{mp}}
\doxysubsubsection{ThrowField()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacemp_aa3f1a805c61c3602d68090c5d3d3851a} 
template$<$typename Input$>$ \\
void Throw\+Field (\begin{DoxyParamCaption}\item[{\textbf{ Type\+List}$<$ std\+::exception $>$}]{}{, }\item[{\textbf{ Invoke\+Context} \&}]{invoke\+\_\+context}{, }\item[{Input \&\&}]{input}{}\end{DoxyParamCaption})}

Special case for generic std\+::exception. It\textquotesingle{}s an abstract type so it can\textquotesingle{}t be created directly. Rethrow as std\+::runtime\+\_\+error so callers expecting it will still catch it. \index{mp@{mp}!TypeName@{TypeName}}
\index{TypeName@{TypeName}!mp@{mp}}
\doxysubsubsection{TypeName()}
{\footnotesize\ttfamily \label{namespacemp_a348de93f4be02f972f7f3a7615480679} 
template$<$typename \textbf{ T}$>$ \\
const char $\ast$ Type\+Name (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Return capnp type name with filename prefix removed. 

\index{mp@{mp}!Unlock@{Unlock}}
\index{Unlock@{Unlock}!mp@{mp}}
\doxysubsubsection{Unlock()}
{\footnotesize\ttfamily \label{namespacemp_ab46f5bea2155b7984451745440f03497} 
template$<$typename \textbf{ Lock}, typename Callback$>$ \\
void Unlock (\begin{DoxyParamCaption}\item[{\textbf{ Lock} \&}]{lock}{, }\item[{Callback \&\&}]{callback}{}\end{DoxyParamCaption})}

\index{mp@{mp}!WaitProcess@{WaitProcess}}
\index{WaitProcess@{WaitProcess}!mp@{mp}}
\doxysubsubsection{WaitProcess()}
{\footnotesize\ttfamily \label{namespacemp_ad714a202bcc6f18a359ae38ef0b23482} 
int Wait\+Process (\begin{DoxyParamCaption}\item[{int}]{pid}{}\end{DoxyParamCaption})}



Wait for a process to exit and return its exit code. 



\label{doc-var-members}
\doxysubsection{Variable Documentation}
\index{mp@{mp}!g\_thread\_context@{g\_thread\_context}}
\index{g\_thread\_context@{g\_thread\_context}!mp@{mp}}
\doxysubsubsection{g\_thread\_context}
{\footnotesize\ttfamily \label{namespacemp_a6779c2c807b5c6d842e8743aa4a1a0b2} 
\textbf{ Thread\+Context} g\+\_\+thread\+\_\+context\hspace{0.3cm}{\ttfamily [thread_local]}}

\index{mp@{mp}!server\_reqs@{server\_reqs}}
\index{server\_reqs@{server\_reqs}!mp@{mp}}
\doxysubsubsection{server\_reqs}
{\footnotesize\ttfamily \label{namespacemp_a238926b410ab10e3f0555f10c64d44c6} 
std\+::atomic$<$ int $>$ server\+\_\+reqs \{0\}}

