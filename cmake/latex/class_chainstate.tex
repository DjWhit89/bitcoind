\doxysection{Chainstate Class Reference}
\label{class_chainstate}\index{Chainstate@{Chainstate}}


{\ttfamily \#include $<$validation.\+h$>$}

Inheritance diagram for Chainstate\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_chainstate}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Chainstate} (\textbf{ CTx\+Mem\+Pool} $\ast$mempool, \textbf{ node\+::\+Block\+Manager} \&blockman, \textbf{ Chainstate\+Manager} \&chainman, std\+::optional$<$ \textbf{ uint256} $>$ from\+\_\+snapshot\+\_\+blockhash=std\+::nullopt)
\item 
\textbf{ fs\+::path} \textbf{ Storage\+Path} () const
\begin{DoxyCompactList}\small\item\em Return path to chainstate leveldb directory. \end{DoxyCompactList}\item 
\textbf{ kernel\+::\+Chainstate\+Role} Get\+Role() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void \textbf{ Init\+Coins\+DB} (size\+\_\+t cache\+\_\+size\+\_\+bytes, bool in\+\_\+memory, bool should\+\_\+wipe)
\item 
void Init\+Coins\+Cache(size\+\_\+t cache\+\_\+size\+\_\+bytes) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool \textbf{ Can\+Flush\+To\+Disk} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\item 
\textbf{ Assumeutxo} m\+\_\+assumeutxo \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
std\+::optional$<$ \textbf{ uint256} $>$ m\+\_\+target\+\_\+blockhash \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
std\+::optional$<$ \textbf{ Assumeutxo\+Hash} $>$ m\+\_\+target\+\_\+utxohash \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
\textbf{ CCoins\+View\+Cache} \& \textbf{ Coins\+Tip} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\item 
\textbf{ CCoins\+View\+DB} \& \textbf{ Coins\+DB} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\item 
\textbf{ CTx\+Mem\+Pool} $\ast$ \textbf{ Get\+Mempool} ()
\item 
\textbf{ CCoins\+View\+Error\+Catcher} \& \textbf{ Coins\+Error\+Catcher} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\item 
void \textbf{ Reset\+Coins\+Views} ()
\begin{DoxyCompactList}\small\item\em Destructs all objects related to accessing the UTXO set. \end{DoxyCompactList}\item 
bool Resize\+Coins\+Caches(size\+\_\+t coinstip\+\_\+size, size\+\_\+t coinsdb\+\_\+size) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool \textbf{ Flush\+State\+To\+Disk} (\textbf{ Block\+Validation\+State} \&state, \textbf{ Flush\+State\+Mode} mode, int n\+Manual\+Prune\+Height=0)
\item 
void \textbf{ Force\+Flush\+State\+To\+Disk} ()
\begin{DoxyCompactList}\small\item\em Unconditionally flush all changes to disk. \end{DoxyCompactList}\item 
void \textbf{ Prune\+And\+Flush} ()
\item 
bool \textbf{ Disconnect\+Tip} (\textbf{ Block\+Validation\+State} \&state, \textbf{ Disconnected\+Block\+Transactions} $\ast$disconnectpool) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main}
\item 
bool \textbf{ Replay\+Blocks} ()
\item 
bool \textbf{ Needs\+Redownload} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ Load\+Genesis\+Block} ()
\item 
void \textbf{ Try\+Add\+Block\+Index\+Candidate} (\textbf{ CBlock\+Index} $\ast$pindex) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Prune\+Block\+Index\+Candidates} ()
\item 
void Clear\+Block\+Index\+Candidates() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(const \textbf{ CBlock\+Index} $\ast$ \textbf{ Find\+Fork\+In\+Global\+Index} (const \textbf{ CBlock\+Locator} \&locator) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ Load\+Chain\+Tip} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
\textbf{ Coins\+Cache\+Size\+State} Get\+Coins\+Cache\+Size\+State() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Coins\+Cache\+Size\+State} Get\+Coins\+Cache\+Size\+State(size\+\_\+t max\+\_\+coins\+\_\+cache\+\_\+size\+\_\+bytes, size\+\_\+t max\+\_\+mempool\+\_\+size\+\_\+bytes) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::string \textbf{ To\+String}() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Recursive\+Mutex} $\ast$ \textbf{ Mempool\+Mutex} () const \textbf{ LOCK\+\_\+\+RETURNED}(\textbf{ m\+\_\+mempool} -\/$>$ \textbf{ cs})
\begin{DoxyCompactList}\small\item\em Indirection necessary to make lock annotations work with an optional mempool. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\textbf{ node\+::\+Block\+Manager} \& \textbf{ m\+\_\+blockman}
\item 
\textbf{ Chainstate\+Manager} \& \textbf{ m\+\_\+chainman}
\item 
\textbf{ CChain} \textbf{ m\+\_\+chain}
\item 
const std\+::optional$<$ \textbf{ uint256} $>$ \textbf{ m\+\_\+from\+\_\+snapshot\+\_\+blockhash}
\item 
const \textbf{ CBlock\+Index} $\ast$Snapshot\+Base() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(const \textbf{ CBlock\+Index} $\ast$Target\+Block() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Set\+Target\+Block(\textbf{ CBlock\+Index} $\ast$block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Set\+Target\+Block\+Hash(\textbf{ uint256} block\+\_\+hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(boo \textbf{ Reached\+Target} )() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\begin{DoxyCompactList}\small\item\em Return true if chainstate reached target block. \end{DoxyCompactList}\item 
std\+::set$<$ \textbf{ CBlock\+Index} $\ast$, \textbf{ node\+::\+CBlock\+Index\+Work\+Comparator} $>$ \textbf{ set\+Block\+Index\+Candidates}
\item 
size\+\_\+t \textbf{ m\+\_\+coinsdb\+\_\+cache\+\_\+size\+\_\+bytes} \{0\}
\begin{DoxyCompactList}\small\item\em The cache size of the on-\/disk coins view. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ m\+\_\+coinstip\+\_\+cache\+\_\+size\+\_\+bytes} \{0\}
\begin{DoxyCompactList}\small\item\em The cache size of the in-\/memory coins view. \end{DoxyCompactList}\item 
bool Activate\+Best\+Chain(\textbf{ Block\+Validation\+State} \&state, std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ pblock=nullptr) \textbf{ LOCKS\+\_\+\+EXCLUDED}(\textbf{ Disconnect\+Result} Disconnect\+Block(const \textbf{ CBlock} \&block, const \textbf{ CBlock\+Index} $\ast$pindex, \textbf{ CCoins\+View\+Cache} \&view) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(boo \textbf{ Connect\+Block} )(const \textbf{ CBlock} \&block, \textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} $\ast$pindex, \textbf{ CCoins\+View\+Cache} \&view, bool f\+Just\+Check=false) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ m\+\_\+mempool} \textbf{ cs}
\item 
bool Precious\+Block(\textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} $\ast$pindex) \textbf{ LOCKS\+\_\+\+EXCLUDED}(bool \textbf{ Invalidate\+Block}(\textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} $\ast$pindex) \textbf{ LOCKS\+\_\+\+EXCLUDED}(void Set\+Block\+Failure\+Flags(\textbf{ CBlock\+Index} $\ast$pindex) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(voi \textbf{ Reset\+Block\+Failure\+Flags} )(\textbf{ CBlock\+Index} $\ast$pindex) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
const \textbf{ CBlock\+Index} $\ast$m\+\_\+cached\+\_\+snapshot\+\_\+base \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\begin{DoxyCompactList}\small\item\em Cached result of Lookup\+Block\+Index($\ast$m\+\_\+from\+\_\+snapshot\+\_\+blockhash). \end{DoxyCompactList}\item 
const \textbf{ CBlock\+Index} $\ast$m\+\_\+cached\+\_\+target\+\_\+block \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\begin{DoxyCompactList}\small\item\em Cached result of Lookup\+Block\+Index($\ast$m\+\_\+target\+\_\+blockhash). \end{DoxyCompactList}\item 
std\+::optional$<$ const char $\ast$ $>$ m\+\_\+last\+\_\+script\+\_\+check\+\_\+reason\+\_\+logged \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
bool \textbf{ Activate\+Best\+Chain\+Step} (\textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} $\ast$pindex\+Most\+Work, const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&pblock, bool \&f\+Invalid\+Found, \textbf{ Connect\+Trace} \&connect\+Trace) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main}
\item 
bool \textbf{ Connect\+Tip} (\textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} $\ast$pindex\+New, std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ block\+\_\+to\+\_\+connect, \textbf{ Connect\+Trace} \&connect\+Trace, \textbf{ Disconnected\+Block\+Transactions} \&disconnectpool) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main}
\item 
void \textbf{ Invalid\+Block\+Found} (\textbf{ CBlock\+Index} $\ast$pindex, const \textbf{ Block\+Validation\+State} \&state) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
\textbf{ CBlock\+Index} $\ast$ \textbf{ Find\+Most\+Work\+Chain} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ Rollforward\+Block} (const \textbf{ CBlock\+Index} $\ast$pindex, \textbf{ CCoins\+View\+Cache} \&inputs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Check\+Fork\+Warning\+Conditions} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Invalid\+Chain\+Found} (\textbf{ CBlock\+Index} $\ast$pindex\+New) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Maybe\+Update\+Mempool\+For\+Reorg} (\textbf{ Disconnected\+Block\+Transactions} \&disconnectpool, bool f\+Add\+To\+Mempool) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main}
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ Mutex} \textbf{ m\+\_\+chainstate\+\_\+mutex}
\item 
\textbf{ CTx\+Mem\+Pool} $\ast$ \textbf{ m\+\_\+mempool}
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Coins\+Views} $>$ \textbf{ m\+\_\+coins\+\_\+views}
\begin{DoxyCompactList}\small\item\em Manages the UTXO set, which is a reflection of the contents of {\ttfamily \doxyref{m\+\_\+chain}{p.}{class_chainstate_ad041fc477f2d0f0774b264bf6f371810}}. \end{DoxyCompactList}\item 
void \textbf{ m\+\_\+mempool} \textbf{ cs}
\item 
void Update\+Tip(const \textbf{ CBlock\+Index} $\ast$pindex\+New) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(Node\+Clock\+::time\+\_\+poin \textbf{ m\+\_\+next\+\_\+write} ) \{Node\+Clock\+::time\+\_\+point\+::max()\}
\item 
\textbf{ util\+::\+Result}$<$ void $>$ Invalidate\+Coins\+DBOn\+Disk() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(friend \textbf{ Chainstate\+Manager}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxyref{Chainstate}{p.}{class_chainstate} stores and provides an API to update our local knowledge of the current best chain.

Eventually, the API here is targeted at being exposed externally as a consumable library, so any functions added must only call other class member functions, pure functions in other parts of the consensus library, callbacks via the validation interface, or read/write-\/to-\/disk functions (eventually this will also be via callbacks).

Anything that is contingent on the current tip of the chain is stored here, whereas block information and metadata independent of the current tip is kept in {\ttfamily \doxyref{Block\+Manager}{p.}{class_block_manager}}. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Chainstate@{Chainstate}!Chainstate@{Chainstate}}
\index{Chainstate@{Chainstate}!Chainstate@{Chainstate}}
\doxysubsubsection{Chainstate()}
{\footnotesize\ttfamily \label{class_chainstate_a70b163a8bca70b51736e75cf3f6282f0} 
\textbf{ Chainstate} (\begin{DoxyParamCaption}\item[{\textbf{ CTx\+Mem\+Pool} $\ast$}]{mempool}{, }\item[{\textbf{ node\+::\+Block\+Manager} \&}]{blockman}{, }\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{std\+::optional$<$ \textbf{ uint256} $>$}]{from\+\_\+snapshot\+\_\+blockhash}{ = {\ttfamily std\+:\+:nullopt}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Chainstate@{Chainstate}!ActivateBestChainStep@{ActivateBestChainStep}}
\index{ActivateBestChainStep@{ActivateBestChainStep}!Chainstate@{Chainstate}}
\doxysubsubsection{ActivateBestChainStep()}
{\footnotesize\ttfamily \label{class_chainstate_a3c22f6ca5579e8366c312e116064b283} 
bool Activate\+Best\+Chain\+Step (\begin{DoxyParamCaption}\item[{\textbf{ Block\+Validation\+State} \&}]{state}{, }\item[{\textbf{ CBlock\+Index} $\ast$}]{pindex\+Most\+Work}{, }\item[{const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&}]{pblock}{, }\item[{bool \&}]{f\+Invalid\+Found}{, }\item[{\textbf{ Connect\+Trace} \&}]{connect\+Trace}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Return the [start, end] (inclusive) of block heights we can prune.

start $>$ end is possible, meaning no blocks can be pruned.

Try to make some progress towards making pindex\+Most\+Work the active block. pblock is either nullptr or a pointer to a \doxyref{CBlock}{p.}{class_c_block} corresponding to pindex\+Most\+Work.

\begin{DoxyReturn}{Returns}
true unless a system error occurred 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!CanFlushToDisk@{CanFlushToDisk}}
\index{CanFlushToDisk@{CanFlushToDisk}!Chainstate@{Chainstate}}
\doxysubsubsection{CanFlushToDisk()}
{\footnotesize\ttfamily \label{class_chainstate_a0d01ef96f22f8aaf273e8e03d993e30a} 
void Init\+Coins\+Cache(size\+\_\+t cache\+\_\+size\+\_\+bytes) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Can\+Flush\+To\+Disk (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Initialize the in-\/memory coins cache (to be done after the health of the on-\/disk database is verified).

\begin{DoxyReturn}{Returns}
whether or not the \doxyref{Coins\+Views}{p.}{class_coins_views} object has been fully initialized and we can safely flush this object to disk. 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!CheckForkWarningConditions@{CheckForkWarningConditions}}
\index{CheckForkWarningConditions@{CheckForkWarningConditions}!Chainstate@{Chainstate}}
\doxysubsubsection{CheckForkWarningConditions()}
{\footnotesize\ttfamily \label{class_chainstate_a7d3637ae43c319b91b55b43ff1dc0a37} 
void Check\+Fork\+Warning\+Conditions (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\index{Chainstate@{Chainstate}!CoinsDB@{CoinsDB}}
\index{CoinsDB@{CoinsDB}!Chainstate@{Chainstate}}
\doxysubsubsection{CoinsDB()}
{\footnotesize\ttfamily \label{class_chainstate_ad876ac510821396146002e921946e008} 
\textbf{ CCoins\+View\+DB} \& Coins\+DB (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
A reference to the on-\/disk UTXO set database. 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!CoinsErrorCatcher@{CoinsErrorCatcher}}
\index{CoinsErrorCatcher@{CoinsErrorCatcher}!Chainstate@{Chainstate}}
\doxysubsubsection{CoinsErrorCatcher()}
{\footnotesize\ttfamily \label{class_chainstate_aee503ee1391fbb6fba220881c203510a} 
\textbf{ CCoins\+View\+Error\+Catcher} \& Coins\+Error\+Catcher (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
A reference to a wrapped view of the in-\/memory UTXO set that handles disk read errors gracefully. 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!CoinsTip@{CoinsTip}}
\index{CoinsTip@{CoinsTip}!Chainstate@{Chainstate}}
\doxysubsubsection{CoinsTip()}
{\footnotesize\ttfamily \label{class_chainstate_a9dce5b2ccab7cbd5ea485e13491bcdef} 
\textbf{ CCoins\+View\+Cache} \& Coins\+Tip (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
A reference to the in-\/memory cache of the UTXO set. 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!ConnectTip@{ConnectTip}}
\index{ConnectTip@{ConnectTip}!Chainstate@{Chainstate}}
\doxysubsubsection{ConnectTip()}
{\footnotesize\ttfamily \label{class_chainstate_a5d8f3346d9afde7670582ba7270f65c0} 
bool Connect\+Tip (\begin{DoxyParamCaption}\item[{\textbf{ Block\+Validation\+State} \&}]{state}{, }\item[{\textbf{ CBlock\+Index} $\ast$}]{pindex\+New}{, }\item[{std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$}]{block\+\_\+to\+\_\+connect}{, }\item[{\textbf{ Connect\+Trace} \&}]{connect\+Trace}{, }\item[{\textbf{ Disconnected\+Block\+Transactions} \&}]{disconnectpool}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Connect a new block to m\+\_\+chain. block\+\_\+to\+\_\+connect is either nullptr or a pointer to a \doxyref{CBlock}{p.}{class_c_block} corresponding to pindex\+New, to bypass loading it again from disk.

The block is added to connect\+Trace if connection succeeds. \index{Chainstate@{Chainstate}!DisconnectTip@{DisconnectTip}}
\index{DisconnectTip@{DisconnectTip}!Chainstate@{Chainstate}}
\doxysubsubsection{DisconnectTip()}
{\footnotesize\ttfamily \label{class_chainstate_a5286c896c77d30226698c47b3f2dfc33} 
bool Disconnect\+Tip (\begin{DoxyParamCaption}\item[{\textbf{ Block\+Validation\+State} \&}]{state}{, }\item[{\textbf{ Disconnected\+Block\+Transactions} $\ast$}]{disconnectpool}{}\end{DoxyParamCaption})}

Disconnect m\+\_\+chain\textquotesingle{}s tip. After calling, the mempool will be in an inconsistent state, with transactions from disconnected blocks being added to disconnectpool. You should make the mempool consistent again by calling Maybe\+Update\+Mempool\+For\+Reorg. with cs\+\_\+main held.

If disconnectpool is nullptr, then no disconnected transactions are added to disconnectpool (note that the caller is responsible for mempool consistency in any case). \index{Chainstate@{Chainstate}!FindForkInGlobalIndex@{FindForkInGlobalIndex}}
\index{FindForkInGlobalIndex@{FindForkInGlobalIndex}!Chainstate@{Chainstate}}
\doxysubsubsection{FindForkInGlobalIndex()}
{\footnotesize\ttfamily \label{class_chainstate_a06368acc383ffa8737427c7279e7d8ac} 
const \textbf{ CBlock\+Index} $\ast$ Find\+Fork\+In\+Global\+Index (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Locator} \&}]{locator}{}\end{DoxyParamCaption}) const}

Find the last common block of this chain and a locator. \index{Chainstate@{Chainstate}!FindMostWorkChain@{FindMostWorkChain}}
\index{FindMostWorkChain@{FindMostWorkChain}!Chainstate@{Chainstate}}
\doxysubsubsection{FindMostWorkChain()}
{\footnotesize\ttfamily \label{class_chainstate_aa9ca3194eec690da7453dfb54549f554} 
\textbf{ CBlock\+Index} $\ast$ Find\+Most\+Work\+Chain (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Return the tip of the chain with the most work in it, that isn\textquotesingle{}t known to be invalid (it\textquotesingle{}s however far from certain to be valid). \index{Chainstate@{Chainstate}!FlushStateToDisk@{FlushStateToDisk}}
\index{FlushStateToDisk@{FlushStateToDisk}!Chainstate@{Chainstate}}
\doxysubsubsection{FlushStateToDisk()}
{\footnotesize\ttfamily \label{class_chainstate_a0f9f0cdb703638cb9818a9b41158ac6a} 
bool Flush\+State\+To\+Disk (\begin{DoxyParamCaption}\item[{\textbf{ Block\+Validation\+State} \&}]{state}{, }\item[{\textbf{ Flush\+State\+Mode}}]{mode}{, }\item[{int}]{n\+Manual\+Prune\+Height}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

Resize the \doxyref{Coins\+Views}{p.}{class_coins_views} caches dynamically and flush state to disk. \begin{DoxyReturn}{Returns}
true unless an error occurred during the flush. Update the on-\/disk chain state. The caches and indexes are flushed depending on the mode we\textquotesingle{}re called with if they\textquotesingle{}re too large, if it\textquotesingle{}s been a while since the last write, or always and in all cases if we\textquotesingle{}re in prune mode and are deleting files.
\end{DoxyReturn}
If \doxyref{Flush\+State\+Mode\+::\+NONE}{p.}{validation_8h_ab30a99e75e9dc44356d1ad6bdd184ae0ab50339a10e1de285ac99d4c3990b8693} is used, then Flush\+State\+To\+Disk(...) won\textquotesingle{}t do anything besides checking if we need to prune.

\begin{DoxyReturn}{Returns}
true unless a system error occurred 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!ForceFlushStateToDisk@{ForceFlushStateToDisk}}
\index{ForceFlushStateToDisk@{ForceFlushStateToDisk}!Chainstate@{Chainstate}}
\doxysubsubsection{ForceFlushStateToDisk()}
{\footnotesize\ttfamily \label{class_chainstate_a7c77d9ae490826de80fea16e44c5e97f} 
void Force\+Flush\+State\+To\+Disk (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Unconditionally flush all changes to disk. 

\index{Chainstate@{Chainstate}!GetMempool@{GetMempool}}
\index{GetMempool@{GetMempool}!Chainstate@{Chainstate}}
\doxysubsubsection{GetMempool()}
{\footnotesize\ttfamily \label{class_chainstate_ac2dc9bde2175dbfb05382c6e8033db28} 
\textbf{ CTx\+Mem\+Pool} $\ast$ Get\+Mempool (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
A pointer to the mempool. 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!Chainstate@{Chainstate}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \label{class_chainstate_a2252973decf90457e41f70caba718ec0} 
std\+::optional$<$ \textbf{ Assumeutxo\+Hash} $>$ m\+\_\+target\+\_\+utxohash GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

Hash of the UTXO set at the target block, computed when the chainstate reaches the target block, and null before then. \index{Chainstate@{Chainstate}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!Chainstate@{Chainstate}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \label{class_chainstate_a75c70a29f731e16a8a0c7447bac1615a} 
std\+::optional$<$ \textbf{ uint256} $>$ m\+\_\+target\+\_\+blockhash GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

Target block for this chainstate. If this is not set, chainstate will target the most-\/work, valid block. If this is set, \doxyref{Chainstate\+Manager}{p.}{class_chainstate_manager} considers this a "{}historical"{} chainstate since it will only contain old blocks up to the target block, not newer blocks. \index{Chainstate@{Chainstate}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!Chainstate@{Chainstate}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \label{class_chainstate_aaffd71a7e774d677fb4cd31eddd20820} 
\textbf{ Assumeutxo} m\+\_\+assumeutxo GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

\doxyref{Assumeutxo}{p.}{validation_8h_a6b7ed8f1aa31880e0db11fd5d379152d} state indicating whether all blocks in the chain were validated, or if the chainstate is based on an assumeutxo snapshot and the snapshot has not been validated. \index{Chainstate@{Chainstate}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!Chainstate@{Chainstate}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \label{class_chainstate_a034d8773d61b4257a107dac0e83c0bff} 
std\+::optional$<$ const char $\ast$ $>$ m\+\_\+last\+\_\+script\+\_\+check\+\_\+reason\+\_\+logged GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

\index{Chainstate@{Chainstate}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!Chainstate@{Chainstate}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \label{class_chainstate_a1bcb4b2d2398c9de8483f02ef338d0f6} 
const \textbf{ CBlock\+Index} $\ast$m\+\_\+cached\+\_\+target\+\_\+block GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}



Cached result of Lookup\+Block\+Index($\ast$m\+\_\+target\+\_\+blockhash). 

\index{Chainstate@{Chainstate}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!Chainstate@{Chainstate}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \label{class_chainstate_a8aaacc9cef5aac71f39b45631ec5ea74} 
const \textbf{ CBlock\+Index} $\ast$m\+\_\+cached\+\_\+snapshot\+\_\+base GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}



Cached result of Lookup\+Block\+Index($\ast$m\+\_\+from\+\_\+snapshot\+\_\+blockhash). 

\index{Chainstate@{Chainstate}!InitCoinsDB@{InitCoinsDB}}
\index{InitCoinsDB@{InitCoinsDB}!Chainstate@{Chainstate}}
\doxysubsubsection{InitCoinsDB()}
{\footnotesize\ttfamily \label{class_chainstate_a870d55495c6a85e99afda4b4788d77e7} 
void Init\+Coins\+DB (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{cache\+\_\+size\+\_\+bytes}{, }\item[{bool}]{in\+\_\+memory}{, }\item[{bool}]{should\+\_\+wipe}{}\end{DoxyParamCaption})}

Return the current role of the chainstate. See {\ttfamily \doxyref{Chainstate\+Manager}{p.}{class_chainstate_manager}} documentation for a description of the different types of chainstates.

\begin{DoxySeeAlso}{See also}
\doxyref{Chainstate\+Role}{p.}{struct_chainstate_role} Initialize the \doxyref{Coins\+Views}{p.}{class_coins_views} UTXO set database management data structures. The in-\/memory cache is initialized separately.
\end{DoxySeeAlso}
All parameters forwarded to \doxyref{Coins\+Views}{p.}{class_coins_views}. \index{Chainstate@{Chainstate}!InvalidBlockFound@{InvalidBlockFound}}
\index{InvalidBlockFound@{InvalidBlockFound}!Chainstate@{Chainstate}}
\doxysubsubsection{InvalidBlockFound()}
{\footnotesize\ttfamily \label{class_chainstate_a9c5078a4a04331cc35d986500a8b30b1} 
void Invalid\+Block\+Found (\begin{DoxyParamCaption}\item[{\textbf{ CBlock\+Index} $\ast$}]{pindex}{, }\item[{const \textbf{ Block\+Validation\+State} \&}]{state}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\index{Chainstate@{Chainstate}!InvalidChainFound@{InvalidChainFound}}
\index{InvalidChainFound@{InvalidChainFound}!Chainstate@{Chainstate}}
\doxysubsubsection{InvalidChainFound()}
{\footnotesize\ttfamily \label{class_chainstate_acd1f6fc8d7b53d55405ed6107ef693ad} 
void Invalid\+Chain\+Found (\begin{DoxyParamCaption}\item[{\textbf{ CBlock\+Index} $\ast$}]{pindex\+New}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\index{Chainstate@{Chainstate}!LoadChainTip@{LoadChainTip}}
\index{LoadChainTip@{LoadChainTip}!Chainstate@{Chainstate}}
\doxysubsubsection{LoadChainTip()}
{\footnotesize\ttfamily \label{class_chainstate_a1ea13869144ef7ef6c69114ce9834a70} 
bool Load\+Chain\+Tip (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Update the chain tip based on database information, i.\+e. \doxyref{Coins\+Tip()}{p.}{class_chainstate_a9dce5b2ccab7cbd5ea485e13491bcdef}\textquotesingle{}s best block. \index{Chainstate@{Chainstate}!LoadGenesisBlock@{LoadGenesisBlock}}
\index{LoadGenesisBlock@{LoadGenesisBlock}!Chainstate@{Chainstate}}
\doxysubsubsection{LoadGenesisBlock()}
{\footnotesize\ttfamily \label{class_chainstate_a1012305331357fcebb918b4e55b92448} 
bool Load\+Genesis\+Block (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Ensures we have a genesis block in the block tree, possibly writing one to disk. \index{Chainstate@{Chainstate}!MaybeUpdateMempoolForReorg@{MaybeUpdateMempoolForReorg}}
\index{MaybeUpdateMempoolForReorg@{MaybeUpdateMempoolForReorg}!Chainstate@{Chainstate}}
\doxysubsubsection{MaybeUpdateMempoolForReorg()}
{\footnotesize\ttfamily \label{class_chainstate_a6382a5c89f0cc48c00603fdfb6426caa} 
void Maybe\+Update\+Mempool\+For\+Reorg (\begin{DoxyParamCaption}\item[{\textbf{ Disconnected\+Block\+Transactions} \&}]{disconnectpool}{, }\item[{bool}]{f\+Add\+To\+Mempool}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Make mempool consistent after a reorg, by re-\/adding or recursively erasing disconnected block transactions from the mempool, and also removing any other transactions from the mempool that are no longer valid given the new tip/height.

Note\+: we assume that disconnectpool only contains transactions that are NOT confirmed in the current chain nor already in the mempool (otherwise, in-\/mempool descendants of such transactions would be removed).

Passing f\+Add\+To\+Mempool=false will skip trying to add the transactions back, and instead just erase from the mempool as needed. \index{Chainstate@{Chainstate}!MempoolMutex@{MempoolMutex}}
\index{MempoolMutex@{MempoolMutex}!Chainstate@{Chainstate}}
\doxysubsubsection{MempoolMutex()}
{\footnotesize\ttfamily \label{class_chainstate_a52cbd849b01fb79124389f885da05779} 
\textbf{ Coins\+Cache\+Size\+State} Get\+Coins\+Cache\+Size\+State() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Coins\+Cache\+Size\+State} Get\+Coins\+Cache\+Size\+State(size\+\_\+t max\+\_\+coins\+\_\+cache\+\_\+size\+\_\+bytes, size\+\_\+t max\+\_\+mempool\+\_\+size\+\_\+bytes) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::string \textbf{ To\+String}() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Recursive\+Mutex} $\ast$ Mempool\+Mutex (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const-\/$>$\textbf{ cs})\hspace{0.3cm}{\ttfamily [inline]}}



Indirection necessary to make lock annotations work with an optional mempool. 

Dictates whether we need to flush the cache to disk or not.

\begin{DoxyReturn}{Returns}
the state of the size of the coins cache. 
\end{DoxyReturn}
\index{Chainstate@{Chainstate}!NeedsRedownload@{NeedsRedownload}}
\index{NeedsRedownload@{NeedsRedownload}!Chainstate@{Chainstate}}
\doxysubsubsection{NeedsRedownload()}
{\footnotesize\ttfamily \label{class_chainstate_a2e0fcf64c918330f1f0ca3be2a117da2} 
bool Needs\+Redownload (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}}

Whether the chain state needs to be redownloaded due to lack of witness data \index{Chainstate@{Chainstate}!PruneAndFlush@{PruneAndFlush}}
\index{PruneAndFlush@{PruneAndFlush}!Chainstate@{Chainstate}}
\doxysubsubsection{PruneAndFlush()}
{\footnotesize\ttfamily \label{class_chainstate_afccc404d3f648d7834ee7522ca348b41} 
void Prune\+And\+Flush (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Prune blockfiles from the disk if necessary and then flush chainstate changes if we pruned. \index{Chainstate@{Chainstate}!PruneBlockIndexCandidates@{PruneBlockIndexCandidates}}
\index{PruneBlockIndexCandidates@{PruneBlockIndexCandidates}!Chainstate@{Chainstate}}
\doxysubsubsection{PruneBlockIndexCandidates()}
{\footnotesize\ttfamily \label{class_chainstate_ab1a46f0614b890eb2be89745e2526b7c} 
void Prune\+Block\+Index\+Candidates (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Delete all entries in set\+Block\+Index\+Candidates that are worse than the current tip. \index{Chainstate@{Chainstate}!ReplayBlocks@{ReplayBlocks}}
\index{ReplayBlocks@{ReplayBlocks}!Chainstate@{Chainstate}}
\doxysubsubsection{ReplayBlocks()}
{\footnotesize\ttfamily \label{class_chainstate_abfebdf0f5e72069d4dfc2486fc590e08} 
bool Replay\+Blocks (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Replay blocks that aren\textquotesingle{}t fully applied to the database. \index{Chainstate@{Chainstate}!ResetCoinsViews@{ResetCoinsViews}}
\index{ResetCoinsViews@{ResetCoinsViews}!Chainstate@{Chainstate}}
\doxysubsubsection{ResetCoinsViews()}
{\footnotesize\ttfamily \label{class_chainstate_a0ba91dec9c233f4e0deda06285b6bbbe} 
void Reset\+Coins\+Views (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destructs all objects related to accessing the UTXO set. 

\index{Chainstate@{Chainstate}!RollforwardBlock@{RollforwardBlock}}
\index{RollforwardBlock@{RollforwardBlock}!Chainstate@{Chainstate}}
\doxysubsubsection{RollforwardBlock()}
{\footnotesize\ttfamily \label{class_chainstate_a3a178fcf153b41445571e1153d23707c} 
bool Rollforward\+Block (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Index} $\ast$}]{pindex}{, }\item[{\textbf{ CCoins\+View\+Cache} \&}]{inputs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

Apply the effects of a block on the utxo cache, ignoring that it may already have been applied. \index{Chainstate@{Chainstate}!StoragePath@{StoragePath}}
\index{StoragePath@{StoragePath}!Chainstate@{Chainstate}}
\doxysubsubsection{StoragePath()}
{\footnotesize\ttfamily \label{class_chainstate_a4afdb9493bd2ee94b23c7b5dd6c51bbc} 
\textbf{ fs\+::path} Storage\+Path (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Return path to chainstate leveldb directory. 

\index{Chainstate@{Chainstate}!TryAddBlockIndexCandidate@{TryAddBlockIndexCandidate}}
\index{TryAddBlockIndexCandidate@{TryAddBlockIndexCandidate}!Chainstate@{Chainstate}}
\doxysubsubsection{TryAddBlockIndexCandidate()}
{\footnotesize\ttfamily \label{class_chainstate_ab86ef2ab974ae064997b910e161c4849} 
void Try\+Add\+Block\+Index\+Candidate (\begin{DoxyParamCaption}\item[{\textbf{ CBlock\+Index} $\ast$}]{pindex}{}\end{DoxyParamCaption})}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{Chainstate@{Chainstate}!ChainstateManager@{ChainstateManager}}
\index{ChainstateManager@{ChainstateManager}!Chainstate@{Chainstate}}
\doxysubsubsection{ChainstateManager}
{\footnotesize\ttfamily \label{class_chainstate_a9bdf1e9f55692f36e65e35912baa05b5} 
\textbf{ util\+::\+Result}$<$void$>$ Invalidate\+Coins\+DBOn\+Disk () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( friend \textbf{ Chainstate\+Manager}\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [protected]}}

In case of an invalid snapshot, rename the coins leveldb directory so that it can be examined for issue diagnosis. \index{Chainstate@{Chainstate}!ConnectBlock@{ConnectBlock}}
\index{ConnectBlock@{ConnectBlock}!Chainstate@{Chainstate}}
\doxysubsubsection{ConnectBlock}
{\footnotesize\ttfamily \label{class_chainstate_a0487c7fe4cdc89e309556f86c2988c80} 
bool Connect\+Block}

Find the best known block, and make it the tip of the block chain. The result is either failure or an activated best chain. pblock is either nullptr or a pointer to a block that is already loaded (to avoid loading it again from disk).

Activate\+Best\+Chain is split into steps (see Activate\+Best\+Chain\+Step) so that we avoid holding cs\+\_\+main for an extended period of time; the length of this call may be quite long during reindexing or a substantial reorg.

May not be called with cs\+\_\+main held. May not be called in a validationinterface callback.

Note that if this is called while a snapshot chainstate is active, and if it is called on a validated chainstate whose tip has reached the base block of the snapshot, its execution will take {\itshape MINUTES} while it hashes the UTXO set to verify the assumeutxo value the snapshot was activated with. {\ttfamily \doxyref{cs\+\_\+main}{p.}{cs__main_8cpp_ab88a4b9173207cf250ece7820db1f36d}} will be held during this time.

\begin{DoxyReturn}{Returns}
true unless a system error occurred
\end{DoxyReturn}
Apply the effects of this block (with given index) on the UTXO set represented by coins. Validity checks that depend on the UTXO set are also done; \doxyref{Connect\+Block()}{p.}{class_chainstate_a0487c7fe4cdc89e309556f86c2988c80} can fail if those validity checks fail (among other reasons). \index{Chainstate@{Chainstate}!cs@{cs}}
\index{cs@{cs}!Chainstate@{Chainstate}}
\doxysubsubsection{cs\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_chainstate_ac3ab13da2b6eca22b0e0c031835f12a7} 
void \textbf{ m\+\_\+mempool} cs\hspace{0.3cm}{\ttfamily [protected]}}

\index{Chainstate@{Chainstate}!cs@{cs}}
\index{cs@{cs}!Chainstate@{Chainstate}}
\doxysubsubsection{cs\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_chainstate_addd1f086c79ae3b4f737851aaa60b861} 
bool \textbf{ m\+\_\+mempool} cs}

\index{Chainstate@{Chainstate}!m\_blockman@{m\_blockman}}
\index{m\_blockman@{m\_blockman}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_blockman}
{\footnotesize\ttfamily \label{class_chainstate_ae4a76e5b8e269dba63add5f28146fbee} 
\textbf{ node\+::\+Block\+Manager}\& m\+\_\+blockman}

Reference to a \doxyref{Block\+Manager}{p.}{class_block_manager} instance which itself is shared across all \doxyref{Chainstate}{p.}{class_chainstate} instances. \index{Chainstate@{Chainstate}!m\_chain@{m\_chain}}
\index{m\_chain@{m\_chain}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_chain}
{\footnotesize\ttfamily \label{class_chainstate_ad041fc477f2d0f0774b264bf6f371810} 
\textbf{ CChain} m\+\_\+chain}

The current chain of blockheaders we consult and build on. \begin{DoxySeeAlso}{See also}
\doxyref{CChain}{p.}{class_c_chain}, \doxyref{CBlock\+Index}{p.}{class_c_block_index}. 
\end{DoxySeeAlso}
\index{Chainstate@{Chainstate}!m\_chainman@{m\_chainman}}
\index{m\_chainman@{m\_chainman}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_chainman}
{\footnotesize\ttfamily \label{class_chainstate_a849eb656e60bb05783801b88ea02c020} 
\textbf{ Chainstate\+Manager}\& m\+\_\+chainman}

The chainstate manager that owns this chainstate. The reference is necessary so that this instance can check whether it is the active chainstate within deeply nested method calls. \index{Chainstate@{Chainstate}!m\_chainstate\_mutex@{m\_chainstate\_mutex}}
\index{m\_chainstate\_mutex@{m\_chainstate\_mutex}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_chainstate\_mutex}
{\footnotesize\ttfamily \label{class_chainstate_a395a52bbdb9bd9589970a6b5c574eb1e} 
\textbf{ Mutex} m\+\_\+chainstate\+\_\+mutex\hspace{0.3cm}{\ttfamily [protected]}}

The Chain\+State \doxyref{Mutex}{p.}{sync_8h_a326d1d46ce05b5316d8ebe2694a10a6e} A lock that must be held when modifying this Chain\+State -\/ held in Activate\+Best\+Chain() and \doxyref{Invalidate\+Block()}{p.}{blockchain_8cpp_a71686ebfe61025c0c683b6658b7e0def} \index{Chainstate@{Chainstate}!m\_coins\_views@{m\_coins\_views}}
\index{m\_coins\_views@{m\_coins\_views}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_coins\_views}
{\footnotesize\ttfamily \label{class_chainstate_a33c67fb1b900add3e05efd125faaae85} 
std\+::unique\+\_\+ptr$<$\textbf{ Coins\+Views}$>$ m\+\_\+coins\+\_\+views\hspace{0.3cm}{\ttfamily [protected]}}



Manages the UTXO set, which is a reflection of the contents of {\ttfamily \doxyref{m\+\_\+chain}{p.}{class_chainstate_ad041fc477f2d0f0774b264bf6f371810}}. 

\index{Chainstate@{Chainstate}!m\_coinsdb\_cache\_size\_bytes@{m\_coinsdb\_cache\_size\_bytes}}
\index{m\_coinsdb\_cache\_size\_bytes@{m\_coinsdb\_cache\_size\_bytes}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_coinsdb\_cache\_size\_bytes}
{\footnotesize\ttfamily \label{class_chainstate_a209fef4fed4aee7188492631ecc6a782} 
size\+\_\+t m\+\_\+coinsdb\+\_\+cache\+\_\+size\+\_\+bytes \{0\}}



The cache size of the on-\/disk coins view. 

\index{Chainstate@{Chainstate}!m\_coinstip\_cache\_size\_bytes@{m\_coinstip\_cache\_size\_bytes}}
\index{m\_coinstip\_cache\_size\_bytes@{m\_coinstip\_cache\_size\_bytes}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_coinstip\_cache\_size\_bytes}
{\footnotesize\ttfamily \label{class_chainstate_a9f27f82f81429b6be783bb2ba38a7383} 
size\+\_\+t m\+\_\+coinstip\+\_\+cache\+\_\+size\+\_\+bytes \{0\}}



The cache size of the in-\/memory coins view. 

\index{Chainstate@{Chainstate}!m\_from\_snapshot\_blockhash@{m\_from\_snapshot\_blockhash}}
\index{m\_from\_snapshot\_blockhash@{m\_from\_snapshot\_blockhash}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_from\_snapshot\_blockhash}
{\footnotesize\ttfamily \label{class_chainstate_a37f0e70024a7d2d694ae27d34609de0e} 
const std\+::optional$<$\textbf{ uint256}$>$ m\+\_\+from\+\_\+snapshot\+\_\+blockhash}

The blockhash which is the base of the snapshot this chainstate was created from.

std\+::nullopt if this chainstate was not created from a snapshot. \index{Chainstate@{Chainstate}!m\_mempool@{m\_mempool}}
\index{m\_mempool@{m\_mempool}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_mempool}
{\footnotesize\ttfamily \label{class_chainstate_a0391c777447c32c2e0d8cfc900a822ca} 
\textbf{ CTx\+Mem\+Pool}$\ast$ m\+\_\+mempool\hspace{0.3cm}{\ttfamily [protected]}}

Optional mempool that is kept in sync with the chain. Only the active chainstate has a mempool. \index{Chainstate@{Chainstate}!m\_next\_write@{m\_next\_write}}
\index{m\_next\_write@{m\_next\_write}!Chainstate@{Chainstate}}
\doxysubsubsection{m\_next\_write}
{\footnotesize\ttfamily \label{class_chainstate_abb0a9547287e409bbd307dd312b87651} 
void Update\+Tip (const \textbf{ CBlock\+Index}$\ast$ pindex\+New) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( Node\+Clock\+::time\+\_\+poin m\+\_\+next\+\_\+write)  \{Node\+Clock\+::time\+\_\+point\+::max()\}\hspace{0.3cm}{\ttfamily [protected]}}

Check warning conditions and do some notifications on new chain tip set. \index{Chainstate@{Chainstate}!ReachedTarget@{ReachedTarget}}
\index{ReachedTarget@{ReachedTarget}!Chainstate@{Chainstate}}
\doxysubsubsection{ReachedTarget}
{\footnotesize\ttfamily \label{class_chainstate_a13f930c315cbf69ccbac5e6187ea5150} 
const \textbf{ CBlock\+Index} $\ast$Snapshot\+Base() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(const \textbf{ CBlock\+Index} $\ast$Target\+Block() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Set\+Target\+Block(\textbf{ CBlock\+Index} $\ast$block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Set\+Target\+Block\+Hash(\textbf{ uint256} block\+\_\+hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(boo Reached\+Target) () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\hspace{0.3cm}{\ttfamily [inline]}}



Return true if chainstate reached target block. 

The base of the snapshot this chainstate was created from.

nullptr if this chainstate was not created from a snapshot.

Return target block which chainstate tip is expected to reach, if this is a historic chainstate being used to validate a snapshot, or null if chainstate targets the most-\/work block.

Set target block for this chainstate. If null, chainstate will target the most-\/work valid block. If non-\/null chainstate will be a historic chainstate and target the specified block.

Set target block for this chainstate using just a block hash. Useful when the block database has not been loaded yet. \index{Chainstate@{Chainstate}!ResetBlockFailureFlags@{ResetBlockFailureFlags}}
\index{ResetBlockFailureFlags@{ResetBlockFailureFlags}!Chainstate@{Chainstate}}
\doxysubsubsection{ResetBlockFailureFlags}
{\footnotesize\ttfamily \label{class_chainstate_aaa64fbfbe0e25889388c2782592a42ba} 
void Reset\+Block\+Failure\+Flags}

Mark a block as precious and reorganize.

May not be called in a validationinterface callback. Mark a block as invalid. Set invalidity status to all descendants of a block Remove invalidity status from a block, its descendants and ancestors and reconsider them for activation \index{Chainstate@{Chainstate}!setBlockIndexCandidates@{setBlockIndexCandidates}}
\index{setBlockIndexCandidates@{setBlockIndexCandidates}!Chainstate@{Chainstate}}
\doxysubsubsection{setBlockIndexCandidates}
{\footnotesize\ttfamily \label{class_chainstate_ab431e79e9a33a0a82cc611f3f8684917} 
std\+::set$<$\textbf{ CBlock\+Index}$\ast$, \textbf{ node\+::\+CBlock\+Index\+Work\+Comparator}$>$ set\+Block\+Index\+Candidates}

The set of all \doxyref{CBlock\+Index}{p.}{class_c_block_index} entries that have as much work as our current tip or more, and transaction data needed to be validated (with BLOCK\+\_\+\+VALID\+\_\+\+TRANSACTIONS for each block and its parents back to the genesis block or an assumeutxo snapshot block). Entries may be failed, though, and pruning nodes may be missing the data for the block. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ validation.\+h}\item 
src/\textbf{ validation.\+cpp}\end{DoxyCompactItemize}
