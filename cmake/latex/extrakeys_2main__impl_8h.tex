\doxysection{src/secp256k1/src/modules/extrakeys/main\+\_\+impl.h File Reference}
\label{extrakeys_2main__impl_8h}\index{src/secp256k1/src/modules/extrakeys/main\_impl.h@{src/secp256k1/src/modules/extrakeys/main\_impl.h}}
{\ttfamily \#include "{}../../../include/secp256k1.\+h"{}}\newline
{\ttfamily \#include "{}../../../include/secp256k1\+\_\+extrakeys.\+h"{}}\newline
{\ttfamily \#include "{}../../util.\+h"{}}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+parse} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey, const unsigned char $\ast$input32)
\item 
int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+serialize} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$output32, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey)
\item 
int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+cmp} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pk0, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pk1)
\item 
int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$xonly\+\_\+pubkey, int $\ast$pk\+\_\+parity, const \textbf{ secp256k1\+\_\+pubkey} $\ast$pubkey)
\item 
int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$output\+\_\+pubkey, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$internal\+\_\+pubkey, const unsigned char $\ast$tweak32)
\item 
int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add\+\_\+check} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, const unsigned char $\ast$tweaked\+\_\+pubkey32, int tweaked\+\_\+pk\+\_\+parity, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$internal\+\_\+pubkey, const unsigned char $\ast$tweak32)
\item 
int \textbf{ secp256k1\+\_\+keypair\+\_\+create} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, const unsigned char $\ast$seckey32)
\item 
int \textbf{ secp256k1\+\_\+keypair\+\_\+sec} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$seckey, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair)
\item 
int \textbf{ secp256k1\+\_\+keypair\+\_\+pub} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$pubkey, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair)
\item 
int \textbf{ secp256k1\+\_\+keypair\+\_\+xonly\+\_\+pub} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey, int $\ast$pk\+\_\+parity, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair)
\item 
int \textbf{ secp256k1\+\_\+keypair\+\_\+xonly\+\_\+tweak\+\_\+add} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, const unsigned char $\ast$tweak32)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{main\_impl.h@{main\_impl.h}!secp256k1\_keypair\_create@{secp256k1\_keypair\_create}}
\index{secp256k1\_keypair\_create@{secp256k1\_keypair\_create}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_keypair\_create()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a0b67a64a755a308e1777e6c2bde4f57b} 
int secp256k1\+\_\+keypair\+\_\+create (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{const unsigned char $\ast$}]{seckey}{}\end{DoxyParamCaption})}

Compute the keypair for a valid secret key.

See the documentation of {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify}{p.}{secp256k1_8h_a366f922fc0c787351e82ff8e3a95f652}} for more information about the validity of secret keys.

Returns\+: 1\+: secret key is valid 0\+: secret key is invalid Args\+: ctx\+: pointer to a context object (not secp256k1\+\_\+context\+\_\+static). Out\+: keypair\+: pointer to the created keypair. In\+: seckey\+: pointer to a 32-\/byte secret key. \index{main\_impl.h@{main\_impl.h}!secp256k1\_keypair\_pub@{secp256k1\_keypair\_pub}}
\index{secp256k1\_keypair\_pub@{secp256k1\_keypair\_pub}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_keypair\_pub()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_ac5836773627908038f7ae3ce78eb12da} 
int secp256k1\+\_\+keypair\+\_\+pub (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{}\end{DoxyParamCaption})}

Get the public key from a keypair.

Returns\+: 1 always. Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to a pubkey object, set to the keypair public key. In\+: keypair\+: pointer to a keypair. \index{main\_impl.h@{main\_impl.h}!secp256k1\_keypair\_sec@{secp256k1\_keypair\_sec}}
\index{secp256k1\_keypair\_sec@{secp256k1\_keypair\_sec}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_keypair\_sec()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a2f1110f6ff6c80818d31b3961e6d3d41} 
int secp256k1\+\_\+keypair\+\_\+sec (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{seckey}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{}\end{DoxyParamCaption})}

Get the secret key from a keypair.

Returns\+: 1 always. Args\+: ctx\+: pointer to a context object. Out\+: seckey\+: pointer to a 32-\/byte buffer for the secret key. In\+: keypair\+: pointer to a keypair. \index{main\_impl.h@{main\_impl.h}!secp256k1\_keypair\_xonly\_pub@{secp256k1\_keypair\_xonly\_pub}}
\index{secp256k1\_keypair\_xonly\_pub@{secp256k1\_keypair\_xonly\_pub}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_keypair\_xonly\_pub()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a5ef5543ae89fd59edea43c13cad73cfb} 
int secp256k1\+\_\+keypair\+\_\+xonly\+\_\+pub (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{int $\ast$}]{pk\+\_\+parity}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{}\end{DoxyParamCaption})}

Get the x-\/only public key from a keypair.

This is the same as calling secp256k1\+\_\+keypair\+\_\+pub and then secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey.

Returns\+: 1 always. Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to an xonly\+\_\+pubkey object, set to the keypair public key after converting it to an xonly\+\_\+pubkey. pk\+\_\+parity\+: Ignored if NULL. Otherwise, pointer to an integer that will be set to the pk\+\_\+parity argument of secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey. In\+: keypair\+: pointer to a keypair. \index{main\_impl.h@{main\_impl.h}!secp256k1\_keypair\_xonly\_tweak\_add@{secp256k1\_keypair\_xonly\_tweak\_add}}
\index{secp256k1\_keypair\_xonly\_tweak\_add@{secp256k1\_keypair\_xonly\_tweak\_add}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_keypair\_xonly\_tweak\_add()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a1534dc2e974d8debf0a2a361b57fba27} 
int secp256k1\+\_\+keypair\+\_\+xonly\+\_\+tweak\+\_\+add (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Tweak a keypair by adding tweak32 to the secret key and updating the public key accordingly.

Calling this function and then secp256k1\+\_\+keypair\+\_\+pub results in the same public key as calling secp256k1\+\_\+keypair\+\_\+xonly\+\_\+pub and then secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add.

Returns\+: 0 if the arguments are invalid or the resulting keypair would be invalid (only when the tweak is the negation of the keypair\textquotesingle{}s secret key). 1 otherwise.

Args\+: ctx\+: pointer to a context object. In/\+Out\+: keypair\+: pointer to a keypair to apply the tweak to. Will be set to an invalid value if this function returns 0. In\+: tweak32\+: pointer to a 32-\/byte tweak, which must be valid according to secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify or 32 zero bytes. For uniformly random 32-\/byte tweaks, the chance of being invalid is negligible (around 1 in 2$^\wedge$128). \index{main\_impl.h@{main\_impl.h}!secp256k1\_xonly\_pubkey\_cmp@{secp256k1\_xonly\_pubkey\_cmp}}
\index{secp256k1\_xonly\_pubkey\_cmp@{secp256k1\_xonly\_pubkey\_cmp}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_cmp()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_af8b4c7998e5f0584b4a4f6b8f740de8b} 
int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+cmp (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pk1}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pk2}{}\end{DoxyParamCaption})}

Compare two x-\/only public keys using lexicographic order

Returns\+: $<$0 if the first public key is less than the second $>$0 if the first public key is greater than the second 0 if the two public keys are equal Args\+: ctx\+: pointer to a context object. In\+: pubkey1\+: first public key to compare pubkey2\+: second public key to compare \index{main\_impl.h@{main\_impl.h}!secp256k1\_xonly\_pubkey\_from\_pubkey@{secp256k1\_xonly\_pubkey\_from\_pubkey}}
\index{secp256k1\_xonly\_pubkey\_from\_pubkey@{secp256k1\_xonly\_pubkey\_from\_pubkey}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_from\_pubkey()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a93b2eb2b61d3df951aa9115234b36faa} 
int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{xonly\+\_\+pubkey}{, }\item[{int $\ast$}]{pk\+\_\+parity}{, }\item[{const \textbf{ secp256k1\+\_\+pubkey} $\ast$}]{pubkey}{}\end{DoxyParamCaption})}

Converts a \doxyref{secp256k1\+\_\+pubkey}{p.}{structsecp256k1__pubkey} into a \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey}.

Returns\+: 1 always.

Args\+: ctx\+: pointer to a context object. Out\+: xonly\+\_\+pubkey\+: pointer to an x-\/only public key object for placing the converted public key. pk\+\_\+parity\+: Ignored if NULL. Otherwise, pointer to an integer that will be set to 1 if the point encoded by xonly\+\_\+pubkey is the negation of the pubkey and set to 0 otherwise. In\+: pubkey\+: pointer to a public key that is converted. \index{main\_impl.h@{main\_impl.h}!secp256k1\_xonly\_pubkey\_parse@{secp256k1\_xonly\_pubkey\_parse}}
\index{secp256k1\_xonly\_pubkey\_parse@{secp256k1\_xonly\_pubkey\_parse}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_parse()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_ad13aa30c6a14103321a6467918965b16} 
int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+parse (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{const unsigned char $\ast$}]{input32}{}\end{DoxyParamCaption})}

Parse a 32-\/byte sequence into a xonly\+\_\+pubkey object.

Returns\+: 1 if the public key was fully valid. 0 if the public key could not be parsed or is invalid.

Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to a pubkey object. If 1 is returned, it is set to a parsed version of input. If not, it\textquotesingle{}s set to an invalid value. In\+: input32\+: pointer to a serialized xonly\+\_\+pubkey. \index{main\_impl.h@{main\_impl.h}!secp256k1\_xonly\_pubkey\_serialize@{secp256k1\_xonly\_pubkey\_serialize}}
\index{secp256k1\_xonly\_pubkey\_serialize@{secp256k1\_xonly\_pubkey\_serialize}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_serialize()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a29339d5ba3db7c60337c8e7fab89c31a} 
int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+serialize (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{output32}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{}\end{DoxyParamCaption})}

Serialize an xonly\+\_\+pubkey object into a 32-\/byte sequence.

Returns\+: 1 always.

Args\+: ctx\+: pointer to a context object. Out\+: output32\+: pointer to a 32-\/byte array to place the serialized key in. In\+: pubkey\+: pointer to a \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey} containing an initialized public key. \index{main\_impl.h@{main\_impl.h}!secp256k1\_xonly\_pubkey\_tweak\_add@{secp256k1\_xonly\_pubkey\_tweak\_add}}
\index{secp256k1\_xonly\_pubkey\_tweak\_add@{secp256k1\_xonly\_pubkey\_tweak\_add}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_tweak\_add()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a23b0b9f1c39ddb8eae5cd9c4116d0d12} 
int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{output\+\_\+pubkey}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{internal\+\_\+pubkey}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Tweak an x-\/only public key by adding the generator multiplied with tweak32 to it.

Note that the resulting point can not in general be represented by an x-\/only pubkey because it may have an odd Y coordinate. Instead, the output\+\_\+pubkey is a normal \doxyref{secp256k1\+\_\+pubkey}{p.}{structsecp256k1__pubkey}.

Returns\+: 0 if the arguments are invalid or the resulting public key would be invalid (only when the tweak is the negation of the corresponding secret key). 1 otherwise.

Args\+: ctx\+: pointer to a context object. Out\+: output\+\_\+pubkey\+: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. In\+: internal\+\_\+pubkey\+: pointer to an x-\/only pubkey to apply the tweak to. tweak32\+: pointer to a 32-\/byte tweak, which must be valid according to secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify or 32 zero bytes. For uniformly random 32-\/byte tweaks, the chance of being invalid is negligible (around 1 in 2$^\wedge$128). \index{main\_impl.h@{main\_impl.h}!secp256k1\_xonly\_pubkey\_tweak\_add\_check@{secp256k1\_xonly\_pubkey\_tweak\_add\_check}}
\index{secp256k1\_xonly\_pubkey\_tweak\_add\_check@{secp256k1\_xonly\_pubkey\_tweak\_add\_check}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_tweak\_add\_check()}
{\footnotesize\ttfamily \label{extrakeys_2main__impl_8h_a2116028e77999db9ce453655ba391cb9} 
int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add\+\_\+check (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{const unsigned char $\ast$}]{tweaked\+\_\+pubkey32}{, }\item[{int}]{tweaked\+\_\+pk\+\_\+parity}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{internal\+\_\+pubkey}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Checks that a tweaked pubkey is the result of calling secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add with internal\+\_\+pubkey and tweak32.

The tweaked pubkey is represented by its 32-\/byte x-\/only serialization and its pk\+\_\+parity, which can both be obtained by converting the result of tweak\+\_\+add to a \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey}.

Note that this alone does {\itshape not} verify that the tweaked pubkey is a commitment. If the tweak is not chosen in a specific way, the tweaked pubkey can easily be the result of a different internal\+\_\+pubkey and tweak.

Returns\+: 0 if the arguments are invalid or the tweaked pubkey is not the result of tweaking the internal\+\_\+pubkey with tweak32. 1 otherwise. Args\+: ctx\+: pointer to a context object. In\+: tweaked\+\_\+pubkey32\+: pointer to a serialized xonly\+\_\+pubkey. tweaked\+\_\+pk\+\_\+parity\+: the parity of the tweaked pubkey (whose serialization is passed in as tweaked\+\_\+pubkey32). This must match the pk\+\_\+parity value that is returned when calling \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey} with the tweaked pubkey, or this function will fail. internal\+\_\+pubkey\+: pointer to an x-\/only public key object to apply the tweak to. tweak32\+: pointer to a 32-\/byte tweak. 