\doxysection{src/coins.h File Reference}
\label{coins_8h}\index{src/coins.h@{src/coins.h}}
{\ttfamily \#include $<$compressor.\+h$>$}\newline
{\ttfamily \#include $<$core\+\_\+memusage.\+h$>$}\newline
{\ttfamily \#include $<$memusage.\+h$>$}\newline
{\ttfamily \#include $<$primitives/transaction.\+h$>$}\newline
{\ttfamily \#include $<$serialize.\+h$>$}\newline
{\ttfamily \#include $<$support/allocators/pool.\+h$>$}\newline
{\ttfamily \#include $<$uint256.\+h$>$}\newline
{\ttfamily \#include $<$util/check.\+h$>$}\newline
{\ttfamily \#include $<$util/hasher.\+h$>$}\newline
{\ttfamily \#include $<$cassert$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$functional$>$}\newline
{\ttfamily \#include $<$unordered\+\_\+map$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Coin}
\item 
struct \textbf{ CCoins\+Cache\+Entry}
\item 
class \textbf{ CCoins\+View\+Cursor}
\item 
struct \textbf{ Coins\+View\+Cache\+Cursor}
\item 
class \textbf{ CCoins\+View}
\item 
class \textbf{ CCoins\+View\+Backed}
\item 
class \textbf{ CCoins\+View\+Cache}
\item 
class \textbf{ CCoins\+View\+Error\+Catcher}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Coins\+Cache\+Pair} = std\+::pair$<$const \textbf{ COut\+Point}, \textbf{ CCoins\+Cache\+Entry}$>$
\item 
using \textbf{ CCoins\+Map}
\item 
using \textbf{ CCoins\+Map\+Memory\+Resource} = CCoins\+Map\+::allocator\+\_\+type\+::\+Resource\+Type
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Add\+Coins} (\textbf{ CCoins\+View\+Cache} \&cache, const \textbf{ CTransaction} \&tx, int \textbf{ n\+Height}, bool check=false)
\item 
const \textbf{ Coin} \& \textbf{ Access\+By\+Txid} (const \textbf{ CCoins\+View\+Cache} \&cache, const \textbf{ Txid} \&txid)
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{coins.h@{coins.h}!CCoinsMap@{CCoinsMap}}
\index{CCoinsMap@{CCoinsMap}!coins.h@{coins.h}}
\doxysubsubsection{CCoinsMap}
{\footnotesize\ttfamily \label{coins_8h_abb6c00f4f94a3084a430d1848fed7697} 
using \textbf{ CCoins\+Map}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::unordered\_map<COutPoint,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CCoinsCacheEntry,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SaltedOutpointHasher,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::equal\_to<COutPoint>,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ PoolAllocator<CoinsCachePair,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{sizeof}(CoinsCachePair)\ +\ \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{void}*)\ *\ 4>>}

\end{DoxyCode}
\doxyref{Pool\+Allocator}{p.}{class_pool_allocator}\textquotesingle{}s MAX\+\_\+\+BLOCK\+\_\+\+SIZE\+\_\+\+BYTES parameter here uses sizeof the data, and adds the size of 4 pointers. We do not know the exact node size used in the std\+::unordered\+\_\+node implementation because it is implementation defined. Most implementations have an overhead of 1 or 2 pointers, so nodes can be connected in a linked list, and in some cases the hash value is stored as well. Using an additional sizeof(void$\ast$)$\ast$4 for MAX\+\_\+\+BLOCK\+\_\+\+SIZE\+\_\+\+BYTES should thus be sufficient so that all implementations can allocate the nodes from the \doxyref{Pool\+Allocator}{p.}{class_pool_allocator}. \index{coins.h@{coins.h}!CCoinsMapMemoryResource@{CCoinsMapMemoryResource}}
\index{CCoinsMapMemoryResource@{CCoinsMapMemoryResource}!coins.h@{coins.h}}
\doxysubsubsection{CCoinsMapMemoryResource}
{\footnotesize\ttfamily \label{coins_8h_ad512438d571689179e69cf922c01bcc8} 
using \textbf{ CCoins\+Map\+Memory\+Resource} = CCoins\+Map\+::allocator\+\_\+type\+::\+Resource\+Type}

\index{coins.h@{coins.h}!CoinsCachePair@{CoinsCachePair}}
\index{CoinsCachePair@{CoinsCachePair}!coins.h@{coins.h}}
\doxysubsubsection{CoinsCachePair}
{\footnotesize\ttfamily \label{coins_8h_a4f73235f01457f00d91f656dffdb6235} 
using \textbf{ Coins\+Cache\+Pair} = std\+::pair$<$const \textbf{ COut\+Point}, \textbf{ CCoins\+Cache\+Entry}$>$}



\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{coins.h@{coins.h}!AccessByTxid@{AccessByTxid}}
\index{AccessByTxid@{AccessByTxid}!coins.h@{coins.h}}
\doxysubsubsection{AccessByTxid()}
{\footnotesize\ttfamily \label{coins_8h_aa7a3b70bc84ca569a0d03183bcb94ea0} 
const \textbf{ Coin} \& Access\+By\+Txid (\begin{DoxyParamCaption}\item[{const \textbf{ CCoins\+View\+Cache} \&}]{cache}{, }\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption})}

Utility function to find any unspent output with a given txid. This function can be quite expensive because in the event of a transaction which is not found in the cache, it can cause up to MAX\+\_\+\+OUTPUTS\+\_\+\+PER\+\_\+\+BLOCK lookups to database, so it should be used with care. \index{coins.h@{coins.h}!AddCoins@{AddCoins}}
\index{AddCoins@{AddCoins}!coins.h@{coins.h}}
\doxysubsubsection{AddCoins()}
{\footnotesize\ttfamily \label{coins_8h_a3ab3ef128100cf9afb171a00bd8728ee} 
void Add\+Coins (\begin{DoxyParamCaption}\item[{\textbf{ CCoins\+View\+Cache} \&}]{cache}{, }\item[{const \textbf{ CTransaction} \&}]{tx}{, }\item[{int}]{n\+Height}{, }\item[{bool}]{check}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Utility function to add all of a transaction\textquotesingle{}s outputs to a cache. When check is false, this assumes that overwrites are only possible for coinbase transactions. When check is true, the underlying view may be queried to determine whether an addition is an overwrite. 