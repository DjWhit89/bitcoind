\doxysection{Chain Class Reference}
\label{classinterfaces_1_1_chain}\index{Chain@{Chain}}


{\ttfamily \#include $<$chain.\+h$>$}

\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Notifications}
\begin{DoxyCompactList}\small\item\em \doxyref{Chain}{p.}{classinterfaces_1_1_chain} notifications. \end{DoxyCompactList}\item 
struct \textbf{ Notify\+Options}
\begin{DoxyCompactList}\small\item\em \doxyref{Options}{p.}{struct_options} specifying which chain notifications are required. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+Chain} ()=default
\item 
virtual std\+::optional$<$ int $>$ \textbf{ get\+Height} ()=0
\item 
virtual \textbf{ uint256} \textbf{ get\+Block\+Hash} (int height)=0
\begin{DoxyCompactList}\small\item\em Get block hash. Height must be valid or this function will abort. \end{DoxyCompactList}\item 
virtual bool \textbf{ have\+Block\+On\+Disk} (int height)=0
\item 
virtual std\+::optional$<$ int $>$ \textbf{ find\+Locator\+Fork} (const \textbf{ CBlock\+Locator} \&locator)=0
\item 
virtual bool \textbf{ has\+Block\+Filter\+Index} (\textbf{ Block\+Filter\+Type} filter\+\_\+type)=0
\begin{DoxyCompactList}\small\item\em Returns whether a block filter index is available. \end{DoxyCompactList}\item 
virtual std\+::optional$<$ bool $>$ \textbf{ block\+Filter\+Matches\+Any} (\textbf{ Block\+Filter\+Type} filter\+\_\+type, const \textbf{ uint256} \&block\+\_\+hash, const \textbf{ GCSFilter\+::\+Element\+Set} \&filter\+\_\+set)=0
\item 
virtual bool \textbf{ find\+Block} (const \textbf{ uint256} \&hash, const \textbf{ Found\+Block} \&block=\{\})=0
\item 
virtual bool \textbf{ find\+First\+Block\+With\+Time\+And\+Height} (int64\+\_\+t min\+\_\+time, int min\+\_\+height, const \textbf{ Found\+Block} \&block=\{\})=0
\item 
virtual bool \textbf{ find\+Ancestor\+By\+Height} (const \textbf{ uint256} \&block\+\_\+hash, int ancestor\+\_\+height, const \textbf{ Found\+Block} \&ancestor\+\_\+out=\{\})=0
\item 
virtual bool \textbf{ find\+Ancestor\+By\+Hash} (const \textbf{ uint256} \&block\+\_\+hash, const \textbf{ uint256} \&ancestor\+\_\+hash, const \textbf{ Found\+Block} \&ancestor\+\_\+out=\{\})=0
\item 
virtual bool \textbf{ find\+Common\+Ancestor} (const \textbf{ uint256} \&block\+\_\+hash1, const \textbf{ uint256} \&block\+\_\+hash2, const \textbf{ Found\+Block} \&ancestor\+\_\+out=\{\}, const \textbf{ Found\+Block} \&block1\+\_\+out=\{\}, const \textbf{ Found\+Block} \&block2\+\_\+out=\{\})=0
\item 
virtual void \textbf{ find\+Coins} (std\+::map$<$ \textbf{ COut\+Point}, \textbf{ Coin} $>$ \&coins)=0
\item 
virtual double \textbf{ guess\+Verification\+Progress} (const \textbf{ uint256} \&block\+\_\+hash)=0
\item 
virtual bool \textbf{ has\+Blocks} (const \textbf{ uint256} \&block\+\_\+hash, int min\+\_\+height=0, std\+::optional$<$ int $>$ max\+\_\+height=\{\})=0
\item 
virtual \textbf{ RBFTransaction\+State} \textbf{ is\+RBFOpt\+In} (const \textbf{ CTransaction} \&tx)=0
\begin{DoxyCompactList}\small\item\em Check if transaction is RBF opt in. \end{DoxyCompactList}\item 
virtual bool \textbf{ is\+In\+Mempool} (const \textbf{ Txid} \&txid)=0
\begin{DoxyCompactList}\small\item\em Check if transaction is in mempool. \end{DoxyCompactList}\item 
virtual bool \textbf{ has\+Descendants\+In\+Mempool} (const \textbf{ Txid} \&txid)=0
\begin{DoxyCompactList}\small\item\em Check if transaction has descendants in mempool. \end{DoxyCompactList}\item 
virtual bool \textbf{ broadcast\+Transaction} (const \textbf{ CTransaction\+Ref} \&tx, const \textbf{ CAmount} \&max\+\_\+tx\+\_\+fee, \textbf{ node\+::\+Tx\+Broadcast} broadcast\+\_\+method, std\+::string \&err\+\_\+string)=0
\item 
virtual void \textbf{ get\+Transaction\+Ancestry} (const \textbf{ Txid} \&txid, size\+\_\+t \&ancestors, size\+\_\+t \&cluster\+\_\+count, size\+\_\+t $\ast$ancestorsize=nullptr, \textbf{ CAmount} $\ast$ancestorfees=nullptr)=0
\begin{DoxyCompactList}\small\item\em Calculate mempool ancestor and cluster counts for the given transaction. \end{DoxyCompactList}\item 
virtual std\+::map$<$ \textbf{ COut\+Point}, \textbf{ CAmount} $>$ \textbf{ calculate\+Individual\+Bump\+Fees} (const std\+::vector$<$ \textbf{ COut\+Point} $>$ \&outpoints, const \textbf{ CFee\+Rate} \&target\+\_\+feerate)=0
\begin{DoxyCompactList}\small\item\em For each outpoint, calculate the fee-\/bumping cost to spend this outpoint at the specified. \end{DoxyCompactList}\item 
virtual std\+::optional$<$ \textbf{ CAmount} $>$ \textbf{ calculate\+Combined\+Bump\+Fee} (const std\+::vector$<$ \textbf{ COut\+Point} $>$ \&outpoints, const \textbf{ CFee\+Rate} \&target\+\_\+feerate)=0
\begin{DoxyCompactList}\small\item\em Calculate the combined bump fee for an input set per the same strategy. \end{DoxyCompactList}\item 
virtual void \textbf{ get\+Package\+Limits} (unsigned int \&limit\+\_\+ancestor\+\_\+count, unsigned int \&limit\+\_\+descendant\+\_\+count)=0
\item 
virtual \textbf{ util\+::\+Result}$<$ void $>$ \textbf{ check\+Chain\+Limits} (const \textbf{ CTransaction\+Ref} \&tx)=0
\begin{DoxyCompactList}\small\item\em Check if transaction will pass the mempool\textquotesingle{}s chain limits. \end{DoxyCompactList}\item 
virtual \textbf{ CFee\+Rate} \textbf{ estimate\+Smart\+Fee} (int num\+\_\+blocks, bool conservative, \textbf{ Fee\+Calculation} $\ast$calc=nullptr)=0
\begin{DoxyCompactList}\small\item\em Estimate smart fee. \end{DoxyCompactList}\item 
virtual unsigned int \textbf{ estimate\+Max\+Blocks} ()=0
\begin{DoxyCompactList}\small\item\em Fee estimator max target. \end{DoxyCompactList}\item 
virtual \textbf{ CFee\+Rate} \textbf{ mempool\+Min\+Fee} ()=0
\begin{DoxyCompactList}\small\item\em Mempool minimum fee. \end{DoxyCompactList}\item 
virtual \textbf{ CFee\+Rate} \textbf{ relay\+Min\+Fee} ()=0
\begin{DoxyCompactList}\small\item\em Relay current minimum fee (from -\/minrelaytxfee and -\/incrementalrelayfee settings). \end{DoxyCompactList}\item 
virtual \textbf{ CFee\+Rate} \textbf{ relay\+Incremental\+Fee} ()=0
\begin{DoxyCompactList}\small\item\em Relay incremental fee setting (-\/incrementalrelayfee), reflecting cost of relay. \end{DoxyCompactList}\item 
virtual \textbf{ CFee\+Rate} \textbf{ relay\+Dust\+Fee} ()=0
\begin{DoxyCompactList}\small\item\em Relay dust fee setting (-\/dustrelayfee), reflecting lowest rate it\textquotesingle{}s economical to spend. \end{DoxyCompactList}\item 
virtual bool \textbf{ have\+Pruned} ()=0
\begin{DoxyCompactList}\small\item\em Check if any block has been pruned. \end{DoxyCompactList}\item 
virtual std\+::optional$<$ int $>$ \textbf{ get\+Prune\+Height} ()=0
\begin{DoxyCompactList}\small\item\em Get the current prune height. \end{DoxyCompactList}\item 
virtual bool \textbf{ is\+Ready\+To\+Broadcast} ()=0
\begin{DoxyCompactList}\small\item\em Check if the node is ready to broadcast transactions. \end{DoxyCompactList}\item 
virtual bool \textbf{ is\+Initial\+Block\+Download} ()=0
\begin{DoxyCompactList}\small\item\em Check if in IBD. \end{DoxyCompactList}\item 
virtual bool \textbf{ shutdown\+Requested} ()=0
\begin{DoxyCompactList}\small\item\em Check if shutdown requested. \end{DoxyCompactList}\item 
virtual void \textbf{ init\+Message} (const std\+::string \&message)=0
\begin{DoxyCompactList}\small\item\em Send init message. \end{DoxyCompactList}\item 
virtual void \textbf{ init\+Warning} (const \textbf{ bilingual\+\_\+str} \&message)=0
\begin{DoxyCompactList}\small\item\em Send init warning. \end{DoxyCompactList}\item 
virtual void \textbf{ init\+Error} (const \textbf{ bilingual\+\_\+str} \&message)=0
\begin{DoxyCompactList}\small\item\em Send init error. \end{DoxyCompactList}\item 
virtual void \textbf{ show\+Progress} (const std\+::string \&title, int progress, bool resume\+\_\+possible)=0
\begin{DoxyCompactList}\small\item\em Send progress indicator. \end{DoxyCompactList}\item 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ Handler} $>$ \textbf{ handle\+Notifications} (std\+::shared\+\_\+ptr$<$ \textbf{ Notifications} $>$ notifications)=0
\begin{DoxyCompactList}\small\item\em Register handler for notifications. \end{DoxyCompactList}\item 
virtual void \textbf{ wait\+For\+Notifications\+If\+Tip\+Changed} (const \textbf{ uint256} \&old\+\_\+tip)=0
\item 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ Handler} $>$ \textbf{ handle\+Rpc} (const \textbf{ CRPCCommand} \&\textbf{ command})=0
\item 
virtual bool \textbf{ rpc\+Enable\+Deprecated} (const std\+::string \&method)=0
\begin{DoxyCompactList}\small\item\em Check if deprecated RPC is enabled. \end{DoxyCompactList}\item 
virtual \textbf{ common\+::\+Settings\+Value} \textbf{ get\+Setting} (const std\+::string \&arg)=0
\begin{DoxyCompactList}\small\item\em Get settings value. \end{DoxyCompactList}\item 
virtual std\+::vector$<$ \textbf{ common\+::\+Settings\+Value} $>$ \textbf{ get\+Settings\+List} (const std\+::string \&arg)=0
\begin{DoxyCompactList}\small\item\em Get list of settings values. \end{DoxyCompactList}\item 
virtual \textbf{ common\+::\+Settings\+Value} \textbf{ get\+Rw\+Setting} (const std\+::string \&\textbf{ name})=0
\begin{DoxyCompactList}\small\item\em Return $<$datadir$>$/settings.json setting value. \end{DoxyCompactList}\item 
virtual bool \textbf{ update\+Rw\+Setting} (const std\+::string \&\textbf{ name}, const \textbf{ Settings\+Update} \&update\+\_\+function)=0
\item 
virtual bool \textbf{ overwrite\+Rw\+Setting} (const std\+::string \&\textbf{ name}, \textbf{ common\+::\+Settings\+Value} value, \textbf{ Settings\+Action} action=\textbf{ Settings\+Action\+::\+WRITE})=0
\item 
virtual bool \textbf{ delete\+Rw\+Settings} (const std\+::string \&\textbf{ name}, \textbf{ Settings\+Action} action=\textbf{ Settings\+Action\+::\+WRITE})=0
\item 
virtual void \textbf{ request\+Mempool\+Transactions} (\textbf{ Notifications} \&notifications)=0
\item 
virtual bool \textbf{ has\+Assumed\+Valid\+Chain} ()=0
\item 
virtual \textbf{ node\+::\+Node\+Context} $\ast$ \textbf{ context} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Interface giving clients (wallet processes, maybe other analysis tools in the future) ability to access to the chain state, receive notifications, estimate fees, and submit transactions.

TODO\+: Current chain methods are too low level, exposing too much of the internal workings of the bitcoin node, and not being very convenient to use. \doxyref{Chain}{p.}{classinterfaces_1_1_chain} methods should be cleaned up and simplified over time. Examples\+:


\begin{DoxyItemize}
\item The init\+Messages() and \doxyref{show\+Progress()}{p.}{classinterfaces_1_1_chain_ab854793852b1f1f3fdaeca07cb6bda15} methods which the wallet uses to send notifications to the GUI should go away when GUI and wallet can directly communicate with each other without going through the node ({\texttt{https\+://github.\+com/bitcoin/bitcoin/pull/15288\#discussion\+\_\+r253321096}}).
\item The handle\+Rpc, register\+Rpcs, rpc\+Enable\+Deprecated methods and other RPC methods can go away if wallets listen for HTTP requests on their own ports instead of registering to handle requests on the node HTTP port.
\item Move fee estimation queries to an asynchronous interface and let the wallet cache it, fee estimation being driven by node mempool, wallet should be the consumer.
\item {\ttfamily \doxyref{guess\+Verification\+Progress}{p.}{classinterfaces_1_1_chain_ad88b6dc0b3a55b2aa1120c3f0a24bb72}} and similar methods can go away if rescan logic moves out of the wallet, and the wallet just requests scans from the node ({\texttt{https\+://github.\+com/bitcoin/bitcoin/issues/11756}}) 
\end{DoxyItemize}

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Chain@{Chain}!````~Chain@{$\sim$Chain}}
\index{````~Chain@{$\sim$Chain}!Chain@{Chain}}
\doxysubsubsection{$\sim$Chain()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a4ddfd37142727ebcc1348854ec948e8d} 
virtual $\sim$\textbf{ Chain} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Chain@{Chain}!blockFilterMatchesAny@{blockFilterMatchesAny}}
\index{blockFilterMatchesAny@{blockFilterMatchesAny}!Chain@{Chain}}
\doxysubsubsection{blockFilterMatchesAny()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a1df79d383669b91c95740098097a71fa} 
virtual std\+::optional$<$ bool $>$ block\+Filter\+Matches\+Any (\begin{DoxyParamCaption}\item[{\textbf{ Block\+Filter\+Type}}]{filter\+\_\+type}{, }\item[{const \textbf{ uint256} \&}]{block\+\_\+hash}{, }\item[{const \textbf{ GCSFilter\+::\+Element\+Set} \&}]{filter\+\_\+set}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Returns whether any of the elements match the block via a BIP 157 block filter or std\+::nullopt if the block filter for this block couldn\textquotesingle{}t be found. \index{Chain@{Chain}!broadcastTransaction@{broadcastTransaction}}
\index{broadcastTransaction@{broadcastTransaction}!Chain@{Chain}}
\doxysubsubsection{broadcastTransaction()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a438c78f40db38c9bc852a22ccdbed590} 
virtual bool broadcast\+Transaction (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction\+Ref} \&}]{tx}{, }\item[{const \textbf{ CAmount} \&}]{max\+\_\+tx\+\_\+fee}{, }\item[{\textbf{ node\+::\+Tx\+Broadcast}}]{broadcast\+\_\+method}{, }\item[{std\+::string \&}]{err\+\_\+string}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Process a local transaction, optionally adding it to the mempool and optionally broadcasting it to the network. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em tx} & Transaction to process. \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+tx\+\_\+fee} & Don\textquotesingle{}t add the transaction to the mempool or broadcast it if its fee is higher than this. \\
\hline
\mbox{\texttt{in}}  & {\em broadcast\+\_\+method} & Whether to add the transaction to the mempool and how/whether to broadcast it. \\
\hline
\mbox{\texttt{out}}  & {\em err\+\_\+string} & Set if an error occurs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
False if the transaction could not be added due to the fee or for another reason. 
\end{DoxyReturn}
\index{Chain@{Chain}!calculateCombinedBumpFee@{calculateCombinedBumpFee}}
\index{calculateCombinedBumpFee@{calculateCombinedBumpFee}!Chain@{Chain}}
\doxysubsubsection{calculateCombinedBumpFee()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ad738113244550a14c60ff00d7957050d} 
virtual std\+::optional$<$ \textbf{ CAmount} $>$ calculate\+Combined\+Bump\+Fee (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ COut\+Point} $>$ \&}]{outpoints}{, }\item[{const \textbf{ CFee\+Rate} \&}]{target\+\_\+feerate}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Calculate the combined bump fee for an input set per the same strategy. 

\index{Chain@{Chain}!calculateIndividualBumpFees@{calculateIndividualBumpFees}}
\index{calculateIndividualBumpFees@{calculateIndividualBumpFees}!Chain@{Chain}}
\doxysubsubsection{calculateIndividualBumpFees()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a4fa322254d0b5e755d4a87323b39c2a8} 
virtual std\+::map$<$ \textbf{ COut\+Point}, \textbf{ CAmount} $>$ calculate\+Individual\+Bump\+Fees (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ COut\+Point} $>$ \&}]{outpoints}{, }\item[{const \textbf{ CFee\+Rate} \&}]{target\+\_\+feerate}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



For each outpoint, calculate the fee-\/bumping cost to spend this outpoint at the specified. 

\index{Chain@{Chain}!checkChainLimits@{checkChainLimits}}
\index{checkChainLimits@{checkChainLimits}!Chain@{Chain}}
\doxysubsubsection{checkChainLimits()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_aed9f6f1aaa132034a7472cbe2a0c2862} 
virtual \textbf{ util\+::\+Result}$<$ void $>$ check\+Chain\+Limits (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction\+Ref} \&}]{tx}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if transaction will pass the mempool\textquotesingle{}s chain limits. 

\index{Chain@{Chain}!context@{context}}
\index{context@{context}!Chain@{Chain}}
\doxysubsubsection{context()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ab6c3517bc6198d0289236eda9353468e} 
virtual \textbf{ node\+::\+Node\+Context} $\ast$ context (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Get internal node context. Useful for testing, but not accessible across processes. \index{Chain@{Chain}!deleteRwSettings@{deleteRwSettings}}
\index{deleteRwSettings@{deleteRwSettings}!Chain@{Chain}}
\doxysubsubsection{deleteRwSettings()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ad7990bec5a11e63c71149e9be4817c1a} 
virtual bool delete\+Rw\+Settings (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name}{, }\item[{\textbf{ Settings\+Action}}]{action}{ = {\ttfamily \textbf{ Settings\+Action\+::\+WRITE}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Delete a given setting in $<$datadir$>$/settings.json. This method provides a simpler alternative to overwrite\+Rw\+Setting when erasing a setting, for ease of use and readability. \index{Chain@{Chain}!estimateMaxBlocks@{estimateMaxBlocks}}
\index{estimateMaxBlocks@{estimateMaxBlocks}!Chain@{Chain}}
\doxysubsubsection{estimateMaxBlocks()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_aaf6594d7773e268b7f07b009904755de} 
virtual unsigned int estimate\+Max\+Blocks (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Fee estimator max target. 

\index{Chain@{Chain}!estimateSmartFee@{estimateSmartFee}}
\index{estimateSmartFee@{estimateSmartFee}!Chain@{Chain}}
\doxysubsubsection{estimateSmartFee()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ac97b43776f0eec98837b9b4ef4359d4e} 
virtual \textbf{ CFee\+Rate} estimate\+Smart\+Fee (\begin{DoxyParamCaption}\item[{int}]{num\+\_\+blocks}{, }\item[{bool}]{conservative}{, }\item[{\textbf{ Fee\+Calculation} $\ast$}]{calc}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Estimate smart fee. 

\index{Chain@{Chain}!findAncestorByHash@{findAncestorByHash}}
\index{findAncestorByHash@{findAncestorByHash}!Chain@{Chain}}
\doxysubsubsection{findAncestorByHash()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ab4c1b5be80d5d5297ea90a47e9857892} 
virtual bool find\+Ancestor\+By\+Hash (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{block\+\_\+hash}{, }\item[{const \textbf{ uint256} \&}]{ancestor\+\_\+hash}{, }\item[{const \textbf{ Found\+Block} \&}]{ancestor\+\_\+out}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Return whether block descends from a specified ancestor, and optionally return ancestor information. \index{Chain@{Chain}!findAncestorByHeight@{findAncestorByHeight}}
\index{findAncestorByHeight@{findAncestorByHeight}!Chain@{Chain}}
\doxysubsubsection{findAncestorByHeight()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a1ed9ccc23e13052bf7a5270842015337} 
virtual bool find\+Ancestor\+By\+Height (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{block\+\_\+hash}{, }\item[{int}]{ancestor\+\_\+height}{, }\item[{const \textbf{ Found\+Block} \&}]{ancestor\+\_\+out}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Find ancestor of block at specified height and optionally return ancestor information. \index{Chain@{Chain}!findBlock@{findBlock}}
\index{findBlock@{findBlock}!Chain@{Chain}}
\doxysubsubsection{findBlock()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ae66d117ee1d2014ddbf93e6aac766775} 
virtual bool find\+Block (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{, }\item[{const \textbf{ Found\+Block} \&}]{block}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Return whether node has the block and optionally return block metadata or contents. \index{Chain@{Chain}!findCoins@{findCoins}}
\index{findCoins@{findCoins}!Chain@{Chain}}
\doxysubsubsection{findCoins()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a4653be016db88024d1739a801128df2f} 
virtual void find\+Coins (\begin{DoxyParamCaption}\item[{std\+::map$<$ \textbf{ COut\+Point}, \textbf{ Coin} $>$ \&}]{coins}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Look up unspent output information. Returns coins in the mempool and in the current chain UTXO set. Iterates through all the keys in the map and populates the values. \index{Chain@{Chain}!findCommonAncestor@{findCommonAncestor}}
\index{findCommonAncestor@{findCommonAncestor}!Chain@{Chain}}
\doxysubsubsection{findCommonAncestor()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a074613b8f218b0cbd06d1a9ddcc8708e} 
virtual bool find\+Common\+Ancestor (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{block\+\_\+hash1}{, }\item[{const \textbf{ uint256} \&}]{block\+\_\+hash2}{, }\item[{const \textbf{ Found\+Block} \&}]{ancestor\+\_\+out}{ = {\ttfamily \{\}}, }\item[{const \textbf{ Found\+Block} \&}]{block1\+\_\+out}{ = {\ttfamily \{\}}, }\item[{const \textbf{ Found\+Block} \&}]{block2\+\_\+out}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Find most recent common ancestor between two blocks and optionally return block information. \index{Chain@{Chain}!findFirstBlockWithTimeAndHeight@{findFirstBlockWithTimeAndHeight}}
\index{findFirstBlockWithTimeAndHeight@{findFirstBlockWithTimeAndHeight}!Chain@{Chain}}
\doxysubsubsection{findFirstBlockWithTimeAndHeight()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_aade4e00bcaf51cadf729c2360c4690ae} 
virtual bool find\+First\+Block\+With\+Time\+And\+Height (\begin{DoxyParamCaption}\item[{int64\+\_\+t}]{min\+\_\+time}{, }\item[{int}]{min\+\_\+height}{, }\item[{const \textbf{ Found\+Block} \&}]{block}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Find first block in the chain with timestamp $>$= the given time and height $>$= than the given height, return false if there is no block with a high enough timestamp and height. Optionally return block information. \index{Chain@{Chain}!findLocatorFork@{findLocatorFork}}
\index{findLocatorFork@{findLocatorFork}!Chain@{Chain}}
\doxysubsubsection{findLocatorFork()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a40ca726a51f9c034e01e84ddf110c6fb} 
virtual std\+::optional$<$ int $>$ find\+Locator\+Fork (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Locator} \&}]{locator}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Return height of the highest block on chain in common with the locator, which will either be the original block used to create the locator, or one of its ancestors. \index{Chain@{Chain}!getBlockHash@{getBlockHash}}
\index{getBlockHash@{getBlockHash}!Chain@{Chain}}
\doxysubsubsection{getBlockHash()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_acea0e891994cbc23684a08a991e0e9bf} 
virtual \textbf{ uint256} get\+Block\+Hash (\begin{DoxyParamCaption}\item[{int}]{height}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get block hash. Height must be valid or this function will abort. 

\index{Chain@{Chain}!getHeight@{getHeight}}
\index{getHeight@{getHeight}!Chain@{Chain}}
\doxysubsubsection{getHeight()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_aa68e13d7ebd0d7c99390db7fddb12464} 
virtual std\+::optional$<$ int $>$ get\+Height (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get current chain height, not including genesis block (returns 0 if chain only contains genesis block, nullopt if chain does not contain any blocks) \index{Chain@{Chain}!getPackageLimits@{getPackageLimits}}
\index{getPackageLimits@{getPackageLimits}!Chain@{Chain}}
\doxysubsubsection{getPackageLimits()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ae787886aac93359148716c797866273d} 
virtual void get\+Package\+Limits (\begin{DoxyParamCaption}\item[{unsigned int \&}]{limit\+\_\+ancestor\+\_\+count}{, }\item[{unsigned int \&}]{limit\+\_\+descendant\+\_\+count}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get the node\textquotesingle{}s package limits. Currently only returns the ancestor and descendant count limits, but could be enhanced to return more policy settings. \index{Chain@{Chain}!getPruneHeight@{getPruneHeight}}
\index{getPruneHeight@{getPruneHeight}!Chain@{Chain}}
\doxysubsubsection{getPruneHeight()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_af43e0f43fa1d3b13bd3aefc0dc1261a7} 
virtual std\+::optional$<$ int $>$ get\+Prune\+Height (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get the current prune height. 

\index{Chain@{Chain}!getRwSetting@{getRwSetting}}
\index{getRwSetting@{getRwSetting}!Chain@{Chain}}
\doxysubsubsection{getRwSetting()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a0373383250377fbff73672712e85c700} 
virtual \textbf{ common\+::\+Settings\+Value} get\+Rw\+Setting (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Return $<$datadir$>$/settings.json setting value. 

\index{Chain@{Chain}!getSetting@{getSetting}}
\index{getSetting@{getSetting}!Chain@{Chain}}
\doxysubsubsection{getSetting()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a5be5022e86c98ecda67e9b4e8d864346} 
virtual \textbf{ common\+::\+Settings\+Value} get\+Setting (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{arg}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get settings value. 

\index{Chain@{Chain}!getSettingsList@{getSettingsList}}
\index{getSettingsList@{getSettingsList}!Chain@{Chain}}
\doxysubsubsection{getSettingsList()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ac1015c874d9a781fbcf5a55f0553b82f} 
virtual std\+::vector$<$ \textbf{ common\+::\+Settings\+Value} $>$ get\+Settings\+List (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{arg}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Get list of settings values. 

\index{Chain@{Chain}!getTransactionAncestry@{getTransactionAncestry}}
\index{getTransactionAncestry@{getTransactionAncestry}!Chain@{Chain}}
\doxysubsubsection{getTransactionAncestry()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a43cc4c340333564b8b45f2a91f1b242a} 
virtual void get\+Transaction\+Ancestry (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{, }\item[{size\+\_\+t \&}]{ancestors}{, }\item[{size\+\_\+t \&}]{cluster\+\_\+count}{, }\item[{size\+\_\+t $\ast$}]{ancestorsize}{ = {\ttfamily nullptr}, }\item[{\textbf{ CAmount} $\ast$}]{ancestorfees}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Calculate mempool ancestor and cluster counts for the given transaction. 

\index{Chain@{Chain}!guessVerificationProgress@{guessVerificationProgress}}
\index{guessVerificationProgress@{guessVerificationProgress}!Chain@{Chain}}
\doxysubsubsection{guessVerificationProgress()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ad88b6dc0b3a55b2aa1120c3f0a24bb72} 
virtual double guess\+Verification\+Progress (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{block\+\_\+hash}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Estimate fraction of total transactions verified if blocks up to the specified block hash are verified. \index{Chain@{Chain}!handleNotifications@{handleNotifications}}
\index{handleNotifications@{handleNotifications}!Chain@{Chain}}
\doxysubsubsection{handleNotifications()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a2d99793b7fec7b60d8f10aacacb5b57e} 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ Handler} $>$ handle\+Notifications (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \textbf{ Notifications} $>$}]{notifications}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Register handler for notifications. 

\index{Chain@{Chain}!handleRpc@{handleRpc}}
\index{handleRpc@{handleRpc}!Chain@{Chain}}
\doxysubsubsection{handleRpc()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a8c4e102a0af9e4b756b8b6c2621d3430} 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ Handler} $>$ handle\+Rpc (\begin{DoxyParamCaption}\item[{const \textbf{ CRPCCommand} \&}]{command}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Register handler for RPC. Command is not copied, so reference needs to remain valid until \doxyref{Handler}{p.}{classinterfaces_1_1_handler} is disconnected. \index{Chain@{Chain}!hasAssumedValidChain@{hasAssumedValidChain}}
\index{hasAssumedValidChain@{hasAssumedValidChain}!Chain@{Chain}}
\doxysubsubsection{hasAssumedValidChain()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a97d60c482f2db36df2ca82db9c1e0697} 
virtual bool has\+Assumed\+Valid\+Chain (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Return true if an assumed-\/valid snapshot is in use. Note that this returns true even after the snapshot is validated, until the next node restart. \index{Chain@{Chain}!hasBlockFilterIndex@{hasBlockFilterIndex}}
\index{hasBlockFilterIndex@{hasBlockFilterIndex}!Chain@{Chain}}
\doxysubsubsection{hasBlockFilterIndex()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a8c8327c210eaaabb6455890927817c6b} 
virtual bool has\+Block\+Filter\+Index (\begin{DoxyParamCaption}\item[{\textbf{ Block\+Filter\+Type}}]{filter\+\_\+type}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Returns whether a block filter index is available. 

\index{Chain@{Chain}!hasBlocks@{hasBlocks}}
\index{hasBlocks@{hasBlocks}!Chain@{Chain}}
\doxysubsubsection{hasBlocks()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_af4a48412505eb7d3fb388793c7390ef6} 
virtual bool has\+Blocks (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{block\+\_\+hash}{, }\item[{int}]{min\+\_\+height}{ = {\ttfamily 0}, }\item[{std\+::optional$<$ int $>$}]{max\+\_\+height}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Return true if data is available for all blocks in the specified range of blocks. This checks all blocks that are ancestors of block\+\_\+hash in the height range from min\+\_\+height to max\+\_\+height, inclusive. \index{Chain@{Chain}!hasDescendantsInMempool@{hasDescendantsInMempool}}
\index{hasDescendantsInMempool@{hasDescendantsInMempool}!Chain@{Chain}}
\doxysubsubsection{hasDescendantsInMempool()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_abba5794bf4acb7bddb5e64ae5efaf1be} 
virtual bool has\+Descendants\+In\+Mempool (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if transaction has descendants in mempool. 

\index{Chain@{Chain}!haveBlockOnDisk@{haveBlockOnDisk}}
\index{haveBlockOnDisk@{haveBlockOnDisk}!Chain@{Chain}}
\doxysubsubsection{haveBlockOnDisk()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ac8e09b2f41743ee56e7457ec68ded53a} 
virtual bool have\+Block\+On\+Disk (\begin{DoxyParamCaption}\item[{int}]{height}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Check that the block is available on disk (i.\+e. has not been pruned), and contains transactions. \index{Chain@{Chain}!havePruned@{havePruned}}
\index{havePruned@{havePruned}!Chain@{Chain}}
\doxysubsubsection{havePruned()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_adf1607bc3bdeb84c474e8cae4b550af9} 
virtual bool have\+Pruned (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if any block has been pruned. 

\index{Chain@{Chain}!initError@{initError}}
\index{initError@{initError}!Chain@{Chain}}
\doxysubsubsection{initError()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ac98913b19a62e6b183ae47baf237e8da} 
virtual void init\+Error (\begin{DoxyParamCaption}\item[{const \textbf{ bilingual\+\_\+str} \&}]{message}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Send init error. 

\index{Chain@{Chain}!initMessage@{initMessage}}
\index{initMessage@{initMessage}!Chain@{Chain}}
\doxysubsubsection{initMessage()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a6c2a86f3bbbf879fcdb7f1cf2801e592} 
virtual void init\+Message (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{message}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Send init message. 

\index{Chain@{Chain}!initWarning@{initWarning}}
\index{initWarning@{initWarning}!Chain@{Chain}}
\doxysubsubsection{initWarning()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ad4d17c41de4e6676c8803ed245a1a0b4} 
virtual void init\+Warning (\begin{DoxyParamCaption}\item[{const \textbf{ bilingual\+\_\+str} \&}]{message}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Send init warning. 

\index{Chain@{Chain}!isInitialBlockDownload@{isInitialBlockDownload}}
\index{isInitialBlockDownload@{isInitialBlockDownload}!Chain@{Chain}}
\doxysubsubsection{isInitialBlockDownload()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a80cb5166168a53326e32afe29e15fb78} 
virtual bool is\+Initial\+Block\+Download (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if in IBD. 

\index{Chain@{Chain}!isInMempool@{isInMempool}}
\index{isInMempool@{isInMempool}!Chain@{Chain}}
\doxysubsubsection{isInMempool()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a51499dc5711720cac32428bcf426681c} 
virtual bool is\+In\+Mempool (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if transaction is in mempool. 

\index{Chain@{Chain}!isRBFOptIn@{isRBFOptIn}}
\index{isRBFOptIn@{isRBFOptIn}!Chain@{Chain}}
\doxysubsubsection{isRBFOptIn()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a642ad3af3ccd8d114335461155f7d907} 
virtual \textbf{ RBFTransaction\+State} is\+RBFOpt\+In (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction} \&}]{tx}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if transaction is RBF opt in. 

\index{Chain@{Chain}!isReadyToBroadcast@{isReadyToBroadcast}}
\index{isReadyToBroadcast@{isReadyToBroadcast}!Chain@{Chain}}
\doxysubsubsection{isReadyToBroadcast()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a166718affc889b84aedf9cfbbfe2c0a4} 
virtual bool is\+Ready\+To\+Broadcast (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if the node is ready to broadcast transactions. 

\index{Chain@{Chain}!mempoolMinFee@{mempoolMinFee}}
\index{mempoolMinFee@{mempoolMinFee}!Chain@{Chain}}
\doxysubsubsection{mempoolMinFee()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a917539d397a14dbe17cf83beef50be11} 
virtual \textbf{ CFee\+Rate} mempool\+Min\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Mempool minimum fee. 

\index{Chain@{Chain}!overwriteRwSetting@{overwriteRwSetting}}
\index{overwriteRwSetting@{overwriteRwSetting}!Chain@{Chain}}
\doxysubsubsection{overwriteRwSetting()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_adb62234333179a81f669c8e2330ac055} 
virtual bool overwrite\+Rw\+Setting (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name}{, }\item[{\textbf{ common\+::\+Settings\+Value}}]{value}{, }\item[{\textbf{ Settings\+Action}}]{action}{ = {\ttfamily \textbf{ Settings\+Action\+::\+WRITE}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Replace a setting in $<$datadir$>$/settings.json with a new value. Null can be passed to erase the setting. This method provides a simpler alternative to update\+Rw\+Setting when atomically reading and updating the setting is not required. \index{Chain@{Chain}!relayDustFee@{relayDustFee}}
\index{relayDustFee@{relayDustFee}!Chain@{Chain}}
\doxysubsubsection{relayDustFee()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a30514a50f2a01cf195dcf7b82d2d9780} 
virtual \textbf{ CFee\+Rate} relay\+Dust\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Relay dust fee setting (-\/dustrelayfee), reflecting lowest rate it\textquotesingle{}s economical to spend. 

\index{Chain@{Chain}!relayIncrementalFee@{relayIncrementalFee}}
\index{relayIncrementalFee@{relayIncrementalFee}!Chain@{Chain}}
\doxysubsubsection{relayIncrementalFee()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a89d6c1ade12869f01139637925521783} 
virtual \textbf{ CFee\+Rate} relay\+Incremental\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Relay incremental fee setting (-\/incrementalrelayfee), reflecting cost of relay. 

\index{Chain@{Chain}!relayMinFee@{relayMinFee}}
\index{relayMinFee@{relayMinFee}!Chain@{Chain}}
\doxysubsubsection{relayMinFee()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a0ba22f4ee3a829765f495de1adfcf1f1} 
virtual \textbf{ CFee\+Rate} relay\+Min\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Relay current minimum fee (from -\/minrelaytxfee and -\/incrementalrelayfee settings). 

\index{Chain@{Chain}!requestMempoolTransactions@{requestMempoolTransactions}}
\index{requestMempoolTransactions@{requestMempoolTransactions}!Chain@{Chain}}
\doxysubsubsection{requestMempoolTransactions()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a04eb49ba0393a8c16ba820cc97fe2b23} 
virtual void request\+Mempool\+Transactions (\begin{DoxyParamCaption}\item[{\textbf{ Notifications} \&}]{notifications}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Synchronously send transaction\+Added\+To\+Mempool notifications about all current mempool transactions to the specified handler and return after the last one is sent. These notifications aren\textquotesingle{}t coordinated with async notifications sent by handle\+Notifications, so out of date async notifications from handle\+Notifications can arrive during and after synchronous notifications from request\+Mempool\+Transactions. Clients need to be prepared to handle this by ignoring notifications about unknown removed transactions and already added new transactions. \index{Chain@{Chain}!rpcEnableDeprecated@{rpcEnableDeprecated}}
\index{rpcEnableDeprecated@{rpcEnableDeprecated}!Chain@{Chain}}
\doxysubsubsection{rpcEnableDeprecated()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_afc92d43d413a59339d30d153375a771d} 
virtual bool rpc\+Enable\+Deprecated (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if deprecated RPC is enabled. 

\index{Chain@{Chain}!showProgress@{showProgress}}
\index{showProgress@{showProgress}!Chain@{Chain}}
\doxysubsubsection{showProgress()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_ab854793852b1f1f3fdaeca07cb6bda15} 
virtual void show\+Progress (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{title}{, }\item[{int}]{progress}{, }\item[{bool}]{resume\+\_\+possible}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Send progress indicator. 

\index{Chain@{Chain}!shutdownRequested@{shutdownRequested}}
\index{shutdownRequested@{shutdownRequested}!Chain@{Chain}}
\doxysubsubsection{shutdownRequested()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_a119f98ffdecb228d79a8c4a1f4648401} 
virtual bool shutdown\+Requested (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Check if shutdown requested. 

\index{Chain@{Chain}!updateRwSetting@{updateRwSetting}}
\index{updateRwSetting@{updateRwSetting}!Chain@{Chain}}
\doxysubsubsection{updateRwSetting()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_acafee837edcfc9de6d50378dd7bba429} 
virtual bool update\+Rw\+Setting (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name}{, }\item[{const \textbf{ Settings\+Update} \&}]{update\+\_\+function}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Updates a setting in $<$datadir$>$/settings.json. Null can be passed to erase the setting. There is intentionally no support for writing null values to settings.\+json. Depending on the action returned by the update function, this will either update the setting in memory or write the updated settings to disk. \index{Chain@{Chain}!waitForNotificationsIfTipChanged@{waitForNotificationsIfTipChanged}}
\index{waitForNotificationsIfTipChanged@{waitForNotificationsIfTipChanged}!Chain@{Chain}}
\doxysubsubsection{waitForNotificationsIfTipChanged()}
{\footnotesize\ttfamily \label{classinterfaces_1_1_chain_aae7675e0bb7bbf072255497ba1b8f0e7} 
virtual void wait\+For\+Notifications\+If\+Tip\+Changed (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{old\+\_\+tip}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Wait for pending notifications to be processed unless block hash points to the current chain tip. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/interfaces/\textbf{ chain.\+h}\end{DoxyCompactItemize}
