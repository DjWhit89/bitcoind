\doxysection{src/util/strencodings.cpp File Reference}
\label{util_2strencodings_8cpp}\index{src/util/strencodings.cpp@{src/util/strencodings.cpp}}
{\ttfamily \#include $<$util/strencodings.\+h$>$}\newline
{\ttfamily \#include $<$crypto/hex\+\_\+base.\+h$>$}\newline
{\ttfamily \#include $<$span.\+h$>$}\newline
{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$cassert$>$}\newline
{\ttfamily \#include $<$cstring$>$}\newline
{\ttfamily \#include $<$limits$>$}\newline
{\ttfamily \#include $<$optional$>$}\newline
{\ttfamily \#include $<$ostream$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ Sanitize\+String} (std\+::string\+\_\+view str, int rule)
\item 
bool \textbf{ Is\+Hex} (std\+::string\+\_\+view str)
\item 
{\footnotesize template$<$typename Byte$>$ }\\std\+::optional$<$ std\+::vector$<$ Byte $>$ $>$ \textbf{ Try\+Parse\+Hex} (std\+::string\+\_\+view str)
\item 
template std\+::optional$<$ std\+::vector$<$ std\+::byte $>$ $>$ \textbf{ Try\+Parse\+Hex} (std\+::string\+\_\+view)
\item 
bool \textbf{ Split\+Host\+Port} (std\+::string\+\_\+view in, uint16\+\_\+t \&port\+Out, std\+::string \&host\+Out)
\item 
std\+::string \textbf{ Encode\+Base64} (std\+::span$<$ const unsigned char $>$ input)
\item 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ \textbf{ Decode\+Base64} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Encode\+Base32} (std\+::span$<$ const unsigned char $>$ input, bool pad)
\item 
std\+::string \textbf{ Encode\+Base32} (std\+::string\+\_\+view str, bool pad)
\item 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ \textbf{ Decode\+Base32} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Format\+Paragraph} (std\+::string\+\_\+view in, size\+\_\+t width, size\+\_\+t indent)
\item 
bool \textbf{ Parse\+Fixed\+Point} (std\+::string\+\_\+view val, int decimals, int64\+\_\+t $\ast$amount\+\_\+out)
\item 
std\+::string \textbf{ To\+Lower} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ To\+Upper} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Capitalize} (std\+::string str)
\item 
std\+::optional$<$ uint64\+\_\+t $>$ \textbf{ Parse\+Byte\+Units} (std\+::string\+\_\+view str, \textbf{ Byte\+Unit} default\+\_\+multiplier)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{strencodings.cpp@{strencodings.cpp}!Capitalize@{Capitalize}}
\index{Capitalize@{Capitalize}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{Capitalize()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_a07fea13e4dba45392e84b1205a3fa598} 
std\+::string Capitalize (\begin{DoxyParamCaption}\item[{std\+::string}]{str}{}\end{DoxyParamCaption})}

Capitalizes the first character of the given string. This function is locale independent. It only converts lowercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to capitalize. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string with the first letter capitalized. 
\end{DoxyReturn}
\index{strencodings.cpp@{strencodings.cpp}!DecodeBase32@{DecodeBase32}}
\index{DecodeBase32@{DecodeBase32}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{DecodeBase32()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_a640f09a4ac872c766bdc141c29c1a994} 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ Decode\+Base32 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.cpp@{strencodings.cpp}!DecodeBase64@{DecodeBase64}}
\index{DecodeBase64@{DecodeBase64}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{DecodeBase64()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_aca3b2791728bc2703381971e5a2d9582} 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ Decode\+Base64 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.cpp@{strencodings.cpp}!EncodeBase32@{EncodeBase32}}
\index{EncodeBase32@{EncodeBase32}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{EncodeBase32()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_a9fc1086e58cffb8ff36eb0e76da3bc33} 
std\+::string Encode\+Base32 (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{input}{, }\item[{bool}]{pad}{ = {\ttfamily true}}\end{DoxyParamCaption})}

Base32 encode. If {\ttfamily pad} is true, then the output will be padded with \textquotesingle{}=\textquotesingle{} so that its length is a multiple of 8. \index{strencodings.cpp@{strencodings.cpp}!EncodeBase32@{EncodeBase32}}
\index{EncodeBase32@{EncodeBase32}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{EncodeBase32()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_affab2d9b869e161a779a637fb0b2997f} 
std\+::string Encode\+Base32 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{bool}]{pad}{ = {\ttfamily true}}\end{DoxyParamCaption})}

Base32 encode. If {\ttfamily pad} is true, then the output will be padded with \textquotesingle{}=\textquotesingle{} so that its length is a multiple of 8. \index{strencodings.cpp@{strencodings.cpp}!EncodeBase64@{EncodeBase64}}
\index{EncodeBase64@{EncodeBase64}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{EncodeBase64()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ad8435069e57a90f332caa363d2b32a1c} 
std\+::string Encode\+Base64 (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{input}{}\end{DoxyParamCaption})}

\index{strencodings.cpp@{strencodings.cpp}!FormatParagraph@{FormatParagraph}}
\index{FormatParagraph@{FormatParagraph}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{FormatParagraph()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ab1b55ef6052788ecd0763f209b3de7f7} 
std\+::string Format\+Paragraph (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{in}{, }\item[{size\+\_\+t}]{width}{ = {\ttfamily 79}, }\item[{size\+\_\+t}]{indent}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\doxyref{Format}{p.}{struct_format} a paragraph of text to a fixed width, adding spaces for indentation to any added line. \index{strencodings.cpp@{strencodings.cpp}!IsHex@{IsHex}}
\index{IsHex@{IsHex}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{IsHex()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ab03ff4257acf4858602d1dc425848a19} 
bool Is\+Hex (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.cpp@{strencodings.cpp}!ParseByteUnits@{ParseByteUnits}}
\index{ParseByteUnits@{ParseByteUnits}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{ParseByteUnits()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ae89e79da81174d0900ca12cc82d04e04} 
std\+::optional$<$ uint64\+\_\+t $>$ Parse\+Byte\+Units (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{\textbf{ Byte\+Unit}}]{default\+\_\+multiplier}{}\end{DoxyParamCaption})}

Parse a string with suffix unit [k$\vert$\+K$\vert$m$\vert$\+M$\vert$g$\vert$\+G$\vert$t$\vert$T]. Must be a whole integer, fractions not allowed (0.\+5t), no whitespace or +-\/ Lowercase units are 1000 base. Uppercase units are 1024 base. Examples\+: 2m,27M,19g,41T


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to convert into bytes \\
\hline
\mbox{\texttt{in}}  & {\em default\+\_\+multiplier} & if no unit is found in str use this unit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
optional uint64\+\_\+t bytes from str or nullopt if To\+Integral is false, str is empty, trailing whitespace or overflow 
\end{DoxyReturn}
\index{strencodings.cpp@{strencodings.cpp}!ParseFixedPoint@{ParseFixedPoint}}
\index{ParseFixedPoint@{ParseFixedPoint}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{ParseFixedPoint()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_a63c53e075107d3d3d9da340abcae81c6} 
bool Parse\+Fixed\+Point (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{val}{, }\item[{int}]{decimals}{, }\item[{int64\+\_\+t $\ast$}]{amount\+\_\+out}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

Parse number as fixed point according to JSON number syntax. \begin{DoxyReturn}{Returns}
true on success, false on error. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The result must be in the range (-\/10$^\wedge$18,10$^\wedge$18), otherwise an overflow error will trigger. 
\end{DoxyNote}
\index{strencodings.cpp@{strencodings.cpp}!SanitizeString@{SanitizeString}}
\index{SanitizeString@{SanitizeString}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{SanitizeString()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_af661610872e92731fc31facae4d42361} 
std\+::string Sanitize\+String (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{int}]{rule}{ = {\ttfamily \textbf{ SAFE\+\_\+\+CHARS\+\_\+\+DEFAULT}}}\end{DoxyParamCaption})}

Remove unsafe chars. Safe chars chosen to allow simple messages/\+URLs/email addresses, but avoid anything even possibly remotely dangerous like \& or $>$ 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & The string to sanitize \\
\hline
\mbox{\texttt{in}}  & {\em rule} & The set of safe chars to choose (default\+: least restrictive) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new string without unsafe chars 
\end{DoxyReturn}
\index{strencodings.cpp@{strencodings.cpp}!SplitHostPort@{SplitHostPort}}
\index{SplitHostPort@{SplitHostPort}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{SplitHostPort()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ad3dd865469a228a338af78c000859b4f} 
bool Split\+Host\+Port (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{in}{, }\item[{uint16\+\_\+t \&}]{port\+Out}{, }\item[{std\+::string \&}]{host\+Out}{}\end{DoxyParamCaption})}

Splits socket address string into host string and port value. Validates port value.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em in} & The socket address string to split. \\
\hline
\mbox{\texttt{out}}  & {\em port\+Out} & Port-\/portion of the input, if found and parsable. \\
\hline
\mbox{\texttt{out}}  & {\em host\+Out} & Host-\/portion of the input, if found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if port-\/portion is absent or within its allowed range, otherwise false 
\end{DoxyReturn}
\index{strencodings.cpp@{strencodings.cpp}!ToLower@{ToLower}}
\index{ToLower@{ToLower}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{ToLower()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_aeb77a2481cc26fe4f5976c908e2378fb} 
std\+::string To\+Lower (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Returns the lowercase equivalent of the given string. This function is locale independent. It only converts uppercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to convert to lowercase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
lowercased equivalent of str 
\end{DoxyReturn}
\index{strencodings.cpp@{strencodings.cpp}!ToUpper@{ToUpper}}
\index{ToUpper@{ToUpper}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{ToUpper()}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_a43a1c84ec663c9f98c8799bfa6eab19f} 
std\+::string To\+Upper (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Returns the uppercase equivalent of the given string. This function is locale independent. It only converts lowercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to convert to uppercase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
UPPERCASED EQUIVALENT OF str 
\end{DoxyReturn}
\index{strencodings.cpp@{strencodings.cpp}!TryParseHex@{TryParseHex}}
\index{TryParseHex@{TryParseHex}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{TryParseHex()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ae3dc76180df5ad4e041d1b7ffb4e90a0} 
template$<$typename Byte$>$ \\
template std\+::optional$<$ std\+::vector$<$ uint8\+\_\+t $>$ $>$ Try\+Parse\+Hex (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Parse the hex string into bytes (uint8\+\_\+t or std\+::byte). Ignores whitespace. Returns nullopt on invalid input. \index{strencodings.cpp@{strencodings.cpp}!TryParseHex@{TryParseHex}}
\index{TryParseHex@{TryParseHex}!strencodings.cpp@{strencodings.cpp}}
\doxysubsubsection{TryParseHex()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{util_2strencodings_8cpp_ad198e389e203be245fe609ace3779e7f} 
template std\+::optional$<$ std\+::vector$<$ std\+::byte $>$ $>$ Try\+Parse\+Hex (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{}{}\end{DoxyParamCaption})}

