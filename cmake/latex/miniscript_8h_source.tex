\doxysection{miniscript.\+h}
\label{miniscript_8h_source}\index{src/script/miniscript.h@{src/script/miniscript.h}}
\textbf{ Go to the documentation of this file.}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ Copyright\ (c)\ 2019-\/present\ The\ Bitcoin\ Core\ developers}}
\DoxyCodeLine{00002\ \textcolor{comment}{//\ Distributed\ under\ the\ MIT\ software\ license,\ see\ the\ accompanying}}
\DoxyCodeLine{00003\ \textcolor{comment}{//\ file\ COPYING\ or\ http://www.opensource.org/licenses/mit-\/license.php.}}
\DoxyCodeLine{00004\ }
\DoxyCodeLine{00005\ \textcolor{preprocessor}{\#ifndef\ BITCOIN\_SCRIPT\_MINISCRIPT\_H}}
\DoxyCodeLine{00006\ \textcolor{preprocessor}{\#define\ BITCOIN\_SCRIPT\_MINISCRIPT\_H}}
\DoxyCodeLine{00007\ }
\DoxyCodeLine{00008\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00009\ \textcolor{preprocessor}{\#include\ <compare>}}
\DoxyCodeLine{00010\ \textcolor{preprocessor}{\#include\ <cstdint>}}
\DoxyCodeLine{00011\ \textcolor{preprocessor}{\#include\ <cstdlib>}}
\DoxyCodeLine{00012\ \textcolor{preprocessor}{\#include\ <iterator>}}
\DoxyCodeLine{00013\ \textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{00014\ \textcolor{preprocessor}{\#include\ <optional>}}
\DoxyCodeLine{00015\ \textcolor{preprocessor}{\#include\ <set>}}
\DoxyCodeLine{00016\ \textcolor{preprocessor}{\#include\ <stdexcept>}}
\DoxyCodeLine{00017\ \textcolor{preprocessor}{\#include\ <tuple>}}
\DoxyCodeLine{00018\ \textcolor{preprocessor}{\#include\ <utility>}}
\DoxyCodeLine{00019\ \textcolor{preprocessor}{\#include\ <vector>}}
\DoxyCodeLine{00020\ }
\DoxyCodeLine{00021\ \textcolor{preprocessor}{\#include\ <consensus/consensus.h>}}
\DoxyCodeLine{00022\ \textcolor{preprocessor}{\#include\ <policy/policy.h>}}
\DoxyCodeLine{00023\ \textcolor{preprocessor}{\#include\ <script/interpreter.h>}}
\DoxyCodeLine{00024\ \textcolor{preprocessor}{\#include\ <script/parsing.h>}}
\DoxyCodeLine{00025\ \textcolor{preprocessor}{\#include\ <script/script.h>}}
\DoxyCodeLine{00026\ \textcolor{preprocessor}{\#include\ <serialize.h>}}
\DoxyCodeLine{00027\ \textcolor{preprocessor}{\#include\ <span.h>}}
\DoxyCodeLine{00028\ \textcolor{preprocessor}{\#include\ <util/check.h>}}
\DoxyCodeLine{00029\ \textcolor{preprocessor}{\#include\ <util/strencodings.h>}}
\DoxyCodeLine{00030\ \textcolor{preprocessor}{\#include\ <util/string.h>}}
\DoxyCodeLine{00031\ \textcolor{preprocessor}{\#include\ <util/vector.h>}}
\DoxyCodeLine{00032\ }
\DoxyCodeLine{00033\ \textcolor{keyword}{namespace\ }miniscript\ \{}
\DoxyCodeLine{00034\ }
\DoxyCodeLine{00126\ \textcolor{keyword}{class\ }Type\ \{}
\DoxyCodeLine{00128\ \ \ \ \ uint32\_t\ m\_flags;}
\DoxyCodeLine{00129\ }
\DoxyCodeLine{00131\ \ \ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{constexpr}\ Type(uint32\_t\ flags)\ :\ m\_flags(flags)\ \{\}}
\DoxyCodeLine{00132\ }
\DoxyCodeLine{00133\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00135\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{consteval}\ Type\ \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_mst(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ c,\ \textcolor{keywordtype}{size\_t}\ l);}
\DoxyCodeLine{00136\ }
\DoxyCodeLine{00138\ \ \ \ \ \textcolor{keyword}{constexpr}\ Type\ operator|(Type\ x)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ Type(m\_flags\ |\ x.m\_flags);\ \}}
\DoxyCodeLine{00139\ }
\DoxyCodeLine{00141\ \ \ \ \ \textcolor{keyword}{constexpr}\ Type\ operator\&(Type\ x)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ Type(m\_flags\ \&\ x.m\_flags);\ \}}
\DoxyCodeLine{00142\ }
\DoxyCodeLine{00144\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ operator<<(Type\ x)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ (x.m\_flags\ \&\ \string~m\_flags)\ ==\ 0;\ \}}
\DoxyCodeLine{00145\ }
\DoxyCodeLine{00147\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ operator<(Type\ x)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ m\_flags\ <\ x.m\_flags;\ \}}
\DoxyCodeLine{00148\ }
\DoxyCodeLine{00150\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ operator==(Type\ x)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ m\_flags\ ==\ x.m\_flags;\ \}}
\DoxyCodeLine{00151\ }
\DoxyCodeLine{00153\ \ \ \ \ \textcolor{keyword}{constexpr}\ Type\ If(\textcolor{keywordtype}{bool}\ x)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ Type(x\ ?\ m\_flags\ :\ 0);\ \}}
\DoxyCodeLine{00154\ \};}
\DoxyCodeLine{00155\ }
\DoxyCodeLine{00157\ \textcolor{keyword}{inline}\ \textcolor{keyword}{consteval}\ Type\ \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_mst(\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}*\ c,\ \textcolor{keywordtype}{size\_t}\ l)}
\DoxyCodeLine{00158\ \{}
\DoxyCodeLine{00159\ \ \ \ \ Type\ typ\{0\};}
\DoxyCodeLine{00160\ }
\DoxyCodeLine{00161\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ *p\ =\ c;\ p\ <\ c\ +\ l;\ p++)\ \{}
\DoxyCodeLine{00162\ \ \ \ \ \ \ \ \ typ\ =\ typ\ |\ Type(}
\DoxyCodeLine{00163\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'B'}\ ?\ 1\ <<\ 0\ :\ \textcolor{comment}{//\ Base\ type}}
\DoxyCodeLine{00164\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'V'}\ ?\ 1\ <<\ 1\ :\ \textcolor{comment}{//\ Verify\ type}}
\DoxyCodeLine{00165\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'K'}\ ?\ 1\ <<\ 2\ :\ \textcolor{comment}{//\ Key\ type}}
\DoxyCodeLine{00166\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'W'}\ ?\ 1\ <<\ 3\ :\ \textcolor{comment}{//\ Wrapped\ type}}
\DoxyCodeLine{00167\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'z'}\ ?\ 1\ <<\ 4\ :\ \textcolor{comment}{//\ Zero-\/arg\ property}}
\DoxyCodeLine{00168\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'o'}\ ?\ 1\ <<\ 5\ :\ \textcolor{comment}{//\ One-\/arg\ property}}
\DoxyCodeLine{00169\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'n'}\ ?\ 1\ <<\ 6\ :\ \textcolor{comment}{//\ Nonzero\ arg\ property}}
\DoxyCodeLine{00170\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'d'}\ ?\ 1\ <<\ 7\ :\ \textcolor{comment}{//\ Dissatisfiable\ property}}
\DoxyCodeLine{00171\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'u'}\ ?\ 1\ <<\ 8\ :\ \textcolor{comment}{//\ Unit\ property}}
\DoxyCodeLine{00172\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'e'}\ ?\ 1\ <<\ 9\ :\ \textcolor{comment}{//\ Expression\ property}}
\DoxyCodeLine{00173\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'f'}\ ?\ 1\ <<\ 10\ :\ \textcolor{comment}{//\ Forced\ property}}
\DoxyCodeLine{00174\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'s'}\ ?\ 1\ <<\ 11\ :\ \textcolor{comment}{//\ Safe\ property}}
\DoxyCodeLine{00175\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'m'}\ ?\ 1\ <<\ 12\ :\ \textcolor{comment}{//\ Nonmalleable\ property}}
\DoxyCodeLine{00176\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'x'}\ ?\ 1\ <<\ 13\ :\ \textcolor{comment}{//\ Expensive\ verify}}
\DoxyCodeLine{00177\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'g'}\ ?\ 1\ <<\ 14\ :\ \textcolor{comment}{//\ older:\ contains\ relative\ time\ timelock\ \ \ (csv\_time)}}
\DoxyCodeLine{00178\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'h'}\ ?\ 1\ <<\ 15\ :\ \textcolor{comment}{//\ older:\ contains\ relative\ height\ timelock\ (csv\_height)}}
\DoxyCodeLine{00179\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'i'}\ ?\ 1\ <<\ 16\ :\ \textcolor{comment}{//\ after:\ contains\ time\ timelock\ \ \ (cltv\_time)}}
\DoxyCodeLine{00180\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'j'}\ ?\ 1\ <<\ 17\ :\ \textcolor{comment}{//\ after:\ contains\ height\ timelock\ \ \ (cltv\_height)}}
\DoxyCodeLine{00181\ \ \ \ \ \ \ \ \ \ \ \ \ *p\ ==\ \textcolor{charliteral}{'k'}\ ?\ 1\ <<\ 18\ :\ \textcolor{comment}{//\ does\ not\ contain\ a\ combination\ of\ height\ and\ time\ locks}}
\DoxyCodeLine{00182\ \ \ \ \ \ \ \ \ \ \ \ \ (\textcolor{keywordflow}{throw}\ std::logic\_error(\textcolor{stringliteral}{"{}Unknown\ character\ in\ \_mst\ literal"{}}),\ 0)}
\DoxyCodeLine{00183\ \ \ \ \ \ \ \ \ );}
\DoxyCodeLine{00184\ \ \ \ \ \}}
\DoxyCodeLine{00185\ }
\DoxyCodeLine{00186\ \ \ \ \ \textcolor{keywordflow}{return}\ typ;}
\DoxyCodeLine{00187\ \}}
\DoxyCodeLine{00188\ }
\DoxyCodeLine{00189\ \textcolor{keyword}{using\ }Opcode\ =\ std::pair<opcodetype,\ std::vector<unsigned\ char>>;}
\DoxyCodeLine{00190\ }
\DoxyCodeLine{00191\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key>\ \textcolor{keyword}{struct\ }Node;}
\DoxyCodeLine{00192\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key>\ \textcolor{keyword}{using\ }NodeRef\ =\ std::unique\_ptr<const\ Node<Key>>;}
\DoxyCodeLine{00193\ }
\DoxyCodeLine{00195\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key,\ \textcolor{keyword}{typename}...\ Args>}
\DoxyCodeLine{00196\ NodeRef<Key>\ MakeNodeRef(Args\&\&...\ args)\ \{\ \textcolor{keywordflow}{return}\ std::make\_unique<const\ Node<Key>>(std::forward<Args>(args)...);\ \}}
\DoxyCodeLine{00197\ }
\DoxyCodeLine{00199\ \textcolor{keyword}{enum\ class}\ Fragment\ \{}
\DoxyCodeLine{00200\ \ \ \ \ JUST\_0,\ \ \ \ }
\DoxyCodeLine{00201\ \ \ \ \ JUST\_1,\ \ \ \ }
\DoxyCodeLine{00202\ \ \ \ \ PK\_K,\ \ \ \ \ \ }
\DoxyCodeLine{00203\ \ \ \ \ PK\_H,\ \ \ \ \ \ }
\DoxyCodeLine{00204\ \ \ \ \ OLDER,\ \ \ \ \ }
\DoxyCodeLine{00205\ \ \ \ \ AFTER,\ \ \ \ \ }
\DoxyCodeLine{00206\ \ \ \ \ SHA256,\ \ \ \ }
\DoxyCodeLine{00207\ \ \ \ \ HASH256,\ \ \ }
\DoxyCodeLine{00208\ \ \ \ \ RIPEMD160,\ }
\DoxyCodeLine{00209\ \ \ \ \ HASH160,\ \ \ }
\DoxyCodeLine{00210\ \ \ \ \ WRAP\_A,\ \ \ \ }
\DoxyCodeLine{00211\ \ \ \ \ WRAP\_S,\ \ \ \ }
\DoxyCodeLine{00212\ \ \ \ \ WRAP\_C,\ \ \ \ }
\DoxyCodeLine{00213\ \ \ \ \ WRAP\_D,\ \ \ \ }
\DoxyCodeLine{00214\ \ \ \ \ WRAP\_V,\ \ \ \ }
\DoxyCodeLine{00215\ \ \ \ \ WRAP\_J,\ \ \ \ }
\DoxyCodeLine{00216\ \ \ \ \ WRAP\_N,\ \ \ \ }
\DoxyCodeLine{00217\ \ \ \ \ AND\_V,\ \ \ \ \ }
\DoxyCodeLine{00218\ \ \ \ \ AND\_B,\ \ \ \ \ }
\DoxyCodeLine{00219\ \ \ \ \ OR\_B,\ \ \ \ \ \ }
\DoxyCodeLine{00220\ \ \ \ \ OR\_C,\ \ \ \ \ \ }
\DoxyCodeLine{00221\ \ \ \ \ OR\_D,\ \ \ \ \ \ }
\DoxyCodeLine{00222\ \ \ \ \ OR\_I,\ \ \ \ \ \ }
\DoxyCodeLine{00223\ \ \ \ \ ANDOR,\ \ \ \ \ }
\DoxyCodeLine{00224\ \ \ \ \ THRESH,\ \ \ \ }
\DoxyCodeLine{00225\ \ \ \ \ MULTI,\ \ \ \ \ }
\DoxyCodeLine{00226\ \ \ \ \ MULTI\_A,\ \ \ }
\DoxyCodeLine{00227\ \ \ \ \ \textcolor{comment}{//\ AND\_N(X,Y)\ is\ represented\ as\ ANDOR(X,Y,0)}}
\DoxyCodeLine{00228\ \ \ \ \ \textcolor{comment}{//\ WRAP\_T(X)\ is\ represented\ as\ AND\_V(X,1)}}
\DoxyCodeLine{00229\ \ \ \ \ \textcolor{comment}{//\ WRAP\_L(X)\ is\ represented\ as\ OR\_I(0,X)}}
\DoxyCodeLine{00230\ \ \ \ \ \textcolor{comment}{//\ WRAP\_U(X)\ is\ represented\ as\ OR\_I(X,0)}}
\DoxyCodeLine{00231\ \};}
\DoxyCodeLine{00232\ }
\DoxyCodeLine{00233\ \textcolor{keyword}{enum\ class}\ Availability\ \{}
\DoxyCodeLine{00234\ \ \ \ \ NO,}
\DoxyCodeLine{00235\ \ \ \ \ YES,}
\DoxyCodeLine{00236\ \ \ \ \ MAYBE,}
\DoxyCodeLine{00237\ \};}
\DoxyCodeLine{00238\ }
\DoxyCodeLine{00239\ \textcolor{keyword}{enum\ class}\ MiniscriptContext\ \{}
\DoxyCodeLine{00240\ \ \ \ \ P2WSH,}
\DoxyCodeLine{00241\ \ \ \ \ TAPSCRIPT,}
\DoxyCodeLine{00242\ \};}
\DoxyCodeLine{00243\ }
\DoxyCodeLine{00245\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ IsTapscript(MiniscriptContext\ ms\_ctx)}
\DoxyCodeLine{00246\ \{}
\DoxyCodeLine{00247\ \ \ \ \ \textcolor{keywordflow}{switch}\ (ms\_ctx)\ \{}
\DoxyCodeLine{00248\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ MiniscriptContext::P2WSH:\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00249\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ MiniscriptContext::TAPSCRIPT:\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00250\ \ \ \ \ \}}
\DoxyCodeLine{00251\ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{00252\ \}}
\DoxyCodeLine{00253\ }
\DoxyCodeLine{00254\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{00255\ }
\DoxyCodeLine{00257\ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ uint32\_t\ MAX\_TAPMINISCRIPT\_STACK\_ELEM\_SIZE\{65\};}
\DoxyCodeLine{00258\ }
\DoxyCodeLine{00260\ \textcolor{keyword}{constexpr}\ uint32\_t\ TX\_OVERHEAD\{4\ +\ 4\};}
\DoxyCodeLine{00262\ \textcolor{keyword}{constexpr}\ uint32\_t\ TXIN\_BYTES\_NO\_WITNESS\{36\ +\ 4\ +\ 1\};}
\DoxyCodeLine{00264\ \textcolor{keyword}{constexpr}\ uint32\_t\ P2WSH\_TXOUT\_BYTES\{8\ +\ 1\ +\ 1\ +\ 33\};}
\DoxyCodeLine{00266\ \textcolor{keyword}{constexpr}\ uint32\_t\ TX\_BODY\_LEEWAY\_WEIGHT\{(TX\_OVERHEAD\ +\ GetSizeOfCompactSize(1)\ +\ TXIN\_BYTES\_NO\_WITNESS\ +\ GetSizeOfCompactSize(1)\ +\ P2WSH\_TXOUT\_BYTES)\ *\ WITNESS\_SCALE\_FACTOR\ +\ 2\};}
\DoxyCodeLine{00268\ \textcolor{keyword}{constexpr}\ uint32\_t\ MAX\_TAPSCRIPT\_SAT\_SIZE\{GetSizeOfCompactSize(MAX\_STACK\_SIZE)\ +\ (GetSizeOfCompactSize(MAX\_TAPMINISCRIPT\_STACK\_ELEM\_SIZE)\ +\ MAX\_TAPMINISCRIPT\_STACK\_ELEM\_SIZE)\ *\ MAX\_STACK\_SIZE\ +\ GetSizeOfCompactSize(TAPROOT\_CONTROL\_MAX\_SIZE)\ +\ TAPROOT\_CONTROL\_MAX\_SIZE\};}
\DoxyCodeLine{00270\ \textcolor{keyword}{constexpr}\ uint32\_t\ MaxScriptSize(MiniscriptContext\ ms\_ctx)}
\DoxyCodeLine{00271\ \{}
\DoxyCodeLine{00272\ \ \ \ \ \textcolor{keywordflow}{if}\ (IsTapscript(ms\_ctx))\ \{}
\DoxyCodeLine{00273\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Leaf\ scripts\ under\ Tapscript\ are\ not\ explicitly\ limited\ in\ size.\ They\ are\ only\ implicitly}}
\DoxyCodeLine{00274\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ bounded\ by\ the\ maximum\ standard\ size\ of\ a\ spending\ transaction.\ Let\ the\ maximum\ script}}
\DoxyCodeLine{00275\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ size\ conservatively\ be\ small\ enough\ such\ that\ even\ a\ maximum\ sized\ witness\ and\ a\ reasonably}}
\DoxyCodeLine{00276\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sized\ spending\ transaction\ can\ spend\ an\ output\ paying\ to\ this\ script\ without\ running\ into}}
\DoxyCodeLine{00277\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ maximum\ standard\ tx\ size\ limit.}}
\DoxyCodeLine{00278\ \ \ \ \ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ max\_size\{MAX\_STANDARD\_TX\_WEIGHT\ -\/\ TX\_BODY\_LEEWAY\_WEIGHT\ -\/\ MAX\_TAPSCRIPT\_SAT\_SIZE\};}
\DoxyCodeLine{00279\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ max\_size\ -\/\ GetSizeOfCompactSize(max\_size);}
\DoxyCodeLine{00280\ \ \ \ \ \}}
\DoxyCodeLine{00281\ \ \ \ \ \textcolor{keywordflow}{return}\ MAX\_STANDARD\_P2WSH\_SCRIPT\_SIZE;}
\DoxyCodeLine{00282\ \}}
\DoxyCodeLine{00283\ }
\DoxyCodeLine{00285\ Type\ ComputeType(Fragment\ fragment,\ Type\ x,\ Type\ y,\ Type\ z,\ \textcolor{keyword}{const}\ std::vector<Type>\&\ sub\_types,\ uint32\_t\ k,\ \textcolor{keywordtype}{size\_t}\ data\_size,\ \textcolor{keywordtype}{size\_t}\ n\_subs,\ \textcolor{keywordtype}{size\_t}\ n\_keys,\ MiniscriptContext\ ms\_ctx);}
\DoxyCodeLine{00286\ }
\DoxyCodeLine{00288\ \textcolor{keywordtype}{size\_t}\ ComputeScriptLen(Fragment\ fragment,\ Type\ sub0typ,\ \textcolor{keywordtype}{size\_t}\ subsize,\ uint32\_t\ k,\ \textcolor{keywordtype}{size\_t}\ n\_subs,\ \textcolor{keywordtype}{size\_t}\ n\_keys,\ MiniscriptContext\ ms\_ctx);}
\DoxyCodeLine{00289\ }
\DoxyCodeLine{00291\ Type\ SanitizeType(Type\ x);}
\DoxyCodeLine{00292\ }
\DoxyCodeLine{00294\ \textcolor{keyword}{struct\ }InputStack\ \{}
\DoxyCodeLine{00300\ \ \ \ \ Availability\ available\ =\ Availability::YES;}
\DoxyCodeLine{00302\ \ \ \ \ \textcolor{keywordtype}{bool}\ has\_sig\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00304\ \ \ \ \ \textcolor{keywordtype}{bool}\ malleable\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00307\ \ \ \ \ \textcolor{keywordtype}{bool}\ non\_canon\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{00309\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ size\ =\ 0;}
\DoxyCodeLine{00311\ \ \ \ \ std::vector<std::vector<unsigned\ char>>\ stack;}
\DoxyCodeLine{00313\ \ \ \ \ InputStack()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{00315\ \ \ \ \ InputStack(std::vector<unsigned\ char>\ in)\ :\ size(in.size()\ +\ 1),\ stack(Vector(std::move(in)))\ \{\}}
\DoxyCodeLine{00317\ \ \ \ \ InputStack\&\ SetAvailable(Availability\ avail);}
\DoxyCodeLine{00319\ \ \ \ \ InputStack\&\ SetWithSig();}
\DoxyCodeLine{00321\ \ \ \ \ InputStack\&\ SetNonCanon();}
\DoxyCodeLine{00323\ \ \ \ \ InputStack\&\ SetMalleable(\textcolor{keywordtype}{bool}\ x\ =\ \textcolor{keyword}{true});}
\DoxyCodeLine{00325\ \ \ \ \ \textcolor{keyword}{friend}\ InputStack\ operator+(InputStack\ a,\ InputStack\ b);}
\DoxyCodeLine{00327\ \ \ \ \ \textcolor{keyword}{friend}\ InputStack\ operator|(InputStack\ a,\ InputStack\ b);}
\DoxyCodeLine{00328\ \};}
\DoxyCodeLine{00329\ }
\DoxyCodeLine{00331\ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ ZERO\ =\ InputStack(std::vector<unsigned\ char>());}
\DoxyCodeLine{00333\ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ ZERO32\ =\ InputStack(std::vector<unsigned\ char>(32,\ 0)).SetMalleable();}
\DoxyCodeLine{00335\ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ ONE\ =\ InputStack(Vector((\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char})1));}
\DoxyCodeLine{00337\ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ EMPTY\ =\ InputStack();}
\DoxyCodeLine{00339\ \textcolor{keyword}{static}\ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ INVALID\ =\ InputStack().SetAvailable(Availability::NO);}
\DoxyCodeLine{00340\ }
\DoxyCodeLine{00342\ \textcolor{keyword}{struct\ }InputResult\ \{}
\DoxyCodeLine{00343\ \ \ \ \ InputStack\ nsat,\ sat;}
\DoxyCodeLine{00344\ }
\DoxyCodeLine{00345\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ A,\ \textcolor{keyword}{typename}\ B>}
\DoxyCodeLine{00346\ \ \ \ \ InputResult(A\&\&\ in\_nsat,\ B\&\&\ in\_sat)\ :\ nsat(std::forward<A>(in\_nsat)),\ sat(std::forward<B>(in\_sat))\ \{\}}
\DoxyCodeLine{00347\ \};}
\DoxyCodeLine{00348\ }
\DoxyCodeLine{00350\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ I>}
\DoxyCodeLine{00351\ \textcolor{keyword}{struct\ }MaxInt\ \{}
\DoxyCodeLine{00352\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ valid;}
\DoxyCodeLine{00353\ \ \ \ \ \textcolor{keyword}{const}\ I\ value;}
\DoxyCodeLine{00354\ }
\DoxyCodeLine{00355\ \ \ \ \ MaxInt()\ :\ valid(false),\ value(0)\ \{\}}
\DoxyCodeLine{00356\ \ \ \ \ MaxInt(I\ val)\ :\ valid(true),\ value(val)\ \{\}}
\DoxyCodeLine{00357\ }
\DoxyCodeLine{00358\ \ \ \ \ \textcolor{keyword}{friend}\ MaxInt<I>\ operator+(\textcolor{keyword}{const}\ MaxInt<I>\&\ a,\ \textcolor{keyword}{const}\ MaxInt<I>\&\ b)\ \{}
\DoxyCodeLine{00359\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!a.valid\ ||\ !b.valid)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00360\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ a.value\ +\ b.value;}
\DoxyCodeLine{00361\ \ \ \ \ \}}
\DoxyCodeLine{00362\ }
\DoxyCodeLine{00363\ \ \ \ \ \textcolor{keyword}{friend}\ MaxInt<I>\ operator|(\textcolor{keyword}{const}\ MaxInt<I>\&\ a,\ \textcolor{keyword}{const}\ MaxInt<I>\&\ b)\ \{}
\DoxyCodeLine{00364\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!a.valid)\ \textcolor{keywordflow}{return}\ b;}
\DoxyCodeLine{00365\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!b.valid)\ \textcolor{keywordflow}{return}\ a;}
\DoxyCodeLine{00366\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::max(a.value,\ b.value);}
\DoxyCodeLine{00367\ \ \ \ \ \}}
\DoxyCodeLine{00368\ \};}
\DoxyCodeLine{00369\ }
\DoxyCodeLine{00370\ \textcolor{keyword}{struct\ }Ops\ \{}
\DoxyCodeLine{00372\ \ \ \ \ uint32\_t\ count;}
\DoxyCodeLine{00374\ \ \ \ \ MaxInt<uint32\_t>\ sat;}
\DoxyCodeLine{00376\ \ \ \ \ MaxInt<uint32\_t>\ dsat;}
\DoxyCodeLine{00377\ }
\DoxyCodeLine{00378\ \ \ \ \ Ops(uint32\_t\ in\_count,\ MaxInt<uint32\_t>\ in\_sat,\ MaxInt<uint32\_t>\ in\_dsat)\ :\ count(in\_count),\ sat(in\_sat),\ dsat(in\_dsat)\ \{\};}
\DoxyCodeLine{00379\ \};}
\DoxyCodeLine{00380\ }
\DoxyCodeLine{00422\ \textcolor{keyword}{struct\ }SatInfo\ \{}
\DoxyCodeLine{00424\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ valid;}
\DoxyCodeLine{00426\ \ \ \ \ \textcolor{keyword}{const}\ int32\_t\ netdiff;}
\DoxyCodeLine{00428\ \ \ \ \ \textcolor{keyword}{const}\ int32\_t\ exec;}
\DoxyCodeLine{00429\ }
\DoxyCodeLine{00431\ \ \ \ \ \textcolor{keyword}{constexpr}\ SatInfo()\ noexcept\ :\ valid(false),\ netdiff(0),\ exec(0)\ \{\}}
\DoxyCodeLine{00432\ }
\DoxyCodeLine{00434\ \ \ \ \ \textcolor{keyword}{constexpr}\ SatInfo(int32\_t\ in\_netdiff,\ int32\_t\ in\_exec)\ noexcept\ :}
\DoxyCodeLine{00435\ \ \ \ \ \ \ \ \ valid\{\textcolor{keyword}{true}\},\ netdiff\{in\_netdiff\},\ exec\{in\_exec\}\ \{\}}
\DoxyCodeLine{00436\ }
\DoxyCodeLine{00438\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{friend}\ SatInfo\ operator|(\textcolor{keyword}{const}\ SatInfo\&\ a,\ \textcolor{keyword}{const}\ SatInfo\&\ b)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00439\ \ \ \ \ \{}
\DoxyCodeLine{00440\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Union\ with\ an\ empty\ set\ is\ itself.}}
\DoxyCodeLine{00441\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!a.valid)\ \textcolor{keywordflow}{return}\ b;}
\DoxyCodeLine{00442\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!b.valid)\ \textcolor{keywordflow}{return}\ a;}
\DoxyCodeLine{00443\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Otherwise\ the\ netdiff\ and\ exec\ of\ the\ union\ is\ the\ maximum\ of\ the\ individual\ values.}}
\DoxyCodeLine{00444\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{std::max(a.netdiff,\ b.netdiff),\ std::max(a.exec,\ b.exec)\};}
\DoxyCodeLine{00445\ \ \ \ \ \}}
\DoxyCodeLine{00446\ }
\DoxyCodeLine{00448\ \ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{friend}\ SatInfo\ operator+(\textcolor{keyword}{const}\ SatInfo\&\ a,\ \textcolor{keyword}{const}\ SatInfo\&\ b)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{00449\ \ \ \ \ \{}
\DoxyCodeLine{00450\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Concatenation\ with\ an\ empty\ set\ yields\ an\ empty\ set.}}
\DoxyCodeLine{00451\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!a.valid\ ||\ !b.valid)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00452\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Otherwise,\ the\ maximum\ stack\ size\ difference\ for\ the\ combined\ scripts\ is\ the\ sum\ of\ the}}
\DoxyCodeLine{00453\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ netdiffs,\ and\ the\ maximum\ stack\ size\ difference\ anywhere\ is\ either\ b.exec\ (if\ the}}
\DoxyCodeLine{00454\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ maximum\ occurred\ in\ b)\ or\ b.netdiff+a.exec\ (if\ the\ maximum\ occurred\ in\ a).}}
\DoxyCodeLine{00455\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{a.netdiff\ +\ b.netdiff,\ std::max(b.exec,\ b.netdiff\ +\ a.exec)\};}
\DoxyCodeLine{00456\ \ \ \ \ \}}
\DoxyCodeLine{00457\ }
\DoxyCodeLine{00459\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ Empty()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{0,\ 0\};\ \}}
\DoxyCodeLine{00461\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ Push()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{-\/1,\ 0\};\ \}}
\DoxyCodeLine{00463\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ Hash()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{0,\ 0\};\ \}}
\DoxyCodeLine{00465\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ Nop()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{0,\ 0\};\ \}}
\DoxyCodeLine{00467\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ If()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{1,\ 1\};\ \}}
\DoxyCodeLine{00469\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ BinaryOp()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{1,\ 1\};\ \}}
\DoxyCodeLine{00470\ }
\DoxyCodeLine{00471\ \ \ \ \ \textcolor{comment}{//\ Scripts\ for\ specific\ individual\ opcodes.}}
\DoxyCodeLine{00472\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_DUP()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{-\/1,\ 0\};\ \}}
\DoxyCodeLine{00473\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_IFDUP(\textcolor{keywordtype}{bool}\ nonzero)\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ \{nonzero\ ?\ -\/1\ :\ 0,\ 0\};\ \}}
\DoxyCodeLine{00474\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_EQUALVERIFY()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{2,\ 2\};\ \}}
\DoxyCodeLine{00475\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_EQUAL()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{1,\ 1\};\ \}}
\DoxyCodeLine{00476\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_SIZE()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{-\/1,\ 0\};\ \}}
\DoxyCodeLine{00477\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_CHECKSIG()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{1,\ 1\};\ \}}
\DoxyCodeLine{00478\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_0NOTEQUAL()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{0,\ 0\};\ \}}
\DoxyCodeLine{00479\ \ \ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{constexpr}\ SatInfo\ OP\_VERIFY()\ noexcept\ \{\ \textcolor{keywordflow}{return}\ \{1,\ 1\};\ \}}
\DoxyCodeLine{00480\ \};}
\DoxyCodeLine{00481\ }
\DoxyCodeLine{00482\ \textcolor{keyword}{struct\ }StackSize\ \{}
\DoxyCodeLine{00483\ \ \ \ \ \textcolor{keyword}{const}\ SatInfo\ sat,\ dsat;}
\DoxyCodeLine{00484\ }
\DoxyCodeLine{00485\ \ \ \ \ \textcolor{keyword}{constexpr}\ StackSize(SatInfo\ in\_sat,\ SatInfo\ in\_dsat)\ noexcept\ :\ sat(in\_sat),\ dsat(in\_dsat)\ \{\};}
\DoxyCodeLine{00486\ \ \ \ \ \textcolor{keyword}{constexpr}\ StackSize(SatInfo\ in\_both)\ noexcept\ :\ sat(in\_both),\ dsat(in\_both)\ \{\};}
\DoxyCodeLine{00487\ \};}
\DoxyCodeLine{00488\ }
\DoxyCodeLine{00489\ \textcolor{keyword}{struct\ }WitnessSize\ \{}
\DoxyCodeLine{00491\ \ \ \ \ MaxInt<uint32\_t>\ sat;}
\DoxyCodeLine{00493\ \ \ \ \ MaxInt<uint32\_t>\ dsat;}
\DoxyCodeLine{00494\ }
\DoxyCodeLine{00495\ \ \ \ \ WitnessSize(MaxInt<uint32\_t>\ in\_sat,\ MaxInt<uint32\_t>\ in\_dsat)\ :\ sat(in\_sat),\ dsat(in\_dsat)\ \{\};}
\DoxyCodeLine{00496\ \};}
\DoxyCodeLine{00497\ }
\DoxyCodeLine{00498\ \textcolor{keyword}{struct\ }NoDupCheck\ \{\};}
\DoxyCodeLine{00499\ }
\DoxyCodeLine{00500\ \}\ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{00501\ }
\DoxyCodeLine{00503\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key>}
\DoxyCodeLine{00504\ \textcolor{keyword}{struct\ }Node\ \{}
\DoxyCodeLine{00506\ \ \ \ \ \textcolor{keyword}{const}\ Fragment\ fragment;}
\DoxyCodeLine{00508\ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ k\ =\ 0;}
\DoxyCodeLine{00510\ \ \ \ \ \textcolor{keyword}{const}\ std::vector<Key>\ keys;}
\DoxyCodeLine{00512\ \ \ \ \ \textcolor{keyword}{const}\ std::vector<unsigned\ char>\ data;}
\DoxyCodeLine{00514\ \ \ \ \ \textcolor{keyword}{mutable}\ std::vector<NodeRef<Key>>\ subs;}
\DoxyCodeLine{00516\ \ \ \ \ \textcolor{keyword}{const}\ MiniscriptContext\ m\_script\_ctx;}
\DoxyCodeLine{00517\ }
\DoxyCodeLine{00518\ \ \ \ \ \textcolor{comment}{/*\ Destroy\ the\ shared\ pointers\ iteratively\ to\ avoid\ a\ stack-\/overflow\ due\ to\ recursive\ calls}}
\DoxyCodeLine{00519\ \textcolor{comment}{\ \ \ \ \ *\ to\ the\ subs'\ destructors.\ */}}
\DoxyCodeLine{00520\ \ \ \ \ \string~Node()\ \{}
\DoxyCodeLine{00521\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (!subs.empty())\ \{}
\DoxyCodeLine{00522\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ node\ =\ std::move(subs.back());}
\DoxyCodeLine{00523\ \ \ \ \ \ \ \ \ \ \ \ \ subs.pop\_back();}
\DoxyCodeLine{00524\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (!node-\/>subs.empty())\ \{}
\DoxyCodeLine{00525\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ subs.push\_back(std::move(node-\/>subs.back()));}
\DoxyCodeLine{00526\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node-\/>subs.pop\_back();}
\DoxyCodeLine{00527\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00528\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00529\ \ \ \ \ \}}
\DoxyCodeLine{00530\ }
\DoxyCodeLine{00531\ \ \ \ \ NodeRef<Key>\ Clone()\textcolor{keyword}{\ const}}
\DoxyCodeLine{00532\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{00533\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Use\ TreeEval()\ to\ avoid\ a\ stack-\/overflow\ due\ to\ recursion}}
\DoxyCodeLine{00534\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ upfn\ =\ [](\textcolor{keyword}{const}\ Node\&\ node,\ std::span<NodeRef<Key>>\ children)\ \{}
\DoxyCodeLine{00535\ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<NodeRef<Key>>\ new\_subs;}
\DoxyCodeLine{00536\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ child\ =\ children.begin();\ child\ !=\ children.end();\ ++child)\ \{}
\DoxyCodeLine{00537\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ new\_subs.emplace\_back(std::move(*child));}
\DoxyCodeLine{00538\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00539\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ std::make\_unique\ (and\ therefore\ MakeNodeRef)\ doesn't\ work\ on\ private\ constructors}}
\DoxyCodeLine{00540\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::unique\_ptr<Node>\{\textcolor{keyword}{new}\ Node\{internal::NoDupCheck\{\},\ node.m\_script\_ctx,\ node.fragment,\ std::move(new\_subs),\ node.keys,\ node.data,\ node.k\}\};}
\DoxyCodeLine{00541\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{00542\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEval<NodeRef<Key>>(upfn);}
\DoxyCodeLine{00543\ \ \ \ \ \}}
\DoxyCodeLine{00544\ }
\DoxyCodeLine{00545\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00547\ \ \ \ \ \textcolor{keyword}{const}\ internal::Ops\ ops;}
\DoxyCodeLine{00549\ \ \ \ \ \textcolor{keyword}{const}\ internal::StackSize\ ss;}
\DoxyCodeLine{00551\ \ \ \ \ \textcolor{keyword}{const}\ internal::WitnessSize\ ws;}
\DoxyCodeLine{00553\ \ \ \ \ \textcolor{keyword}{const}\ Type\ typ;}
\DoxyCodeLine{00555\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ scriptlen;}
\DoxyCodeLine{00561\ \ \ \ \ \textcolor{keyword}{mutable}\ std::optional<bool>\ has\_duplicate\_keys;}
\DoxyCodeLine{00562\ }
\DoxyCodeLine{00563\ \ \ \ \ \textcolor{comment}{//\ Constructor\ which\ takes\ all\ of\ the\ data\ that\ a\ Node\ could\ possibly\ contain.}}
\DoxyCodeLine{00564\ \ \ \ \ \textcolor{comment}{//\ This\ is\ kept\ private\ as\ no\ valid\ fragment\ has\ all\ of\ these\ arguments.}}
\DoxyCodeLine{00565\ \ \ \ \ \textcolor{comment}{//\ Only\ used\ by\ Clone()}}
\DoxyCodeLine{00566\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ std::vector<Key>\ key,\ std::vector<unsigned\ char>\ arg,\ uint32\_t\ val)}
\DoxyCodeLine{00567\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ keys(key),\ data(std::move(arg)),\ subs(std::move(sub)),\ m\_script\_ctx\{script\_ctx\},\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{00568\ }
\DoxyCodeLine{00570\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ CalcScriptLen()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00571\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ subsize\ =\ 0;}
\DoxyCodeLine{00572\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ sub\ :\ subs)\ \{}
\DoxyCodeLine{00573\ \ \ \ \ \ \ \ \ \ \ \ \ subsize\ +=\ sub-\/>ScriptSize();}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00575\ \ \ \ \ \ \ \ \ Type\ sub0type\ =\ subs.size()\ >\ 0\ ?\ subs[0]-\/>GetType()\ :\ \textcolor{stringliteral}{"{}"{}}\_mst;}
\DoxyCodeLine{00576\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ internal::ComputeScriptLen(fragment,\ sub0type,\ subsize,\ k,\ subs.size(),\ keys.size(),\ m\_script\_ctx);}
\DoxyCodeLine{00577\ \ \ \ \ \}}
\DoxyCodeLine{00578\ }
\DoxyCodeLine{00579\ \ \ \ \ \textcolor{comment}{/*\ Apply\ a\ recursive\ algorithm\ to\ a\ Miniscript\ tree,\ without\ actual\ recursive\ calls.}}
\DoxyCodeLine{00580\ \textcolor{comment}{\ \ \ \ \ *}}
\DoxyCodeLine{00581\ \textcolor{comment}{\ \ \ \ \ *\ The\ algorithm\ is\ defined\ by\ two\ functions:\ downfn\ and\ upfn.\ Conceptually,\ the}}
\DoxyCodeLine{00582\ \textcolor{comment}{\ \ \ \ \ *\ result\ can\ be\ thought\ of\ as\ first\ using\ downfn\ to\ compute\ a\ "{}state"{}\ for\ each\ node,}}
\DoxyCodeLine{00583\ \textcolor{comment}{\ \ \ \ \ *\ from\ the\ root\ down\ to\ the\ leaves.\ Then\ upfn\ is\ used\ to\ compute\ a\ "{}result"{}\ for\ each}}
\DoxyCodeLine{00584\ \textcolor{comment}{\ \ \ \ \ *\ node,\ from\ the\ leaves\ back\ up\ to\ the\ root,\ which\ is\ then\ returned.\ In\ the\ actual}}
\DoxyCodeLine{00585\ \textcolor{comment}{\ \ \ \ \ *\ implementation,\ both\ functions\ are\ invoked\ in\ an\ interleaved\ fashion,\ performing\ a}}
\DoxyCodeLine{00586\ \textcolor{comment}{\ \ \ \ \ *\ depth-\/first\ traversal\ of\ the\ tree.}}
\DoxyCodeLine{00587\ \textcolor{comment}{\ \ \ \ \ *}}
\DoxyCodeLine{00588\ \textcolor{comment}{\ \ \ \ \ *\ In\ more\ detail,\ it\ is\ invoked\ as\ node.TreeEvalMaybe<Result>(root,\ downfn,\ upfn):}}
\DoxyCodeLine{00589\ \textcolor{comment}{\ \ \ \ \ *\ -\/\ root\ is\ the\ state\ of\ the\ root\ node,\ of\ type\ State.}}
\DoxyCodeLine{00590\ \textcolor{comment}{\ \ \ \ \ *\ -\/\ downfn\ is\ a\ callable\ (State\&,\ const\ Node\&,\ size\_t)\ -\/>\ State,\ which\ given\ a}}
\DoxyCodeLine{00591\ \textcolor{comment}{\ \ \ \ \ *\ \ \ node,\ its\ state,\ and\ an\ index\ of\ one\ of\ its\ children,\ computes\ the\ state\ of\ that}}
\DoxyCodeLine{00592\ \textcolor{comment}{\ \ \ \ \ *\ \ \ child.\ It\ can\ modify\ the\ state.\ Children\ of\ a\ given\ node\ will\ have\ downfn()}}
\DoxyCodeLine{00593\ \textcolor{comment}{\ \ \ \ \ *\ \ \ called\ in\ order.}}
\DoxyCodeLine{00594\ \textcolor{comment}{\ \ \ \ \ *\ -\/\ upfn\ is\ a\ callable\ (State\&\&,\ const\ Node\&,\ std::span<Result>)\ -\/>\ std::optional<Result>,}}
\DoxyCodeLine{00595\ \textcolor{comment}{\ \ \ \ \ *\ \ \ which\ given\ a\ node,\ its\ state,\ and\ a\ span\ of\ the\ results\ of\ its\ children,}}
\DoxyCodeLine{00596\ \textcolor{comment}{\ \ \ \ \ *\ \ \ computes\ the\ result\ of\ the\ node.\ If\ std::nullopt\ is\ returned\ by\ upfn,}}
\DoxyCodeLine{00597\ \textcolor{comment}{\ \ \ \ \ *\ \ \ TreeEvalMaybe()\ immediately\ returns\ std::nullopt.}}
\DoxyCodeLine{00598\ \textcolor{comment}{\ \ \ \ \ *\ The\ return\ value\ of\ TreeEvalMaybe\ is\ the\ result\ of\ the\ root\ node.}}
\DoxyCodeLine{00599\ \textcolor{comment}{\ \ \ \ \ *}}
\DoxyCodeLine{00600\ \textcolor{comment}{\ \ \ \ \ *\ Result\ type\ cannot\ be\ bool\ due\ to\ the\ std::vector<bool>\ specialization.}}
\DoxyCodeLine{00601\ \textcolor{comment}{\ \ \ \ \ */}}
\DoxyCodeLine{00602\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Result,\ \textcolor{keyword}{typename}\ State,\ \textcolor{keyword}{typename}\ DownFn,\ \textcolor{keyword}{typename}\ UpFn>}
\DoxyCodeLine{00603\ \ \ \ \ std::optional<Result>\ TreeEvalMaybe(State\ root\_state,\ DownFn\ downfn,\ UpFn\ upfn)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00604\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{00606\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }StackElem}
\DoxyCodeLine{00607\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00608\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Node\&\ node;\ }
\DoxyCodeLine{00609\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ expanded;\ }
\DoxyCodeLine{00610\ \ \ \ \ \ \ \ \ \ \ \ \ State\ state;\ }
\DoxyCodeLine{00611\ }
\DoxyCodeLine{00612\ \ \ \ \ \ \ \ \ \ \ \ \ StackElem(\textcolor{keyword}{const}\ Node\&\ node\_,\ \textcolor{keywordtype}{size\_t}\ exp\_,\ State\&\&\ state\_)\ :}
\DoxyCodeLine{00613\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node(node\_),\ expanded(exp\_),\ state(std::move(state\_))\ \{\}}
\DoxyCodeLine{00614\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{00615\ \ \ \ \ \ \ \ \ \textcolor{comment}{/*\ Stack\ of\ tree\ nodes\ being\ explored.\ */}}
\DoxyCodeLine{00616\ \ \ \ \ \ \ \ \ std::vector<StackElem>\ stack;}
\DoxyCodeLine{00617\ \ \ \ \ \ \ \ \ \textcolor{comment}{/*\ Results\ of\ subtrees\ so\ far.\ Their\ order\ and\ mapping\ to\ tree\ nodes}}
\DoxyCodeLine{00618\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ is\ implicitly\ defined\ by\ stack.\ */}}
\DoxyCodeLine{00619\ \ \ \ \ \ \ \ \ std::vector<Result>\ results;}
\DoxyCodeLine{00620\ \ \ \ \ \ \ \ \ stack.emplace\_back(*\textcolor{keyword}{this},\ 0,\ std::move(root\_state));}
\DoxyCodeLine{00621\ }
\DoxyCodeLine{00622\ \ \ \ \ \ \ \ \ \textcolor{comment}{/*\ Here\ is\ a\ demonstration\ of\ the\ algorithm,\ for\ an\ example\ tree\ A(B,C(D,E),F).}}
\DoxyCodeLine{00623\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ State\ variables\ are\ omitted\ for\ simplicity.}}
\DoxyCodeLine{00624\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *}}
\DoxyCodeLine{00625\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ First:\ stack=[(A,0)]\ results=[]}}
\DoxyCodeLine{00626\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,1),(B,0)]\ results=[]}}
\DoxyCodeLine{00627\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,1)]\ results=[B]}}
\DoxyCodeLine{00628\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,2),(C,0)]\ results=[B]}}
\DoxyCodeLine{00629\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,2),(C,1),(D,0)]\ results=[B]}}
\DoxyCodeLine{00630\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,2),(C,1)]\ results=[B,D]}}
\DoxyCodeLine{00631\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,2),(C,2),(E,0)]\ results=[B,D]}}
\DoxyCodeLine{00632\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,2),(C,2)]\ results=[B,D,E]}}
\DoxyCodeLine{00633\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,2)]\ results=[B,C]}}
\DoxyCodeLine{00634\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,3),(F,0)]\ results=[B,C]}}
\DoxyCodeLine{00635\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ \ \ \ \ \ \ \ stack=[(A,3)]\ results=[B,C,F]}}
\DoxyCodeLine{00636\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ *\ Final:\ stack=[]\ results=[A]}}
\DoxyCodeLine{00637\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ */}}
\DoxyCodeLine{00638\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (stack.size())\ \{}
\DoxyCodeLine{00639\ \ \ \ \ \ \ \ \ \ \ \ \ const\ Node\&\ node\ =\ stack.back().node;}
\DoxyCodeLine{00640\ \ \ \ \ \ \ \ \ \ \ \ \ if\ (stack.back().expanded\ <\ node.subs.size())\ \{}
\DoxyCodeLine{00641\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{/*\ We\ encounter\ a\ tree\ node\ with\ at\ least\ one\ unexpanded\ child.}}
\DoxyCodeLine{00642\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *\ Expand\ it.\ By\ the\ time\ we\ hit\ this\ node\ again,\ the\ result\ of}}
\DoxyCodeLine{00643\ \textcolor{comment}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *\ that\ child\ (and\ all\ earlier\ children)\ will\ be\ at\ the\ end\ of\ \`{}results`.\ */}}
\DoxyCodeLine{00644\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ size\_t\ child\_index\ =\ stack.back().expanded++;}
\DoxyCodeLine{00645\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ State\ child\_state\ =\ downfn(stack.back().state,\ node,\ child\_index);}
\DoxyCodeLine{00646\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ stack.emplace\_back(*node.subs[child\_index],\ 0,\ std::move(child\_state));}
\DoxyCodeLine{00647\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ continue;}
\DoxyCodeLine{00648\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00649\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Invoke\ upfn\ with\ the\ last\ node.subs.size()\ elements\ of\ results\ as\ input.}}
\DoxyCodeLine{00650\ \ \ \ \ \ \ \ \ \ \ \ \ assert(results.size()\ >=\ node.subs.size());}
\DoxyCodeLine{00651\ \ \ \ \ \ \ \ \ \ \ \ \ std::optional<Result>\ result\{upfn(std::move(stack.back().state),\ node,}
\DoxyCodeLine{00652\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::span<Result>\{results\}.last(node.subs.size()))\};}
\DoxyCodeLine{00653\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ evaluation\ returns\ std::nullopt,\ abort\ immediately.}}
\DoxyCodeLine{00654\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!result)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00655\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Replace\ the\ last\ node.subs.size()\ elements\ of\ results\ with\ the\ new\ result.}}
\DoxyCodeLine{00656\ \ \ \ \ \ \ \ \ \ \ \ \ results.erase(results.end()\ -\/\ node.subs.size(),\ results.end());}
\DoxyCodeLine{00657\ \ \ \ \ \ \ \ \ \ \ \ \ results.push\_back(std::move(*result));}
\DoxyCodeLine{00658\ \ \ \ \ \ \ \ \ \ \ \ \ stack.pop\_back();}
\DoxyCodeLine{00659\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00660\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ final\ remaining\ results\ element\ is\ the\ root\ result,\ return\ it.}}
\DoxyCodeLine{00661\ \ \ \ \ \ \ \ \ assert(results.size()\ >=\ 1);}
\DoxyCodeLine{00662\ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(results.size()\ ==\ 1);}
\DoxyCodeLine{00663\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(results[0]);}
\DoxyCodeLine{00664\ \ \ \ \ \}}
\DoxyCodeLine{00665\ }
\DoxyCodeLine{00668\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Result,\ \textcolor{keyword}{typename}\ UpFn>}
\DoxyCodeLine{00669\ \ \ \ \ std::optional<Result>\ TreeEvalMaybe(UpFn\ upfn)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00670\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{00671\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }DummyState\ \{\};}
\DoxyCodeLine{00672\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEvalMaybe<Result>(DummyState\{\},}
\DoxyCodeLine{00673\ \ \ \ \ \ \ \ \ \ \ \ \ [](DummyState,\ \textcolor{keyword}{const}\ Node\&,\ size\_t)\ \{\ \textcolor{keywordflow}{return}\ DummyState\{\};\ \},}
\DoxyCodeLine{00674\ \ \ \ \ \ \ \ \ \ \ \ \ [\&upfn](DummyState,\ \textcolor{keyword}{const}\ Node\&\ node,\ std::span<Result>\ subs)\ \{}
\DoxyCodeLine{00675\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ upfn(node,\ subs);}
\DoxyCodeLine{00676\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00677\ \ \ \ \ \ \ \ \ );}
\DoxyCodeLine{00678\ \ \ \ \ \}}
\DoxyCodeLine{00679\ }
\DoxyCodeLine{00681\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Result,\ \textcolor{keyword}{typename}\ State,\ \textcolor{keyword}{typename}\ DownFn,\ \textcolor{keyword}{typename}\ UpFn>}
\DoxyCodeLine{00682\ \ \ \ \ Result\ TreeEval(State\ root\_state,\ DownFn\&\&\ downfn,\ UpFn\ upfn)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00683\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{00684\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Invoke\ TreeEvalMaybe\ with\ upfn\ wrapped\ to\ return\ std::optional<Result>,\ and\ then}}
\DoxyCodeLine{00685\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ unconditionally\ dereference\ the\ result\ (it\ cannot\ be\ std::nullopt).}}
\DoxyCodeLine{00686\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(*TreeEvalMaybe<Result>(std::move(root\_state),}
\DoxyCodeLine{00687\ \ \ \ \ \ \ \ \ \ \ \ \ std::forward<DownFn>(downfn),}
\DoxyCodeLine{00688\ \ \ \ \ \ \ \ \ \ \ \ \ [\&upfn](State\&\&\ state,\ \textcolor{keyword}{const}\ Node\&\ node,\ std::span<Result>\ subs)\ \{}
\DoxyCodeLine{00689\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Result\ res\{upfn(std::move(state),\ node,\ subs)\};}
\DoxyCodeLine{00690\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::optional<Result>(std::move(res));}
\DoxyCodeLine{00691\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00692\ \ \ \ \ \ \ \ \ ));}
\DoxyCodeLine{00693\ \ \ \ \ \}}
\DoxyCodeLine{00694\ }
\DoxyCodeLine{00697\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Result,\ \textcolor{keyword}{typename}\ UpFn>}
\DoxyCodeLine{00698\ \ \ \ \ Result\ TreeEval(UpFn\ upfn)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00699\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{00700\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }DummyState\ \{\};}
\DoxyCodeLine{00701\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(*TreeEvalMaybe<Result>(DummyState\{\},}
\DoxyCodeLine{00702\ \ \ \ \ \ \ \ \ \ \ \ \ [](DummyState,\ \textcolor{keyword}{const}\ Node\&,\ size\_t)\ \{\ \textcolor{keywordflow}{return}\ DummyState\{\};\ \},}
\DoxyCodeLine{00703\ \ \ \ \ \ \ \ \ \ \ \ \ [\&upfn](DummyState,\ \textcolor{keyword}{const}\ Node\&\ node,\ std::span<Result>\ subs)\ \{}
\DoxyCodeLine{00704\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Result\ res\{upfn(node,\ subs)\};}
\DoxyCodeLine{00705\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::optional<Result>(std::move(res));}
\DoxyCodeLine{00706\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00707\ \ \ \ \ \ \ \ \ ));}
\DoxyCodeLine{00708\ \ \ \ \ \}}
\DoxyCodeLine{00709\ }
\DoxyCodeLine{00711\ \ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keywordtype}{int}\ Compare(\textcolor{keyword}{const}\ Node<Key>\&\ node1,\ \textcolor{keyword}{const}\ Node<Key>\&\ node2)}
\DoxyCodeLine{00712\ \ \ \ \ \{}
\DoxyCodeLine{00713\ \ \ \ \ \ \ \ \ std::vector<std::pair<const\ Node<Key>\&,\ \textcolor{keyword}{const}\ Node<Key>\&>>\ queue;}
\DoxyCodeLine{00714\ \ \ \ \ \ \ \ \ queue.emplace\_back(node1,\ node2);}
\DoxyCodeLine{00715\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (!queue.empty())\ \{}
\DoxyCodeLine{00716\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [a,\ b]\ =\ queue.back();}
\DoxyCodeLine{00717\ \ \ \ \ \ \ \ \ \ \ \ \ queue.pop\_back();}
\DoxyCodeLine{00718\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (std::tie(a.fragment,\ a.k,\ a.keys,\ a.data)\ <\ std::tie(b.fragment,\ b.k,\ b.keys,\ b.data))\ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{00719\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (std::tie(b.fragment,\ b.k,\ b.keys,\ b.data)\ <\ std::tie(a.fragment,\ a.k,\ a.keys,\ a.data))\ \textcolor{keywordflow}{return}\ 1;}
\DoxyCodeLine{00720\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (a.subs.size()\ <\ b.subs.size())\ \textcolor{keywordflow}{return}\ -\/1;}
\DoxyCodeLine{00721\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (b.subs.size()\ <\ a.subs.size())\ \textcolor{keywordflow}{return}\ 1;}
\DoxyCodeLine{00722\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ n\ =\ a.subs.size();}
\DoxyCodeLine{00723\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ n;\ ++i)\ \{}
\DoxyCodeLine{00724\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ queue.emplace\_back(*a.subs[n\ -\/\ 1\ -\/\ i],\ *b.subs[n\ -\/\ 1\ -\/\ i]);}
\DoxyCodeLine{00725\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00726\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00727\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00728\ \ \ \ \ \}}
\DoxyCodeLine{00729\ }
\DoxyCodeLine{00731\ \ \ \ \ Type\ CalcType()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00732\ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ namespace\ }internal;}
\DoxyCodeLine{00733\ }
\DoxyCodeLine{00734\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ THRESH\ has\ a\ variable\ number\ of\ subexpressions}}
\DoxyCodeLine{00735\ \ \ \ \ \ \ \ \ std::vector<Type>\ sub\_types;}
\DoxyCodeLine{00736\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (fragment\ ==\ Fragment::THRESH)\ \{}
\DoxyCodeLine{00737\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ sub\ :\ subs)\ sub\_types.push\_back(sub-\/>GetType());}
\DoxyCodeLine{00738\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00739\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ All\ other\ nodes\ than\ THRESH\ can\ be\ computed\ just\ from\ the\ types\ of\ the\ 0-\/3\ subexpressions.}}
\DoxyCodeLine{00740\ \ \ \ \ \ \ \ \ Type\ x\ =\ subs.size()\ >\ 0\ ?\ subs[0]-\/>GetType()\ :\ \textcolor{stringliteral}{"{}"{}}\_mst;}
\DoxyCodeLine{00741\ \ \ \ \ \ \ \ \ Type\ y\ =\ subs.size()\ >\ 1\ ?\ subs[1]-\/>GetType()\ :\ \textcolor{stringliteral}{"{}"{}}\_mst;}
\DoxyCodeLine{00742\ \ \ \ \ \ \ \ \ Type\ z\ =\ subs.size()\ >\ 2\ ?\ subs[2]-\/>GetType()\ :\ \textcolor{stringliteral}{"{}"{}}\_mst;}
\DoxyCodeLine{00743\ }
\DoxyCodeLine{00744\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ SanitizeType(ComputeType(fragment,\ x,\ y,\ z,\ sub\_types,\ k,\ data.size(),\ subs.size(),\ keys.size(),\ m\_script\_ctx));}
\DoxyCodeLine{00745\ \ \ \ \ \}}
\DoxyCodeLine{00746\ }
\DoxyCodeLine{00747\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00748\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{00749\ \ \ \ \ CScript\ ToScript(\textcolor{keyword}{const}\ Ctx\&\ ctx)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00750\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{00751\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ To\ construct\ the\ CScript\ for\ a\ Miniscript\ object,\ we\ use\ the\ TreeEval\ algorithm.}}
\DoxyCodeLine{00752\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ State\ is\ a\ boolean:\ whether\ or\ not\ the\ node's\ script\ expansion\ is\ followed}}
\DoxyCodeLine{00753\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ by\ an\ OP\_VERIFY\ (which\ may\ need\ to\ be\ combined\ with\ the\ last\ script\ opcode).}}
\DoxyCodeLine{00754\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ downfn\ =\ [](\textcolor{keywordtype}{bool}\ verify,\ \textcolor{keyword}{const}\ Node\&\ node,\ \textcolor{keywordtype}{size\_t}\ index)\ \{}
\DoxyCodeLine{00755\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ WRAP\_V,\ the\ subexpression\ is\ certainly\ followed\ by\ OP\_VERIFY.}}
\DoxyCodeLine{00756\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.fragment\ ==\ Fragment::WRAP\_V)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00757\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ subexpression\ of\ WRAP\_S,\ and\ the\ last\ subexpression\ of\ AND\_V}}
\DoxyCodeLine{00758\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ inherit\ the\ followed-\/by-\/OP\_VERIFY\ property\ from\ the\ parent.}}
\DoxyCodeLine{00759\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.fragment\ ==\ Fragment::WRAP\_S\ ||}
\DoxyCodeLine{00760\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (node.fragment\ ==\ Fragment::AND\_V\ \&\&\ index\ ==\ 1))\ \textcolor{keywordflow}{return}\ verify;}
\DoxyCodeLine{00761\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{00762\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{00763\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ upward\ function\ computes\ for\ a\ node,\ given\ its\ followed-\/by-\/OP\_VERIFY\ status}}
\DoxyCodeLine{00764\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\ the\ CScripts\ of\ its\ child\ nodes,\ the\ CScript\ of\ the\ node.}}
\DoxyCodeLine{00765\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ is\_tapscript\{IsTapscript(m\_script\_ctx)\};}
\DoxyCodeLine{00766\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ upfn\ =\ [\&ctx,\ is\_tapscript](\textcolor{keywordtype}{bool}\ verify,\ \textcolor{keyword}{const}\ Node\&\ node,\ std::span<CScript>\ subs)\ -\/>\ CScript\ \{}
\DoxyCodeLine{00767\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (node.fragment)\ \{}
\DoxyCodeLine{00768\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:\ \textcolor{keywordflow}{return}\ BuildScript(ctx.ToPKBytes(node.keys[0]));}
\DoxyCodeLine{00769\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_DUP,\ OP\_HASH160,\ ctx.ToPKHBytes(node.keys[0]),\ OP\_EQUALVERIFY);}
\DoxyCodeLine{00770\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:\ \textcolor{keywordflow}{return}\ BuildScript(node.k,\ OP\_CHECKSEQUENCEVERIFY);}
\DoxyCodeLine{00771\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:\ \textcolor{keywordflow}{return}\ BuildScript(node.k,\ OP\_CHECKLOCKTIMEVERIFY);}
\DoxyCodeLine{00772\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_SIZE,\ 32,\ OP\_EQUALVERIFY,\ OP\_SHA256,\ node.data,\ verify\ ?\ OP\_EQUALVERIFY\ :\ OP\_EQUAL);}
\DoxyCodeLine{00773\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_SIZE,\ 32,\ OP\_EQUALVERIFY,\ OP\_RIPEMD160,\ node.data,\ verify\ ?\ OP\_EQUALVERIFY\ :\ OP\_EQUAL);}
\DoxyCodeLine{00774\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_SIZE,\ 32,\ OP\_EQUALVERIFY,\ OP\_HASH256,\ node.data,\ verify\ ?\ OP\_EQUALVERIFY\ :\ OP\_EQUAL);}
\DoxyCodeLine{00775\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_SIZE,\ 32,\ OP\_EQUALVERIFY,\ OP\_HASH160,\ node.data,\ verify\ ?\ OP\_EQUALVERIFY\ :\ OP\_EQUAL);}
\DoxyCodeLine{00776\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_A:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_TOALTSTACK,\ subs[0],\ OP\_FROMALTSTACK);}
\DoxyCodeLine{00777\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_S:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_SWAP,\ subs[0]);}
\DoxyCodeLine{00778\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_C:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ verify\ ?\ OP\_CHECKSIGVERIFY\ :\ OP\_CHECKSIG);}
\DoxyCodeLine{00779\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_D:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_DUP,\ OP\_IF,\ subs[0],\ OP\_ENDIF);}
\DoxyCodeLine{00780\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_V:\ \{}
\DoxyCodeLine{00781\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[0]-\/>GetType()\ <<\ \textcolor{stringliteral}{"{}x"{}}\_mst)\ \{}
\DoxyCodeLine{00782\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ OP\_VERIFY);}
\DoxyCodeLine{00783\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00784\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(subs[0]);}
\DoxyCodeLine{00785\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00786\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00787\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_J:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_SIZE,\ OP\_0NOTEQUAL,\ OP\_IF,\ subs[0],\ OP\_ENDIF);}
\DoxyCodeLine{00788\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_N:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ OP\_0NOTEQUAL);}
\DoxyCodeLine{00789\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_1);}
\DoxyCodeLine{00790\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_0);}
\DoxyCodeLine{00791\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ subs[1]);}
\DoxyCodeLine{00792\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ subs[1],\ OP\_BOOLAND);}
\DoxyCodeLine{00793\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ subs[1],\ OP\_BOOLOR);}
\DoxyCodeLine{00794\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ OP\_IFDUP,\ OP\_NOTIF,\ subs[1],\ OP\_ENDIF);}
\DoxyCodeLine{00795\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ OP\_NOTIF,\ subs[1],\ OP\_ENDIF);}
\DoxyCodeLine{00796\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:\ \textcolor{keywordflow}{return}\ BuildScript(OP\_IF,\ subs[0],\ OP\_ELSE,\ subs[1],\ OP\_ENDIF);}
\DoxyCodeLine{00797\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:\ \textcolor{keywordflow}{return}\ BuildScript(std::move(subs[0]),\ OP\_NOTIF,\ subs[2],\ OP\_ELSE,\ subs[1],\ OP\_ENDIF);}
\DoxyCodeLine{00798\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:\ \{}
\DoxyCodeLine{00799\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(!is\_tapscript);}
\DoxyCodeLine{00800\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CScript\ script\ =\ BuildScript(node.k);}
\DoxyCodeLine{00801\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ key\ :\ node.keys)\ \{}
\DoxyCodeLine{00802\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\ =\ BuildScript(std::move(script),\ ctx.ToPKBytes(key));}
\DoxyCodeLine{00803\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00804\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ BuildScript(std::move(script),\ node.keys.size(),\ verify\ ?\ OP\_CHECKMULTISIGVERIFY\ :\ OP\_CHECKMULTISIG);}
\DoxyCodeLine{00805\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00806\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:\ \{}
\DoxyCodeLine{00807\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(is\_tapscript);}
\DoxyCodeLine{00808\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CScript\ script\ =\ BuildScript(ctx.ToPKBytes(*node.keys.begin()),\ OP\_CHECKSIG);}
\DoxyCodeLine{00809\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ node.keys.begin()\ +\ 1;\ it\ !=\ node.keys.end();\ ++it)\ \{}
\DoxyCodeLine{00810\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\ =\ BuildScript(std::move(script),\ ctx.ToPKBytes(*it),\ OP\_CHECKSIGADD);}
\DoxyCodeLine{00811\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00812\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ BuildScript(std::move(script),\ node.k,\ verify\ ?\ OP\_NUMEQUALVERIFY\ :\ OP\_NUMEQUAL);}
\DoxyCodeLine{00813\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00814\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:\ \{}
\DoxyCodeLine{00815\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CScript\ script\ =\ std::move(subs[0]);}
\DoxyCodeLine{00816\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 1;\ i\ <\ subs.size();\ ++i)\ \{}
\DoxyCodeLine{00817\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\ =\ BuildScript(std::move(script),\ subs[i],\ OP\_ADD);}
\DoxyCodeLine{00818\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00819\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ BuildScript(std::move(script),\ node.k,\ verify\ ?\ OP\_EQUALVERIFY\ :\ OP\_EQUAL);}
\DoxyCodeLine{00820\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00821\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00822\ \ \ \ \ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{00823\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{00824\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEval<CScript>(\textcolor{keyword}{false},\ downfn,\ upfn);}
\DoxyCodeLine{00825\ \ \ \ \ \}}
\DoxyCodeLine{00826\ }
\DoxyCodeLine{00827\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ CTx>}
\DoxyCodeLine{00828\ \ \ \ \ std::optional<std::string>\ ToString(\textcolor{keyword}{const}\ CTx\&\ ctx)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00829\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ To\ construct\ the\ std::string\ representation\ for\ a\ Miniscript\ object,\ we\ use}}
\DoxyCodeLine{00830\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ TreeEvalMaybe\ algorithm.\ The\ State\ is\ a\ boolean:\ whether\ the\ parent\ node\ is\ a}}
\DoxyCodeLine{00831\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ wrapper.\ If\ so,\ non-\/wrapper\ expressions\ must\ be\ prefixed\ with\ a\ "{}:"{}.}}
\DoxyCodeLine{00832\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ downfn\ =\ [](bool,\ \textcolor{keyword}{const}\ Node\&\ node,\ size\_t)\ \{}
\DoxyCodeLine{00833\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (node.fragment\ ==\ Fragment::WRAP\_A\ ||\ node.fragment\ ==\ Fragment::WRAP\_S\ ||}
\DoxyCodeLine{00834\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node.fragment\ ==\ Fragment::WRAP\_D\ ||\ node.fragment\ ==\ Fragment::WRAP\_V\ ||}
\DoxyCodeLine{00835\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node.fragment\ ==\ Fragment::WRAP\_J\ ||\ node.fragment\ ==\ Fragment::WRAP\_N\ ||}
\DoxyCodeLine{00836\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node.fragment\ ==\ Fragment::WRAP\_C\ ||}
\DoxyCodeLine{00837\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (node.fragment\ ==\ Fragment::AND\_V\ \&\&\ node.subs[1]-\/>fragment\ ==\ Fragment::JUST\_1)\ ||}
\DoxyCodeLine{00838\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (node.fragment\ ==\ Fragment::OR\_I\ \&\&\ node.subs[0]-\/>fragment\ ==\ Fragment::JUST\_0)\ ||}
\DoxyCodeLine{00839\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (node.fragment\ ==\ Fragment::OR\_I\ \&\&\ node.subs[1]-\/>fragment\ ==\ Fragment::JUST\_0));}
\DoxyCodeLine{00840\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{00841\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ upward\ function\ computes\ for\ a\ node,\ given\ whether\ its\ parent\ is\ a\ wrapper,}}
\DoxyCodeLine{00842\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\ the\ string\ representations\ of\ its\ child\ nodes,\ the\ string\ representation\ of\ the\ node.}}
\DoxyCodeLine{00843\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ is\_tapscript\{IsTapscript(m\_script\_ctx)\};}
\DoxyCodeLine{00844\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ upfn\ =\ [\&ctx,\ is\_tapscript](\textcolor{keywordtype}{bool}\ wrapped,\ \textcolor{keyword}{const}\ Node\&\ node,\ std::span<std::string>\ subs)\ -\/>\ std::optional<std::string>\ \{}
\DoxyCodeLine{00845\ \ \ \ \ \ \ \ \ \ \ \ \ std::string\ ret\ =\ wrapped\ ?\ \textcolor{stringliteral}{"{}:"{}}\ :\ \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{00846\ }
\DoxyCodeLine{00847\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (node.fragment)\ \{}
\DoxyCodeLine{00848\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_A:\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}a"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00849\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_S:\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}s"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00850\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_C:}
\DoxyCodeLine{00851\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[0]-\/>fragment\ ==\ Fragment::PK\_K)\ \{}
\DoxyCodeLine{00852\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ pk(K)\ is\ syntactic\ sugar\ for\ c:pk\_k(K)}}
\DoxyCodeLine{00853\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\_str\ =\ ctx.ToString(node.subs[0]-\/>keys[0]);}
\DoxyCodeLine{00854\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key\_str)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00855\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}pk("{}}\ +\ std::move(*key\_str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00856\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00857\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[0]-\/>fragment\ ==\ Fragment::PK\_H)\ \{}
\DoxyCodeLine{00858\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ pkh(K)\ is\ syntactic\ sugar\ for\ c:pk\_h(K)}}
\DoxyCodeLine{00859\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\_str\ =\ ctx.ToString(node.subs[0]-\/>keys[0]);}
\DoxyCodeLine{00860\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key\_str)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00861\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}pkh("{}}\ +\ std::move(*key\_str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00862\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00863\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}c"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00864\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_D:\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}d"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_V:\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}v"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00866\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_J:\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}j"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00867\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_N:\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}n"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00868\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:}
\DoxyCodeLine{00869\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ t:X\ is\ syntactic\ sugar\ for\ and\_v(X,1).}}
\DoxyCodeLine{00870\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[1]-\/>fragment\ ==\ Fragment::JUST\_1)\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}t"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00871\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00872\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:}
\DoxyCodeLine{00873\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[0]-\/>fragment\ ==\ Fragment::JUST\_0)\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}l"{}}\ +\ std::move(subs[1]);}
\DoxyCodeLine{00874\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[1]-\/>fragment\ ==\ Fragment::JUST\_0)\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}u"{}}\ +\ std::move(subs[0]);}
\DoxyCodeLine{00875\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00876\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00877\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00878\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (node.fragment)\ \{}
\DoxyCodeLine{00879\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:\ \{}
\DoxyCodeLine{00880\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\_str\ =\ ctx.ToString(node.keys[0]);}
\DoxyCodeLine{00881\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key\_str)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00882\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}pk\_k("{}}\ +\ std::move(*key\_str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00883\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00884\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:\ \{}
\DoxyCodeLine{00885\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\_str\ =\ ctx.ToString(node.keys[0]);}
\DoxyCodeLine{00886\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key\_str)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00887\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}pk\_h("{}}\ +\ std::move(*key\_str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00888\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00889\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}after("{}}\ +\ util::ToString(node.k)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00890\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}older("{}}\ +\ util::ToString(node.k)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00891\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}hash256("{}}\ +\ HexStr(node.data)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00892\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}hash160("{}}\ +\ HexStr(node.data)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00893\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}sha256("{}}\ +\ HexStr(node.data)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00894\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}ripemd160("{}}\ +\ HexStr(node.data)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00895\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}1"{}};}
\DoxyCodeLine{00896\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}0"{}};}
\DoxyCodeLine{00897\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}and\_v("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00898\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}and\_b("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00899\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}or\_b("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00900\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}or\_d("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00901\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}or\_c("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00902\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}or\_i("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00903\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:}
\DoxyCodeLine{00904\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\_n(X,Y)\ is\ syntactic\ sugar\ for\ andor(X,Y,0).}}
\DoxyCodeLine{00905\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.subs[2]-\/>fragment\ ==\ Fragment::JUST\_0)\ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}and\_n("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00906\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}andor("{}}\ +\ std::move(subs[0])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[1])\ +\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(subs[2])\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00907\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:\ \{}
\DoxyCodeLine{00908\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(!is\_tapscript);}
\DoxyCodeLine{00909\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ str\ =\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}multi("{}}\ +\ util::ToString(node.k);}
\DoxyCodeLine{00910\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ key\ :\ node.keys)\ \{}
\DoxyCodeLine{00911\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\_str\ =\ ctx.ToString(key);}
\DoxyCodeLine{00912\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key\_str)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00913\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ str\ +=\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(*key\_str);}
\DoxyCodeLine{00914\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00915\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00916\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00917\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:\ \{}
\DoxyCodeLine{00918\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(is\_tapscript);}
\DoxyCodeLine{00919\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ str\ =\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}multi\_a("{}}\ +\ util::ToString(node.k);}
\DoxyCodeLine{00920\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ key\ :\ node.keys)\ \{}
\DoxyCodeLine{00921\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\_str\ =\ ctx.ToString(key);}
\DoxyCodeLine{00922\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key\_str)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{00923\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ str\ +=\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(*key\_str);}
\DoxyCodeLine{00924\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00925\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00926\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00927\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:\ \{}
\DoxyCodeLine{00928\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ str\ =\ std::move(ret)\ +\ \textcolor{stringliteral}{"{}thresh("{}}\ +\ util::ToString(node.k);}
\DoxyCodeLine{00929\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\&\ sub\ :\ subs)\ \{}
\DoxyCodeLine{00930\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ str\ +=\ \textcolor{stringliteral}{"{},"{}}\ +\ std::move(sub);}
\DoxyCodeLine{00931\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00932\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(str)\ +\ \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{00933\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00934\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00935\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00936\ \ \ \ \ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{00937\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{00938\ }
\DoxyCodeLine{00939\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEvalMaybe<std::string>(\textcolor{keyword}{false},\ downfn,\ upfn);}
\DoxyCodeLine{00940\ \ \ \ \ \}}
\DoxyCodeLine{00941\ }
\DoxyCodeLine{00942\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00943\ \ \ \ \ internal::Ops\ CalcOps()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00944\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (fragment)\ \{}
\DoxyCodeLine{00945\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:\ \textcolor{keywordflow}{return}\ \{0,\ 0,\ \{\}\};}
\DoxyCodeLine{00946\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:\ \textcolor{keywordflow}{return}\ \{0,\ \{\},\ 0\};}
\DoxyCodeLine{00947\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:\ \textcolor{keywordflow}{return}\ \{0,\ 0,\ 0\};}
\DoxyCodeLine{00948\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:\ \textcolor{keywordflow}{return}\ \{3,\ 0,\ 0\};}
\DoxyCodeLine{00949\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:}
\DoxyCodeLine{00950\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:\ \textcolor{keywordflow}{return}\ \{1,\ 0,\ \{\}\};}
\DoxyCodeLine{00951\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:}
\DoxyCodeLine{00952\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:}
\DoxyCodeLine{00953\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:}
\DoxyCodeLine{00954\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:\ \textcolor{keywordflow}{return}\ \{4,\ 0,\ \{\}\};}
\DoxyCodeLine{00955\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count,\ subs[0]-\/>ops.sat\ +\ subs[1]-\/>ops.sat,\ \{\}\};}
\DoxyCodeLine{00956\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:\ \{}
\DoxyCodeLine{00957\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ count\{1\ +\ subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count\};}
\DoxyCodeLine{00958\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{subs[0]-\/>ops.sat\ +\ subs[1]-\/>ops.sat\};}
\DoxyCodeLine{00959\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ops.dsat\ +\ subs[1]-\/>ops.dsat\};}
\DoxyCodeLine{00960\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sat,\ dsat\};}
\DoxyCodeLine{00961\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00962\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:\ \{}
\DoxyCodeLine{00963\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ count\{1\ +\ subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count\};}
\DoxyCodeLine{00964\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{(subs[0]-\/>ops.sat\ +\ subs[1]-\/>ops.dsat)\ |\ (subs[1]-\/>ops.sat\ +\ subs[0]-\/>ops.dsat)\};}
\DoxyCodeLine{00965\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ops.dsat\ +\ subs[1]-\/>ops.dsat\};}
\DoxyCodeLine{00966\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sat,\ dsat\};}
\DoxyCodeLine{00967\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00968\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:\ \{}
\DoxyCodeLine{00969\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ count\{3\ +\ subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count\};}
\DoxyCodeLine{00970\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{subs[0]-\/>ops.sat\ |\ (subs[1]-\/>ops.sat\ +\ subs[0]-\/>ops.dsat)\};}
\DoxyCodeLine{00971\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ops.dsat\ +\ subs[1]-\/>ops.dsat\};}
\DoxyCodeLine{00972\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sat,\ dsat\};}
\DoxyCodeLine{00973\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00974\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:\ \{}
\DoxyCodeLine{00975\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ count\{2\ +\ subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count\};}
\DoxyCodeLine{00976\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{subs[0]-\/>ops.sat\ |\ (subs[1]-\/>ops.sat\ +\ subs[0]-\/>ops.dsat)\};}
\DoxyCodeLine{00977\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sat,\ \{\}\};}
\DoxyCodeLine{00978\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00979\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:\ \{}
\DoxyCodeLine{00980\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ count\{3\ +\ subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count\};}
\DoxyCodeLine{00981\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{subs[0]-\/>ops.sat\ |\ subs[1]-\/>ops.sat\};}
\DoxyCodeLine{00982\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ops.dsat\ |\ subs[1]-\/>ops.dsat\};}
\DoxyCodeLine{00983\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sat,\ dsat\};}
\DoxyCodeLine{00984\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00985\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:\ \{}
\DoxyCodeLine{00986\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ count\{3\ +\ subs[0]-\/>ops.count\ +\ subs[1]-\/>ops.count\ +\ subs[2]-\/>ops.count\};}
\DoxyCodeLine{00987\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{(subs[1]-\/>ops.sat\ +\ subs[0]-\/>ops.sat)\ |\ (subs[0]-\/>ops.dsat\ +\ subs[2]-\/>ops.sat)\};}
\DoxyCodeLine{00988\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ops.dsat\ +\ subs[2]-\/>ops.dsat\};}
\DoxyCodeLine{00989\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sat,\ dsat\};}
\DoxyCodeLine{00990\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00991\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:\ \textcolor{keywordflow}{return}\ \{1,\ (uint32\_t)keys.size(),\ (uint32\_t)keys.size()\};}
\DoxyCodeLine{00992\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:\ \textcolor{keywordflow}{return}\ \{(uint32\_t)keys.size()\ +\ 1,\ 0,\ 0\};}
\DoxyCodeLine{00993\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_S:}
\DoxyCodeLine{00994\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_C:}
\DoxyCodeLine{00995\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_N:\ \textcolor{keywordflow}{return}\ \{1\ +\ subs[0]-\/>ops.count,\ subs[0]-\/>ops.sat,\ subs[0]-\/>ops.dsat\};}
\DoxyCodeLine{00996\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_A:\ \textcolor{keywordflow}{return}\ \{2\ +\ subs[0]-\/>ops.count,\ subs[0]-\/>ops.sat,\ subs[0]-\/>ops.dsat\};}
\DoxyCodeLine{00997\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_D:\ \textcolor{keywordflow}{return}\ \{3\ +\ subs[0]-\/>ops.count,\ subs[0]-\/>ops.sat,\ 0\};}
\DoxyCodeLine{00998\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_J:\ \textcolor{keywordflow}{return}\ \{4\ +\ subs[0]-\/>ops.count,\ subs[0]-\/>ops.sat,\ 0\};}
\DoxyCodeLine{00999\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_V:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ops.count\ +\ (subs[0]-\/>GetType()\ <<\ \textcolor{stringliteral}{"{}x"{}}\_mst),\ subs[0]-\/>ops.sat,\ \{\}\};}
\DoxyCodeLine{01000\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:\ \{}
\DoxyCodeLine{01001\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint32\_t\ count\ =\ 0;}
\DoxyCodeLine{01002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ sats\ =\ Vector(internal::MaxInt<uint32\_t>(0));}
\DoxyCodeLine{01003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ sub\ :\ subs)\ \{}
\DoxyCodeLine{01004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ count\ +=\ sub-\/>ops.count\ +\ 1;}
\DoxyCodeLine{01005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\_sats\ =\ Vector(sats[0]\ +\ sub-\/>ops.dsat);}
\DoxyCodeLine{01006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 1;\ j\ <\ sats.size();\ ++j)\ next\_sats.push\_back((sats[j]\ +\ sub-\/>ops.dsat)\ |\ (sats[j\ -\/\ 1]\ +\ sub-\/>ops.sat));}
\DoxyCodeLine{01007\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(sats[sats.size()\ -\/\ 1]\ +\ sub-\/>ops.sat);}
\DoxyCodeLine{01008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats\ =\ std::move(next\_sats);}
\DoxyCodeLine{01009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(k\ <\ sats.size());}
\DoxyCodeLine{01011\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{count,\ sats[k],\ sats[0]\};}
\DoxyCodeLine{01012\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01013\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01014\ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{01015\ \ \ \ \ \}}
\DoxyCodeLine{01016\ }
\DoxyCodeLine{01017\ \ \ \ \ internal::StackSize\ CalcStackSize()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01018\ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ namespace\ }internal;}
\DoxyCodeLine{01019\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (fragment)\ \{}
\DoxyCodeLine{01020\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:\ \textcolor{keywordflow}{return}\ \{\{\},\ SatInfo::Push()\};}
\DoxyCodeLine{01021\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:\ \textcolor{keywordflow}{return}\ \{SatInfo::Push(),\ \{\}\};}
\DoxyCodeLine{01022\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:}
\DoxyCodeLine{01023\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:\ \textcolor{keywordflow}{return}\ \{SatInfo::Push()\ +\ SatInfo::Nop(),\ \{\}\};}
\DoxyCodeLine{01024\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:\ \textcolor{keywordflow}{return}\ \{SatInfo::Push()\};}
\DoxyCodeLine{01025\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:\ \textcolor{keywordflow}{return}\ \{SatInfo::OP\_DUP()\ +\ SatInfo::Hash()\ +\ SatInfo::Push()\ +\ SatInfo::OP\_EQUALVERIFY()\};}
\DoxyCodeLine{01026\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:}
\DoxyCodeLine{01027\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:}
\DoxyCodeLine{01028\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:}
\DoxyCodeLine{01029\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:\ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01030\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SatInfo::OP\_SIZE()\ +\ SatInfo::Push()\ +\ SatInfo::OP\_EQUALVERIFY()\ +\ SatInfo::Hash()\ +\ SatInfo::Push()\ +\ SatInfo::OP\_EQUAL(),}
\DoxyCodeLine{01031\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\}}
\DoxyCodeLine{01032\ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01033\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:\ \{}
\DoxyCodeLine{01034\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01035\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01036\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ z\{subs[2]-\/>ss\};}
\DoxyCodeLine{01037\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01038\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (x.sat\ +\ SatInfo::If()\ +\ y.sat)\ |\ (x.dsat\ +\ SatInfo::If()\ +\ z.sat),}
\DoxyCodeLine{01039\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x.dsat\ +\ SatInfo::If()\ +\ z.dsat}
\DoxyCodeLine{01040\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01041\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01042\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:\ \{}
\DoxyCodeLine{01043\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01044\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01045\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{x.sat\ +\ y.sat,\ \{\}\};}
\DoxyCodeLine{01046\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01047\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:\ \{}
\DoxyCodeLine{01048\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01049\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01050\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{x.sat\ +\ y.sat\ +\ SatInfo::BinaryOp(),\ x.dsat\ +\ y.dsat\ +\ SatInfo::BinaryOp()\};}
\DoxyCodeLine{01051\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01052\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:\ \{}
\DoxyCodeLine{01053\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01054\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01055\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01056\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ((x.sat\ +\ y.dsat)\ |\ (x.dsat\ +\ y.sat))\ +\ SatInfo::BinaryOp(),}
\DoxyCodeLine{01057\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x.dsat\ +\ y.dsat\ +\ SatInfo::BinaryOp()}
\DoxyCodeLine{01058\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01059\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01060\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:\ \{}
\DoxyCodeLine{01061\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01062\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01063\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{(x.sat\ +\ SatInfo::If())\ |\ (x.dsat\ +\ SatInfo::If()\ +\ y.sat),\ \{\}\};}
\DoxyCodeLine{01064\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01065\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:\ \{}
\DoxyCodeLine{01066\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01067\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01068\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01069\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (x.sat\ +\ SatInfo::OP\_IFDUP(\textcolor{keyword}{true})\ +\ SatInfo::If())\ |\ (x.dsat\ +\ SatInfo::OP\_IFDUP(\textcolor{keyword}{false})\ +\ SatInfo::If()\ +\ y.sat),}
\DoxyCodeLine{01070\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ x.dsat\ +\ SatInfo::OP\_IFDUP(\textcolor{keyword}{false})\ +\ SatInfo::If()\ +\ y.dsat}
\DoxyCodeLine{01071\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01072\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01073\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:\ \{}
\DoxyCodeLine{01074\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ x\{subs[0]-\/>ss\};}
\DoxyCodeLine{01075\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ y\{subs[1]-\/>ss\};}
\DoxyCodeLine{01076\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{SatInfo::If()\ +\ (x.sat\ |\ y.sat),\ SatInfo::If()\ +\ (x.dsat\ |\ y.dsat)\};}
\DoxyCodeLine{01077\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01078\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ multi(k,\ key1,\ key2,\ ...,\ key\_n)\ starts\ off\ with\ k+1\ stack\ elements\ (a\ 0,\ plus\ k}}
\DoxyCodeLine{01079\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ signatures),\ then\ reaches\ n+k+3\ stack\ elements\ after\ pushing\ the\ n\ keys,\ plus\ k\ and}}
\DoxyCodeLine{01080\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ n\ itself,\ and\ ends\ with\ 1\ stack\ element\ (success\ or\ failure).\ Thus,\ it\ net\ removes}}
\DoxyCodeLine{01081\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ k\ elements\ (from\ k+1\ to\ 1),\ while\ reaching\ k+n+2\ more\ than\ it\ ends\ with.}}
\DoxyCodeLine{01082\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:\ \textcolor{keywordflow}{return}\ \{SatInfo(k,\ k\ +\ keys.size()\ +\ 2)\};}
\DoxyCodeLine{01083\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ multi\_a(k,\ key1,\ key2,\ ...,\ key\_n)\ starts\ off\ with\ n\ stack\ elements\ (the}}
\DoxyCodeLine{01084\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ signatures),\ reaches\ 1\ more\ (after\ the\ first\ key\ push),\ and\ ends\ with\ 1.\ Thus\ it\ net}}
\DoxyCodeLine{01085\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ removes\ n-\/1\ elements\ (from\ n\ to\ 1)\ while\ reaching\ n\ more\ than\ it\ ends\ with.}}
\DoxyCodeLine{01086\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:\ \textcolor{keywordflow}{return}\ \{SatInfo(keys.size()\ -\/\ 1,\ keys.size())\};}
\DoxyCodeLine{01087\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_A:}
\DoxyCodeLine{01088\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_N:}
\DoxyCodeLine{01089\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_S:\ \textcolor{keywordflow}{return}\ subs[0]-\/>ss;}
\DoxyCodeLine{01090\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_C:\ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01091\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ subs[0]-\/>ss.sat\ +\ SatInfo::OP\_CHECKSIG(),}
\DoxyCodeLine{01092\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ subs[0]-\/>ss.dsat\ +\ SatInfo::OP\_CHECKSIG()}
\DoxyCodeLine{01093\ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01094\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_D:\ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01095\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SatInfo::OP\_DUP()\ +\ SatInfo::If()\ +\ subs[0]-\/>ss.sat,}
\DoxyCodeLine{01096\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SatInfo::OP\_DUP()\ +\ SatInfo::If()}
\DoxyCodeLine{01097\ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01098\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_V:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ss.sat\ +\ SatInfo::OP\_VERIFY(),\ \{\}\};}
\DoxyCodeLine{01099\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_J:\ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01100\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SatInfo::OP\_SIZE()\ +\ SatInfo::OP\_0NOTEQUAL()\ +\ SatInfo::If()\ +\ subs[0]-\/>ss.sat,}
\DoxyCodeLine{01101\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ SatInfo::OP\_SIZE()\ +\ SatInfo::OP\_0NOTEQUAL()\ +\ SatInfo::If()}
\DoxyCodeLine{01102\ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01103\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:\ \{}
\DoxyCodeLine{01104\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sats[j]\ is\ the\ SatInfo\ corresponding\ to\ all\ traces\ reaching\ j\ satisfactions.}}
\DoxyCodeLine{01105\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ sats\ =\ Vector(SatInfo::Empty());}
\DoxyCodeLine{01106\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ subs.size();\ ++i)\ \{}
\DoxyCodeLine{01107\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Loop\ over\ the\ subexpressions,\ processing\ them\ one\ by\ one.\ After\ adding}}
\DoxyCodeLine{01108\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ element\ i\ we\ need\ to\ add\ OP\_ADD\ (if\ i>0).}}
\DoxyCodeLine{01109\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ add\ =\ i\ ?\ SatInfo::BinaryOp()\ :\ SatInfo::Empty();}
\DoxyCodeLine{01110\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Construct\ a\ variable\ that\ will\ become\ the\ next\ sats,\ starting\ with\ index\ 0.}}
\DoxyCodeLine{01111\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\_sats\ =\ Vector(sats[0]\ +\ subs[i]-\/>ss.dsat\ +\ add);}
\DoxyCodeLine{01112\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Then\ loop\ to\ construct\ next\_sats[1..i].}}
\DoxyCodeLine{01113\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 1;\ j\ <\ sats.size();\ ++j)\ \{}
\DoxyCodeLine{01114\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(((sats[j]\ +\ subs[i]-\/>ss.dsat)\ |\ (sats[j\ -\/\ 1]\ +\ subs[i]-\/>ss.sat))\ +\ add);}
\DoxyCodeLine{01115\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01116\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Finally\ construct\ next\_sats[i+1].}}
\DoxyCodeLine{01117\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(sats[sats.size()\ -\/\ 1]\ +\ subs[i]-\/>ss.sat\ +\ add);}
\DoxyCodeLine{01118\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Switch\ over.}}
\DoxyCodeLine{01119\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats\ =\ std::move(next\_sats);}
\DoxyCodeLine{01120\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01121\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ To\ satisfy\ thresh\ we\ need\ k\ satisfactions;\ to\ dissatisfy\ we\ need\ 0.\ In\ both}}
\DoxyCodeLine{01122\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ cases\ a\ push\ of\ k\ and\ an\ OP\_EQUAL\ follow.}}
\DoxyCodeLine{01123\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{}
\DoxyCodeLine{01124\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats[k]\ +\ SatInfo::Push()\ +\ SatInfo::OP\_EQUAL(),}
\DoxyCodeLine{01125\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats[0]\ +\ SatInfo::Push()\ +\ SatInfo::OP\_EQUAL()}
\DoxyCodeLine{01126\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01127\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01128\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01129\ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{01130\ \ \ \ \ \}}
\DoxyCodeLine{01131\ }
\DoxyCodeLine{01132\ \ \ \ \ internal::WitnessSize\ CalcWitnessSize()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01133\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ sig\_size\ =\ IsTapscript(m\_script\_ctx)\ ?\ 1\ +\ 65\ :\ 1\ +\ 72;}
\DoxyCodeLine{01134\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ uint32\_t\ pubkey\_size\ =\ IsTapscript(m\_script\_ctx)\ ?\ 1\ +\ 32\ :\ 1\ +\ 33;}
\DoxyCodeLine{01135\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (fragment)\ \{}
\DoxyCodeLine{01136\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:\ \textcolor{keywordflow}{return}\ \{\{\},\ 0\};}
\DoxyCodeLine{01137\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:}
\DoxyCodeLine{01138\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:}
\DoxyCodeLine{01139\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:\ \textcolor{keywordflow}{return}\ \{0,\ \{\}\};}
\DoxyCodeLine{01140\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:\ \textcolor{keywordflow}{return}\ \{sig\_size,\ 1\};}
\DoxyCodeLine{01141\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:\ \textcolor{keywordflow}{return}\ \{sig\_size\ +\ pubkey\_size,\ 1\ +\ pubkey\_size\};}
\DoxyCodeLine{01142\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:}
\DoxyCodeLine{01143\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:}
\DoxyCodeLine{01144\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:}
\DoxyCodeLine{01145\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:\ \textcolor{keywordflow}{return}\ \{1\ +\ 32,\ \{\}\};}
\DoxyCodeLine{01146\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:\ \{}
\DoxyCodeLine{01147\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{(subs[0]-\/>ws.sat\ +\ subs[1]-\/>ws.sat)\ |\ (subs[0]-\/>ws.dsat\ +\ subs[2]-\/>ws.sat)\};}
\DoxyCodeLine{01148\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ws.dsat\ +\ subs[2]-\/>ws.dsat\};}
\DoxyCodeLine{01149\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{sat,\ dsat\};}
\DoxyCodeLine{01150\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01151\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ws.sat\ +\ subs[1]-\/>ws.sat,\ \{\}\};}
\DoxyCodeLine{01152\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ws.sat\ +\ subs[1]-\/>ws.sat,\ subs[0]-\/>ws.dsat\ +\ subs[1]-\/>ws.dsat\};}
\DoxyCodeLine{01153\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:\ \{}
\DoxyCodeLine{01154\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ sat\{(subs[0]-\/>ws.dsat\ +\ subs[1]-\/>ws.sat)\ |\ (subs[0]-\/>ws.sat\ +\ subs[1]-\/>ws.dsat)\};}
\DoxyCodeLine{01155\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ dsat\{subs[0]-\/>ws.dsat\ +\ subs[1]-\/>ws.dsat\};}
\DoxyCodeLine{01156\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{sat,\ dsat\};}
\DoxyCodeLine{01157\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01158\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ws.sat\ |\ (subs[0]-\/>ws.dsat\ +\ subs[1]-\/>ws.sat),\ \{\}\};}
\DoxyCodeLine{01159\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ws.sat\ |\ (subs[0]-\/>ws.dsat\ +\ subs[1]-\/>ws.sat),\ subs[0]-\/>ws.dsat\ +\ subs[1]-\/>ws.dsat\};}
\DoxyCodeLine{01160\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:\ \textcolor{keywordflow}{return}\ \{(subs[0]-\/>ws.sat\ +\ 1\ +\ 1)\ |\ (subs[1]-\/>ws.sat\ +\ 1),\ (subs[0]-\/>ws.dsat\ +\ 1\ +\ 1)\ |\ (subs[1]-\/>ws.dsat\ +\ 1)\};}
\DoxyCodeLine{01161\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:\ \textcolor{keywordflow}{return}\ \{k\ *\ sig\_size\ +\ 1,\ k\ +\ 1\};}
\DoxyCodeLine{01162\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:\ \textcolor{keywordflow}{return}\ \{k\ *\ sig\_size\ +\ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(keys.size())\ -\/\ k,\ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(keys.size())\};}
\DoxyCodeLine{01163\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_A:}
\DoxyCodeLine{01164\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_N:}
\DoxyCodeLine{01165\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_S:}
\DoxyCodeLine{01166\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_C:\ \textcolor{keywordflow}{return}\ subs[0]-\/>ws;}
\DoxyCodeLine{01167\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_D:\ \textcolor{keywordflow}{return}\ \{1\ +\ 1\ +\ subs[0]-\/>ws.sat,\ 1\};}
\DoxyCodeLine{01168\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_V:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ws.sat,\ \{\}\};}
\DoxyCodeLine{01169\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_J:\ \textcolor{keywordflow}{return}\ \{subs[0]-\/>ws.sat,\ 1\};}
\DoxyCodeLine{01170\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:\ \{}
\DoxyCodeLine{01171\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ sats\ =\ Vector(internal::MaxInt<uint32\_t>(0));}
\DoxyCodeLine{01172\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ sub\ :\ subs)\ \{}
\DoxyCodeLine{01173\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ next\_sats\ =\ Vector(sats[0]\ +\ sub-\/>ws.dsat);}
\DoxyCodeLine{01174\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 1;\ j\ <\ sats.size();\ ++j)\ next\_sats.push\_back((sats[j]\ +\ sub-\/>ws.dsat)\ |\ (sats[j\ -\/\ 1]\ +\ sub-\/>ws.sat));}
\DoxyCodeLine{01175\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(sats[sats.size()\ -\/\ 1]\ +\ sub-\/>ws.sat);}
\DoxyCodeLine{01176\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats\ =\ std::move(next\_sats);}
\DoxyCodeLine{01177\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01178\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(k\ <\ sats.size());}
\DoxyCodeLine{01179\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{sats[k],\ sats[0]\};}
\DoxyCodeLine{01180\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01181\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01182\ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{01183\ \ \ \ \ \}}
\DoxyCodeLine{01184\ }
\DoxyCodeLine{01185\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{01186\ \ \ \ \ internal::InputResult\ ProduceInput(\textcolor{keyword}{const}\ Ctx\&\ ctx)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01187\ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ namespace\ }internal;}
\DoxyCodeLine{01188\ }
\DoxyCodeLine{01189\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Internal\ function\ which\ is\ invoked\ for\ every\ tree\ node,\ constructing\ satisfaction/dissatisfactions}}
\DoxyCodeLine{01190\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ given\ those\ of\ its\ subnodes.}}
\DoxyCodeLine{01191\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ helper\ =\ [\&ctx](\textcolor{keyword}{const}\ Node\&\ node,\ std::span<InputResult>\ subres)\ -\/>\ InputResult\ \{}
\DoxyCodeLine{01192\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (node.fragment)\ \{}
\DoxyCodeLine{01193\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:\ \{}
\DoxyCodeLine{01194\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ sig;}
\DoxyCodeLine{01195\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.Sign(node.keys[0],\ sig);}
\DoxyCodeLine{01196\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO,\ InputStack(std::move(sig)).SetWithSig().SetAvailable(avail)\};}
\DoxyCodeLine{01197\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01198\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:\ \{}
\DoxyCodeLine{01199\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ key\ =\ ctx.ToPKBytes(node.keys[0]),\ sig;}
\DoxyCodeLine{01200\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.Sign(node.keys[0],\ sig);}
\DoxyCodeLine{01201\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO\ +\ InputStack(key),\ (InputStack(std::move(sig)).SetWithSig()\ +\ InputStack(key)).SetAvailable(avail)\};}
\DoxyCodeLine{01202\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01203\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:\ \{}
\DoxyCodeLine{01204\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sats[j]\ represents\ the\ best\ stack\ containing\ j\ valid\ signatures\ (out\ of\ the\ first\ i\ keys).}}
\DoxyCodeLine{01205\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ In\ the\ loop\ below,\ these\ stacks\ are\ built\ up\ using\ a\ dynamic\ programming\ approach.}}
\DoxyCodeLine{01206\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<InputStack>\ sats\ =\ Vector(EMPTY);}
\DoxyCodeLine{01207\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ node.keys.size();\ ++i)\ \{}
\DoxyCodeLine{01208\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ the\ signature\ for\ the\ i'th\ key\ in\ reverse\ order\ (the\ signature\ for\ the\ first\ key\ needs\ to}}
\DoxyCodeLine{01209\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ be\ at\ the\ top\ of\ the\ stack,\ contrary\ to\ CHECKMULTISIG's\ satisfaction).}}
\DoxyCodeLine{01210\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ sig;}
\DoxyCodeLine{01211\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.Sign(node.keys[node.keys.size()\ -\/\ 1\ -\/\ i],\ sig);}
\DoxyCodeLine{01212\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Compute\ signature\ stack\ for\ just\ this\ key.}}
\DoxyCodeLine{01213\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ sat\ =\ InputStack(std::move(sig)).SetWithSig().SetAvailable(avail);}
\DoxyCodeLine{01214\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Compute\ the\ next\ sats\ vector:\ next\_sats[0]\ is\ a\ copy\ of\ sats[0]\ (no\ signatures).\ All\ further}}
\DoxyCodeLine{01215\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ next\_sats[j]\ are\ equal\ to\ either\ the\ existing\ sats[j]\ +\ ZERO,\ or\ sats[j-\/1]\ plus\ a\ signature}}
\DoxyCodeLine{01216\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ for\ the\ current\ (i'th)\ key.\ The\ very\ last\ element\ needs\ all\ signatures\ filled.}}
\DoxyCodeLine{01217\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<InputStack>\ next\_sats;}
\DoxyCodeLine{01218\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(sats[0]\ +\ ZERO);}
\DoxyCodeLine{01219\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 1;\ j\ <\ sats.size();\ ++j)\ next\_sats.push\_back((sats[j]\ +\ ZERO)\ |\ (std::move(sats[j\ -\/\ 1])\ +\ sat));}
\DoxyCodeLine{01220\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(std::move(sats[sats.size()\ -\/\ 1])\ +\ std::move(sat));}
\DoxyCodeLine{01221\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Switch\ over.}}
\DoxyCodeLine{01222\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats\ =\ std::move(next\_sats);}
\DoxyCodeLine{01223\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01224\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ dissatisfaction\ consists\ of\ as\ many\ empty\ vectors\ as\ there\ are\ keys,\ which\ is\ the\ same\ as}}
\DoxyCodeLine{01225\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ satisfying\ 0\ keys.}}
\DoxyCodeLine{01226\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ nsat\{sats[0]\};}
\DoxyCodeLine{01227\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(node.k\ !=\ 0);}
\DoxyCodeLine{01228\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(node.k\ <\ sats.size());}
\DoxyCodeLine{01229\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{std::move(nsat),\ std::move(sats[node.k])\};}
\DoxyCodeLine{01230\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01231\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:\ \{}
\DoxyCodeLine{01232\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sats[j]\ represents\ the\ best\ stack\ containing\ j\ valid\ signatures\ (out\ of\ the\ first\ i\ keys).}}
\DoxyCodeLine{01233\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ In\ the\ loop\ below,\ these\ stacks\ are\ built\ up\ using\ a\ dynamic\ programming\ approach.}}
\DoxyCodeLine{01234\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sats[0]\ starts\ off\ being\ \{0\},\ due\ to\ the\ CHECKMULTISIG\ bug\ that\ pops\ off\ one\ element\ too\ many.}}
\DoxyCodeLine{01235\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<InputStack>\ sats\ =\ Vector(ZERO);}
\DoxyCodeLine{01236\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ node.keys.size();\ ++i)\ \{}
\DoxyCodeLine{01237\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ sig;}
\DoxyCodeLine{01238\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.Sign(node.keys[i],\ sig);}
\DoxyCodeLine{01239\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Compute\ signature\ stack\ for\ just\ the\ i'th\ key.}}
\DoxyCodeLine{01240\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ sat\ =\ InputStack(std::move(sig)).SetWithSig().SetAvailable(avail);}
\DoxyCodeLine{01241\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Compute\ the\ next\ sats\ vector:\ next\_sats[0]\ is\ a\ copy\ of\ sats[0]\ (no\ signatures).\ All\ further}}
\DoxyCodeLine{01242\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ next\_sats[j]\ are\ equal\ to\ either\ the\ existing\ sats[j],\ or\ sats[j-\/1]\ plus\ a\ signature\ for\ the}}
\DoxyCodeLine{01243\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ current\ (i'th)\ key.\ The\ very\ last\ element\ needs\ all\ signatures\ filled.}}
\DoxyCodeLine{01244\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<InputStack>\ next\_sats;}
\DoxyCodeLine{01245\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(sats[0]);}
\DoxyCodeLine{01246\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 1;\ j\ <\ sats.size();\ ++j)\ next\_sats.push\_back(sats[j]\ |\ (std::move(sats[j\ -\/\ 1])\ +\ sat));}
\DoxyCodeLine{01247\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(std::move(sats[sats.size()\ -\/\ 1])\ +\ std::move(sat));}
\DoxyCodeLine{01248\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Switch\ over.}}
\DoxyCodeLine{01249\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats\ =\ std::move(next\_sats);}
\DoxyCodeLine{01250\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01251\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ dissatisfaction\ consists\ of\ k+1\ stack\ elements\ all\ equal\ to\ 0.}}
\DoxyCodeLine{01252\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputStack\ nsat\ =\ ZERO;}
\DoxyCodeLine{01253\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ node.k;\ ++i)\ nsat\ =\ std::move(nsat)\ +\ ZERO;}
\DoxyCodeLine{01254\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(node.k\ <\ sats.size());}
\DoxyCodeLine{01255\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{std::move(nsat),\ std::move(sats[node.k])\};}
\DoxyCodeLine{01256\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01257\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:\ \{}
\DoxyCodeLine{01258\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sats[k]\ represents\ the\ best\ stack\ that\ satisfies\ k\ out\ of\ the\ *last*\ i\ subexpressions.}}
\DoxyCodeLine{01259\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ In\ the\ loop\ below,\ these\ stacks\ are\ built\ up\ using\ a\ dynamic\ programming\ approach.}}
\DoxyCodeLine{01260\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ sats[0]\ starts\ off\ empty.}}
\DoxyCodeLine{01261\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<InputStack>\ sats\ =\ Vector(EMPTY);}
\DoxyCodeLine{01262\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ subres.size();\ ++i)\ \{}
\DoxyCodeLine{01263\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Introduce\ an\ alias\ for\ the\ i'th\ last\ satisfaction/dissatisfaction.}}
\DoxyCodeLine{01264\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ res\ =\ subres[subres.size()\ -\/\ i\ -\/\ 1];}
\DoxyCodeLine{01265\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Compute\ the\ next\ sats\ vector:\ next\_sats[0]\ is\ sats[0]\ plus\ res.nsat\ (thus\ containing\ all\ dissatisfactions}}
\DoxyCodeLine{01266\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ so\ far.\ next\_sats[j]\ is\ either\ sats[j]\ +\ res.nsat\ (reusing\ j\ earlier\ satisfactions)\ or\ sats[j-\/1]\ +\ res.sat}}
\DoxyCodeLine{01267\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ (reusing\ j-\/1\ earlier\ satisfactions\ plus\ a\ new\ one).\ The\ very\ last\ next\_sats[j]\ is\ all\ satisfactions.}}
\DoxyCodeLine{01268\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<InputStack>\ next\_sats;}
\DoxyCodeLine{01269\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(sats[0]\ +\ res.nsat);}
\DoxyCodeLine{01270\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 1;\ j\ <\ sats.size();\ ++j)\ next\_sats.push\_back((sats[j]\ +\ res.nsat)\ |\ (std::move(sats[j\ -\/\ 1])\ +\ res.sat));}
\DoxyCodeLine{01271\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ next\_sats.push\_back(std::move(sats[sats.size()\ -\/\ 1])\ +\ std::move(res.sat));}
\DoxyCodeLine{01272\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Switch\ over.}}
\DoxyCodeLine{01273\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sats\ =\ std::move(next\_sats);}
\DoxyCodeLine{01274\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01275\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ At\ this\ point,\ sats[k].sat\ is\ the\ best\ satisfaction\ for\ the\ overall\ thresh()\ node.\ The\ best\ dissatisfaction}}
\DoxyCodeLine{01276\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ is\ computed\ by\ gathering\ all\ sats[i].nsat\ for\ i\ !=\ k.}}
\DoxyCodeLine{01277\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputStack\ nsat\ =\ INVALID;}
\DoxyCodeLine{01278\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 0;\ i\ <\ sats.size();\ ++i)\ \{}
\DoxyCodeLine{01279\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ i==k\ is\ the\ satisfaction;\ i==0\ is\ the\ canonical\ dissatisfaction;}}
\DoxyCodeLine{01280\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ rest\ are\ non-\/canonical\ (a\ no-\/signature\ dissatisfaction\ -\/\ the\ i=0}}
\DoxyCodeLine{01281\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ form\ -\/\ is\ always\ available)\ and\ malleable\ (due\ to\ overcompleteness).}}
\DoxyCodeLine{01282\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Marking\ the\ solutions\ malleable\ here\ is\ not\ strictly\ necessary,\ as\ they}}
\DoxyCodeLine{01283\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ should\ already\ never\ be\ picked\ in\ non-\/malleable\ solutions\ due\ to\ the}}
\DoxyCodeLine{01284\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ availability\ of\ the\ i=0\ form.}}
\DoxyCodeLine{01285\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ 0\ \&\&\ i\ !=\ node.k)\ sats[i].SetMalleable().SetNonCanon();}
\DoxyCodeLine{01286\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Include\ all\ dissatisfactions\ (even\ these\ non-\/canonical\ ones)\ in\ nsat.}}
\DoxyCodeLine{01287\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (i\ !=\ node.k)\ nsat\ =\ std::move(nsat)\ |\ std::move(sats[i]);}
\DoxyCodeLine{01288\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01289\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(node.k\ <\ sats.size());}
\DoxyCodeLine{01290\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{std::move(nsat),\ std::move(sats[node.k])\};}
\DoxyCodeLine{01291\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01292\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:\ \{}
\DoxyCodeLine{01293\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{INVALID,\ ctx.CheckOlder(node.k)\ ?\ EMPTY\ :\ INVALID\};}
\DoxyCodeLine{01294\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01295\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:\ \{}
\DoxyCodeLine{01296\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{INVALID,\ ctx.CheckAfter(node.k)\ ?\ EMPTY\ :\ INVALID\};}
\DoxyCodeLine{01297\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01298\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:\ \{}
\DoxyCodeLine{01299\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ preimage;}
\DoxyCodeLine{01300\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.SatSHA256(node.data,\ preimage);}
\DoxyCodeLine{01301\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO32,\ InputStack(std::move(preimage)).SetAvailable(avail)\};}
\DoxyCodeLine{01302\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01303\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:\ \{}
\DoxyCodeLine{01304\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ preimage;}
\DoxyCodeLine{01305\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.SatRIPEMD160(node.data,\ preimage);}
\DoxyCodeLine{01306\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO32,\ InputStack(std::move(preimage)).SetAvailable(avail)\};}
\DoxyCodeLine{01307\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01308\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:\ \{}
\DoxyCodeLine{01309\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ preimage;}
\DoxyCodeLine{01310\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.SatHASH256(node.data,\ preimage);}
\DoxyCodeLine{01311\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO32,\ InputStack(std::move(preimage)).SetAvailable(avail)\};}
\DoxyCodeLine{01312\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01313\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:\ \{}
\DoxyCodeLine{01314\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<unsigned\ char>\ preimage;}
\DoxyCodeLine{01315\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Availability\ avail\ =\ ctx.SatHASH160(node.data,\ preimage);}
\DoxyCodeLine{01316\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO32,\ InputStack(std::move(preimage)).SetAvailable(avail)\};}
\DoxyCodeLine{01317\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01318\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:\ \{}
\DoxyCodeLine{01319\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&y\ =\ subres[1];}
\DoxyCodeLine{01320\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ As\ the\ dissatisfaction\ here\ only\ consist\ of\ a\ single\ option,\ it\ doesn't}}
\DoxyCodeLine{01321\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ actually\ need\ to\ be\ listed\ (it's\ not\ required\ for\ reasoning\ about\ malleability\ of}}
\DoxyCodeLine{01322\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ other\ options),\ and\ is\ never\ required\ (no\ valid\ miniscript\ relies\ on\ the\ ability}}
\DoxyCodeLine{01323\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ satisfy\ the\ type\ V\ left\ subexpression).\ It's\ still\ listed\ here\ for}}
\DoxyCodeLine{01324\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ completeness,\ as\ a\ hypothetical\ (not\ currently\ implemented)\ satisfier\ that\ doesn't}}
\DoxyCodeLine{01325\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ care\ about\ malleability\ might\ in\ some\ cases\ prefer\ it\ still.}}
\DoxyCodeLine{01326\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{(y.nsat\ +\ x.sat).SetNonCanon(),\ y.sat\ +\ x.sat\};}
\DoxyCodeLine{01327\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01328\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:\ \{}
\DoxyCodeLine{01329\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&y\ =\ subres[1];}
\DoxyCodeLine{01330\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Note\ that\ it\ is\ not\ strictly\ necessary\ to\ mark\ the\ 2nd\ and\ 3rd\ dissatisfaction\ here}}
\DoxyCodeLine{01331\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ as\ malleable.\ While\ they\ are\ definitely\ malleable,\ they\ are\ also\ non-\/canonical\ due}}
\DoxyCodeLine{01332\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ to\ the\ guaranteed\ existence\ of\ a\ no-\/signature\ other\ dissatisfaction\ (the\ 1st)}}
\DoxyCodeLine{01333\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ option.\ Because\ of\ that,\ the\ 2nd\ and\ 3rd\ option\ will\ never\ be\ chosen,\ even\ if\ they}}
\DoxyCodeLine{01334\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ weren't\ marked\ as\ malleable.}}
\DoxyCodeLine{01335\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{(y.nsat\ +\ x.nsat)\ |\ (y.sat\ +\ x.nsat).SetMalleable().SetNonCanon()\ |\ (y.nsat\ +\ x.sat).SetMalleable().SetNonCanon(),\ y.sat\ +\ x.sat\};}
\DoxyCodeLine{01336\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01337\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:\ \{}
\DoxyCodeLine{01338\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&z\ =\ subres[1];}
\DoxyCodeLine{01339\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ (sat(Z)\ sat(X))\ solution\ is\ overcomplete\ (attacker\ can\ change\ either\ into\ dsat).}}
\DoxyCodeLine{01340\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{z.nsat\ +\ x.nsat,\ (z.nsat\ +\ x.sat)\ |\ (z.sat\ +\ x.nsat)\ |\ (z.sat\ +\ x.sat).SetMalleable().SetNonCanon()\};}
\DoxyCodeLine{01341\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01342\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:\ \{}
\DoxyCodeLine{01343\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&z\ =\ subres[1];}
\DoxyCodeLine{01344\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{INVALID,\ std::move(x.sat)\ |\ (z.sat\ +\ x.nsat)\};}
\DoxyCodeLine{01345\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01346\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:\ \{}
\DoxyCodeLine{01347\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&z\ =\ subres[1];}
\DoxyCodeLine{01348\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{z.nsat\ +\ x.nsat,\ std::move(x.sat)\ |\ (z.sat\ +\ x.nsat)\};}
\DoxyCodeLine{01349\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01350\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:\ \{}
\DoxyCodeLine{01351\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&z\ =\ subres[1];}
\DoxyCodeLine{01352\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{(x.nsat\ +\ ONE)\ |\ (z.nsat\ +\ ZERO),\ (x.sat\ +\ ONE)\ |\ (z.sat\ +\ ZERO)\};}
\DoxyCodeLine{01353\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01354\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:\ \{}
\DoxyCodeLine{01355\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ x\ =\ subres[0],\ \&y\ =\ subres[1],\ \&z\ =\ subres[2];}
\DoxyCodeLine{01356\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{(y.nsat\ +\ x.sat).SetNonCanon()\ |\ (z.nsat\ +\ x.nsat),\ (y.sat\ +\ x.sat)\ |\ (z.sat\ +\ x.nsat)\};}
\DoxyCodeLine{01357\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01358\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_A:}
\DoxyCodeLine{01359\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_S:}
\DoxyCodeLine{01360\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_C:}
\DoxyCodeLine{01361\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_N:}
\DoxyCodeLine{01362\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(subres[0]);}
\DoxyCodeLine{01363\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_D:\ \{}
\DoxyCodeLine{01364\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ \&x\ =\ subres[0];}
\DoxyCodeLine{01365\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{ZERO,\ x.sat\ +\ ONE\};}
\DoxyCodeLine{01366\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01367\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_J:\ \{}
\DoxyCodeLine{01368\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ \&x\ =\ subres[0];}
\DoxyCodeLine{01369\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ a\ dissatisfaction\ with\ a\ nonzero\ top\ stack\ element\ exists,\ an\ alternative\ dissatisfaction\ exists.}}
\DoxyCodeLine{01370\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ As\ the\ dissatisfaction\ logic\ currently\ doesn't\ keep\ track\ of\ this\ nonzeroness\ property,\ and\ thus\ even}}
\DoxyCodeLine{01371\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ if\ a\ dissatisfaction\ with\ a\ top\ zero\ element\ is\ found,\ we\ don't\ know\ whether\ another\ one\ with\ a}}
\DoxyCodeLine{01372\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ nonzero\ top\ stack\ element\ exists.\ Make\ the\ conservative\ assumption\ that\ whenever\ the\ subexpression\ is\ weakly}}
\DoxyCodeLine{01373\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ dissatisfiable,\ this\ alternative\ dissatisfaction\ exists\ and\ leads\ to\ malleability.}}
\DoxyCodeLine{01374\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{InputStack(ZERO).SetMalleable(x.nsat.available\ !=\ Availability::NO\ \&\&\ !x.nsat.has\_sig),\ std::move(x.sat)\};}
\DoxyCodeLine{01375\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01376\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::WRAP\_V:\ \{}
\DoxyCodeLine{01377\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ \&x\ =\ subres[0];}
\DoxyCodeLine{01378\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{INVALID,\ std::move(x.sat)\};}
\DoxyCodeLine{01379\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01380\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:\ \textcolor{keywordflow}{return}\ \{EMPTY,\ INVALID\};}
\DoxyCodeLine{01381\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:\ \textcolor{keywordflow}{return}\ \{INVALID,\ EMPTY\};}
\DoxyCodeLine{01382\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01383\ \ \ \ \ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false});}
\DoxyCodeLine{01384\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{INVALID,\ INVALID\};}
\DoxyCodeLine{01385\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01386\ }
\DoxyCodeLine{01387\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ tester\ =\ [\&helper](\textcolor{keyword}{const}\ Node\&\ node,\ std::span<InputResult>\ subres)\ -\/>\ InputResult\ \{}
\DoxyCodeLine{01388\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ ret\ =\ helper(node,\ subres);}
\DoxyCodeLine{01389\ }
\DoxyCodeLine{01390\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Do\ a\ consistency\ check\ between\ the\ satisfaction\ code\ and\ the\ type\ checker}}
\DoxyCodeLine{01391\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ (the\ actual\ satisfaction\ code\ in\ ProduceInputHelper\ does\ not\ use\ GetType)}}
\DoxyCodeLine{01392\ }
\DoxyCodeLine{01393\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ 'z'\ nodes,\ available\ satisfactions/dissatisfactions\ must\ have\ stack\ size\ 0.}}
\DoxyCodeLine{01394\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}z"{}}\_mst\ \&\&\ ret.nsat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.nsat.stack.size()\ ==\ 0);}
\DoxyCodeLine{01395\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}z"{}}\_mst\ \&\&\ ret.sat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.sat.stack.size()\ ==\ 0);}
\DoxyCodeLine{01396\ }
\DoxyCodeLine{01397\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ 'o'\ nodes,\ available\ satisfactions/dissatisfactions\ must\ have\ stack\ size\ 1.}}
\DoxyCodeLine{01398\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}o"{}}\_mst\ \&\&\ ret.nsat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.nsat.stack.size()\ ==\ 1);}
\DoxyCodeLine{01399\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}o"{}}\_mst\ \&\&\ ret.sat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.sat.stack.size()\ ==\ 1);}
\DoxyCodeLine{01400\ }
\DoxyCodeLine{01401\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ 'n'\ nodes,\ available\ satisfactions/dissatisfactions\ must\ have\ stack\ size\ 1\ or\ larger.\ For\ satisfactions,}}
\DoxyCodeLine{01402\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ the\ top\ element\ cannot\ be\ 0.}}
\DoxyCodeLine{01403\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}n"{}}\_mst\ \&\&\ ret.sat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.sat.stack.size()\ >=\ 1);}
\DoxyCodeLine{01404\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}n"{}}\_mst\ \&\&\ ret.nsat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.nsat.stack.size()\ >=\ 1);}
\DoxyCodeLine{01405\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}n"{}}\_mst\ \&\&\ ret.sat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(!ret.sat.stack.back().empty());}
\DoxyCodeLine{01406\ }
\DoxyCodeLine{01407\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ 'd'\ nodes,\ a\ dissatisfaction\ must\ exist,\ and\ they\ must\ not\ need\ a\ signature.\ If\ it\ is\ non-\/malleable,}}
\DoxyCodeLine{01408\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ it\ must\ be\ canonical.}}
\DoxyCodeLine{01409\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}d"{}}\_mst)\ CHECK\_NONFATAL(ret.nsat.available\ !=\ Availability::NO);}
\DoxyCodeLine{01410\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}d"{}}\_mst)\ CHECK\_NONFATAL(!ret.nsat.has\_sig);}
\DoxyCodeLine{01411\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}d"{}}\_mst\ \&\&\ !ret.nsat.malleable)\ CHECK\_NONFATAL(!ret.nsat.non\_canon);}
\DoxyCodeLine{01412\ }
\DoxyCodeLine{01413\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ 'f'/'s'\ nodes,\ dissatisfactions/satisfactions\ must\ have\ a\ signature.}}
\DoxyCodeLine{01414\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}f"{}}\_mst\ \&\&\ ret.nsat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.nsat.has\_sig);}
\DoxyCodeLine{01415\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}s"{}}\_mst\ \&\&\ ret.sat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(ret.sat.has\_sig);}
\DoxyCodeLine{01416\ }
\DoxyCodeLine{01417\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ non-\/malleable\ 'e'\ nodes,\ a\ non-\/malleable\ dissatisfaction\ must\ exist.}}
\DoxyCodeLine{01418\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}me"{}}\_mst)\ CHECK\_NONFATAL(ret.nsat.available\ !=\ Availability::NO);}
\DoxyCodeLine{01419\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}me"{}}\_mst)\ CHECK\_NONFATAL(!ret.nsat.malleable);}
\DoxyCodeLine{01420\ }
\DoxyCodeLine{01421\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ For\ 'm'\ nodes,\ if\ a\ satisfaction\ exists,\ it\ must\ be\ non-\/malleable.}}
\DoxyCodeLine{01422\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.GetType()\ <<\ \textcolor{stringliteral}{"{}m"{}}\_mst\ \&\&\ ret.sat.available\ !=\ Availability::NO)\ CHECK\_NONFATAL(!ret.sat.malleable);}
\DoxyCodeLine{01423\ }
\DoxyCodeLine{01424\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ a\ non-\/malleable\ satisfaction\ exists,\ it\ must\ be\ canonical.}}
\DoxyCodeLine{01425\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ret.sat.available\ !=\ Availability::NO\ \&\&\ !ret.sat.malleable)\ CHECK\_NONFATAL(!ret.sat.non\_canon);}
\DoxyCodeLine{01426\ }
\DoxyCodeLine{01427\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{01428\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01429\ }
\DoxyCodeLine{01430\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEval<InputResult>(tester);}
\DoxyCodeLine{01431\ \ \ \ \ \}}
\DoxyCodeLine{01432\ }
\DoxyCodeLine{01433\ \textcolor{keyword}{public}:}
\DoxyCodeLine{01439\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>\ \textcolor{keywordtype}{void}\ DuplicateKeyCheck(\textcolor{keyword}{const}\ Ctx\&\ ctx)\textcolor{keyword}{\ const}}
\DoxyCodeLine{01440\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{01441\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ We\ cannot\ use\ a\ lambda\ here,\ as\ lambdas\ are\ non\ assignable,\ and\ the\ set\ operations}}
\DoxyCodeLine{01442\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ below\ require\ moving\ the\ comparators\ around.}}
\DoxyCodeLine{01443\ \ \ \ \ \ \ \ \ \textcolor{keyword}{struct\ }Comp\ \{}
\DoxyCodeLine{01444\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Ctx*\ ctx\_ptr;}
\DoxyCodeLine{01445\ \ \ \ \ \ \ \ \ \ \ \ \ Comp(\textcolor{keyword}{const}\ Ctx\&\ ctx)\ :\ ctx\_ptr(\&ctx)\ \{\}}
\DoxyCodeLine{01446\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ operator()(\textcolor{keyword}{const}\ Key\&\ a,\ \textcolor{keyword}{const}\ Key\&\ b)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ ctx\_ptr-\/>KeyCompare(a,\ b);\ \}}
\DoxyCodeLine{01447\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01448\ }
\DoxyCodeLine{01449\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ state\ in\ the\ recursive\ computation:}}
\DoxyCodeLine{01450\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ -\/\ std::nullopt\ means\ "{}this\ node\ has\ duplicates"{}}}
\DoxyCodeLine{01451\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ -\/\ an\ std::set\ means\ "{}this\ node\ has\ no\ duplicate\ keys,\ and\ they\ are:\ ..."{}.}}
\DoxyCodeLine{01452\ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }keyset\ =\ std::set<Key,\ Comp>;}
\DoxyCodeLine{01453\ \ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }state\ =\ std::optional<keyset>;}
\DoxyCodeLine{01454\ }
\DoxyCodeLine{01455\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ upfn\ =\ [\&ctx](\textcolor{keyword}{const}\ Node\&\ node,\ std::span<state>\ subs)\ -\/>\ state\ \{}
\DoxyCodeLine{01456\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ this\ node\ is\ already\ known\ to\ have\ duplicates,\ nothing\ left\ to\ do.}}
\DoxyCodeLine{01457\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node.has\_duplicate\_keys.has\_value()\ \&\&\ *node.has\_duplicate\_keys)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01458\ }
\DoxyCodeLine{01459\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Check\ if\ one\ of\ the\ children\ is\ already\ known\ to\ have\ duplicates.}}
\DoxyCodeLine{01460\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\&\ sub\ :\ subs)\ \{}
\DoxyCodeLine{01461\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!sub.has\_value())\ \{}
\DoxyCodeLine{01462\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node.has\_duplicate\_keys\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{01463\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01464\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01465\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01466\ }
\DoxyCodeLine{01467\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Start\ building\ the\ set\ of\ keys\ involved\ in\ this\ node\ and\ children.}}
\DoxyCodeLine{01468\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Start\ by\ keys\ in\ this\ node\ directly.}}
\DoxyCodeLine{01469\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{size\_t}\ keys\_count\ =\ node.keys.size();}
\DoxyCodeLine{01470\ \ \ \ \ \ \ \ \ \ \ \ \ keyset\ key\_set\{node.keys.begin(),\ node.keys.end(),\ Comp(ctx)\};}
\DoxyCodeLine{01471\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (key\_set.size()\ !=\ keys\_count)\ \{}
\DoxyCodeLine{01472\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ It\ already\ has\ duplicates;\ bail\ out.}}
\DoxyCodeLine{01473\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node.has\_duplicate\_keys\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{01474\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01475\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01476\ }
\DoxyCodeLine{01477\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Merge\ the\ keys\ from\ the\ children\ into\ this\ set.}}
\DoxyCodeLine{01478\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\&\ sub\ :\ subs)\ \{}
\DoxyCodeLine{01479\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ keys\_count\ +=\ sub-\/>size();}
\DoxyCodeLine{01480\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Small\ optimization:\ std::set::merge\ is\ linear\ in\ the\ size\ of\ the\ second\ arg\ but}}
\DoxyCodeLine{01481\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ logarithmic\ in\ the\ size\ of\ the\ first.}}
\DoxyCodeLine{01482\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (key\_set.size()\ <\ sub-\/>size())\ std::swap(key\_set,\ *sub);}
\DoxyCodeLine{01483\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ key\_set.merge(*sub);}
\DoxyCodeLine{01484\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (key\_set.size()\ !=\ keys\_count)\ \{}
\DoxyCodeLine{01485\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node.has\_duplicate\_keys\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{01486\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01487\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01488\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01489\ }
\DoxyCodeLine{01490\ \ \ \ \ \ \ \ \ \ \ \ \ node.has\_duplicate\_keys\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{01491\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ key\_set;}
\DoxyCodeLine{01492\ \ \ \ \ \ \ \ \ \};}
\DoxyCodeLine{01493\ }
\DoxyCodeLine{01494\ \ \ \ \ \ \ \ \ TreeEval<state>(upfn);}
\DoxyCodeLine{01495\ \ \ \ \ \}}
\DoxyCodeLine{01496\ }
\DoxyCodeLine{01498\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ ScriptSize()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ scriptlen;\ \}}
\DoxyCodeLine{01499\ }
\DoxyCodeLine{01501\ \ \ \ \ std::optional<uint32\_t>\ GetOps()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01502\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!ops.sat.valid)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01503\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ops.count\ +\ ops.sat.value;}
\DoxyCodeLine{01504\ \ \ \ \ \}}
\DoxyCodeLine{01505\ }
\DoxyCodeLine{01507\ \ \ \ \ uint32\_t\ GetStaticOps()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ ops.count;\ \}}
\DoxyCodeLine{01508\ }
\DoxyCodeLine{01510\ \ \ \ \ \textcolor{keywordtype}{bool}\ CheckOpsLimit()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01511\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (IsTapscript(m\_script\_ctx))\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01512\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ ops\ =\ GetOps())\ \textcolor{keywordflow}{return}\ *ops\ <=\ MAX\_OPS\_PER\_SCRIPT;}
\DoxyCodeLine{01513\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01514\ \ \ \ \ \}}
\DoxyCodeLine{01515\ }
\DoxyCodeLine{01517\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsBKW()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01518\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ !((GetType()\ \&\ \textcolor{stringliteral}{"{}BKW"{}}\_mst)\ ==\ \textcolor{stringliteral}{"{}"{}}\_mst);}
\DoxyCodeLine{01519\ \ \ \ \ \}}
\DoxyCodeLine{01520\ }
\DoxyCodeLine{01522\ \ \ \ \ std::optional<uint32\_t>\ GetStackSize()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01523\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!ss.sat.valid)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01524\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ss.sat.netdiff\ +\ \textcolor{keyword}{static\_cast<}int32\_t\textcolor{keyword}{>}(IsBKW());}
\DoxyCodeLine{01525\ \ \ \ \ \}}
\DoxyCodeLine{01526\ }
\DoxyCodeLine{01528\ \ \ \ \ std::optional<uint32\_t>\ GetExecStackSize()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01529\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!ss.sat.valid)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01530\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ss.sat.exec\ +\ \textcolor{keyword}{static\_cast<}int32\_t\textcolor{keyword}{>}(IsBKW());}
\DoxyCodeLine{01531\ \ \ \ \ \}}
\DoxyCodeLine{01532\ }
\DoxyCodeLine{01534\ \ \ \ \ \textcolor{keywordtype}{bool}\ CheckStackSize()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01535\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Since\ in\ Tapscript\ there\ is\ no\ standardness\ limit\ on\ the\ script\ and\ witness\ sizes,\ we\ may\ run}}
\DoxyCodeLine{01536\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ into\ the\ maximum\ stack\ size\ while\ executing\ the\ script.\ Make\ sure\ it\ doesn't\ happen.}}
\DoxyCodeLine{01537\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (IsTapscript(m\_script\_ctx))\ \{}
\DoxyCodeLine{01538\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ exec\_ss\ =\ GetExecStackSize())\ \textcolor{keywordflow}{return}\ exec\_ss\ <=\ MAX\_STACK\_SIZE;}
\DoxyCodeLine{01539\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01540\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01541\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ ss\ =\ GetStackSize())\ \textcolor{keywordflow}{return}\ *ss\ <=\ MAX\_STANDARD\_P2WSH\_STACK\_ITEMS;}
\DoxyCodeLine{01542\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01543\ \ \ \ \ \}}
\DoxyCodeLine{01544\ }
\DoxyCodeLine{01546\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsNotSatisfiable()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ !GetStackSize();\ \}}
\DoxyCodeLine{01547\ }
\DoxyCodeLine{01550\ \ \ \ \ std::optional<uint32\_t>\ GetWitnessSize()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01551\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!ws.sat.valid)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01552\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ws.sat.value;}
\DoxyCodeLine{01553\ \ \ \ \ \}}
\DoxyCodeLine{01554\ }
\DoxyCodeLine{01556\ \ \ \ \ Type\ GetType()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ typ;\ \}}
\DoxyCodeLine{01557\ }
\DoxyCodeLine{01559\ \ \ \ \ MiniscriptContext\ GetMsCtx()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ m\_script\_ctx;\ \}}
\DoxyCodeLine{01560\ }
\DoxyCodeLine{01562\ \ \ \ \ \textcolor{keyword}{const}\ Node*\ FindInsaneSub()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01563\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEval<const\ Node*>([](\textcolor{keyword}{const}\ Node\&\ node,\ std::span<const\ Node*>\ subs)\ -\/>\ \textcolor{keyword}{const}\ Node*\ \{}
\DoxyCodeLine{01564\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\&\ sub:\ subs)\ \textcolor{keywordflow}{if}\ (sub)\ \textcolor{keywordflow}{return}\ sub;}
\DoxyCodeLine{01565\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!node.IsSaneSubexpression())\ \textcolor{keywordflow}{return}\ \&node;}
\DoxyCodeLine{01566\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{01567\ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{01568\ \ \ \ \ \}}
\DoxyCodeLine{01569\ }
\DoxyCodeLine{01572\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ F>}
\DoxyCodeLine{01573\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsSatisfiable(F\ fn)\textcolor{keyword}{\ const}}
\DoxyCodeLine{01574\ \textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{01575\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ TreeEval()\ doesn't\ support\ bool\ as\ NodeType,\ so\ use\ int\ instead.}}
\DoxyCodeLine{01576\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ TreeEval<int>([\&fn](\textcolor{keyword}{const}\ Node\&\ node,\ std::span<int>\ subs)\ -\/>\ \textcolor{keywordtype}{bool}\ \{}
\DoxyCodeLine{01577\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (node.fragment)\ \{}
\DoxyCodeLine{01578\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_0:}
\DoxyCodeLine{01579\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01580\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::JUST\_1:}
\DoxyCodeLine{01581\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01582\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_K:}
\DoxyCodeLine{01583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::PK\_H:}
\DoxyCodeLine{01584\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI:}
\DoxyCodeLine{01585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::MULTI\_A:}
\DoxyCodeLine{01586\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AFTER:}
\DoxyCodeLine{01587\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OLDER:}
\DoxyCodeLine{01588\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH256:}
\DoxyCodeLine{01589\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::HASH160:}
\DoxyCodeLine{01590\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::SHA256:}
\DoxyCodeLine{01591\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::RIPEMD160:}
\DoxyCodeLine{01592\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keywordtype}{bool}\{fn(node)\};}
\DoxyCodeLine{01593\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::ANDOR:}
\DoxyCodeLine{01594\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ (subs[0]\ \&\&\ subs[1])\ ||\ subs[2];}
\DoxyCodeLine{01595\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_V:}
\DoxyCodeLine{01596\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::AND\_B:}
\DoxyCodeLine{01597\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ subs[0]\ \&\&\ subs[1];}
\DoxyCodeLine{01598\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_B:}
\DoxyCodeLine{01599\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_C:}
\DoxyCodeLine{01600\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_D:}
\DoxyCodeLine{01601\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::OR\_I:}
\DoxyCodeLine{01602\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ subs[0]\ ||\ subs[1];}
\DoxyCodeLine{01603\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ Fragment::THRESH:}
\DoxyCodeLine{01604\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(std::count(subs.begin(),\ subs.end(),\ \textcolor{keyword}{true}))\ >=\ node.k;}
\DoxyCodeLine{01605\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{default}:\ \textcolor{comment}{//\ wrappers}}
\DoxyCodeLine{01606\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ assert(subs.size()\ >=\ 1);}
\DoxyCodeLine{01607\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ CHECK\_NONFATAL(subs.size()\ ==\ 1);}
\DoxyCodeLine{01608\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ subs[0];}
\DoxyCodeLine{01609\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01610\ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{01611\ \ \ \ \ \}}
\DoxyCodeLine{01612\ }
\DoxyCodeLine{01614\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsValid()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01615\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (GetType()\ ==\ \textcolor{stringliteral}{"{}"{}}\_mst)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01616\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ScriptSize()\ <=\ internal::MaxScriptSize(m\_script\_ctx);}
\DoxyCodeLine{01617\ \ \ \ \ \}}
\DoxyCodeLine{01618\ }
\DoxyCodeLine{01620\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsValidTopLevel()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ IsValid()\ \&\&\ GetType()\ <<\ \textcolor{stringliteral}{"{}B"{}}\_mst;\ \}}
\DoxyCodeLine{01621\ }
\DoxyCodeLine{01623\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsNonMalleable()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ GetType()\ <<\ \textcolor{stringliteral}{"{}m"{}}\_mst;\ \}}
\DoxyCodeLine{01624\ }
\DoxyCodeLine{01626\ \ \ \ \ \textcolor{keywordtype}{bool}\ NeedsSignature()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ GetType()\ <<\ \textcolor{stringliteral}{"{}s"{}}\_mst;\ \}}
\DoxyCodeLine{01627\ }
\DoxyCodeLine{01629\ \ \ \ \ \textcolor{keywordtype}{bool}\ CheckTimeLocksMix()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ GetType()\ <<\ \textcolor{stringliteral}{"{}k"{}}\_mst;\ \}}
\DoxyCodeLine{01630\ }
\DoxyCodeLine{01632\ \ \ \ \ \textcolor{keywordtype}{bool}\ CheckDuplicateKey()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ has\_duplicate\_keys\ \&\&\ !*has\_duplicate\_keys;\ \}}
\DoxyCodeLine{01633\ }
\DoxyCodeLine{01635\ \ \ \ \ \textcolor{keywordtype}{bool}\ ValidSatisfactions()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ IsValid()\ \&\&\ CheckOpsLimit()\ \&\&\ CheckStackSize();\ \}}
\DoxyCodeLine{01636\ }
\DoxyCodeLine{01638\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsSaneSubexpression()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ ValidSatisfactions()\ \&\&\ IsNonMalleable()\ \&\&\ CheckTimeLocksMix()\ \&\&\ CheckDuplicateKey();\ \}}
\DoxyCodeLine{01639\ }
\DoxyCodeLine{01641\ \ \ \ \ \textcolor{keywordtype}{bool}\ IsSane()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ IsValidTopLevel()\ \&\&\ IsSaneSubexpression()\ \&\&\ NeedsSignature();\ \}}
\DoxyCodeLine{01642\ }
\DoxyCodeLine{01647\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{01648\ \ \ \ \ Availability\ Satisfy(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ std::vector<std::vector<unsigned\ char>>\&\ stack,\ \textcolor{keywordtype}{bool}\ nonmalleable\ =\ \textcolor{keyword}{true})\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{01649\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ ret\ =\ ProduceInput(ctx);}
\DoxyCodeLine{01650\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (nonmalleable\ \&\&\ (ret.sat.malleable\ ||\ !ret.sat.has\_sig))\ \textcolor{keywordflow}{return}\ Availability::NO;}
\DoxyCodeLine{01651\ \ \ \ \ \ \ \ \ stack\ =\ std::move(ret.sat.stack);}
\DoxyCodeLine{01652\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ret.sat.available;}
\DoxyCodeLine{01653\ \ \ \ \ \}}
\DoxyCodeLine{01654\ }
\DoxyCodeLine{01656\ \ \ \ \ \textcolor{keywordtype}{bool}\ operator==(\textcolor{keyword}{const}\ Node<Key>\&\ arg)\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ Compare(*\textcolor{keyword}{this},\ arg)\ ==\ 0;\ \}}
\DoxyCodeLine{01657\ }
\DoxyCodeLine{01658\ \ \ \ \ \textcolor{comment}{//\ Constructors\ with\ various\ argument\ combinations,\ which\ bypass\ the\ duplicate\ key\ check.}}
\DoxyCodeLine{01659\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ std::vector<unsigned\ char>\ arg,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01660\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ data(std::move(arg)),\ subs(std::move(sub)),\ m\_script\_ctx\{script\_ctx\},\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{01661\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<unsigned\ char>\ arg,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01662\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ data(std::move(arg)),\ m\_script\_ctx\{script\_ctx\},\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{01663\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ std::vector<Key>\ key,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01664\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ keys(std::move(key)),\ m\_script\_ctx\{script\_ctx\},\ subs(std::move(sub)),\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{01665\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<Key>\ key,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01666\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ keys(std::move(key)),\ m\_script\_ctx\{script\_ctx\},\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{01667\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01668\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ subs(std::move(sub)),\ m\_script\_ctx\{script\_ctx\},\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{01669\ \ \ \ \ Node(internal::NoDupCheck,\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01670\ \ \ \ \ \ \ \ \ :\ fragment(nt),\ k(val),\ m\_script\_ctx\{script\_ctx\},\ ops(CalcOps()),\ ss(CalcStackSize()),\ ws(CalcWitnessSize()),\ typ(CalcType()),\ scriptlen(CalcScriptLen())\ \{\}}
\DoxyCodeLine{01671\ }
\DoxyCodeLine{01672\ \ \ \ \ \textcolor{comment}{//\ Constructors\ with\ various\ argument\ combinations,\ which\ do\ perform\ the\ duplicate\ key\ check.}}
\DoxyCodeLine{01673\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Ctx>\ Node(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ std::vector<unsigned\ char>\ arg,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01674\ \ \ \ \ \ \ \ \ :\ Node(internal::NoDupCheck\{\},\ ctx.MsContext(),\ nt,\ std::move(sub),\ std::move(arg),\ val)\ \{\ DuplicateKeyCheck(ctx);\ \}}
\DoxyCodeLine{01675\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Ctx>\ Node(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ Fragment\ nt,\ std::vector<unsigned\ char>\ arg,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01676\ \ \ \ \ \ \ \ \ :\ Node(internal::NoDupCheck\{\},\ ctx.MsContext(),\ nt,\ std::move(arg),\ val)\ \{\ DuplicateKeyCheck(ctx);\}}
\DoxyCodeLine{01677\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Ctx>\ Node(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ std::vector<Key>\ key,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01678\ \ \ \ \ \ \ \ \ :\ Node(internal::NoDupCheck\{\},\ ctx.MsContext(),\ nt,\ std::move(sub),\ std::move(key),\ val)\ \{\ DuplicateKeyCheck(ctx);\ \}}
\DoxyCodeLine{01679\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Ctx>\ Node(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ Fragment\ nt,\ std::vector<Key>\ key,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01680\ \ \ \ \ \ \ \ \ :\ Node(internal::NoDupCheck\{\},\ ctx.MsContext(),\ nt,\ std::move(key),\ val)\ \{\ DuplicateKeyCheck(ctx);\ \}}
\DoxyCodeLine{01681\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Ctx>\ Node(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\ sub,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01682\ \ \ \ \ \ \ \ \ :\ Node(internal::NoDupCheck\{\},\ ctx.MsContext(),\ nt,\ std::move(sub),\ val)\ \{\ DuplicateKeyCheck(ctx);\ \}}
\DoxyCodeLine{01683\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Ctx>\ Node(\textcolor{keyword}{const}\ Ctx\&\ ctx,\ Fragment\ nt,\ uint32\_t\ val\ =\ 0)}
\DoxyCodeLine{01684\ \ \ \ \ \ \ \ \ :\ Node(internal::NoDupCheck\{\},\ ctx.MsContext(),\ nt,\ val)\ \{\ DuplicateKeyCheck(ctx);\ \}}
\DoxyCodeLine{01685\ }
\DoxyCodeLine{01686\ \ \ \ \ \textcolor{comment}{//\ Delete\ copy\ constructor\ and\ assignment\ operator,\ use\ Clone()\ instead}}
\DoxyCodeLine{01687\ \ \ \ \ Node(\textcolor{keyword}{const}\ Node\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{01688\ \ \ \ \ Node\&\ operator=(\textcolor{keyword}{const}\ Node\&)\ =\ \textcolor{keyword}{delete};}
\DoxyCodeLine{01689\ \};}
\DoxyCodeLine{01690\ }
\DoxyCodeLine{01691\ \textcolor{keyword}{namespace\ }internal\ \{}
\DoxyCodeLine{01692\ }
\DoxyCodeLine{01693\ \textcolor{keyword}{enum\ class}\ ParseContext\ \{}
\DoxyCodeLine{01695\ \ \ \ \ WRAPPED\_EXPR,}
\DoxyCodeLine{01697\ \ \ \ \ EXPR,}
\DoxyCodeLine{01698\ }
\DoxyCodeLine{01700\ \ \ \ \ SWAP,}
\DoxyCodeLine{01702\ \ \ \ \ ALT,}
\DoxyCodeLine{01704\ \ \ \ \ CHECK,}
\DoxyCodeLine{01706\ \ \ \ \ DUP\_IF,}
\DoxyCodeLine{01708\ \ \ \ \ VERIFY,}
\DoxyCodeLine{01710\ \ \ \ \ NON\_ZERO,}
\DoxyCodeLine{01712\ \ \ \ \ ZERO\_NOTEQUAL,}
\DoxyCodeLine{01714\ \ \ \ \ WRAP\_U,}
\DoxyCodeLine{01716\ \ \ \ \ WRAP\_T,}
\DoxyCodeLine{01717\ }
\DoxyCodeLine{01719\ \ \ \ \ AND\_N,}
\DoxyCodeLine{01721\ \ \ \ \ AND\_V,}
\DoxyCodeLine{01723\ \ \ \ \ AND\_B,}
\DoxyCodeLine{01725\ \ \ \ \ ANDOR,}
\DoxyCodeLine{01727\ \ \ \ \ OR\_B,}
\DoxyCodeLine{01729\ \ \ \ \ OR\_C,}
\DoxyCodeLine{01731\ \ \ \ \ OR\_D,}
\DoxyCodeLine{01733\ \ \ \ \ OR\_I,}
\DoxyCodeLine{01734\ }
\DoxyCodeLine{01739\ \ \ \ \ THRESH,}
\DoxyCodeLine{01740\ }
\DoxyCodeLine{01742\ \ \ \ \ COMMA,}
\DoxyCodeLine{01744\ \ \ \ \ CLOSE\_BRACKET,}
\DoxyCodeLine{01745\ \};}
\DoxyCodeLine{01746\ }
\DoxyCodeLine{01747\ \textcolor{keywordtype}{int}\ FindNextChar(std::span<const\ char>\ in,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{char}\ m);}
\DoxyCodeLine{01748\ }
\DoxyCodeLine{01750\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key,\ \textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{01751\ std::optional<std::pair<Key,\ int>>\ ParseKeyEnd(std::span<const\ char>\ in,\ \textcolor{keyword}{const}\ Ctx\&\ ctx)}
\DoxyCodeLine{01752\ \{}
\DoxyCodeLine{01753\ \ \ \ \ \textcolor{keywordtype}{int}\ key\_size\ =\ FindNextChar(in,\ \textcolor{charliteral}{')'});}
\DoxyCodeLine{01754\ \ \ \ \ \textcolor{keywordflow}{if}\ (key\_size\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01755\ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ ctx.FromString(in.begin(),\ in.begin()\ +\ key\_size);}
\DoxyCodeLine{01756\ \ \ \ \ \textcolor{keywordflow}{if}\ (!key)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01757\ \ \ \ \ \textcolor{keywordflow}{return}\ \{\{std::move(*key),\ key\_size\}\};}
\DoxyCodeLine{01758\ \}}
\DoxyCodeLine{01759\ }
\DoxyCodeLine{01761\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{01762\ std::optional<std::pair<std::vector<unsigned\ char>,\ \textcolor{keywordtype}{int}>>\ ParseHexStrEnd(std::span<const\ char>\ in,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ expected\_size,}
\DoxyCodeLine{01763\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ Ctx\&\ ctx)}
\DoxyCodeLine{01764\ \{}
\DoxyCodeLine{01765\ \ \ \ \ \textcolor{keywordtype}{int}\ hash\_size\ =\ FindNextChar(in,\ \textcolor{charliteral}{')'});}
\DoxyCodeLine{01766\ \ \ \ \ \textcolor{keywordflow}{if}\ (hash\_size\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01767\ \ \ \ \ std::string\ val\ =\ std::string(in.begin(),\ in.begin()\ +\ hash\_size);}
\DoxyCodeLine{01768\ \ \ \ \ \textcolor{keywordflow}{if}\ (!IsHex(val))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01769\ \ \ \ \ \textcolor{keyword}{auto}\ hash\ =\ ParseHex(val);}
\DoxyCodeLine{01770\ \ \ \ \ \textcolor{keywordflow}{if}\ (hash.size()\ !=\ expected\_size)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01771\ \ \ \ \ \textcolor{keywordflow}{return}\ \{\{std::move(hash),\ hash\_size\}\};}
\DoxyCodeLine{01772\ \}}
\DoxyCodeLine{01773\ }
\DoxyCodeLine{01775\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key>}
\DoxyCodeLine{01776\ \textcolor{keywordtype}{void}\ BuildBack(\textcolor{keyword}{const}\ MiniscriptContext\ script\_ctx,\ Fragment\ nt,\ std::vector<NodeRef<Key>>\&\ constructed,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ reverse\ =\ \textcolor{keyword}{false})}
\DoxyCodeLine{01777\ \{}
\DoxyCodeLine{01778\ \ \ \ \ NodeRef<Key>\ child\ =\ std::move(constructed.back());}
\DoxyCodeLine{01779\ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{01780\ \ \ \ \ \textcolor{keywordflow}{if}\ (reverse)\ \{}
\DoxyCodeLine{01781\ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ script\_ctx,\ nt,\ Vector(std::move(child),\ std::move(constructed.back())));}
\DoxyCodeLine{01782\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01783\ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ script\_ctx,\ nt,\ Vector(std::move(constructed.back()),\ std::move(child)));}
\DoxyCodeLine{01784\ \ \ \ \ \}}
\DoxyCodeLine{01785\ \}}
\DoxyCodeLine{01786\ }
\DoxyCodeLine{01792\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key,\ \textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{01793\ \textcolor{keyword}{inline}\ NodeRef<Key>\ Parse(std::span<const\ char>\ in,\ \textcolor{keyword}{const}\ Ctx\&\ ctx)}
\DoxyCodeLine{01794\ \{}
\DoxyCodeLine{01795\ \ \ \ \ \textcolor{keyword}{using\ namespace\ }script;}
\DoxyCodeLine{01796\ }
\DoxyCodeLine{01797\ \ \ \ \ \textcolor{comment}{//\ Account\ for\ the\ minimum\ script\ size\ for\ all\ parsed\ fragments\ so\ far.\ It\ "{}borrows"{}\ 1}}
\DoxyCodeLine{01798\ \ \ \ \ \textcolor{comment}{//\ script\ byte\ from\ all\ leaf\ nodes,\ counting\ it\ instead\ whenever\ a\ space\ for\ a\ recursive}}
\DoxyCodeLine{01799\ \ \ \ \ \textcolor{comment}{//\ expression\ is\ added\ (through\ andor,\ and\_*,\ or\_*,\ thresh).\ This\ guarantees\ that\ all\ fragments}}
\DoxyCodeLine{01800\ \ \ \ \ \textcolor{comment}{//\ increment\ the\ script\_size\ by\ at\ least\ one,\ except\ for:}}
\DoxyCodeLine{01801\ \ \ \ \ \textcolor{comment}{//\ -\/\ "{}0"{},\ "{}1"{}:\ these\ leafs\ are\ only\ a\ single\ byte,\ so\ their\ subtracted-\/from\ increment\ is\ 0.}}
\DoxyCodeLine{01802\ \ \ \ \ \textcolor{comment}{//\ \ \ This\ is\ not\ an\ issue\ however,\ as\ "{}space"{}\ for\ them\ has\ to\ be\ created\ by\ combinators,}}
\DoxyCodeLine{01803\ \ \ \ \ \textcolor{comment}{//\ \ \ which\ do\ increment\ script\_size.}}
\DoxyCodeLine{01804\ \ \ \ \ \textcolor{comment}{//\ -\/\ "{}v:"{}:\ the\ v\ wrapper\ adds\ nothing\ as\ in\ some\ cases\ it\ results\ in\ no\ opcode\ being\ added}}
\DoxyCodeLine{01805\ \ \ \ \ \textcolor{comment}{//\ \ \ (instead\ transforming\ another\ opcode\ into\ its\ VERIFY\ form).\ However,\ the\ v:\ wrapper\ has}}
\DoxyCodeLine{01806\ \ \ \ \ \textcolor{comment}{//\ \ \ to\ be\ interleaved\ with\ other\ fragments\ to\ be\ valid,\ so\ this\ is\ not\ a\ concern.}}
\DoxyCodeLine{01807\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ script\_size\{1\};}
\DoxyCodeLine{01808\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ max\_size\{internal::MaxScriptSize(ctx.MsContext())\};}
\DoxyCodeLine{01809\ }
\DoxyCodeLine{01810\ \ \ \ \ \textcolor{comment}{//\ The\ two\ integers\ are\ used\ to\ hold\ state\ for\ thresh()}}
\DoxyCodeLine{01811\ \ \ \ \ std::vector<std::tuple<ParseContext,\ int64\_t,\ int64\_t>>\ to\_parse;}
\DoxyCodeLine{01812\ \ \ \ \ std::vector<NodeRef<Key>>\ constructed;}
\DoxyCodeLine{01813\ }
\DoxyCodeLine{01814\ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{01815\ }
\DoxyCodeLine{01816\ \ \ \ \ \textcolor{comment}{//\ Parses\ a\ multi()\ or\ multi\_a()\ from\ its\ string\ representation.\ Returns\ false\ on\ parsing\ error.}}
\DoxyCodeLine{01817\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ parse\_multi\_exp\ =\ [\&](std::span<const\ char>\&\ in,\ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ is\_multi\_a)\ -\/>\ \textcolor{keywordtype}{bool}\ \{}
\DoxyCodeLine{01818\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ max\_keys\{is\_multi\_a\ ?\ MAX\_PUBKEYS\_PER\_MULTI\_A\ :\ MAX\_PUBKEYS\_PER\_MULTISIG\};}
\DoxyCodeLine{01819\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ required\_ctx\{is\_multi\_a\ ?\ MiniscriptContext::TAPSCRIPT\ :\ MiniscriptContext::P2WSH\};}
\DoxyCodeLine{01820\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (ctx.MsContext()\ !=\ required\_ctx)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01821\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ threshold}}
\DoxyCodeLine{01822\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ next\_comma\ =\ FindNextChar(in,\ \textcolor{charliteral}{','});}
\DoxyCodeLine{01823\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (next\_comma\ <\ 1)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01824\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ k\_to\_integral\{ToIntegral<int64\_t>(std::string\_view(in.data(),\ next\_comma))\};}
\DoxyCodeLine{01825\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!k\_to\_integral.has\_value())\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01826\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ int64\_t\ k\{k\_to\_integral.value()\};}
\DoxyCodeLine{01827\ \ \ \ \ \ \ \ \ in\ =\ in.subspan(next\_comma\ +\ 1);}
\DoxyCodeLine{01828\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ keys.\ It\ is\ compatible\ for\ both\ compressed\ and\ x-\/only\ keys.}}
\DoxyCodeLine{01829\ \ \ \ \ \ \ \ \ std::vector<Key>\ keys;}
\DoxyCodeLine{01830\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (next\_comma\ !=\ -\/1)\ \{}
\DoxyCodeLine{01831\ \ \ \ \ \ \ \ \ \ \ \ \ next\_comma\ =\ FindNextChar(in,\ \textcolor{charliteral}{','});}
\DoxyCodeLine{01832\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ key\_length\ =\ (next\_comma\ ==\ -\/1)\ ?\ FindNextChar(in,\ \textcolor{charliteral}{')'})\ :\ next\_comma;}
\DoxyCodeLine{01833\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (key\_length\ <\ 1)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01834\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ ctx.FromString(in.begin(),\ in.begin()\ +\ key\_length);}
\DoxyCodeLine{01835\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01836\ \ \ \ \ \ \ \ \ \ \ \ \ keys.push\_back(std::move(*key));}
\DoxyCodeLine{01837\ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(key\_length\ +\ 1);}
\DoxyCodeLine{01838\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01839\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (keys.size()\ <\ 1\ ||\ keys.size()\ >\ max\_keys)\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01840\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (k\ <\ 1\ ||\ k\ >\ (int64\_t)keys.size())\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};}
\DoxyCodeLine{01841\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (is\_multi\_a)\ \{}
\DoxyCodeLine{01842\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ (push\ +\ xonly-\/key\ +\ CHECKSIG[ADD])\ *\ n\ +\ k\ +\ OP\_NUMEQUAL(VERIFY),\ minus\ one.}}
\DoxyCodeLine{01843\ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ (1\ +\ 32\ +\ 1)\ *\ keys.size()\ +\ BuildScript(k).size();}
\DoxyCodeLine{01844\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::MULTI\_A,\ std::move(keys),\ k));}
\DoxyCodeLine{01845\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01846\ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 2\ +\ (keys.size()\ >\ 16)\ +\ (k\ >\ 16)\ +\ 34\ *\ keys.size();}
\DoxyCodeLine{01847\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::MULTI,\ std::move(keys),\ k));}
\DoxyCodeLine{01848\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01849\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{01850\ \ \ \ \ \};}
\DoxyCodeLine{01851\ }
\DoxyCodeLine{01852\ \ \ \ \ \textcolor{keywordflow}{while}\ (!to\_parse.empty())\ \{}
\DoxyCodeLine{01853\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (script\_size\ >\ max\_size)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01854\ }
\DoxyCodeLine{01855\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ the\ current\ context\ we\ are\ decoding\ within}}
\DoxyCodeLine{01856\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ [cur\_context,\ n,\ k]\ =\ to\_parse.back();}
\DoxyCodeLine{01857\ \ \ \ \ \ \ \ \ to\_parse.pop\_back();}
\DoxyCodeLine{01858\ }
\DoxyCodeLine{01859\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}\ (cur\_context)\ \{}
\DoxyCodeLine{01860\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::WRAPPED\_EXPR:\ \{}
\DoxyCodeLine{01861\ \ \ \ \ \ \ \ \ \ \ \ \ std::optional<size\_t>\ colon\_index\{\};}
\DoxyCodeLine{01862\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ i\ =\ 1;\ i\ <\ in.size();\ ++i)\ \{}
\DoxyCodeLine{01863\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[i]\ ==\ \textcolor{charliteral}{':'})\ \{}
\DoxyCodeLine{01864\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ colon\_index\ =\ i;}
\DoxyCodeLine{01865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{01866\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01867\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[i]\ <\ \textcolor{charliteral}{'a'}\ ||\ in[i]\ >\ \textcolor{charliteral}{'z'})\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{01868\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01869\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ there\ is\ no\ colon,\ this\ loop\ won't\ execute}}
\DoxyCodeLine{01870\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ last\_was\_v\{\textcolor{keyword}{false}\};}
\DoxyCodeLine{01871\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{size\_t}\ j\ =\ 0;\ colon\_index\ \&\&\ j\ <\ *colon\_index;\ ++j)\ \{}
\DoxyCodeLine{01872\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (script\_size\ >\ max\_size)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01873\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'a'})\ \{}
\DoxyCodeLine{01874\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 2;}
\DoxyCodeLine{01875\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::ALT,\ -\/1,\ -\/1);}
\DoxyCodeLine{01876\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'s'})\ \{}
\DoxyCodeLine{01877\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1;}
\DoxyCodeLine{01878\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::SWAP,\ -\/1,\ -\/1);}
\DoxyCodeLine{01879\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'c'})\ \{}
\DoxyCodeLine{01880\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1;}
\DoxyCodeLine{01881\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::CHECK,\ -\/1,\ -\/1);}
\DoxyCodeLine{01882\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'d'})\ \{}
\DoxyCodeLine{01883\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 3;}
\DoxyCodeLine{01884\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::DUP\_IF,\ -\/1,\ -\/1);}
\DoxyCodeLine{01885\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'j'})\ \{}
\DoxyCodeLine{01886\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 4;}
\DoxyCodeLine{01887\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::NON\_ZERO,\ -\/1,\ -\/1);}
\DoxyCodeLine{01888\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'n'})\ \{}
\DoxyCodeLine{01889\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1;}
\DoxyCodeLine{01890\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::ZERO\_NOTEQUAL,\ -\/1,\ -\/1);}
\DoxyCodeLine{01891\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'v'})\ \{}
\DoxyCodeLine{01892\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ do\ not\ permit\ "{}...vv...:"{};\ it's\ not\ valid,\ and\ also\ doesn't\ trigger\ early}}
\DoxyCodeLine{01893\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ failure\ as\ script\_size\ isn't\ incremented.}}
\DoxyCodeLine{01894\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\_was\_v)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01895\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::VERIFY,\ -\/1,\ -\/1);}
\DoxyCodeLine{01896\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'u'})\ \{}
\DoxyCodeLine{01897\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 4;}
\DoxyCodeLine{01898\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAP\_U,\ -\/1,\ -\/1);}
\DoxyCodeLine{01899\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'t'})\ \{}
\DoxyCodeLine{01900\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1;}
\DoxyCodeLine{01901\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAP\_T,\ -\/1,\ -\/1);}
\DoxyCodeLine{01902\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[j]\ ==\ \textcolor{charliteral}{'l'})\ \{}
\DoxyCodeLine{01903\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ l:\ wrapper\ is\ equivalent\ to\ or\_i(0,X)}}
\DoxyCodeLine{01904\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 4;}
\DoxyCodeLine{01905\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_0));}
\DoxyCodeLine{01906\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::OR\_I,\ -\/1,\ -\/1);}
\DoxyCodeLine{01907\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{01908\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01909\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01910\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ last\_was\_v\ =\ (in[j]\ ==\ \textcolor{charliteral}{'v'});}
\DoxyCodeLine{01911\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01912\ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{01913\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (colon\_index)\ in\ =\ in.subspan(*colon\_index\ +\ 1);}
\DoxyCodeLine{01914\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{01915\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{01916\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::EXPR:\ \{}
\DoxyCodeLine{01917\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}0"{}},\ in))\ \{}
\DoxyCodeLine{01918\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_0));}
\DoxyCodeLine{01919\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}1"{}},\ in))\ \{}
\DoxyCodeLine{01920\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_1));}
\DoxyCodeLine{01921\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}pk("{}},\ in))\ \{}
\DoxyCodeLine{01922\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseKeyEnd<Key,\ Ctx>(in,\ ctx);}
\DoxyCodeLine{01923\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01924\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [key,\ key\_size]\ =\ *res;}
\DoxyCodeLine{01925\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_C,\ Vector(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::PK\_K,\ Vector(std::move(key))))));}
\DoxyCodeLine{01926\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(key\_size\ +\ 1);}
\DoxyCodeLine{01927\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ IsTapscript(ctx.MsContext())\ ?\ 33\ :\ 34;}
\DoxyCodeLine{01928\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}pkh("{}},\ in))\ \{}
\DoxyCodeLine{01929\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseKeyEnd<Key>(in,\ ctx);}
\DoxyCodeLine{01930\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01931\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [key,\ key\_size]\ =\ *res;}
\DoxyCodeLine{01932\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_C,\ Vector(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::PK\_H,\ Vector(std::move(key))))));}
\DoxyCodeLine{01933\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(key\_size\ +\ 1);}
\DoxyCodeLine{01934\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 24;}
\DoxyCodeLine{01935\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}pk\_k("{}},\ in))\ \{}
\DoxyCodeLine{01936\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseKeyEnd<Key>(in,\ ctx);}
\DoxyCodeLine{01937\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01938\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [key,\ key\_size]\ =\ *res;}
\DoxyCodeLine{01939\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::PK\_K,\ Vector(std::move(key))));}
\DoxyCodeLine{01940\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(key\_size\ +\ 1);}
\DoxyCodeLine{01941\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ IsTapscript(ctx.MsContext())\ ?\ 32\ :\ 33;}
\DoxyCodeLine{01942\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}pk\_h("{}},\ in))\ \{}
\DoxyCodeLine{01943\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseKeyEnd<Key>(in,\ ctx);}
\DoxyCodeLine{01944\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01945\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [key,\ key\_size]\ =\ *res;}
\DoxyCodeLine{01946\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::PK\_H,\ Vector(std::move(key))));}
\DoxyCodeLine{01947\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(key\_size\ +\ 1);}
\DoxyCodeLine{01948\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 23;}
\DoxyCodeLine{01949\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}sha256("{}},\ in))\ \{}
\DoxyCodeLine{01950\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseHexStrEnd(in,\ 32,\ ctx);}
\DoxyCodeLine{01951\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01952\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [hash,\ hash\_size]\ =\ *res;}
\DoxyCodeLine{01953\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::SHA256,\ std::move(hash)));}
\DoxyCodeLine{01954\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(hash\_size\ +\ 1);}
\DoxyCodeLine{01955\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 38;}
\DoxyCodeLine{01956\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}ripemd160("{}},\ in))\ \{}
\DoxyCodeLine{01957\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseHexStrEnd(in,\ 20,\ ctx);}
\DoxyCodeLine{01958\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01959\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [hash,\ hash\_size]\ =\ *res;}
\DoxyCodeLine{01960\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::RIPEMD160,\ std::move(hash)));}
\DoxyCodeLine{01961\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(hash\_size\ +\ 1);}
\DoxyCodeLine{01962\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 26;}
\DoxyCodeLine{01963\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}hash256("{}},\ in))\ \{}
\DoxyCodeLine{01964\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseHexStrEnd(in,\ 32,\ ctx);}
\DoxyCodeLine{01965\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01966\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [hash,\ hash\_size]\ =\ *res;}
\DoxyCodeLine{01967\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::HASH256,\ std::move(hash)));}
\DoxyCodeLine{01968\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(hash\_size\ +\ 1);}
\DoxyCodeLine{01969\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 38;}
\DoxyCodeLine{01970\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}hash160("{}},\ in))\ \{}
\DoxyCodeLine{01971\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ res\ =\ ParseHexStrEnd(in,\ 20,\ ctx);}
\DoxyCodeLine{01972\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!res)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01973\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\&\ [hash,\ hash\_size]\ =\ *res;}
\DoxyCodeLine{01974\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::HASH160,\ std::move(hash)));}
\DoxyCodeLine{01975\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(hash\_size\ +\ 1);}
\DoxyCodeLine{01976\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 26;}
\DoxyCodeLine{01977\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}after("{}},\ in))\ \{}
\DoxyCodeLine{01978\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ arg\_size\ =\ FindNextChar(in,\ \textcolor{charliteral}{')'});}
\DoxyCodeLine{01979\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (arg\_size\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01980\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ num\{ToIntegral<int64\_t>(std::string\_view(in.data(),\ arg\_size))\};}
\DoxyCodeLine{01981\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!num.has\_value()\ ||\ *num\ <\ 1\ ||\ *num\ >=\ 0x80000000L)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01982\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::AFTER,\ *num));}
\DoxyCodeLine{01983\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(arg\_size\ +\ 1);}
\DoxyCodeLine{01984\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1\ +\ (*num\ >\ 16)\ +\ (*num\ >\ 0x7f)\ +\ (*num\ >\ 0x7fff)\ +\ (*num\ >\ 0x7fffff);}
\DoxyCodeLine{01985\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}older("{}},\ in))\ \{}
\DoxyCodeLine{01986\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ arg\_size\ =\ FindNextChar(in,\ \textcolor{charliteral}{')'});}
\DoxyCodeLine{01987\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (arg\_size\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01988\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ num\{ToIntegral<int64\_t>(std::string\_view(in.data(),\ arg\_size))\};}
\DoxyCodeLine{01989\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!num.has\_value()\ ||\ *num\ <\ 1\ ||\ *num\ >=\ 0x80000000L)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01990\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::OLDER,\ *num));}
\DoxyCodeLine{01991\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(arg\_size\ +\ 1);}
\DoxyCodeLine{01992\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1\ +\ (*num\ >\ 16)\ +\ (*num\ >\ 0x7f)\ +\ (*num\ >\ 0x7fff)\ +\ (*num\ >\ 0x7fffff);}
\DoxyCodeLine{01993\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}multi("{}},\ in))\ \{}
\DoxyCodeLine{01994\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!parse\_multi\_exp(in,\ \textcolor{comment}{/*\ is\_multi\_a\ =\ */}\textcolor{keyword}{false}))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01995\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}multi\_a("{}},\ in))\ \{}
\DoxyCodeLine{01996\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!parse\_multi\_exp(in,\ \textcolor{comment}{/*\ is\_multi\_a\ =\ */}\textcolor{keyword}{true}))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{01997\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}thresh("{}},\ in))\ \{}
\DoxyCodeLine{01998\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ next\_comma\ =\ FindNextChar(in,\ \textcolor{charliteral}{','});}
\DoxyCodeLine{01999\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (next\_comma\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02000\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ k\{ToIntegral<int64\_t>(std::string\_view(in.data(),\ next\_comma))\};}
\DoxyCodeLine{02001\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!k.has\_value()\ ||\ *k\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(next\_comma\ +\ 1);}
\DoxyCodeLine{02003\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ n\ =\ 1\ here\ because\ we\ read\ the\ first\ WRAPPED\_EXPR\ before\ reaching\ THRESH}}
\DoxyCodeLine{02004\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::THRESH,\ 1,\ *k);}
\DoxyCodeLine{02005\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02006\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 2\ +\ (*k\ >\ 16)\ +\ (*k\ >\ 0x7f)\ +\ (*k\ >\ 0x7fff)\ +\ (*k\ >\ 0x7fffff);}
\DoxyCodeLine{02007\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}andor("{}},\ in))\ \{}
\DoxyCodeLine{02008\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::ANDOR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02009\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::CLOSE\_BRACKET,\ -\/1,\ -\/1);}
\DoxyCodeLine{02010\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02011\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::COMMA,\ -\/1,\ -\/1);}
\DoxyCodeLine{02012\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02013\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::COMMA,\ -\/1,\ -\/1);}
\DoxyCodeLine{02014\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02015\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 5;}
\DoxyCodeLine{02016\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02017\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}and\_n("{}},\ in))\ \{}
\DoxyCodeLine{02018\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::AND\_N,\ -\/1,\ -\/1);}
\DoxyCodeLine{02019\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 5;}
\DoxyCodeLine{02020\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}and\_b("{}},\ in))\ \{}
\DoxyCodeLine{02021\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::AND\_B,\ -\/1,\ -\/1);}
\DoxyCodeLine{02022\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 2;}
\DoxyCodeLine{02023\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}and\_v("{}},\ in))\ \{}
\DoxyCodeLine{02024\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::AND\_V,\ -\/1,\ -\/1);}
\DoxyCodeLine{02025\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 1;}
\DoxyCodeLine{02026\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}or\_b("{}},\ in))\ \{}
\DoxyCodeLine{02027\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::OR\_B,\ -\/1,\ -\/1);}
\DoxyCodeLine{02028\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 2;}
\DoxyCodeLine{02029\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}or\_c("{}},\ in))\ \{}
\DoxyCodeLine{02030\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::OR\_C,\ -\/1,\ -\/1);}
\DoxyCodeLine{02031\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 3;}
\DoxyCodeLine{02032\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}or\_d("{}},\ in))\ \{}
\DoxyCodeLine{02033\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::OR\_D,\ -\/1,\ -\/1);}
\DoxyCodeLine{02034\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 4;}
\DoxyCodeLine{02035\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (Const(\textcolor{stringliteral}{"{}or\_i("{}},\ in))\ \{}
\DoxyCodeLine{02036\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::OR\_I,\ -\/1,\ -\/1);}
\DoxyCodeLine{02037\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 4;}
\DoxyCodeLine{02038\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02039\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02040\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02041\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::CLOSE\_BRACKET,\ -\/1,\ -\/1);}
\DoxyCodeLine{02042\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02043\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::COMMA,\ -\/1,\ -\/1);}
\DoxyCodeLine{02044\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02045\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02046\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02047\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02048\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::ALT:\ \{}
\DoxyCodeLine{02049\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_A,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02050\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02051\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02052\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::SWAP:\ \{}
\DoxyCodeLine{02053\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_S,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02054\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02055\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02056\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::CHECK:\ \{}
\DoxyCodeLine{02057\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_C,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02058\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02059\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02060\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::DUP\_IF:\ \{}
\DoxyCodeLine{02061\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_D,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02062\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02063\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02064\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::NON\_ZERO:\ \{}
\DoxyCodeLine{02065\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_J,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02066\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02067\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02068\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::ZERO\_NOTEQUAL:\ \{}
\DoxyCodeLine{02069\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_N,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02070\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02071\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02072\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::VERIFY:\ \{}
\DoxyCodeLine{02073\ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ (constructed.back()-\/>GetType()\ <<\ \textcolor{stringliteral}{"{}x"{}}\_mst);}
\DoxyCodeLine{02074\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_V,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02075\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02076\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02077\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::WRAP\_U:\ \{}
\DoxyCodeLine{02078\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::OR\_I,\ Vector(std::move(constructed.back()),\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_0)));}
\DoxyCodeLine{02079\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02080\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02081\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::WRAP\_T:\ \{}
\DoxyCodeLine{02082\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::AND\_V,\ Vector(std::move(constructed.back()),\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_1)));}
\DoxyCodeLine{02083\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02084\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02085\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::AND\_B:\ \{}
\DoxyCodeLine{02086\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::AND\_B,\ constructed);}
\DoxyCodeLine{02087\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02088\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02089\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::AND\_N:\ \{}
\DoxyCodeLine{02090\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ mid\ =\ std::move(constructed.back());}
\DoxyCodeLine{02091\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02092\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::ANDOR,\ Vector(std::move(constructed.back()),\ std::move(mid),\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_0)));}
\DoxyCodeLine{02093\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02094\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02095\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::AND\_V:\ \{}
\DoxyCodeLine{02096\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::AND\_V,\ constructed);}
\DoxyCodeLine{02097\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02098\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02099\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::OR\_B:\ \{}
\DoxyCodeLine{02100\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_B,\ constructed);}
\DoxyCodeLine{02101\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02102\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02103\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::OR\_C:\ \{}
\DoxyCodeLine{02104\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_C,\ constructed);}
\DoxyCodeLine{02105\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02106\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02107\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::OR\_D:\ \{}
\DoxyCodeLine{02108\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_D,\ constructed);}
\DoxyCodeLine{02109\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02110\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02111\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::OR\_I:\ \{}
\DoxyCodeLine{02112\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_I,\ constructed);}
\DoxyCodeLine{02113\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02114\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02115\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::ANDOR:\ \{}
\DoxyCodeLine{02116\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ right\ =\ std::move(constructed.back());}
\DoxyCodeLine{02117\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02118\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ mid\ =\ std::move(constructed.back());}
\DoxyCodeLine{02119\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02120\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::ANDOR,\ Vector(std::move(constructed.back()),\ std::move(mid),\ std::move(right)));}
\DoxyCodeLine{02121\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02122\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02123\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::THRESH:\ \{}
\DoxyCodeLine{02124\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in.size()\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02125\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0]\ ==\ \textcolor{charliteral}{','})\ \{}
\DoxyCodeLine{02126\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(1);}
\DoxyCodeLine{02127\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::THRESH,\ n+1,\ k);}
\DoxyCodeLine{02128\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(ParseContext::WRAPPED\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02129\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ script\_size\ +=\ 2;}
\DoxyCodeLine{02130\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[0]\ ==\ \textcolor{charliteral}{')'})\ \{}
\DoxyCodeLine{02131\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (k\ >\ n)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02132\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(1);}
\DoxyCodeLine{02133\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Children\ are\ constructed\ in\ reverse\ order,\ so\ iterate\ from\ end\ to\ beginning}}
\DoxyCodeLine{02134\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<NodeRef<Key>>\ subs;}
\DoxyCodeLine{02135\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ n;\ ++i)\ \{}
\DoxyCodeLine{02136\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ subs.push\_back(std::move(constructed.back()));}
\DoxyCodeLine{02137\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02138\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02139\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::reverse(subs.begin(),\ subs.end());}
\DoxyCodeLine{02140\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::THRESH,\ std::move(subs),\ k));}
\DoxyCodeLine{02141\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02142\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02143\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02144\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02145\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02146\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::COMMA:\ \{}
\DoxyCodeLine{02147\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in.size()\ <\ 1\ ||\ in[0]\ !=\ \textcolor{charliteral}{','})\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02148\ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(1);}
\DoxyCodeLine{02149\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02150\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02151\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ ParseContext::CLOSE\_BRACKET:\ \{}
\DoxyCodeLine{02152\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in.size()\ <\ 1\ ||\ in[0]\ !=\ \textcolor{charliteral}{')'})\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02153\ \ \ \ \ \ \ \ \ \ \ \ \ in\ =\ in.subspan(1);}
\DoxyCodeLine{02154\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02155\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02156\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02157\ \ \ \ \ \}}
\DoxyCodeLine{02158\ }
\DoxyCodeLine{02159\ \ \ \ \ \textcolor{comment}{//\ Sanity\ checks\ on\ the\ produced\ miniscript}}
\DoxyCodeLine{02160\ \ \ \ \ assert(constructed.size()\ >=\ 1);}
\DoxyCodeLine{02161\ \ \ \ \ CHECK\_NONFATAL(constructed.size()\ ==\ 1);}
\DoxyCodeLine{02162\ \ \ \ \ assert(constructed[0]-\/>ScriptSize()\ ==\ script\_size);}
\DoxyCodeLine{02163\ \ \ \ \ \textcolor{keywordflow}{if}\ (in.size()\ >\ 0)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02164\ \ \ \ \ NodeRef<Key>\ tl\_node\ =\ std::move(constructed.front());}
\DoxyCodeLine{02165\ \ \ \ \ tl\_node-\/>DuplicateKeyCheck(ctx);}
\DoxyCodeLine{02166\ \ \ \ \ \textcolor{keywordflow}{return}\ tl\_node;}
\DoxyCodeLine{02167\ \}}
\DoxyCodeLine{02168\ }
\DoxyCodeLine{02177\ std::optional<std::vector<Opcode>>\ DecomposeScript(\textcolor{keyword}{const}\ CScript\&\ script);}
\DoxyCodeLine{02178\ }
\DoxyCodeLine{02180\ std::optional<int64\_t>\ ParseScriptNumber(\textcolor{keyword}{const}\ Opcode\&\ in);}
\DoxyCodeLine{02181\ }
\DoxyCodeLine{02182\ \textcolor{keyword}{enum\ class}\ DecodeContext\ \{}
\DoxyCodeLine{02185\ \ \ \ \ SINGLE\_BKV\_EXPR,}
\DoxyCodeLine{02188\ \ \ \ \ BKV\_EXPR,}
\DoxyCodeLine{02190\ \ \ \ \ W\_EXPR,}
\DoxyCodeLine{02191\ }
\DoxyCodeLine{02195\ \ \ \ \ SWAP,}
\DoxyCodeLine{02198\ \ \ \ \ ALT,}
\DoxyCodeLine{02200\ \ \ \ \ CHECK,}
\DoxyCodeLine{02202\ \ \ \ \ DUP\_IF,}
\DoxyCodeLine{02204\ \ \ \ \ VERIFY,}
\DoxyCodeLine{02206\ \ \ \ \ NON\_ZERO,}
\DoxyCodeLine{02208\ \ \ \ \ ZERO\_NOTEQUAL,}
\DoxyCodeLine{02209\ }
\DoxyCodeLine{02214\ \ \ \ \ MAYBE\_AND\_V,}
\DoxyCodeLine{02216\ \ \ \ \ AND\_V,}
\DoxyCodeLine{02218\ \ \ \ \ AND\_B,}
\DoxyCodeLine{02220\ \ \ \ \ ANDOR,}
\DoxyCodeLine{02222\ \ \ \ \ OR\_B,}
\DoxyCodeLine{02224\ \ \ \ \ OR\_C,}
\DoxyCodeLine{02226\ \ \ \ \ OR\_D,}
\DoxyCodeLine{02227\ }
\DoxyCodeLine{02231\ \ \ \ \ THRESH\_W,}
\DoxyCodeLine{02234\ \ \ \ \ THRESH\_E,}
\DoxyCodeLine{02235\ }
\DoxyCodeLine{02239\ \ \ \ \ ENDIF,}
\DoxyCodeLine{02243\ \ \ \ \ ENDIF\_NOTIF,}
\DoxyCodeLine{02247\ \ \ \ \ ENDIF\_ELSE,}
\DoxyCodeLine{02248\ \};}
\DoxyCodeLine{02249\ }
\DoxyCodeLine{02251\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Key,\ \textcolor{keyword}{typename}\ Ctx,\ \textcolor{keyword}{typename}\ I>}
\DoxyCodeLine{02252\ \textcolor{keyword}{inline}\ NodeRef<Key>\ DecodeScript(I\&\ in,\ I\ last,\ \textcolor{keyword}{const}\ Ctx\&\ ctx)}
\DoxyCodeLine{02253\ \{}
\DoxyCodeLine{02254\ \ \ \ \ \textcolor{comment}{//\ The\ two\ integers\ are\ used\ to\ hold\ state\ for\ thresh()}}
\DoxyCodeLine{02255\ \ \ \ \ std::vector<std::tuple<DecodeContext,\ int64\_t,\ int64\_t>>\ to\_parse;}
\DoxyCodeLine{02256\ \ \ \ \ std::vector<NodeRef<Key>>\ constructed;}
\DoxyCodeLine{02257\ }
\DoxyCodeLine{02258\ \ \ \ \ \textcolor{comment}{//\ This\ is\ the\ top\ level,\ so\ we\ assume\ the\ type\ is\ B}}
\DoxyCodeLine{02259\ \ \ \ \ \textcolor{comment}{//\ (in\ particular,\ disallowing\ top\ level\ W\ expressions)}}
\DoxyCodeLine{02260\ \ \ \ \ to\_parse.emplace\_back(DecodeContext::BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02261\ }
\DoxyCodeLine{02262\ \ \ \ \ \textcolor{keywordflow}{while}\ (!to\_parse.empty())\ \{}
\DoxyCodeLine{02263\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Exit\ early\ if\ the\ Miniscript\ is\ not\ going\ to\ be\ valid.}}
\DoxyCodeLine{02264\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!constructed.empty()\ \&\&\ !constructed.back()-\/>IsValid())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02265\ }
\DoxyCodeLine{02266\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Get\ the\ current\ context\ we\ are\ decoding\ within}}
\DoxyCodeLine{02267\ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ [cur\_context,\ n,\ k]\ =\ to\_parse.back();}
\DoxyCodeLine{02268\ \ \ \ \ \ \ \ \ to\_parse.pop\_back();}
\DoxyCodeLine{02269\ }
\DoxyCodeLine{02270\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{switch}(cur\_context)\ \{}
\DoxyCodeLine{02271\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::SINGLE\_BKV\_EXPR:\ \{}
\DoxyCodeLine{02272\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02273\ }
\DoxyCodeLine{02274\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Constants}}
\DoxyCodeLine{02275\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_1)\ \{}
\DoxyCodeLine{02276\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02277\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_1));}
\DoxyCodeLine{02278\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02279\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02280\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_0)\ \{}
\DoxyCodeLine{02281\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02282\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::JUST\_0));}
\DoxyCodeLine{02283\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02284\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02285\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Public\ keys}}
\DoxyCodeLine{02286\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].second.size()\ ==\ 33\ ||\ in[0].second.size()\ ==\ 32)\ \{}
\DoxyCodeLine{02287\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ ctx.FromPKBytes(in[0].second.begin(),\ in[0].second.end());}
\DoxyCodeLine{02288\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02289\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02290\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::PK\_K,\ Vector(std::move(*key))));}
\DoxyCodeLine{02291\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02292\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02293\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 5\ \&\&\ in[0].first\ ==\ OP\_VERIFY\ \&\&\ in[1].first\ ==\ OP\_EQUAL\ \&\&\ in[3].first\ ==\ OP\_HASH160\ \&\&\ in[4].first\ ==\ OP\_DUP\ \&\&\ in[2].second.size()\ ==\ 20)\ \{}
\DoxyCodeLine{02294\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ ctx.FromPKHBytes(in[2].second.begin(),\ in[2].second.end());}
\DoxyCodeLine{02295\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02296\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 5;}
\DoxyCodeLine{02297\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::PK\_H,\ Vector(std::move(*key))));}
\DoxyCodeLine{02298\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02299\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02300\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Time\ locks}}
\DoxyCodeLine{02301\ \ \ \ \ \ \ \ \ \ \ \ \ std::optional<int64\_t>\ num;}
\DoxyCodeLine{02302\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 2\ \&\&\ in[0].first\ ==\ OP\_CHECKSEQUENCEVERIFY\ \&\&\ (num\ =\ ParseScriptNumber(in[1])))\ \{}
\DoxyCodeLine{02303\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 2;}
\DoxyCodeLine{02304\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*num\ <\ 1\ ||\ *num\ >\ 0x7FFFFFFFL)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02305\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::OLDER,\ *num));}
\DoxyCodeLine{02306\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02307\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02308\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 2\ \&\&\ in[0].first\ ==\ OP\_CHECKLOCKTIMEVERIFY\ \&\&\ (num\ =\ ParseScriptNumber(in[1])))\ \{}
\DoxyCodeLine{02309\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 2;}
\DoxyCodeLine{02310\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (num\ <\ 1\ ||\ num\ >\ 0x7FFFFFFFL)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02311\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::AFTER,\ *num));}
\DoxyCodeLine{02312\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02313\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02314\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Hashes}}
\DoxyCodeLine{02315\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 7\ \&\&\ in[0].first\ ==\ OP\_EQUAL\ \&\&\ in[3].first\ ==\ OP\_VERIFY\ \&\&\ in[4].first\ ==\ OP\_EQUAL\ \&\&\ (num\ =\ ParseScriptNumber(in[5]))\ \&\&\ num\ ==\ 32\ \&\&\ in[6].first\ ==\ OP\_SIZE)\ \{}
\DoxyCodeLine{02316\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[2].first\ ==\ OP\_SHA256\ \&\&\ in[1].second.size()\ ==\ 32)\ \{}
\DoxyCodeLine{02317\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::SHA256,\ in[1].second));}
\DoxyCodeLine{02318\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 7;}
\DoxyCodeLine{02319\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02320\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[2].first\ ==\ OP\_RIPEMD160\ \&\&\ in[1].second.size()\ ==\ 20)\ \{}
\DoxyCodeLine{02321\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::RIPEMD160,\ in[1].second));}
\DoxyCodeLine{02322\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 7;}
\DoxyCodeLine{02323\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02324\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[2].first\ ==\ OP\_HASH256\ \&\&\ in[1].second.size()\ ==\ 32)\ \{}
\DoxyCodeLine{02325\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::HASH256,\ in[1].second));}
\DoxyCodeLine{02326\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 7;}
\DoxyCodeLine{02327\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02328\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[2].first\ ==\ OP\_HASH160\ \&\&\ in[1].second.size()\ ==\ 20)\ \{}
\DoxyCodeLine{02329\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::HASH160,\ in[1].second));}
\DoxyCodeLine{02330\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 7;}
\DoxyCodeLine{02331\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02332\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02333\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02334\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Multi}}
\DoxyCodeLine{02335\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 3\ \&\&\ in[0].first\ ==\ OP\_CHECKMULTISIG)\ \{}
\DoxyCodeLine{02336\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (IsTapscript(ctx.MsContext()))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02337\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<Key>\ keys;}
\DoxyCodeLine{02338\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ n\ =\ ParseScriptNumber(in[1]);}
\DoxyCodeLine{02339\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!n\ ||\ last\ -\/\ in\ <\ 3\ +\ *n)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02340\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*n\ <\ 1\ ||\ *n\ >\ 20)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02341\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ *n;\ ++i)\ \{}
\DoxyCodeLine{02342\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[2\ +\ i].second.size()\ !=\ 33)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02343\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ ctx.FromPKBytes(in[2\ +\ i].second.begin(),\ in[2\ +\ i].second.end());}
\DoxyCodeLine{02344\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02345\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ keys.push\_back(std::move(*key));}
\DoxyCodeLine{02346\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02347\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ k\ =\ ParseScriptNumber(in[2\ +\ *n]);}
\DoxyCodeLine{02348\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!k\ ||\ *k\ <\ 1\ ||\ *k\ >\ *n)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02349\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 3\ +\ *n;}
\DoxyCodeLine{02350\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::reverse(keys.begin(),\ keys.end());}
\DoxyCodeLine{02351\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::MULTI,\ std::move(keys),\ *k));}
\DoxyCodeLine{02352\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02353\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02354\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Tapscript's\ equivalent\ of\ multi}}
\DoxyCodeLine{02355\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 4\ \&\&\ in[0].first\ ==\ OP\_NUMEQUAL)\ \{}
\DoxyCodeLine{02356\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!IsTapscript(ctx.MsContext()))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02357\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ The\ necessary\ threshold\ of\ signatures.}}
\DoxyCodeLine{02358\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ k\ =\ ParseScriptNumber(in[1]);}
\DoxyCodeLine{02359\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!k)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02360\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*k\ <\ 1\ ||\ *k\ >\ MAX\_PUBKEYS\_PER\_MULTI\_A)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02361\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ <\ 2\ +\ *k\ *\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02362\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<Key>\ keys;}
\DoxyCodeLine{02363\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ keys.reserve(*k);}
\DoxyCodeLine{02364\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Walk\ through\ the\ expected\ (pubkey,\ CHECKSIG[ADD])\ pairs.}}
\DoxyCodeLine{02365\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ pos\ =\ 2;;\ pos\ +=\ 2)\ \{}
\DoxyCodeLine{02366\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ <\ pos\ +\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02367\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Make\ sure\ it's\ indeed\ an\ x-\/only\ pubkey\ and\ a\ CHECKSIG[ADD],\ then\ parse\ the\ key.}}
\DoxyCodeLine{02368\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[pos].first\ !=\ OP\_CHECKSIGADD\ \&\&\ in[pos].first\ !=\ OP\_CHECKSIG)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02369\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[pos\ +\ 1].second.size()\ !=\ 32)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02370\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ ctx.FromPKBytes(in[pos\ +\ 1].second.begin(),\ in[pos\ +\ 1].second.end());}
\DoxyCodeLine{02371\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!key)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02372\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ keys.push\_back(std::move(*key));}
\DoxyCodeLine{02373\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Make\ sure\ early\ we\ don't\ parse\ an\ arbitrary\ large\ expression.}}
\DoxyCodeLine{02374\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (keys.size()\ >\ MAX\_PUBKEYS\_PER\_MULTI\_A)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02375\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ OP\_CHECKSIG\ means\ it\ was\ the\ last\ one\ to\ parse.}}
\DoxyCodeLine{02376\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[pos].first\ ==\ OP\_CHECKSIG)\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02377\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02378\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (keys.size()\ <\ (\textcolor{keywordtype}{size\_t})*k)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02379\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 2\ +\ keys.size()\ *\ 2;}
\DoxyCodeLine{02380\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::reverse(keys.begin(),\ keys.end());}
\DoxyCodeLine{02381\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::MULTI\_A,\ std::move(keys),\ *k));}
\DoxyCodeLine{02382\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02383\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02387\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ c:\ wrapper}}
\DoxyCodeLine{02388\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_CHECKSIG)\ \{}
\DoxyCodeLine{02389\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02390\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::CHECK,\ -\/1,\ -\/1);}
\DoxyCodeLine{02391\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02392\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02393\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02394\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ v:\ wrapper}}
\DoxyCodeLine{02395\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_VERIFY)\ \{}
\DoxyCodeLine{02396\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02397\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::VERIFY,\ -\/1,\ -\/1);}
\DoxyCodeLine{02398\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02399\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02400\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02401\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ n:\ wrapper}}
\DoxyCodeLine{02402\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_0NOTEQUAL)\ \{}
\DoxyCodeLine{02403\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02404\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::ZERO\_NOTEQUAL,\ -\/1,\ -\/1);}
\DoxyCodeLine{02405\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02406\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02407\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02408\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Thresh}}
\DoxyCodeLine{02409\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 3\ \&\&\ in[0].first\ ==\ OP\_EQUAL\ \&\&\ (num\ =\ ParseScriptNumber(in[1])))\ \{}
\DoxyCodeLine{02410\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (*num\ <\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02411\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 2;}
\DoxyCodeLine{02412\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::THRESH\_W,\ 0,\ *num);}
\DoxyCodeLine{02413\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02414\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02415\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ OP\_ENDIF\ can\ be\ WRAP\_J,\ WRAP\_D,\ ANDOR,\ OR\_C,\ OR\_D,\ or\ OR\_I}}
\DoxyCodeLine{02416\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_ENDIF)\ \{}
\DoxyCodeLine{02417\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02418\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::ENDIF,\ -\/1,\ -\/1);}
\DoxyCodeLine{02419\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02420\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02421\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02427\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ and\_b}}
\DoxyCodeLine{02428\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_BOOLAND)\ \{}
\DoxyCodeLine{02429\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02430\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::AND\_B,\ -\/1,\ -\/1);}
\DoxyCodeLine{02431\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02432\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::W\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02433\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02434\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02435\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ or\_b}}
\DoxyCodeLine{02436\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_BOOLOR)\ \{}
\DoxyCodeLine{02437\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02438\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::OR\_B,\ -\/1,\ -\/1);}
\DoxyCodeLine{02439\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02440\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::W\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02441\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02442\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02443\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Unrecognised\ expression}}
\DoxyCodeLine{02444\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02445\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02446\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::BKV\_EXPR:\ \{}
\DoxyCodeLine{02447\ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::MAYBE\_AND\_V,\ -\/1,\ -\/1);}
\DoxyCodeLine{02448\ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02449\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02450\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02451\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::W\_EXPR:\ \{}
\DoxyCodeLine{02452\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ a:\ wrapper}}
\DoxyCodeLine{02453\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02454\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_FROMALTSTACK)\ \{}
\DoxyCodeLine{02455\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02456\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::ALT,\ -\/1,\ -\/1);}
\DoxyCodeLine{02457\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02458\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SWAP,\ -\/1,\ -\/1);}
\DoxyCodeLine{02459\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02460\ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02461\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02462\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02463\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::MAYBE\_AND\_V:\ \{}
\DoxyCodeLine{02464\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ If\ we\ reach\ a\ potential\ AND\_V\ top-\/level,\ check\ if\ the\ next\ part\ of\ the\ script\ could\ be\ another\ AND\_V\ child}}
\DoxyCodeLine{02465\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ These\ op-\/codes\ cannot\ end\ any\ well-\/formed\ miniscript\ so\ cannot\ be\ used\ in\ an\ and\_v\ node.}}
\DoxyCodeLine{02466\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ <\ last\ \&\&\ in[0].first\ !=\ OP\_IF\ \&\&\ in[0].first\ !=\ OP\_ELSE\ \&\&\ in[0].first\ !=\ OP\_NOTIF\ \&\&\ in[0].first\ !=\ OP\_TOALTSTACK\ \&\&\ in[0].first\ !=\ OP\_SWAP)\ \{}
\DoxyCodeLine{02467\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::AND\_V,\ -\/1,\ -\/1);}
\DoxyCodeLine{02468\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ BKV\_EXPR\ can\ contain\ more\ AND\_V\ nodes}}
\DoxyCodeLine{02469\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02470\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02471\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02472\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02473\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::SWAP:\ \{}
\DoxyCodeLine{02474\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last\ ||\ in[0].first\ !=\ OP\_SWAP\ ||\ constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02475\ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02476\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_S,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02477\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02478\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02479\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::ALT:\ \{}
\DoxyCodeLine{02480\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last\ ||\ in[0].first\ !=\ OP\_TOALTSTACK\ ||\ constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02481\ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02482\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_A,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02483\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02484\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02485\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::CHECK:\ \{}
\DoxyCodeLine{02486\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02487\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_C,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02488\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02489\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02490\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::DUP\_IF:\ \{}
\DoxyCodeLine{02491\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02492\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_D,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02493\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02494\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02495\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::VERIFY:\ \{}
\DoxyCodeLine{02496\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02497\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_V,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02498\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02499\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02500\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::NON\_ZERO:\ \{}
\DoxyCodeLine{02501\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02502\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_J,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02503\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02504\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02505\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::ZERO\_NOTEQUAL:\ \{}
\DoxyCodeLine{02506\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.empty())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02507\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::WRAP\_N,\ Vector(std::move(constructed.back())));}
\DoxyCodeLine{02508\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02509\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02510\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::AND\_V:\ \{}
\DoxyCodeLine{02511\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ <\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02512\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::AND\_V,\ constructed,\ \textcolor{comment}{/*reverse=*/}\textcolor{keyword}{true});}
\DoxyCodeLine{02513\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02514\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02515\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::AND\_B:\ \{}
\DoxyCodeLine{02516\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ <\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02517\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::AND\_B,\ constructed,\ \textcolor{comment}{/*reverse=*/}\textcolor{keyword}{true});}
\DoxyCodeLine{02518\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02519\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02520\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::OR\_B:\ \{}
\DoxyCodeLine{02521\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ <\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02522\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_B,\ constructed,\ \textcolor{comment}{/*reverse=*/}\textcolor{keyword}{true});}
\DoxyCodeLine{02523\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02524\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02525\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::OR\_C:\ \{}
\DoxyCodeLine{02526\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ <\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02527\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_C,\ constructed,\ \textcolor{comment}{/*reverse=*/}\textcolor{keyword}{true});}
\DoxyCodeLine{02528\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02529\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02530\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::OR\_D:\ \{}
\DoxyCodeLine{02531\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ <\ 2)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02532\ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_D,\ constructed,\ \textcolor{comment}{/*reverse=*/}\textcolor{keyword}{true});}
\DoxyCodeLine{02533\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02534\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02535\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::ANDOR:\ \{}
\DoxyCodeLine{02536\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ <\ 3)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02537\ \ \ \ \ \ \ \ \ \ \ \ \ NodeRef<Key>\ left\ =\ std::move(constructed.back());}
\DoxyCodeLine{02538\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02539\ \ \ \ \ \ \ \ \ \ \ \ \ NodeRef<Key>\ right\ =\ std::move(constructed.back());}
\DoxyCodeLine{02540\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02541\ \ \ \ \ \ \ \ \ \ \ \ \ NodeRef<Key>\ mid\ =\ std::move(constructed.back());}
\DoxyCodeLine{02542\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.back()\ =\ MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::ANDOR,\ Vector(std::move(left),\ std::move(mid),\ std::move(right)));}
\DoxyCodeLine{02543\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02544\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02545\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::THRESH\_W:\ \{}
\DoxyCodeLine{02546\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02547\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_ADD)\ \{}
\DoxyCodeLine{02548\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02549\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::THRESH\_W,\ n+1,\ k);}
\DoxyCodeLine{02550\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::W\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02551\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02552\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::THRESH\_E,\ n+1,\ k);}
\DoxyCodeLine{02553\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ All\ children\ of\ thresh\ have\ type\ modifier\ d,\ so\ cannot\ be\ and\_v}}
\DoxyCodeLine{02554\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02555\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02556\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02557\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02558\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::THRESH\_E:\ \{}
\DoxyCodeLine{02559\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (k\ <\ 1\ ||\ k\ >\ n\ ||\ constructed.size()\ <\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02560\ \ \ \ \ \ \ \ \ \ \ \ \ std::vector<NodeRef<Key>>\ subs;}
\DoxyCodeLine{02561\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ n;\ ++i)\ \{}
\DoxyCodeLine{02562\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ NodeRef<Key>\ sub\ =\ std::move(constructed.back());}
\DoxyCodeLine{02563\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ constructed.pop\_back();}
\DoxyCodeLine{02564\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ subs.push\_back(std::move(sub));}
\DoxyCodeLine{02565\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02566\ \ \ \ \ \ \ \ \ \ \ \ \ constructed.push\_back(MakeNodeRef<Key>(internal::NoDupCheck\{\},\ ctx.MsContext(),\ Fragment::THRESH,\ std::move(subs),\ k));}
\DoxyCodeLine{02567\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02568\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02569\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::ENDIF:\ \{}
\DoxyCodeLine{02570\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02571\ }
\DoxyCodeLine{02572\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ could\ be\ andor\ or\ or\_i}}
\DoxyCodeLine{02573\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_ELSE)\ \{}
\DoxyCodeLine{02574\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02575\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::ENDIF\_ELSE,\ -\/1,\ -\/1);}
\DoxyCodeLine{02576\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02577\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02578\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ could\ be\ j:\ or\ d:\ wrapper}}
\DoxyCodeLine{02579\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_IF)\ \{}
\DoxyCodeLine{02580\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 2\ \&\&\ in[1].first\ ==\ OP\_DUP)\ \{}
\DoxyCodeLine{02581\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 2;}
\DoxyCodeLine{02582\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::DUP\_IF,\ -\/1,\ -\/1);}
\DoxyCodeLine{02583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (last\ -\/\ in\ >=\ 3\ \&\&\ in[1].first\ ==\ OP\_0NOTEQUAL\ \&\&\ in[2].first\ ==\ OP\_SIZE)\ \{}
\DoxyCodeLine{02584\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ +=\ 3;}
\DoxyCodeLine{02585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::NON\_ZERO,\ -\/1,\ -\/1);}
\DoxyCodeLine{02586\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02587\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02588\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02589\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02590\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ could\ be\ or\_c\ or\ or\_d}}
\DoxyCodeLine{02591\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_NOTIF)\ \{}
\DoxyCodeLine{02592\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02593\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::ENDIF\_NOTIF,\ -\/1,\ -\/1);}
\DoxyCodeLine{02594\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02595\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02596\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02597\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02598\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02599\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02600\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::ENDIF\_NOTIF:\ \{}
\DoxyCodeLine{02601\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02602\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_IFDUP)\ \{}
\DoxyCodeLine{02603\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02604\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::OR\_D,\ -\/1,\ -\/1);}
\DoxyCodeLine{02605\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02606\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::OR\_C,\ -\/1,\ -\/1);}
\DoxyCodeLine{02607\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02608\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ or\_c\ and\ or\_d\ both\ require\ X\ to\ have\ type\ modifier\ d\ so,\ can't\ contain\ and\_v}}
\DoxyCodeLine{02609\ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02610\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02611\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02612\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{case}\ DecodeContext::ENDIF\_ELSE:\ \{}
\DoxyCodeLine{02613\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in\ >=\ last)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02614\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_IF)\ \{}
\DoxyCodeLine{02615\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02616\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ BuildBack(ctx.MsContext(),\ Fragment::OR\_I,\ constructed,\ \textcolor{comment}{/*reverse=*/}\textcolor{keyword}{true});}
\DoxyCodeLine{02617\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (in[0].first\ ==\ OP\_NOTIF)\ \{}
\DoxyCodeLine{02618\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ++in;}
\DoxyCodeLine{02619\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::ANDOR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02620\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ andor\ requires\ X\ to\ have\ type\ modifier\ d,\ so\ it\ can't\ be\ and\_v}}
\DoxyCodeLine{02621\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_parse.emplace\_back(DecodeContext::SINGLE\_BKV\_EXPR,\ -\/1,\ -\/1);}
\DoxyCodeLine{02622\ \ \ \ \ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02623\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02624\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02625\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02626\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02627\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{02628\ \ \ \ \ \}}
\DoxyCodeLine{02629\ \ \ \ \ \textcolor{keywordflow}{if}\ (constructed.size()\ !=\ 1)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02630\ \ \ \ \ NodeRef<Key>\ tl\_node\ =\ std::move(constructed.front());}
\DoxyCodeLine{02631\ \ \ \ \ tl\_node-\/>DuplicateKeyCheck(ctx);}
\DoxyCodeLine{02632\ \ \ \ \ \textcolor{comment}{//\ Note\ that\ due\ to\ how\ ComputeType\ works\ (only\ assign\ the\ type\ to\ the\ node\ if\ the}}
\DoxyCodeLine{02633\ \ \ \ \ \textcolor{comment}{//\ subs'\ types\ are\ valid)\ this\ would\ fail\ if\ any\ node\ of\ tree\ is\ badly\ typed.}}
\DoxyCodeLine{02634\ \ \ \ \ \textcolor{keywordflow}{if}\ (!tl\_node-\/>IsValidTopLevel())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02635\ \ \ \ \ \textcolor{keywordflow}{return}\ tl\_node;}
\DoxyCodeLine{02636\ \}}
\DoxyCodeLine{02637\ }
\DoxyCodeLine{02638\ \}\ \textcolor{comment}{//\ namespace\ internal}}
\DoxyCodeLine{02639\ }
\DoxyCodeLine{02640\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{02641\ \textcolor{keyword}{inline}\ NodeRef<typename\ Ctx::Key>\ FromString(\textcolor{keyword}{const}\ std::string\&\ str,\ \textcolor{keyword}{const}\ Ctx\&\ ctx)\ \{}
\DoxyCodeLine{02642\ \ \ \ \ \textcolor{keywordflow}{return}\ internal::Parse<typename\ Ctx::Key>(str,\ ctx);}
\DoxyCodeLine{02643\ \}}
\DoxyCodeLine{02644\ }
\DoxyCodeLine{02645\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Ctx>}
\DoxyCodeLine{02646\ \textcolor{keyword}{inline}\ NodeRef<typename\ Ctx::Key>\ FromScript(\textcolor{keyword}{const}\ CScript\&\ script,\ \textcolor{keyword}{const}\ Ctx\&\ ctx)\ \{}
\DoxyCodeLine{02647\ \ \ \ \ \textcolor{keyword}{using\ namespace\ }internal;}
\DoxyCodeLine{02648\ \ \ \ \ \textcolor{comment}{//\ A\ too\ large\ Script\ is\ necessarily\ invalid,\ don't\ bother\ parsing\ it.}}
\DoxyCodeLine{02649\ \ \ \ \ \textcolor{keywordflow}{if}\ (script.size()\ >\ MaxScriptSize(ctx.MsContext()))\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02650\ \ \ \ \ \textcolor{keyword}{auto}\ decomposed\ =\ DecomposeScript(script);}
\DoxyCodeLine{02651\ \ \ \ \ \textcolor{keywordflow}{if}\ (!decomposed)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02652\ \ \ \ \ \textcolor{keyword}{auto}\ it\ =\ decomposed-\/>begin();}
\DoxyCodeLine{02653\ \ \ \ \ \textcolor{keyword}{auto}\ ret\ =\ DecodeScript<typename\ Ctx::Key>(it,\ decomposed-\/>end(),\ ctx);}
\DoxyCodeLine{02654\ \ \ \ \ \textcolor{keywordflow}{if}\ (!ret)\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02655\ \ \ \ \ \textcolor{keywordflow}{if}\ (it\ !=\ decomposed-\/>end())\ \textcolor{keywordflow}{return}\ \{\};}
\DoxyCodeLine{02656\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{02657\ \}}
\DoxyCodeLine{02658\ }
\DoxyCodeLine{02659\ \}\ \textcolor{comment}{//\ namespace\ miniscript}}
\DoxyCodeLine{02660\ }
\DoxyCodeLine{02661\ \textcolor{preprocessor}{\#endif\ }\textcolor{comment}{//\ BITCOIN\_SCRIPT\_MINISCRIPT\_H}}

\end{DoxyCode}
