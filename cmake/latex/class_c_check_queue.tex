\doxysection{CCheck\+Queue$<$ T, R $>$ Class Template Reference}
\label{class_c_check_queue}\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}


{\ttfamily \#include $<$checkqueue.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCheck\+Queue} (unsigned int batch\+\_\+size, int worker\+\_\+threads\+\_\+num)
\begin{DoxyCompactList}\small\item\em Create a new check queue. \end{DoxyCompactList}\item 
\textbf{ CCheck\+Queue} (const \textbf{ CCheck\+Queue} \&)=delete
\item 
\textbf{ CCheck\+Queue} \& \textbf{ operator=} (const \textbf{ CCheck\+Queue} \&)=delete
\item 
\textbf{ CCheck\+Queue} (\textbf{ CCheck\+Queue} \&\&)=delete
\item 
\textbf{ CCheck\+Queue} \& \textbf{ operator=} (\textbf{ CCheck\+Queue} \&\&)=delete
\item 
std\+::optional$<$ R $>$ \textbf{ Complete} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\item 
void \textbf{ Add} (std\+::vector$<$ \textbf{ T} $>$ \&\&v\+Checks) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\begin{DoxyCompactList}\small\item\em Add a batch of checks to the queue. \end{DoxyCompactList}\item 
\textbf{ $\sim$\+CCheck\+Queue} ()
\item 
bool \textbf{ Has\+Threads} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\textbf{ Mutex} \textbf{ m\+\_\+control\+\_\+mutex}
\begin{DoxyCompactList}\small\item\em \doxyref{Mutex}{p.}{sync_8h_a326d1d46ce05b5316d8ebe2694a10a6e} to ensure only one concurrent \doxyref{CCheck\+Queue\+Control}{p.}{class_c_check_queue_control}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$\newline
class CCheck\+Queue$<$ T, R $>$}
Queue for verifications that have to be performed. The verifications are represented by a type T, which must provide an operator(), returning an std\+::optional$<$\+R$>$.

The overall result of the computation is std\+::nullopt if all invocations return std\+::nullopt, or one of the other results otherwise.

One thread (the master) is assumed to push batches of verifications onto the queue, where they are processed by N-\/1 worker threads. When the master is done adding work, it temporarily joins the worker pool as an N\textquotesingle{}th worker, until all jobs are done. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!CCheckQueue@{CCheckQueue}}
\index{CCheckQueue@{CCheckQueue}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{CCheckQueue()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{class_c_check_queue_a628155aab35c456de3f0e77c11c7cddb} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
\textbf{ CCheck\+Queue} (\begin{DoxyParamCaption}\item[{unsigned int}]{batch\+\_\+size}{, }\item[{int}]{worker\+\_\+threads\+\_\+num}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Create a new check queue. 

\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!CCheckQueue@{CCheckQueue}}
\index{CCheckQueue@{CCheckQueue}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{CCheckQueue()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{class_c_check_queue_aacd3f0a7a56dcf5a4ab416184303a8d7} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
\textbf{ CCheck\+Queue} (\begin{DoxyParamCaption}\item[{const \textbf{ CCheck\+Queue}$<$ \textbf{ T}, R $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!CCheckQueue@{CCheckQueue}}
\index{CCheckQueue@{CCheckQueue}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{CCheckQueue()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{class_c_check_queue_a9f23902910d81701adc8ce8898e545a3} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
\textbf{ CCheck\+Queue} (\begin{DoxyParamCaption}\item[{\textbf{ CCheck\+Queue}$<$ \textbf{ T}, R $>$ \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!````~CCheckQueue@{$\sim$CCheckQueue}}
\index{````~CCheckQueue@{$\sim$CCheckQueue}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{$\sim$CCheckQueue()}
{\footnotesize\ttfamily \label{class_c_check_queue_a3191ce6fb47fc7a6301f45a9cd8457b0} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
$\sim$\textbf{ CCheck\+Queue} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!Add@{Add}}
\index{Add@{Add}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{Add()}
{\footnotesize\ttfamily \label{class_c_check_queue_a8c5a84cbdf81b2568e9eba87149faf30} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
void Add (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \textbf{ T} $>$ \&\&}]{v\+Checks}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Add a batch of checks to the queue. 

\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!Complete@{Complete}}
\index{Complete@{Complete}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{Complete()}
{\footnotesize\ttfamily \label{class_c_check_queue_a583ea5c6d0803757ad5fd467e3f5ba75} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
std\+::optional$<$ R $>$ Complete (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Join the execution until completion. If at least one evaluation wasn\textquotesingle{}t successful, return its error. \index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!HasThreads@{HasThreads}}
\index{HasThreads@{HasThreads}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{HasThreads()}
{\footnotesize\ttfamily \label{class_c_check_queue_ac04e45e79565b10e40a258d01ce40969} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
bool Has\+Threads (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!operator=@{operator=}}
\index{operator=@{operator=}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_check_queue_a1b3f885e5052ea930fdc32ed812fc87c} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
\textbf{ CCheck\+Queue} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ CCheck\+Queue}$<$ \textbf{ T}, R $>$ \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!operator=@{operator=}}
\index{operator=@{operator=}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_check_queue_abc1fa25c8312d4204f15a4b27085f7a6} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
\textbf{ CCheck\+Queue} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ CCheck\+Queue}$<$ \textbf{ T}, R $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}!m\_control\_mutex@{m\_control\_mutex}}
\index{m\_control\_mutex@{m\_control\_mutex}!CCheckQueue$<$ T, R $>$@{CCheckQueue$<$ T, R $>$}}
\doxysubsubsection{m\_control\_mutex}
{\footnotesize\ttfamily \label{class_c_check_queue_af01ac6c7afb778ed51571e8dd39ed6ff} 
template$<$typename \textbf{ T}, typename R = std\+::remove\+\_\+cvref\+\_\+t$<$decltype(std\+::declval$<$\+T$>$()().\+value())$>$$>$ \\
\textbf{ Mutex} m\+\_\+control\+\_\+mutex}



\doxyref{Mutex}{p.}{sync_8h_a326d1d46ce05b5316d8ebe2694a10a6e} to ensure only one concurrent \doxyref{CCheck\+Queue\+Control}{p.}{class_c_check_queue_control}. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ checkqueue.\+h}\end{DoxyCompactItemize}
