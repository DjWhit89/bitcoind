\doxysection{CTx\+Mem\+Pool Class Reference}
\label{class_c_tx_mem_pool}\index{CTxMemPool@{CTxMemPool}}


{\ttfamily \#include $<$txmempool.\+h$>$}

Inheritance diagram for CTx\+Mem\+Pool\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_tx_mem_pool}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ CTx\+Mem\+Pool\+Entry\+\_\+\+Indices}
\item 
struct \textbf{ delta\+\_\+info}
\item 
class \textbf{ Change\+Set}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef boost\+::multi\+\_\+index\+\_\+container$<$ \textbf{ CTx\+Mem\+Pool\+Entry}, \textbf{ CTx\+Mem\+Pool\+Entry\+\_\+\+Indices} $>$ \textbf{ indexed\+\_\+transaction\+\_\+set}
\item 
using \textbf{ txiter} = indexed\+\_\+transaction\+\_\+set\+::nth\+\_\+index$<$0$>$\+::type\+::const\+\_\+iterator
\item 
typedef std\+::set$<$ \textbf{ txiter}, \textbf{ Compare\+Iterator\+By\+Hash} $>$ \textbf{ set\+Entries}
\item 
using \textbf{ Limits} = \textbf{ kernel\+::\+Mem\+Pool\+Limits}
\item 
using \textbf{ Options} = \textbf{ kernel\+::\+Mem\+Pool\+Options}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Graph} $>$ m\+\_\+txgraph \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Graph\+::\+Block\+Builder} $>$ m\+\_\+builder \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ indexed\+\_\+transaction\+\_\+set} map\+Tx \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
std\+::vector$<$ std\+::pair$<$ \textbf{ Wtxid}, \textbf{ txiter} $>$ $>$ txns\+\_\+randomized \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em All transactions in map\+Tx with their wtxids, in arbitrary order. \end{DoxyCompactList}\item 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, \textbf{ CAmount} $>$ \textbf{ Calculate\+Ancestor\+Data} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, \textbf{ CAmount} $>$ \textbf{ Calculate\+Descendant\+Data} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
int64\+\_\+t \textbf{ Get\+Descendant\+Count} (\textbf{ txiter} \textbf{ it}) const
\item 
int64\+\_\+t \textbf{ Get\+Descendant\+Count} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&e) const
\item 
int64\+\_\+t \textbf{ Get\+Ancestor\+Count} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&e) const
\item 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \textbf{ Get\+Children} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const
\item 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \textbf{ Get\+Parents} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const
\item 
\textbf{ indirectmap}$<$ \textbf{ COut\+Point}, \textbf{ txiter} $>$ map\+Next\+Tx \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
std\+::map$<$ \textbf{ Txid}, \textbf{ CAmount} $>$ map\+Deltas \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ CTx\+Mem\+Pool} (\textbf{ Options}\textbf{ Options} opts, \textbf{ bilingual\+\_\+str} \&error)
\item 
void \textbf{ remove\+For\+Reorg} (\textbf{ CChain} \&chain, std\+::function$<$ bool(\textbf{ txiter})$>$ filter\+\_\+final\+\_\+and\+\_\+mature) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
void \textbf{ remove\+For\+Block} (const std\+::vector$<$ \textbf{ CTransaction\+Ref} $>$ \&vtx, unsigned int n\+Block\+Height) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ Compare\+Mining\+Score\+With\+Topology} (const \textbf{ Wtxid} \&hasha, const \textbf{ Wtxid} \&hashb) const
\item 
bool \textbf{ is\+Spent} (const \textbf{ COut\+Point} \&outpoint) const
\item 
unsigned int \textbf{ Get\+Transactions\+Updated} () const
\item 
void \textbf{ Add\+Transactions\+Updated} (unsigned int n)
\item 
bool \textbf{ Has\+No\+Inputs\+Of} (const \textbf{ CTransaction} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Prioritise\+Transaction} (const \textbf{ Txid} \&hash, const \textbf{ CAmount} \&n\+Fee\+Delta)
\item 
void \textbf{ Apply\+Delta} (const \textbf{ Txid} \&hash, \textbf{ CAmount} \&n\+Fee\+Delta) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Clear\+Prioritisation} (const \textbf{ Txid} \&hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ \textbf{ delta\+\_\+info} $>$ \textbf{ Get\+Prioritised\+Transactions} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!\textbf{ cs})
\item 
const \textbf{ CTransaction} $\ast$ \textbf{ Get\+Conflict\+Tx} (const \textbf{ COut\+Point} \&prevout) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::optional$<$ \textbf{ txiter} $>$ \textbf{ Get\+Iter} (const \textbf{ Txid} \&txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::optional$<$ \textbf{ txiter} $>$ \textbf{ Get\+Iter} (const \textbf{ Wtxid} \&wtxid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ set\+Entries} \textbf{ Get\+Iter\+Set} (const std\+::set$<$ \textbf{ Txid} $>$ \&hashes) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ \textbf{ txiter} $>$ \textbf{ Get\+Iter\+Vec} (const std\+::vector$<$ \textbf{ Txid} $>$ \&txids) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Update\+Transactions\+From\+Block} (const std\+::vector$<$ \textbf{ Txid} $>$ \&v\+Hashes\+To\+Update) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
void \textbf{ cs\+\_\+main} \textbf{ LOCKS\+\_\+\+EXCLUDED} (\textbf{ m\+\_\+epoch})
\item 
std\+::vector$<$ \textbf{ Fee\+Per\+Weight} $>$ \textbf{ Get\+Feerate\+Diagram} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ Fee\+Per\+Weight} \textbf{ Get\+Main\+Chunk\+Feerate} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ const \textbf{ CTx\+Mem\+Pool\+Entry} $\ast$ $>$ \textbf{ Get\+Cluster} (\textbf{ Txid} txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
size\+\_\+t \textbf{ Get\+Unique\+Cluster\+Count} (const \textbf{ set\+Entries} \&iters\+\_\+conflicting) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ set\+Entries} \textbf{ Calculate\+Mem\+Pool\+Ancestors} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ Has\+Descendants} (const \textbf{ Txid} \&txid) const
\item 
std\+::vector$<$ \textbf{ txiter} $>$ \textbf{ Gather\+Clusters} (const std\+::vector$<$ \textbf{ Txid} $>$ \&txids) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Calculate\+Descendants} (\textbf{ txiter} \textbf{ it}, \textbf{ set\+Entries} \&set\+Descendants) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CTx\+Mem\+Pool\+::txiter} \textbf{ Calculate\+Descendants} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry, \textbf{ set\+Entries} \&set\+Descendants) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CFee\+Rate} \textbf{ Get\+Min\+Fee} () const
\item 
void \textbf{ Trim\+To\+Size} (size\+\_\+t sizelimit, std\+::vector$<$ \textbf{ COut\+Point} $>$ $\ast$pv\+No\+Spends\+Remaining=nullptr) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
int \textbf{ Expire} (std\+::chrono\+::seconds time) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Get\+Transaction\+Ancestry} (const \textbf{ Txid} \&txid, size\+\_\+t \&ancestors, size\+\_\+t \&cluster\+\_\+count, size\+\_\+t $\ast$ancestorsize=nullptr, \textbf{ CAmount} $\ast$ancestorfees=nullptr) const
\item 
bool \textbf{ Get\+Load\+Tried} () const
\item 
void \textbf{ Set\+Load\+Tried} (bool load\+\_\+tried)
\item 
unsigned long \textbf{ size} () const
\item 
uint64\+\_\+t \textbf{ Get\+Total\+Tx\+Size} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CAmount} \textbf{ Get\+Total\+Fee} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ exists} (const \textbf{ Txid} \&txid) const
\item 
bool \textbf{ exists} (const \textbf{ Wtxid} \&wtxid) const
\item 
const \textbf{ CTx\+Mem\+Pool\+Entry} $\ast$ \textbf{ Get\+Entry} (const \textbf{ Txid} \&txid) const \textbf{ LIFETIMEBOUND} \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CTransaction\+Ref} \textbf{ get} (const \textbf{ Txid} \&hash) const
\item 
{\footnotesize template$<$\textbf{ Txid\+Or\+Wtxid} T$>$ }\\\textbf{ Tx\+Mempool\+Info} \textbf{ info} (const \textbf{ T} \&id) const
\item 
{\footnotesize template$<$\textbf{ Txid\+Or\+Wtxid} T$>$ }\\\textbf{ Tx\+Mempool\+Info} \textbf{ info\+\_\+for\+\_\+relay} (const \textbf{ T} \&id, uint64\+\_\+t last\+\_\+sequence) const
\item 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+Ref} $>$ \textbf{ entry\+All} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ \textbf{ Tx\+Mempool\+Info} $>$ \textbf{ info\+All} () const
\item 
size\+\_\+t \textbf{ Dynamic\+Memory\+Usage} () const
\item 
void \textbf{ Add\+Unbroadcast\+Tx} (const \textbf{ Txid} \&txid)
\item 
bool \textbf{ Check\+Policy\+Limits} (const \textbf{ CTransaction\+Ref} \&tx)
\item 
void \textbf{ Remove\+Unbroadcast\+Tx} (const \textbf{ Txid} \&txid, const bool unchecked=false)
\item 
std\+::set$<$ \textbf{ Txid} $>$ \textbf{ Get\+Unbroadcast\+Txs} () const
\item 
bool \textbf{ Is\+Unbroadcast\+Tx} (const \textbf{ Txid} \&txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
uint64\+\_\+t \textbf{ Get\+And\+Increment\+Sequence} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
uint64\+\_\+t \textbf{ Get\+Sequence} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ visited} (const \textbf{ txiter} \textbf{ it}) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
bool \textbf{ visited} (std\+::optional$<$ \textbf{ txiter} $>$ \textbf{ it}) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Change\+Set} $>$ \textbf{ Get\+Change\+Set} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool m\+\_\+have\+\_\+changeset \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
void \textbf{ Start\+Block\+Building} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ Fee\+Per\+Weight} \textbf{ Get\+Block\+Builder\+Chunk} (std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \&entries) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Include\+Builder\+Chunk} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Skip\+Builder\+Chunk} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Stop\+Block\+Building} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\textbf{ Recursive\+Mutex} \textbf{ cs}
\item 
const \textbf{ Options}\textbf{ Options} \textbf{ m\+\_\+opts}
\item 
void check(const \textbf{ CCoins\+View\+Cache} \&active\+\_\+coins\+\_\+tip, int64\+\_\+t spendheight) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(voi \textbf{ remove\+Recursive} )(const \textbf{ CTransaction} \&tx, \textbf{ Mem\+Pool\+Removal\+Reason} reason) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ cs\+\_\+main}
\item 
bool \textbf{ m\+\_\+epoch}
\item 
return !it \textbf{ visited} $\ast$ \textbf{ it}
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const int \textbf{ ROLLING\+\_\+\+FEE\+\_\+\+HALFLIFE} = 60 $\ast$ 60 $\ast$ 12
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
uint64\+\_\+t total\+Tx\+Size \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ CAmount} m\+\_\+total\+\_\+fee \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em sum of all mempool tx\textquotesingle{}s virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141. \end{DoxyCompactList}\item 
uint64\+\_\+t cached\+Inner\+Usage \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em sum of all mempool tx\textquotesingle{}s fees (NOT modified fee) \end{DoxyCompactList}\item 
int64\+\_\+t last\+Rolling\+Fee\+Update \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em sum of dynamic memory usage of all the map elements (NOT the maps themselves) \end{DoxyCompactList}\item 
bool block\+Since\+Last\+Rolling\+Fee\+Bump \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
double rolling\+Minimum\+Fee\+Rate \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ Epoch} \textbf{ m\+\_\+epoch} \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em minimum fee to get into the pool, decreases exponentially \end{DoxyCompactList}\item 
uint64\+\_\+t m\+\_\+sequence\+\_\+number \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
void \textbf{ track\+Package\+Removed} (const \textbf{ CFee\+Rate} \&rate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool m\+\_\+load\+\_\+tried \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ CFee\+Rate} \textbf{ Get\+Min\+Fee} (size\+\_\+t sizelimit) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::atomic$<$ unsigned int $>$ \textbf{ n\+Transactions\+Updated} \{0\}
\begin{DoxyCompactList}\small\item\em Used by getblocktemplate to trigger Create\+New\+Block() invocation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \textbf{ CTx\+Mem\+Pool\+::\+Change\+Set}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxyref{CTx\+Mem\+Pool}{p.}{class_c_tx_mem_pool} stores valid-\/according-\/to-\/the-\/current-\/best-\/chain transactions that may be included in the next block.

Transactions are added when they are seen on the network (or created by the local node), but not all transactions seen are added to the pool. For example, the following new transactions will not be added to the mempool\+:
\begin{DoxyItemize}
\item a transaction which doesn\textquotesingle{}t meet the minimum fee requirements.
\item a new transaction that double-\/spends an input of a transaction already in the pool where the new transaction does not meet the Replace-\/\+By-\/\+Fee requirements as defined in doc/policy/mempool-\/replacements.\+md.
\item a non-\/standard transaction.
\end{DoxyItemize}

\doxyref{Tx\+Graph}{p.}{class_tx_graph} (CTx\+Mem\+Pool\+::m\+\_\+txgraph) provides an abstraction layer for separating the transaction graph parts of the mempool from the rest of the Bitcoin-\/specific logic. Specifically, \doxyref{Tx\+Graph}{p.}{class_tx_graph} handles (for each transaction) managing the in-\/mempool parents and children, and has knowledge of the fee and size of every transaction. It uses this to partition the mempool into connected clusters, and it implements (among other things)\+:
\begin{DoxyItemize}
\item limits on the size of a cluster (in both number of transactions and total weight)
\item sorting the mempool optimally for block inclusion, taking into account dependencies
\item selecting transactions for removal due to cluster size limit violations after a reorg. See \doxyref{txgraph.\+h}{p.}{txgraph_8h} and txgraph.\+cpp for more details.
\end{DoxyItemize}

\doxyref{CTx\+Mem\+Pool}{p.}{class_c_tx_mem_pool} itself handles the Bitcoin-\/specific parts of mempool transactions; it stores the full transaction inside \doxyref{CTx\+Mem\+Pool\+Entry}{p.}{class_c_tx_mem_pool_entry}, along with other consensus-\/specific fields (such as whether a transaction spends a coinbase, or the \doxyref{Lock\+Points}{p.}{struct_lock_points} for transaction finality). And it provides interfaces to the rest of the codebase, such as\+:
\begin{DoxyItemize}
\item to validation for replace-\/by-\/fee calculations and cluster size limits when evaluating unconfirmed transactions
\item to validation for evicting transactions due to expiry or the mempool size limit being hit
\item to validation for updating the mempool to be consistent with the best chain after a new block is connected or after a reorg.
\item to net\+\_\+processing for ordering transactions that are to-\/be-\/announced to other peers
\item to RPC code for inspecting the mempool
\end{DoxyItemize}

(Many of these interfaces are just wrappers around corresponding \doxyref{Tx\+Graph}{p.}{class_tx_graph} functions.)

Within \doxyref{CTx\+Mem\+Pool}{p.}{class_c_tx_mem_pool}, the mempool entries are stored in a boost\+::multi\+\_\+index map\+Tx, which sorts the mempool on 3 criteria\+:
\begin{DoxyItemize}
\item transaction hash (txid)
\item witness-\/transaction hash (wtxid)
\item time in mempool
\end{DoxyItemize}

We also maintain a map from \doxyref{COut\+Point}{p.}{class_c_out_point} to the (in-\/mempool) transaction that spends it (map\+Next\+Tx). This allows us to recover from a reorg and find transactions in the mempool that conflict with transactions that are confirmed in a block. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{CTxMemPool@{CTxMemPool}!indexed\_transaction\_set@{indexed\_transaction\_set}}
\index{indexed\_transaction\_set@{indexed\_transaction\_set}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{indexed\_transaction\_set}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a165a170905de46a4ad6ceb4dda49f0cb} 
typedef boost\+::multi\+\_\+index\+\_\+container$<$ \textbf{ CTx\+Mem\+Pool\+Entry}, \textbf{ CTx\+Mem\+Pool\+Entry\+\_\+\+Indices} $>$ \textbf{ indexed\+\_\+transaction\+\_\+set}}

\index{CTxMemPool@{CTxMemPool}!Limits@{Limits}}
\index{Limits@{Limits}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{Limits}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_aec0e85395e7b6f5d7d5d3f3dd5b89e08} 
using \textbf{ Limits} = \textbf{ kernel\+::\+Mem\+Pool\+Limits}}

\index{CTxMemPool@{CTxMemPool}!Options@{Options}}
\index{Options@{Options}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{Options}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a181c4ec7f3c173e8ab60665e6cc5f400} 
using \textbf{ Options}\textbf{ Options} = \textbf{ kernel\+::\+Mem\+Pool\+Options}}

\index{CTxMemPool@{CTxMemPool}!setEntries@{setEntries}}
\index{setEntries@{setEntries}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{setEntries}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_aa8f69e66acbab7cc883b13876a49766a} 
typedef std\+::set$<$\textbf{ txiter}, \textbf{ Compare\+Iterator\+By\+Hash}$>$ \textbf{ set\+Entries}}

\index{CTxMemPool@{CTxMemPool}!txiter@{txiter}}
\index{txiter@{txiter}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{txiter}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_abd8c1d2efe4dbb1d8eb1c86646dd4b00} 
using \textbf{ txiter} = indexed\+\_\+transaction\+\_\+set\+::nth\+\_\+index$<$0$>$\+::type\+::const\+\_\+iterator}



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CTxMemPool@{CTxMemPool}!CTxMemPool@{CTxMemPool}}
\index{CTxMemPool@{CTxMemPool}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CTxMemPool()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ada885a4781f2fe487b3de0e6ad44db32} 
\textbf{ CTx\+Mem\+Pool} (\begin{DoxyParamCaption}\item[{\textbf{ Options}\textbf{ Options}}]{opts}{, }\item[{\textbf{ bilingual\+\_\+str} \&}]{error}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

Create a new \doxyref{CTx\+Mem\+Pool}{p.}{class_c_tx_mem_pool}. Sanity checks will be off by default for performance, because otherwise accepting transactions becomes O(\+N$^\wedge$2) where N is the number of transactions in the pool. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CTxMemPool@{CTxMemPool}!AddTransactionsUpdated@{AddTransactionsUpdated}}
\index{AddTransactionsUpdated@{AddTransactionsUpdated}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{AddTransactionsUpdated()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_abcae654cf22c85db10dbd26441ae7dec} 
void Add\+Transactions\+Updated (\begin{DoxyParamCaption}\item[{unsigned int}]{n}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!AddUnbroadcastTx@{AddUnbroadcastTx}}
\index{AddUnbroadcastTx@{AddUnbroadcastTx}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{AddUnbroadcastTx()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a324c4e1751ad695a70acd46e29a438e3} 
void Add\+Unbroadcast\+Tx (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Adds a transaction to the unbroadcast set \index{CTxMemPool@{CTxMemPool}!ApplyDelta@{ApplyDelta}}
\index{ApplyDelta@{ApplyDelta}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{ApplyDelta()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a728496172f5b281b15e56f0d53ef1df1} 
void Apply\+Delta (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{hash}{, }\item[{\textbf{ CAmount} \&}]{n\+Fee\+Delta}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!CalculateAncestorData@{CalculateAncestorData}}
\index{CalculateAncestorData@{CalculateAncestorData}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CalculateAncestorData()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a8ff8b27ea1d3b6998258980f4b2f31d0} 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, \textbf{ CAmount} $>$ Calculate\+Ancestor\+Data (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!CalculateDescendantData@{CalculateDescendantData}}
\index{CalculateDescendantData@{CalculateDescendantData}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CalculateDescendantData()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a0626fdf6e4c86e76cc787058e45d1d5c} 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, \textbf{ CAmount} $>$ Calculate\+Descendant\+Data (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!CalculateDescendants@{CalculateDescendants}}
\index{CalculateDescendants@{CalculateDescendants}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CalculateDescendants()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a7668a46813dba7392767151d53606aa6} 
\textbf{ CTx\+Mem\+Pool\+::txiter} Calculate\+Descendants (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{, }\item[{\textbf{ set\+Entries} \&}]{set\+Descendants}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!CalculateDescendants@{CalculateDescendants}}
\index{CalculateDescendants@{CalculateDescendants}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CalculateDescendants()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a621d6e94d75c9c7d466deeceb3e6df62} 
void Calculate\+Descendants (\begin{DoxyParamCaption}\item[{\textbf{ txiter}}]{it}{, }\item[{\textbf{ set\+Entries} \&}]{set\+Descendants}{}\end{DoxyParamCaption}) const}

Populate set\+Descendants with all in-\/mempool descendants of given transaction. Assumes that set\+Descendants includes all in-\/mempool descendants of anything already in it. \index{CTxMemPool@{CTxMemPool}!CalculateMemPoolAncestors@{CalculateMemPoolAncestors}}
\index{CalculateMemPoolAncestors@{CalculateMemPoolAncestors}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CalculateMemPoolAncestors()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_afd7b3256c898184717f4f98627dc1114} 
\textbf{ CTx\+Mem\+Pool\+::set\+Entries} Calculate\+Mem\+Pool\+Ancestors (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{}\end{DoxyParamCaption}) const}

Calculate all in-\/mempool ancestors of entry (not including the tx itself)


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em entry} & \doxyref{CTx\+Mem\+Pool\+Entry}{p.}{class_c_tx_mem_pool_entry} of which all in-\/mempool ancestors are calculated\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
all in-\/mempool ancestors 
\end{DoxyReturn}
\index{CTxMemPool@{CTxMemPool}!CheckPolicyLimits@{CheckPolicyLimits}}
\index{CheckPolicyLimits@{CheckPolicyLimits}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CheckPolicyLimits()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a39725cf7bd24735c8b535905e981b453} 
bool Check\+Policy\+Limits (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction\+Ref} \&}]{tx}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!ClearPrioritisation@{ClearPrioritisation}}
\index{ClearPrioritisation@{ClearPrioritisation}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{ClearPrioritisation()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a9ed30d28d0c99716831d2ae99ba48c9c} 
void Clear\+Prioritisation (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{hash}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!CompareMiningScoreWithTopology@{CompareMiningScoreWithTopology}}
\index{CompareMiningScoreWithTopology@{CompareMiningScoreWithTopology}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CompareMiningScoreWithTopology()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a47f736457eb0a52142718a8623e5c9d6} 
bool Compare\+Mining\+Score\+With\+Topology (\begin{DoxyParamCaption}\item[{const \textbf{ Wtxid} \&}]{hasha}{, }\item[{const \textbf{ Wtxid} \&}]{hashb}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!DynamicMemoryUsage@{DynamicMemoryUsage}}
\index{DynamicMemoryUsage@{DynamicMemoryUsage}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{DynamicMemoryUsage()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_afcc22204abc15aeefd5d1f7396e909a4} 
size\+\_\+t Dynamic\+Memory\+Usage (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!entryAll@{entryAll}}
\index{entryAll@{entryAll}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{entryAll()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ae0e204c17eb9a11780b362f0315eaf88} 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+Ref} $>$ entry\+All (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!exists@{exists}}
\index{exists@{exists}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{exists()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a4f1dcdad840ef946c9925b0f4a0f95b9} 
bool exists (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!exists@{exists}}
\index{exists@{exists}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{exists()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_aae31b6406922392ed4aaee3f79e13020} 
bool exists (\begin{DoxyParamCaption}\item[{const \textbf{ Wtxid} \&}]{wtxid}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!Expire@{Expire}}
\index{Expire@{Expire}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{Expire()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a5a715e9838711cd2cd54768c8961c44f} 
int Expire (\begin{DoxyParamCaption}\item[{std\+::chrono\+::seconds}]{time}{}\end{DoxyParamCaption})}

Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. \index{CTxMemPool@{CTxMemPool}!GatherClusters@{GatherClusters}}
\index{GatherClusters@{GatherClusters}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GatherClusters()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a998e1b90efb070bf2dc18e6ead3f1de7} 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+::txiter} $>$ Gather\+Clusters (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ Txid} $>$ \&}]{txids}{}\end{DoxyParamCaption}) const}

Collect the entire cluster of connected transactions for each transaction in txids. All txids must correspond to transaction entries in the mempool, otherwise this returns an empty vector. This call will also exit early and return an empty vector if it collects 500 or more transactions as a DoS protection. \index{CTxMemPool@{CTxMemPool}!get@{get}}
\index{get@{get}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{get()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_add969118b972f73b902bdf73dd5912f4} 
\textbf{ CTransaction\+Ref} get (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{hash}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetAncestorCount@{GetAncestorCount}}
\index{GetAncestorCount@{GetAncestorCount}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetAncestorCount()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a8a3d1c3f2d5fc2bcd3050fcef13feac4} 
int64\+\_\+t Get\+Ancestor\+Count (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{e}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetAndIncrementSequence@{GetAndIncrementSequence}}
\index{GetAndIncrementSequence@{GetAndIncrementSequence}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetAndIncrementSequence()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a2720ea12b86320ed18e584725ea3cf76} 
uint64\+\_\+t Get\+And\+Increment\+Sequence (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Guards this internal counter for external reporting \index{CTxMemPool@{CTxMemPool}!GetBlockBuilderChunk@{GetBlockBuilderChunk}}
\index{GetBlockBuilderChunk@{GetBlockBuilderChunk}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetBlockBuilderChunk()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a218e50f3c65727716c581684a9875e59} 
\textbf{ Fee\+Per\+Weight} Get\+Block\+Builder\+Chunk (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \&}]{entries}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetChangeSet@{GetChangeSet}}
\index{GetChangeSet@{GetChangeSet}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetChangeSet()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a73f1a871ee46b6a104bd6489441eb87b} 
std\+::unique\+\_\+ptr$<$ \textbf{ Change\+Set} $>$ Get\+Change\+Set (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetChildren@{GetChildren}}
\index{GetChildren@{GetChildren}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetChildren()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a94c9da361a72657bca743105806faf21} 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ Get\+Children (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetCluster@{GetCluster}}
\index{GetCluster@{GetCluster}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetCluster()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ad143aea711418e0dcf2fe9ed7f692933} 
std\+::vector$<$ const \textbf{ CTx\+Mem\+Pool\+Entry} $\ast$ $>$ Get\+Cluster (\begin{DoxyParamCaption}\item[{\textbf{ Txid}}]{txid}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetConflictTx@{GetConflictTx}}
\index{GetConflictTx@{GetConflictTx}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetConflictTx()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a795fa65f17897485303cd15a711acc6c} 
const \textbf{ CTransaction} $\ast$ Get\+Conflict\+Tx (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{prevout}{}\end{DoxyParamCaption}) const}

Get the transaction in the pool that spends the same prevout \index{CTxMemPool@{CTxMemPool}!GetDescendantCount@{GetDescendantCount}}
\index{GetDescendantCount@{GetDescendantCount}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetDescendantCount()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_afa4f99339a3c907080cb613b80f2ec3f} 
int64\+\_\+t Get\+Descendant\+Count (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{e}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetDescendantCount@{GetDescendantCount}}
\index{GetDescendantCount@{GetDescendantCount}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetDescendantCount()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ad1f6d5c2a4e12c0af73b12914cc04128} 
int64\+\_\+t Get\+Descendant\+Count (\begin{DoxyParamCaption}\item[{\textbf{ txiter}}]{it}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetEntry@{GetEntry}}
\index{GetEntry@{GetEntry}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetEntry()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_af88c474ce801f62208a5b1f320ba138c} 
const \textbf{ CTx\+Mem\+Pool\+Entry} $\ast$ Get\+Entry (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetFeerateDiagram@{GetFeerateDiagram}}
\index{GetFeerateDiagram@{GetFeerateDiagram}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetFeerateDiagram()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_afeb4b75cecd3224c689d10c1a2b9a46c} 
std\+::vector$<$ \textbf{ Fee\+Per\+Weight} $>$ Get\+Feerate\+Diagram (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetIter@{GetIter}}
\index{GetIter@{GetIter}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetIter()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ae2097b56302767d8ec0fb585bce77490} 
std\+::optional$<$ \textbf{ CTx\+Mem\+Pool\+::txiter} $>$ Get\+Iter (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption}) const}

Returns an iterator to the given hash, if found \index{CTxMemPool@{CTxMemPool}!GetIter@{GetIter}}
\index{GetIter@{GetIter}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetIter()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a4faa8217f552f45c3c18a97193633e52} 
std\+::optional$<$ \textbf{ CTx\+Mem\+Pool\+::txiter} $>$ Get\+Iter (\begin{DoxyParamCaption}\item[{const \textbf{ Wtxid} \&}]{wtxid}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetIterSet@{GetIterSet}}
\index{GetIterSet@{GetIterSet}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetIterSet()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a8960da66f5e997b29b78c3ebe025a6ab} 
\textbf{ CTx\+Mem\+Pool\+::set\+Entries} Get\+Iter\+Set (\begin{DoxyParamCaption}\item[{const std\+::set$<$ \textbf{ Txid} $>$ \&}]{hashes}{}\end{DoxyParamCaption}) const}

Translate a set of hashes into a set of pool iterators to avoid repeated lookups. Does not require that all of the hashes correspond to actual transactions in the mempool, only returns the ones that exist. \index{CTxMemPool@{CTxMemPool}!GetIterVec@{GetIterVec}}
\index{GetIterVec@{GetIterVec}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetIterVec()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ae78c5d897340b938f9d7c6c317a07465} 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+::txiter} $>$ Get\+Iter\+Vec (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ Txid} $>$ \&}]{txids}{}\end{DoxyParamCaption}) const}

Translate a list of hashes into a list of mempool iterators to avoid repeated lookups. The nth element in txids becomes the nth element in the returned vector. If any of the txids don\textquotesingle{}t actually exist in the mempool, returns an empty vector. \index{CTxMemPool@{CTxMemPool}!GetLoadTried@{GetLoadTried}}
\index{GetLoadTried@{GetLoadTried}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetLoadTried()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a323af340ddab179effe8cfd8eccf6867} 
bool Get\+Load\+Tried (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\begin{DoxyReturn}{Returns}
true if an initial attempt to load the persisted mempool was made, regardless of whether the attempt was successful or not 
\end{DoxyReturn}
\index{CTxMemPool@{CTxMemPool}!GetMainChunkFeerate@{GetMainChunkFeerate}}
\index{GetMainChunkFeerate@{GetMainChunkFeerate}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetMainChunkFeerate()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a25f0b4bbd34d11a4d8b3124324a38faf} 
\textbf{ Fee\+Per\+Weight} Get\+Main\+Chunk\+Feerate (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{tx}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetMinFee@{GetMinFee}}
\index{GetMinFee@{GetMinFee}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetMinFee()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a75775c43d0d75f872ffecfd91650e116} 
\textbf{ CFee\+Rate} Get\+Min\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

The minimum fee to get into the mempool, which may itself not be enough for larger-\/sized transactions. The m\+\_\+incremental\+\_\+relay\+\_\+feerate policy variable is used to bound the time it takes the fee rate to go back down all the way to 0. When the feerate would otherwise be half of this, it is set to 0 instead. \index{CTxMemPool@{CTxMemPool}!GetMinFee@{GetMinFee}}
\index{GetMinFee@{GetMinFee}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetMinFee()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a7afb20886dc0488c9f76578b16b4faad} 
\textbf{ CFee\+Rate} Get\+Min\+Fee (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{sizelimit}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!GetParents@{GetParents}}
\index{GetParents@{GetParents}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetParents()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ad67bc54113b9b07ec253b7e306b4ea95} 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ Get\+Parents (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool\+Entry} \&}]{entry}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetPrioritisedTransactions@{GetPrioritisedTransactions}}
\index{GetPrioritisedTransactions@{GetPrioritisedTransactions}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetPrioritisedTransactions()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a0cbb19ad088ad3257b88906cbd764455} 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+::delta\+\_\+info} $>$ Get\+Prioritised\+Transactions (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Return a vector of all entries in map\+Deltas with their corresponding \doxyref{delta\+\_\+info}{p.}{struct_c_tx_mem_pool_1_1delta__info}. \index{CTxMemPool@{CTxMemPool}!GetSequence@{GetSequence}}
\index{GetSequence@{GetSequence}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetSequence()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a5c168b6f87d8b12617ed813ba79a0863} 
uint64\+\_\+t Get\+Sequence (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetTotalFee@{GetTotalFee}}
\index{GetTotalFee@{GetTotalFee}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetTotalFee()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a6d2b479af5d85d18fda6cb3dfa7639d6} 
\textbf{ CAmount} Get\+Total\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetTotalTxSize@{GetTotalTxSize}}
\index{GetTotalTxSize@{GetTotalTxSize}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetTotalTxSize()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_aabc9f9e1dc8925f1257c3800d2d886c3} 
uint64\+\_\+t Get\+Total\+Tx\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GetTransactionAncestry@{GetTransactionAncestry}}
\index{GetTransactionAncestry@{GetTransactionAncestry}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetTransactionAncestry()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a43139580314706772a0e1b3d94f0bd8b} 
void Get\+Transaction\+Ancestry (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{, }\item[{size\+\_\+t \&}]{ancestors}{, }\item[{size\+\_\+t \&}]{cluster\+\_\+count}{, }\item[{size\+\_\+t $\ast$}]{ancestorsize}{ = {\ttfamily nullptr}, }\item[{\textbf{ CAmount} $\ast$}]{ancestorfees}{ = {\ttfamily nullptr}}\end{DoxyParamCaption}) const}

Calculate the ancestor and cluster count for the given transaction. The counts include the transaction itself. When ancestors is non-\/zero (ie, the transaction itself is in the mempool), ancestorsize and ancestorfees will also be set to the appropriate values. \index{CTxMemPool@{CTxMemPool}!GetTransactionsUpdated@{GetTransactionsUpdated}}
\index{GetTransactionsUpdated@{GetTransactionsUpdated}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetTransactionsUpdated()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a6b37790b200c77ddc0ba6dda2754ed2a} 
unsigned int Get\+Transactions\+Updated (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!GetUnbroadcastTxs@{GetUnbroadcastTxs}}
\index{GetUnbroadcastTxs@{GetUnbroadcastTxs}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetUnbroadcastTxs()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ac2b86aa51025367f16bff990e7c5a1d8} 
std\+::set$<$ \textbf{ Txid} $>$ Get\+Unbroadcast\+Txs (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns transactions in unbroadcast set \index{CTxMemPool@{CTxMemPool}!GetUniqueClusterCount@{GetUniqueClusterCount}}
\index{GetUniqueClusterCount@{GetUniqueClusterCount}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GetUniqueClusterCount()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a7b8b074fc1ecd2d5150863a85678e86a} 
size\+\_\+t Get\+Unique\+Cluster\+Count (\begin{DoxyParamCaption}\item[{const \textbf{ set\+Entries} \&}]{iters\+\_\+conflicting}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a44ab12e47e9a12e7c19a7db5590ca2dd} 
bool m\+\_\+have\+\_\+changeset GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ab01aa4f5592de6f9fc339fafd3405cdf} 
std\+::map$<$ \textbf{ Txid}, \textbf{ CAmount} $>$ map\+Deltas GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [3/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ab535c76032f9f36d42dd6961b21c9252} 
\textbf{ indirectmap}$<$ \textbf{ COut\+Point}, \textbf{ txiter} $>$ map\+Next\+Tx GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [4/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a24e2162c579983616f8cccd0cba8566f} 
std\+::vector$<$ std\+::pair$<$ \textbf{ Wtxid}, \textbf{ txiter} $>$ $>$ txns\+\_\+randomized GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})}



All transactions in map\+Tx with their wtxids, in arbitrary order. 

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [5/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a283007dc110d59a7e84a22a2e9a3d039} 
\textbf{ indexed\+\_\+transaction\+\_\+set} map\+Tx GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [6/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a62dc736f4934be4bc1a06ebfa200fd09} 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Graph\+::\+Block\+Builder} $>$ m\+\_\+builder GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [mutable]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [7/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_af0cd165bf7240ed73fce982fd8353312} 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Graph} $>$ m\+\_\+txgraph GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [8/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a78f7a15c59d14bb44e505171959b42ad} 
bool m\+\_\+load\+\_\+tried GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [9/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a741310b4002825d6d423cc84de598282} 
uint64\+\_\+t m\+\_\+sequence\+\_\+number GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [10/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a18124ba564d2deec7f229e57a0147bd9} 
\textbf{ Epoch} \textbf{ m\+\_\+epoch} GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}



minimum fee to get into the pool, decreases exponentially 

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [11/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a29ed7cca82c75795201c4d7bec8e4e27} 
double rolling\+Minimum\+Fee\+Rate GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [12/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_aed6f6a25f89931a38b7cca711f9fdd52} 
bool block\+Since\+Last\+Rolling\+Fee\+Bump GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [13/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a111d17614af6e33237230a6d739cf912} 
int64\+\_\+t last\+Rolling\+Fee\+Update GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [mutable]}, {\ttfamily [protected]}}



sum of dynamic memory usage of all the map elements (NOT the maps themselves) 

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [14/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ac3bfc3ea0f2651a24b7898f7c30e6176} 
uint64\+\_\+t cached\+Inner\+Usage GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



sum of all mempool tx\textquotesingle{}s fees (NOT modified fee) 

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [15/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a15e22d25741492a8c42865ec9bdf7c1d} 
\textbf{ CAmount} m\+\_\+total\+\_\+fee GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



sum of all mempool tx\textquotesingle{}s virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141. 

\index{CTxMemPool@{CTxMemPool}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [16/16]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_afc3e068afe850dd873670c6365dbf1e2} 
uint64\+\_\+t total\+Tx\+Size GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!HasDescendants@{HasDescendants}}
\index{HasDescendants@{HasDescendants}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{HasDescendants()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ad65ab5234e8f5f45d52ef603d7342877} 
bool Has\+Descendants (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!HasNoInputsOf@{HasNoInputsOf}}
\index{HasNoInputsOf@{HasNoInputsOf}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{HasNoInputsOf()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a759a72decf76f3d5ee1855c68e064336} 
bool Has\+No\+Inputs\+Of (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction} \&}]{tx}{}\end{DoxyParamCaption}) const}

Check that none of this transactions inputs are in the mempool, and thus the tx is not dependent on other mempool transactions to be included in a block. \index{CTxMemPool@{CTxMemPool}!IncludeBuilderChunk@{IncludeBuilderChunk}}
\index{IncludeBuilderChunk@{IncludeBuilderChunk}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{IncludeBuilderChunk()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a31cec99516b1071527fefbec18b66a96} 
void Include\+Builder\+Chunk (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!info@{info}}
\index{info@{info}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{info()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a004f3e09a902839ab270b91a254bfda9} 
template$<$\textbf{ Txid\+Or\+Wtxid} T$>$ \\
\textbf{ Tx\+Mempool\+Info} info (\begin{DoxyParamCaption}\item[{const \textbf{ T} \&}]{id}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!info\_for\_relay@{info\_for\_relay}}
\index{info\_for\_relay@{info\_for\_relay}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{info\_for\_relay()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a34585ef669394d19269d5589dc3e520e} 
template$<$\textbf{ Txid\+Or\+Wtxid} T$>$ \\
\textbf{ Tx\+Mempool\+Info} info\+\_\+for\+\_\+relay (\begin{DoxyParamCaption}\item[{const \textbf{ T} \&}]{id}{, }\item[{uint64\+\_\+t}]{last\+\_\+sequence}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns info for a transaction if its entry\+\_\+sequence $<$ last\+\_\+sequence \index{CTxMemPool@{CTxMemPool}!infoAll@{infoAll}}
\index{infoAll@{infoAll}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{infoAll()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a86d9bb8441b9a708ae3fe2b5d468580f} 
std\+::vector$<$ \textbf{ Tx\+Mempool\+Info} $>$ info\+All (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!isSpent@{isSpent}}
\index{isSpent@{isSpent}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{isSpent()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a360d89f43a203e043dc1bdc523384eaf} 
bool is\+Spent (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const}

\index{CTxMemPool@{CTxMemPool}!IsUnbroadcastTx@{IsUnbroadcastTx}}
\index{IsUnbroadcastTx@{IsUnbroadcastTx}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{IsUnbroadcastTx()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a56ddb14d97fb08eb7576246b86da2092} 
bool Is\+Unbroadcast\+Tx (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns whether a txid is in the unbroadcast set \index{CTxMemPool@{CTxMemPool}!LOCKS\_EXCLUDED@{LOCKS\_EXCLUDED}}
\index{LOCKS\_EXCLUDED@{LOCKS\_EXCLUDED}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{LOCKS\_EXCLUDED()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a53541db89f3f38af1d3a67ff1534a6fe} 
void \textbf{ cs\+\_\+main} LOCKS\+\_\+\+EXCLUDED (\begin{DoxyParamCaption}\item[{\textbf{ m\+\_\+epoch}}]{}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!PrioritiseTransaction@{PrioritiseTransaction}}
\index{PrioritiseTransaction@{PrioritiseTransaction}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{PrioritiseTransaction()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ae834f1f693a548ba798a6886ca181bd3} 
void Prioritise\+Transaction (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{hash}{, }\item[{const \textbf{ CAmount} \&}]{n\+Fee\+Delta}{}\end{DoxyParamCaption})}

Affect Create\+New\+Block prioritisation of transactions \index{CTxMemPool@{CTxMemPool}!removeForBlock@{removeForBlock}}
\index{removeForBlock@{removeForBlock}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{removeForBlock()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ae6a5941791919c5870b862326c0a6c51} 
void remove\+For\+Block (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ CTransaction\+Ref} $>$ \&}]{vtx}{, }\item[{unsigned int}]{n\+Block\+Height}{}\end{DoxyParamCaption})}

\index{CTxMemPool@{CTxMemPool}!removeForReorg@{removeForReorg}}
\index{removeForReorg@{removeForReorg}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{removeForReorg()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a8e963c6b03da2b1cb9d630a16026783d} 
void remove\+For\+Reorg (\begin{DoxyParamCaption}\item[{\textbf{ CChain} \&}]{chain}{, }\item[{std\+::function$<$ bool(\textbf{ txiter})$>$}]{filter\+\_\+final\+\_\+and\+\_\+mature}{}\end{DoxyParamCaption})}

After reorg, filter the entries that would no longer be valid in the next block, and update the entries\textquotesingle{} cached \doxyref{Lock\+Points}{p.}{struct_lock_points} if needed. The mempool does not have any knowledge of consensus rules. It just applies the callable function and removes the ones for which it returns true. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em filter\+\_\+final\+\_\+and\+\_\+mature} & Predicate that checks the relevant validation rules and updates an entry\textquotesingle{}s \doxyref{Lock\+Points}{p.}{struct_lock_points}. \\
\hline
\end{DoxyParams}
\index{CTxMemPool@{CTxMemPool}!RemoveUnbroadcastTx@{RemoveUnbroadcastTx}}
\index{RemoveUnbroadcastTx@{RemoveUnbroadcastTx}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{RemoveUnbroadcastTx()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a7252105274f9b0e060438692de785a8c} 
void Remove\+Unbroadcast\+Tx (\begin{DoxyParamCaption}\item[{const \textbf{ Txid} \&}]{txid}{, }\item[{const bool}]{unchecked}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Removes a transaction from the unbroadcast set \index{CTxMemPool@{CTxMemPool}!SetLoadTried@{SetLoadTried}}
\index{SetLoadTried@{SetLoadTried}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{SetLoadTried()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ac6517e02d477ea0bfcaeb5b50df9be6e} 
void Set\+Load\+Tried (\begin{DoxyParamCaption}\item[{bool}]{load\+\_\+tried}{}\end{DoxyParamCaption})}

Set whether or not an initial attempt to load the persisted mempool was made (regardless of whether the attempt was successful or not) \index{CTxMemPool@{CTxMemPool}!size@{size}}
\index{size@{size}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{size()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_af22b5286aa0191a7087a205f6d04b032} 
unsigned long size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!SkipBuilderChunk@{SkipBuilderChunk}}
\index{SkipBuilderChunk@{SkipBuilderChunk}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{SkipBuilderChunk()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ab3055f98733e8143ff7fe7fd2dc7a84f} 
void Skip\+Builder\+Chunk (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!StartBlockBuilding@{StartBlockBuilding}}
\index{StartBlockBuilding@{StartBlockBuilding}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{StartBlockBuilding()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a79b1b1a4a42271d59a6d74582cdd7128} 
void Start\+Block\+Building (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!StopBlockBuilding@{StopBlockBuilding}}
\index{StopBlockBuilding@{StopBlockBuilding}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{StopBlockBuilding()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a7991caa5ce3f4c3419d4e732d1ba0d8f} 
void Stop\+Block\+Building (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CTxMemPool@{CTxMemPool}!trackPackageRemoved@{trackPackageRemoved}}
\index{trackPackageRemoved@{trackPackageRemoved}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{trackPackageRemoved()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a52c6852ae77074722a8a1eb1d84ac8b9} 
void track\+Package\+Removed (\begin{DoxyParamCaption}\item[{const \textbf{ CFee\+Rate} \&}]{rate}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\index{CTxMemPool@{CTxMemPool}!TrimToSize@{TrimToSize}}
\index{TrimToSize@{TrimToSize}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{TrimToSize()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a8d3b2b85c1e8d71acb0670889801c1ae} 
void Trim\+To\+Size (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{sizelimit}{, }\item[{std\+::vector$<$ \textbf{ COut\+Point} $>$ $\ast$}]{pv\+No\+Spends\+Remaining}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Remove transactions from the mempool until its dynamic size is $<$= sizelimit. pv\+No\+Spends\+Remaining, if set, will be populated with the list of outpoints which are not in mempool which no longer have any spends in this mempool. \index{CTxMemPool@{CTxMemPool}!UpdateTransactionsFromBlock@{UpdateTransactionsFromBlock}}
\index{UpdateTransactionsFromBlock@{UpdateTransactionsFromBlock}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{UpdateTransactionsFromBlock()}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a13afb65ccaf2860da2529ade52c45620} 
void Update\+Transactions\+From\+Block (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ Txid} $>$ \&}]{v\+Hashes\+To\+Update}{}\end{DoxyParamCaption})}

Update\+Transactions\+From\+Block is called when adding transactions from a disconnected block back to the mempool, new mempool entries may have children in the mempool (which is generally not the case when otherwise adding transactions). \begin{DoxyPostcond}{Postcondition}
updated descendant state for descendants of each transaction in v\+Hashes\+To\+Update (excluding any child transactions present in v\+Hashes\+To\+Update, which are already accounted for). Updated state includes add fee/size information for such descendants to the parent and updated ancestor state to include the parent.
\end{DoxyPostcond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em v\+Hashes\+To\+Update} & The set of txids from the disconnected block that have been accepted back into the mempool. \\
\hline
\end{DoxyParams}
\index{CTxMemPool@{CTxMemPool}!visited@{visited}}
\index{visited@{visited}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{visited()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ae4add0006d726649983ba51170a11fce} 
bool visited (\begin{DoxyParamCaption}\item[{const \textbf{ txiter}}]{it}{}\end{DoxyParamCaption}) const}

visited marks a \doxyref{CTx\+Mem\+Pool\+Entry}{p.}{class_c_tx_mem_pool_entry} as having been traversed during the lifetime of the most recently created \doxyref{Epoch\+::\+Guard}{p.}{class_epoch_1_1_guard} and returns false if we are the first visitor, true otherwise.

An \doxyref{Epoch\+::\+Guard}{p.}{class_epoch_1_1_guard} must be held when visited is called or an assert will be triggered. \index{CTxMemPool@{CTxMemPool}!visited@{visited}}
\index{visited@{visited}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{visited()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a008ed41c92e38905b600f5043862089f} 
bool visited (\begin{DoxyParamCaption}\item[{std\+::optional$<$ \textbf{ txiter} $>$}]{it}{}\end{DoxyParamCaption}) const}



\label{doc-related-members}
\doxysubsection{Friends And Related Symbol Documentation}
\index{CTxMemPool@{CTxMemPool}!CTxMemPool::ChangeSet@{CTxMemPool::ChangeSet}}
\index{CTxMemPool::ChangeSet@{CTxMemPool::ChangeSet}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{CTxMemPool::ChangeSet}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ad51df18e39efb2e1284324907c3aa33b} 
friend class CTx\+Mem\+Pool\+::\+Change\+Set\hspace{0.3cm}{\ttfamily [friend]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CTxMemPool@{CTxMemPool}!cs@{cs}}
\index{cs@{cs}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{cs}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ab322659c2acf98d3bb6e877e69414281} 
\textbf{ Recursive\+Mutex} cs\hspace{0.3cm}{\ttfamily [mutable]}}

This mutex needs to be locked when accessing {\ttfamily map\+Tx} or other members that are guarded by it.

\begin{DoxyParagraph}{Consistency guarantees}
By design, it is guaranteed that\+:
\begin{DoxyEnumerate}
\item Locking both {\ttfamily \doxyref{cs\+\_\+main}{p.}{class_c_tx_mem_pool_a7f780d253178a3b665d24201ed971b27}} and {\ttfamily mempool.\+cs} will give a view of mempool that is consistent with current chain tip ({\ttfamily Active\+Chain()} and {\ttfamily Coins\+Tip()}) and is fully populated. Fully populated means that if the current active chain is missing transactions that were present in a previously active chain, all the missing transactions will have been re-\/added to the mempool and should be present if they meet size and consistency constraints.
\item Locking {\ttfamily mempool.\+cs} without {\ttfamily \doxyref{cs\+\_\+main}{p.}{class_c_tx_mem_pool_a7f780d253178a3b665d24201ed971b27}} will give a view of a mempool consistent with some chain that was active since {\ttfamily \doxyref{cs\+\_\+main}{p.}{class_c_tx_mem_pool_a7f780d253178a3b665d24201ed971b27}} was last locked, and that is fully populated as described above. It is ok for code that only needs to query or remove transactions from the mempool to lock just {\ttfamily mempool.\+cs} without {\ttfamily \doxyref{cs\+\_\+main}{p.}{class_c_tx_mem_pool_a7f780d253178a3b665d24201ed971b27}}.
\end{DoxyEnumerate}
\end{DoxyParagraph}
To provide these guarantees, it is necessary to lock both {\ttfamily \doxyref{cs\+\_\+main}{p.}{class_c_tx_mem_pool_a7f780d253178a3b665d24201ed971b27}} and {\ttfamily mempool.\+cs} whenever adding transactions to the mempool and whenever changing the chain tip. It\textquotesingle{}s necessary to keep both mutexes locked until the mempool is consistent with the new chain tip and fully populated. \index{CTxMemPool@{CTxMemPool}!cs\_main@{cs\_main}}
\index{cs\_main@{cs\_main}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{cs\_main}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a7f780d253178a3b665d24201ed971b27} 
void cs\+\_\+main}

\index{CTxMemPool@{CTxMemPool}!it@{it}}
\index{it@{it}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{it}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_ad2a3bc0f2cb678cd26bc25bbadbce4b4} 
return !it \textbf{ visited}$\ast$ it}

\index{CTxMemPool@{CTxMemPool}!m\_epoch@{m\_epoch}}
\index{m\_epoch@{m\_epoch}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{m\_epoch}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a298e9e695e5b6c24abe5079a8db90145} 
bool m\+\_\+epoch}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ m\_epoch.visited(it-\/>m\_epoch\_marker)}

\end{DoxyCode}
\index{CTxMemPool@{CTxMemPool}!m\_opts@{m\_opts}}
\index{m\_opts@{m\_opts}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{m\_opts}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a817fbbfe836e70934594dea772b4181b} 
const \textbf{ Options}\textbf{ Options} m\+\_\+opts}

\index{CTxMemPool@{CTxMemPool}!nTransactionsUpdated@{nTransactionsUpdated}}
\index{nTransactionsUpdated@{nTransactionsUpdated}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{nTransactionsUpdated}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a0a9f242444810e4ab3ac9c988956b0d6} 
std\+::atomic$<$unsigned int$>$ n\+Transactions\+Updated \{0\}\hspace{0.3cm}{\ttfamily [protected]}}



Used by getblocktemplate to trigger Create\+New\+Block() invocation. 

\index{CTxMemPool@{CTxMemPool}!removeRecursive@{removeRecursive}}
\index{removeRecursive@{removeRecursive}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{removeRecursive}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a747fe559a1a336f2de303fd2bbae6e18} 
void remove\+Recursive}

If sanity-\/checking is turned on, check makes sure the pool is consistent (does not contain two transactions that spend the same inputs, all inputs are in the map\+Next\+Tx array). If sanity-\/checking is turned off, check does nothing. Remove a transaction from the mempool along with any descendants. If the transaction is not already in the mempool, find any descendants and remove them. \index{CTxMemPool@{CTxMemPool}!ROLLING\_FEE\_HALFLIFE@{ROLLING\_FEE\_HALFLIFE}}
\index{ROLLING\_FEE\_HALFLIFE@{ROLLING\_FEE\_HALFLIFE}!CTxMemPool@{CTxMemPool}}
\doxysubsubsection{ROLLING\_FEE\_HALFLIFE}
{\footnotesize\ttfamily \label{class_c_tx_mem_pool_a14087996bff339364370542b84b72fc9} 
const int ROLLING\+\_\+\+FEE\+\_\+\+HALFLIFE = 60 $\ast$ 60 $\ast$ 12\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ txmempool.\+h}\item 
src/\textbf{ txmempool.\+cpp}\end{DoxyCompactItemize}
