\doxysection{Sock Class Reference}
\label{class_sock}\index{Sock@{Sock}}


{\ttfamily \#include $<$sock.\+h$>$}

Inheritance diagram for Sock\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_sock}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Events}
\item 
struct \textbf{ Hash\+Shared\+Ptr\+Sock}
\item 
struct \textbf{ Equal\+Shared\+Ptr\+Sock}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Event} = uint8\+\_\+t
\item 
using \textbf{ Events\+Per\+Sock} = std\+::unordered\+\_\+map$<$std\+::shared\+\_\+ptr$<$const \textbf{ Sock}$>$, \textbf{ Events}, \textbf{ Hash\+Shared\+Ptr\+Sock}, \textbf{ Equal\+Shared\+Ptr\+Sock}$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Sock} ()=delete
\item 
\textbf{ Sock} (\textbf{ SOCKET} s)
\item 
\textbf{ Sock} (const \textbf{ Sock} \&)=delete
\item 
\textbf{ Sock} (\textbf{ Sock} \&\&other)
\item 
virtual \textbf{ $\sim$\+Sock} ()
\item 
\textbf{ Sock} \& \textbf{ operator=} (const \textbf{ Sock} \&)=delete
\item 
virtual \textbf{ Sock} \& \textbf{ operator=} (\textbf{ Sock} \&\&other)
\item 
virtual ssize\+\_\+t \textbf{ Send} (const void $\ast$data, size\+\_\+t len, int \textbf{ flags}) const
\item 
virtual ssize\+\_\+t \textbf{ Recv} (void $\ast$buf, size\+\_\+t len, int \textbf{ flags}) const
\item 
virtual int \textbf{ Connect} (const sockaddr $\ast$addr, socklen\+\_\+t addr\+\_\+len) const
\item 
virtual int \textbf{ Bind} (const sockaddr $\ast$addr, socklen\+\_\+t addr\+\_\+len) const
\item 
virtual int \textbf{ Listen} (int backlog) const
\item 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ \textbf{ Accept} (sockaddr $\ast$addr, socklen\+\_\+t $\ast$addr\+\_\+len) const
\item 
virtual int \textbf{ Get\+Sock\+Opt} (int level, int opt\+\_\+name, void $\ast$opt\+\_\+val, socklen\+\_\+t $\ast$opt\+\_\+len) const
\item 
virtual int \textbf{ Set\+Sock\+Opt} (int level, int opt\+\_\+name, const void $\ast$opt\+\_\+val, socklen\+\_\+t opt\+\_\+len) const
\item 
virtual int \textbf{ Get\+Sock\+Name} (sockaddr $\ast$\textbf{ name}, socklen\+\_\+t $\ast$name\+\_\+len) const
\item 
virtual bool \textbf{ Set\+Non\+Blocking} () const
\item 
virtual bool \textbf{ Is\+Selectable} () const
\item 
virtual bool \textbf{ Wait} (std\+::chrono\+::milliseconds timeout, \textbf{ Event} requested, \textbf{ Event} $\ast$occurred=nullptr) const
\item 
virtual bool \textbf{ Wait\+Many} (std\+::chrono\+::milliseconds timeout, \textbf{ Events\+Per\+Sock} \&events\+\_\+per\+\_\+sock) const
\item 
virtual void \textbf{ Send\+Complete} (std\+::span$<$ const unsigned char $>$ data, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt) const
\item 
virtual void \textbf{ Send\+Complete} (std\+::span$<$ const char $>$ data, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt) const
\item 
virtual std\+::string \textbf{ Recv\+Until\+Terminator} (uint8\+\_\+t terminator, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt, size\+\_\+t max\+\_\+data) const
\item 
virtual bool \textbf{ Is\+Connected} (std\+::string \&errmsg) const
\item 
bool \textbf{ operator==} (\textbf{ SOCKET} s) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static constexpr \textbf{ Event} \textbf{ RECV} = 0b001
\item 
static constexpr \textbf{ Event} \textbf{ SEND} = 0b010
\item 
static constexpr \textbf{ Event} \textbf{ ERR} = 0b100
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ SOCKET} \textbf{ m\+\_\+socket}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
RAII helper class that manages a socket and closes it automatically when it goes out of scope. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{Sock@{Sock}!Event@{Event}}
\index{Event@{Event}!Sock@{Sock}}
\doxysubsubsection{Event}
{\footnotesize\ttfamily \label{class_sock_a4b6dc81990bf0cf4838a46f8c9729e1b} 
using \textbf{ Event} = uint8\+\_\+t}

\index{Sock@{Sock}!EventsPerSock@{EventsPerSock}}
\index{EventsPerSock@{EventsPerSock}!Sock@{Sock}}
\doxysubsubsection{EventsPerSock}
{\footnotesize\ttfamily \label{class_sock_a3c7a13923a7186b4d5a8ba7981729638} 
using \textbf{ Events\+Per\+Sock} = std\+::unordered\+\_\+map$<$std\+::shared\+\_\+ptr$<$const \textbf{ Sock}$>$, \textbf{ Events}, \textbf{ Hash\+Shared\+Ptr\+Sock}, \textbf{ Equal\+Shared\+Ptr\+Sock}$>$}

On which socket to wait for what events in {\ttfamily \doxyref{Wait\+Many()}{p.}{class_sock_a6ec7a34cbf87594ed9b7eac590cf965f}}. The {\ttfamily shared\+\_\+ptr} is copied into the map to ensure that the {\ttfamily \doxyref{Sock}{p.}{class_sock}} object is not destroyed (its destructor would close the underlying socket). If this happens shortly before or after we call {\ttfamily poll(2)} and a new socket gets created under the same file descriptor number then the report from {\ttfamily \doxyref{Wait\+Many()}{p.}{class_sock_a6ec7a34cbf87594ed9b7eac590cf965f}} will be bogus. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Sock@{Sock}!Sock@{Sock}}
\index{Sock@{Sock}!Sock@{Sock}}
\doxysubsubsection{Sock()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{class_sock_aa514692e524d2d55d80976eac6456d12} 
\textbf{ Sock} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{Sock@{Sock}!Sock@{Sock}}
\index{Sock@{Sock}!Sock@{Sock}}
\doxysubsubsection{Sock()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{class_sock_a76264c08d7dff8a6c0521733d5bd850c} 
\textbf{ Sock} (\begin{DoxyParamCaption}\item[{\textbf{ SOCKET}}]{s}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

Take ownership of an existent socket. \index{Sock@{Sock}!Sock@{Sock}}
\index{Sock@{Sock}!Sock@{Sock}}
\doxysubsubsection{Sock()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{class_sock_a000e1d0f0c23801b9a15043312d90b15} 
\textbf{ Sock} (\begin{DoxyParamCaption}\item[{const \textbf{ Sock} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

Copy constructor, disabled because closing the same socket twice is undesirable. \index{Sock@{Sock}!Sock@{Sock}}
\index{Sock@{Sock}!Sock@{Sock}}
\doxysubsubsection{Sock()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{class_sock_a014eef261ec754e8e3586d5d11f260fb} 
\textbf{ Sock} (\begin{DoxyParamCaption}\item[{\textbf{ Sock} \&\&}]{other}{}\end{DoxyParamCaption})}

Move constructor, grab the socket from another object and close ours (if set). \index{Sock@{Sock}!````~Sock@{$\sim$Sock}}
\index{````~Sock@{$\sim$Sock}!Sock@{Sock}}
\doxysubsubsection{$\sim$Sock()}
{\footnotesize\ttfamily \label{class_sock_a6c6d5559856121d4b1a18465e2901c94} 
$\sim$\textbf{ Sock} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Destructor, close the socket or do nothing if empty. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Sock@{Sock}!Accept@{Accept}}
\index{Accept@{Accept}!Sock@{Sock}}
\doxysubsubsection{Accept()}
{\footnotesize\ttfamily \label{class_sock_a0478fe1f85686563dafce68f30878fa6} 
std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ Accept (\begin{DoxyParamCaption}\item[{sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t $\ast$}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

accept(2) wrapper. Equivalent to {\ttfamily std\+::make\+\_\+unique$<$\doxyref{Sock}{p.}{class_sock}$>$(accept(m\+\_\+socket, addr, addr\+\_\+len))}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. The returned unique\+\_\+ptr is empty if {\ttfamily accept()} failed in which case errno will be set. 

Reimplemented in \textbf{ Dyn\+Sock} \doxyref{}{p.}{class_dyn_sock_a36b4abe351193181c883d465020aa101}, \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a36b4abe351193181c883d465020aa101}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a36b4abe351193181c883d465020aa101}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a36b4abe351193181c883d465020aa101}.

\index{Sock@{Sock}!Bind@{Bind}}
\index{Bind@{Bind}!Sock@{Sock}}
\doxysubsubsection{Bind()}
{\footnotesize\ttfamily \label{class_sock_ae84297efb7d81f94d5c839a4b3b2abd8} 
int Bind (\begin{DoxyParamCaption}\item[{const sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

bind(2) wrapper. Equivalent to {\ttfamily bind(m\+\_\+socket, addr, addr\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_ab8f4fedff95b14573fabc05c019f9f8e}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_ac775d2a939e07c034c199227da9a4f26}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_ab8f4fedff95b14573fabc05c019f9f8e}.

\index{Sock@{Sock}!Connect@{Connect}}
\index{Connect@{Connect}!Sock@{Sock}}
\doxysubsubsection{Connect()}
{\footnotesize\ttfamily \label{class_sock_a5f5be77492fb494cd6b2effd50d18435} 
int Connect (\begin{DoxyParamCaption}\item[{const sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

connect(2) wrapper. Equivalent to {\ttfamily connect(m\+\_\+socket, addr, addrlen)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a2a2d42283320a5a051f301933328ad09}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a4c7f5777ead2f1ab3b2d80669b5b3925}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a2a2d42283320a5a051f301933328ad09}.

\index{Sock@{Sock}!GetSockName@{GetSockName}}
\index{GetSockName@{GetSockName}!Sock@{Sock}}
\doxysubsubsection{GetSockName()}
{\footnotesize\ttfamily \label{class_sock_a8544fa939816100e03ecba0a79fde2b1} 
int Get\+Sock\+Name (\begin{DoxyParamCaption}\item[{sockaddr $\ast$}]{name}{, }\item[{socklen\+\_\+t $\ast$}]{name\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

getsockname(2) wrapper. Equivalent to {\ttfamily getsockname(m\+\_\+socket, name, name\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a16930ee6ded3a8fe47a7adaf178affff}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a16930ee6ded3a8fe47a7adaf178affff}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a16930ee6ded3a8fe47a7adaf178affff}.

\index{Sock@{Sock}!GetSockOpt@{GetSockOpt}}
\index{GetSockOpt@{GetSockOpt}!Sock@{Sock}}
\doxysubsubsection{GetSockOpt()}
{\footnotesize\ttfamily \label{class_sock_a36a481d2609f5c4626a8c6136ee1f26f} 
int Get\+Sock\+Opt (\begin{DoxyParamCaption}\item[{int}]{level}{, }\item[{int}]{opt\+\_\+name}{, }\item[{void $\ast$}]{opt\+\_\+val}{, }\item[{socklen\+\_\+t $\ast$}]{opt\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

getsockopt(2) wrapper. Equivalent to {\ttfamily getsockopt(m\+\_\+socket, level, opt\+\_\+name, opt\+\_\+val, opt\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a5b5845e5aca634a6f79c82afecbc37fd}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a5b5845e5aca634a6f79c82afecbc37fd}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a5b5845e5aca634a6f79c82afecbc37fd}.

\index{Sock@{Sock}!IsConnected@{IsConnected}}
\index{IsConnected@{IsConnected}!Sock@{Sock}}
\doxysubsubsection{IsConnected()}
{\footnotesize\ttfamily \label{class_sock_a395f618148d26468dc12324ffcddbd4a} 
bool Is\+Connected (\begin{DoxyParamCaption}\item[{std\+::string \&}]{errmsg}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

Check if still connected. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{out}}  & {\em errmsg} & The error string, if the socket has been disconnected. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if connected 
\end{DoxyReturn}


Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a559bd3d4e08847304e64ef6fdac33ad4}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_aa18949f10a1aafa5498ee991e5f61fcd}, and \textbf{ Static\+Contents\+Sock} \doxyref{}{p.}{class_static_contents_sock_aa18949f10a1aafa5498ee991e5f61fcd}.

\index{Sock@{Sock}!IsSelectable@{IsSelectable}}
\index{IsSelectable@{IsSelectable}!Sock@{Sock}}
\doxysubsubsection{IsSelectable()}
{\footnotesize\ttfamily \label{class_sock_a39fd9751352b6030c42c342066a1b887} 
bool Is\+Selectable (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

Check if the underlying socket can be used for {\ttfamily select(2)} (or the {\ttfamily \doxyref{Wait()}{p.}{class_sock_a851a09613d347a157da032137020065a}} method). \begin{DoxyReturn}{Returns}
true if selectable 
\end{DoxyReturn}


Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a598fdcc705deaa438fba72650d51fe20}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a598fdcc705deaa438fba72650d51fe20}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a598fdcc705deaa438fba72650d51fe20}.

\index{Sock@{Sock}!Listen@{Listen}}
\index{Listen@{Listen}!Sock@{Sock}}
\doxysubsubsection{Listen()}
{\footnotesize\ttfamily \label{class_sock_a88c18587b3e874ee2a5fde74d6bb3cc2} 
int Listen (\begin{DoxyParamCaption}\item[{int}]{backlog}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

listen(2) wrapper. Equivalent to {\ttfamily listen(m\+\_\+socket, backlog)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_af72b3b4f4890c8c2b1b78620cfb4ae8f}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a172d2ef5e777674d5445aac1387bab41}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a172d2ef5e777674d5445aac1387bab41}.

\index{Sock@{Sock}!operator=@{operator=}}
\index{operator=@{operator=}!Sock@{Sock}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_sock_a4c90c4a9a6886cb68a9ee851522afff1} 
\textbf{ Sock} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Sock} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

Copy assignment operator, disabled because closing the same socket twice is undesirable. \index{Sock@{Sock}!operator=@{operator=}}
\index{operator=@{operator=}!Sock@{Sock}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_sock_aed8298a36ba25760ceb8d1207a39f8db} 
\textbf{ Sock} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ Sock} \&\&}]{other}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Move assignment operator, grab the socket from another object and close ours (if set). 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a3cf34ea45c3835396beb4ce77d32d120}, and \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a9a8dd74dd909f175c3cc342c65e3e19c}.

\index{Sock@{Sock}!operator==@{operator==}}
\index{operator==@{operator==}!Sock@{Sock}}
\doxysubsubsection{operator==()}
{\footnotesize\ttfamily \label{class_sock_a0e4e0f6358b1a1c9d549037d265cc729} 
bool operator== (\begin{DoxyParamCaption}\item[{\textbf{ SOCKET}}]{s}{}\end{DoxyParamCaption}) const}

Check if the internal socket is equal to {\ttfamily s}. Use only in tests. \index{Sock@{Sock}!Recv@{Recv}}
\index{Recv@{Recv}!Sock@{Sock}}
\doxysubsubsection{Recv()}
{\footnotesize\ttfamily \label{class_sock_ad5d478226aba69810d73757744e13317} 
ssize\+\_\+t Recv (\begin{DoxyParamCaption}\item[{void $\ast$}]{buf}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

recv(2) wrapper. Equivalent to {\ttfamily recv(m\+\_\+socket, buf, len, flags);}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Dyn\+Sock} \doxyref{}{p.}{class_dyn_sock_acc57da900d09bf26675b155ff9f4ac89}, \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_acc57da900d09bf26675b155ff9f4ac89}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_acc57da900d09bf26675b155ff9f4ac89}, \textbf{ Static\+Contents\+Sock} \doxyref{}{p.}{class_static_contents_sock_acc57da900d09bf26675b155ff9f4ac89}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_acc57da900d09bf26675b155ff9f4ac89}.

\index{Sock@{Sock}!RecvUntilTerminator@{RecvUntilTerminator}}
\index{RecvUntilTerminator@{RecvUntilTerminator}!Sock@{Sock}}
\doxysubsubsection{RecvUntilTerminator()}
{\footnotesize\ttfamily \label{class_sock_a27107f318fb56aa730ab7572ac613479} 
std\+::string Recv\+Until\+Terminator (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{terminator}{, }\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ CThread\+Interrupt} \&}]{interrupt}{, }\item[{size\+\_\+t}]{max\+\_\+data}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

Read from socket until a terminator character is encountered. Will never consume bytes past the terminator from the socket. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em terminator} & Character up to which to read from the socket. \\
\hline
\mbox{\texttt{in}}  & {\em timeout} & Timeout for the entire operation. \\
\hline
\mbox{\texttt{in}}  & {\em interrupt} & If this is signaled then the operation is canceled. \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+data} & The maximum amount of data (in bytes) to receive. If this many bytes are received and there is still no terminator, then this method will throw an exception. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The data that has been read, without the terminating character. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the operation cannot be completed. In this case some bytes may have been consumed from the socket. \\
\hline
\end{DoxyExceptions}
\index{Sock@{Sock}!Send@{Send}}
\index{Send@{Send}!Sock@{Sock}}
\doxysubsubsection{Send()}
{\footnotesize\ttfamily \label{class_sock_ad50f4b43d2b968d64162193e9254d6b5} 
ssize\+\_\+t Send (\begin{DoxyParamCaption}\item[{const void $\ast$}]{data}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

send(2) wrapper. Equivalent to {\ttfamily send(m\+\_\+socket, data, len, flags);}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Dyn\+Sock} \doxyref{}{p.}{class_dyn_sock_a91f43a08763aa3988637e9242bc1219f}, \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_acea3de5ef4ffb5d3c9ab0529c7f31fa9}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_ac2038678b0e7c9edc578bc68a5871b17}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a9261d901e7024d8f9678d2fb9b0e1788}.

\index{Sock@{Sock}!SendComplete@{SendComplete}}
\index{SendComplete@{SendComplete}!Sock@{Sock}}
\doxysubsubsection{SendComplete()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_sock_a885ca2c5b4d6185c0393595967115e6d} 
void Send\+Complete (\begin{DoxyParamCaption}\item[{std\+::span$<$ const char $>$}]{data}{, }\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ CThread\+Interrupt} \&}]{interrupt}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Convenience method, equivalent to {\ttfamily Send\+Complete(\+Make\+UChar\+Span(data), timeout, interrupt)}. \index{Sock@{Sock}!SendComplete@{SendComplete}}
\index{SendComplete@{SendComplete}!Sock@{Sock}}
\doxysubsubsection{SendComplete()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_sock_a43f09a43a02f01718f04fd139c2a5ed4} 
void Send\+Complete (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{data}{, }\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ CThread\+Interrupt} \&}]{interrupt}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Send the given data, retrying on transient errors. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em data} & Data to send. \\
\hline
\mbox{\texttt{in}}  & {\em timeout} & Timeout for the entire operation. \\
\hline
\mbox{\texttt{in}}  & {\em interrupt} & If this is signaled then the operation is canceled. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the operation cannot be completed. In this case only some of the data will be written to the socket. \\
\hline
\end{DoxyExceptions}
\index{Sock@{Sock}!SetNonBlocking@{SetNonBlocking}}
\index{SetNonBlocking@{SetNonBlocking}!Sock@{Sock}}
\doxysubsubsection{SetNonBlocking()}
{\footnotesize\ttfamily \label{class_sock_a11c30b8078693d82b98b44a8b81bb71d} 
bool Set\+Non\+Blocking (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

Set the non-\/blocking option on the socket. \begin{DoxyReturn}{Returns}
true if set successfully 
\end{DoxyReturn}


Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a8a6517d31b9c4c9a895c1cbb83387c86}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a8a6517d31b9c4c9a895c1cbb83387c86}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a8a6517d31b9c4c9a895c1cbb83387c86}.

\index{Sock@{Sock}!SetSockOpt@{SetSockOpt}}
\index{SetSockOpt@{SetSockOpt}!Sock@{Sock}}
\doxysubsubsection{SetSockOpt()}
{\footnotesize\ttfamily \label{class_sock_a72351052778d8f7107546f9e32159dc9} 
int Set\+Sock\+Opt (\begin{DoxyParamCaption}\item[{int}]{level}{, }\item[{int}]{opt\+\_\+name}{, }\item[{const void $\ast$}]{opt\+\_\+val}{, }\item[{socklen\+\_\+t}]{opt\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

setsockopt(2) wrapper. Equivalent to {\ttfamily setsockopt(m\+\_\+socket, level, opt\+\_\+name, opt\+\_\+val, opt\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented in \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_a1796957359313c29b05c500cd424d3a2}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_a94f895afc687c06525ac15ccb10ce2b0}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_a94f895afc687c06525ac15ccb10ce2b0}.

\index{Sock@{Sock}!Wait@{Wait}}
\index{Wait@{Wait}!Sock@{Sock}}
\doxysubsubsection{Wait()}
{\footnotesize\ttfamily \label{class_sock_a851a09613d347a157da032137020065a} 
bool Wait (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ Event}}]{requested}{, }\item[{\textbf{ Event} $\ast$}]{occurred}{ = {\ttfamily nullptr}}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

Wait for readiness for input (recv) or output (send). 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em timeout} & Wait this much for at least one of the requested events to occur. \\
\hline
\mbox{\texttt{in}}  & {\em requested} & Wait for those events, bitwise-\/or of {\ttfamily \doxyref{RECV}{p.}{class_sock_ae15d539512bccb6583fc75310b0d2f86}} and {\ttfamily \doxyref{SEND}{p.}{class_sock_ac739f9398eaa67718961a5ac331fba4a}}. \\
\hline
\mbox{\texttt{out}}  & {\em occurred} & If not nullptr and the function returns {\ttfamily true}, then this indicates which of the requested events occurred ({\ttfamily \doxyref{ERR}{p.}{class_sock_a2d9bf7f3d9855e98e28b9224cab3920e}} will be added, even if not requested, if an exceptional event occurs on the socket). A timeout is indicated by return value of {\ttfamily true} and {\ttfamily occurred} being set to 0. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success (or timeout, if {\ttfamily occurred} of 0 is returned), false otherwise 
\end{DoxyReturn}


Reimplemented in \textbf{ Dyn\+Sock} \doxyref{}{p.}{class_dyn_sock_aa9d44903b57505d9f8765404cb04f35f}, \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_aa9d44903b57505d9f8765404cb04f35f}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_aa9d44903b57505d9f8765404cb04f35f}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_aa9d44903b57505d9f8765404cb04f35f}.

\index{Sock@{Sock}!WaitMany@{WaitMany}}
\index{WaitMany@{WaitMany}!Sock@{Sock}}
\doxysubsubsection{WaitMany()}
{\footnotesize\ttfamily \label{class_sock_a6ec7a34cbf87594ed9b7eac590cf965f} 
bool Wait\+Many (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ Events\+Per\+Sock} \&}]{events\+\_\+per\+\_\+sock}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [virtual]}}

Same as {\ttfamily \doxyref{Wait()}{p.}{class_sock_a851a09613d347a157da032137020065a}}, but wait on many sockets within the same timeout. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em timeout} & Wait this long for at least one of the requested events to occur. \\
\hline
\mbox{\texttt{in,out}}  & {\em events\+\_\+per\+\_\+sock} & Wait for the requested events on these sockets and set {\ttfamily occurred} for the events that actually occurred. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success (or timeout, if all {\ttfamily what[].occurred} are returned as 0), false otherwise 
\end{DoxyReturn}


Reimplemented in \textbf{ Dyn\+Sock} \doxyref{}{p.}{class_dyn_sock_af35a7663942bba32c947f387114bc068}, \textbf{ Fuzzed\+Sock} \doxyref{}{p.}{class_fuzzed_sock_af35a7663942bba32c947f387114bc068}, \textbf{ PCPTest\+Sock} \doxyref{}{p.}{class_p_c_p_test_sock_af35a7663942bba32c947f387114bc068}, and \textbf{ Zero\+Sock} \doxyref{}{p.}{class_zero_sock_af35a7663942bba32c947f387114bc068}.



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{Sock@{Sock}!ERR@{ERR}}
\index{ERR@{ERR}!Sock@{Sock}}
\doxysubsubsection{ERR}
{\footnotesize\ttfamily \label{class_sock_a2d9bf7f3d9855e98e28b9224cab3920e} 
\textbf{ Event} ERR = 0b100\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

Ignored if passed to {\ttfamily \doxyref{Wait()}{p.}{class_sock_a851a09613d347a157da032137020065a}}, but could be set in the occurred events if an exceptional condition has occurred on the socket or if it has been disconnected. \index{Sock@{Sock}!m\_socket@{m\_socket}}
\index{m\_socket@{m\_socket}!Sock@{Sock}}
\doxysubsubsection{m\_socket}
{\footnotesize\ttfamily \label{class_sock_a453ef0b211974cc0b3f59651f2759a85} 
\textbf{ SOCKET} m\+\_\+socket\hspace{0.3cm}{\ttfamily [protected]}}

Contained socket. {\ttfamily \doxyref{INVALID\+\_\+\+SOCKET}{p.}{compat_8h_a26769957ec1a2beaf223f33b66ee64ab}} designates the object is empty. \index{Sock@{Sock}!RECV@{RECV}}
\index{RECV@{RECV}!Sock@{Sock}}
\doxysubsubsection{RECV}
{\footnotesize\ttfamily \label{class_sock_ae15d539512bccb6583fc75310b0d2f86} 
\textbf{ Event} RECV = 0b001\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

If passed to {\ttfamily \doxyref{Wait()}{p.}{class_sock_a851a09613d347a157da032137020065a}}, then it will wait for readiness to read from the socket. \index{Sock@{Sock}!SEND@{SEND}}
\index{SEND@{SEND}!Sock@{Sock}}
\doxysubsubsection{SEND}
{\footnotesize\ttfamily \label{class_sock_ac739f9398eaa67718961a5ac331fba4a} 
\textbf{ Event} SEND = 0b010\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

If passed to {\ttfamily \doxyref{Wait()}{p.}{class_sock_a851a09613d347a157da032137020065a}}, then it will wait for readiness to send to the socket. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/util/\textbf{ sock.\+h}\item 
src/util/\textbf{ sock.\+cpp}\end{DoxyCompactItemize}
