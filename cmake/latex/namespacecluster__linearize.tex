\doxysection{cluster\+\_\+linearize Namespace Reference}
\label{namespacecluster__linearize}\index{cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Dep\+Graph}
\item 
struct \textbf{ Set\+Info}
\item 
class \textbf{ Spanning\+Forest\+State}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Dep\+Graph\+Index} = uint32\+\_\+t
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Set\+Type$>$ }\\std\+::vector$<$ \textbf{ Set\+Info}$<$ Set\+Type $>$ $>$ \textbf{ Chunk\+Linearization\+Info} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph, std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$ linearization) noexcept
\item 
{\footnotesize template$<$typename Set\+Type$>$ }\\std\+::vector$<$ \textbf{ Fee\+Frac} $>$ \textbf{ Chunk\+Linearization} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph, std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$ linearization) noexcept
\item 
{\footnotesize template$<$typename Set\+Type$>$ }\\std\+::tuple$<$ std\+::vector$<$ \textbf{ Dep\+Graph\+Index} $>$, bool, uint64\+\_\+t $>$ \textbf{ Linearize} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph, uint64\+\_\+t max\+\_\+iterations, uint64\+\_\+t rng\+\_\+seed, std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$ old\+\_\+linearization=\{\}) noexcept
\item 
{\footnotesize template$<$typename Set\+Type$>$ }\\void \textbf{ Post\+Linearize} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph, std\+::span$<$ \textbf{ Dep\+Graph\+Index} $>$ linearization)
\item 
{\footnotesize template$<$typename Set\+Type$>$ }\\void \textbf{ Fix\+Linearization} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph, std\+::span$<$ \textbf{ Dep\+Graph\+Index} $>$ linearization) noexcept
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{cluster\_linearize@{cluster\_linearize}!DepGraphIndex@{DepGraphIndex}}
\index{DepGraphIndex@{DepGraphIndex}!cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection{DepGraphIndex}
{\footnotesize\ttfamily \label{namespacecluster__linearize_afe7ae098b4cbd5b112f81d1e9429e90d} 
using \textbf{ Dep\+Graph\+Index} = uint32\+\_\+t}

Data type to represent transaction indices in Dep\+Graphs and the clusters they represent. 

\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{cluster\_linearize@{cluster\_linearize}!ChunkLinearization@{ChunkLinearization}}
\index{ChunkLinearization@{ChunkLinearization}!cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection{ChunkLinearization()}
{\footnotesize\ttfamily \label{namespacecluster__linearize_a8efd6c0d9203d9d942b0c8b9baf81e87} 
template$<$typename Set\+Type$>$ \\
std\+::vector$<$ \textbf{ Fee\+Frac} $>$ Chunk\+Linearization (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{, }\item[{std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$}]{linearization}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Compute the feerates of the chunks of linearization. Identical to Chunk\+Linearization\+Info, but only returns the chunk feerates, not the corresponding transaction sets. The new chunk to be added, initially a singleton.\index{cluster\_linearize@{cluster\_linearize}!ChunkLinearizationInfo@{ChunkLinearizationInfo}}
\index{ChunkLinearizationInfo@{ChunkLinearizationInfo}!cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection{ChunkLinearizationInfo()}
{\footnotesize\ttfamily \label{namespacecluster__linearize_a30f9a354e247428df47e59a11e2a098f} 
template$<$typename Set\+Type$>$ \\
std\+::vector$<$ \textbf{ Set\+Info}$<$ Set\+Type $>$ $>$ Chunk\+Linearization\+Info (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{, }\item[{std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$}]{linearization}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Compute the chunks of linearization as Set\+Infos. The new chunk to be added, initially a singleton.\index{cluster\_linearize@{cluster\_linearize}!FixLinearization@{FixLinearization}}
\index{FixLinearization@{FixLinearization}!cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection{FixLinearization()}
{\footnotesize\ttfamily \label{namespacecluster__linearize_a2d8e8c7af3c1fd9b4bbd67716b358430} 
template$<$typename Set\+Type$>$ \\
void Fix\+Linearization (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{, }\item[{std\+::span$<$ \textbf{ Dep\+Graph\+Index} $>$}]{linearization}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Make linearization topological, retaining its ordering where possible. The element at that position.

j represents how far from the back of the linearization elem should be placed.\index{cluster\_linearize@{cluster\_linearize}!Linearize@{Linearize}}
\index{Linearize@{Linearize}!cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection{Linearize()}
{\footnotesize\ttfamily \label{namespacecluster__linearize_ad7fec78514892bfc4213dec2180ea5fa} 
template$<$typename Set\+Type$>$ \\
std\+::tuple$<$ std\+::vector$<$ \textbf{ Dep\+Graph\+Index} $>$, bool, uint64\+\_\+t $>$ Linearize (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{, }\item[{uint64\+\_\+t}]{max\+\_\+iterations}{, }\item[{uint64\+\_\+t}]{rng\+\_\+seed}{, }\item[{std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$}]{old\+\_\+linearization}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Find or improve a linearization for a cluster.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em depgraph} & Dependency graph of the cluster to be linearized. \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+iterations} & Upper bound on the amount of work that will be done. \\
\hline
\mbox{\texttt{in}}  & {\em rng\+\_\+seed} & A random number seed to control search order. This prevents peers from predicting exactly which clusters would be hard for us to linearize. \\
\hline
\mbox{\texttt{in}}  & {\em old\+\_\+linearization} & An existing linearization for the cluster (which must be topologically valid), or empty. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A tuple of\+:
\begin{DoxyItemize}
\item The resulting linearization. It is guaranteed to be at least as good (in the feerate diagram sense) as old\+\_\+linearization.
\item A boolean indicating whether the result is guaranteed to be optimal.
\item How many optimization steps were actually performed. 
\end{DoxyItemize}
\end{DoxyReturn}
Initialize a spanning forest data structure for this cluster.\index{cluster\_linearize@{cluster\_linearize}!PostLinearize@{PostLinearize}}
\index{PostLinearize@{PostLinearize}!cluster\_linearize@{cluster\_linearize}}
\doxysubsubsection{PostLinearize()}
{\footnotesize\ttfamily \label{namespacecluster__linearize_ab4dfb7a53e485a4f5eac2219e4176a91} 
template$<$typename Set\+Type$>$ \\
void Post\+Linearize (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{, }\item[{std\+::span$<$ \textbf{ Dep\+Graph\+Index} $>$}]{linearization}{}\end{DoxyParamCaption})}

Improve a given linearization.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em depgraph} & Dependency graph of the cluster being linearized. \\
\hline
\mbox{\texttt{in,out}}  & {\em linearization} & On input, an existing linearization for depgraph. On output, a potentially better linearization for the same graph.\\
\hline
\end{DoxyParams}
Postlinearization guarantees\+:
\begin{DoxyItemize}
\item The resulting chunks are connected.
\item If the input has a tree shape (either all transactions have at most one child, or all transactions have at most one parent), the result is optimal.
\item Given a linearization L1 and a leaf transaction T in it. Let L2 be L1 with T moved to the end, optionally with its fee increased. Let L3 be the postlinearization of L2. L3 will be at least as good as L1. This means that replacing transactions with same-\/size higher-\/fee transactions will not worsen linearizations through a "{}drop conflicts, append new transactions,   postlinearize"{} process. 
\end{DoxyItemize}Index of the sentinel in the entries array below.

Indicator that a group has no previous transaction.

Data structure per transaction entry.

The index of the previous transaction in this group; NO\+\_\+\+PREV\+\_\+\+TX if this is the first entry of a group.

Index of the first transaction in this group, possibly itself.

Index of the last transaction in the previous group. The first group (the sentinel) points back to the last group here, making it a singly-\/linked circular list.

All transactions in the group. Empty for the sentinel.

All dependencies of the group (descendants in even passes; ancestors in odd ones).

The combined fee/size of transactions in the group. Fee is negated in even passes.