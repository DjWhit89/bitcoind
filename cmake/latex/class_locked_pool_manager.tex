\doxysection{Locked\+Pool\+Manager Class Reference}
\label{class_locked_pool_manager}\index{LockedPoolManager@{LockedPoolManager}}


{\ttfamily \#include $<$lockedpool.\+h$>$}

Inheritance diagram for Locked\+Pool\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_locked_pool_manager}
\end{center}
\end{figure}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \textbf{ Locked\+Pool\+Manager} \& \textbf{ Instance} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Locked\+Pool}}
\begin{DoxyCompactItemize}
\item 
typedef bool($\ast$ \textbf{ Locking\+Failed\+\_\+\+Callback}) ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Locked\+Pool}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Locked\+Pool} (std\+::unique\+\_\+ptr$<$ \textbf{ Locked\+Page\+Allocator} $>$ allocator, \textbf{ Locking\+Failed\+\_\+\+Callback} lf\+\_\+cb\+\_\+in=nullptr)
\item 
\textbf{ $\sim$\+Locked\+Pool} ()
\item 
\textbf{ Locked\+Pool} (const \textbf{ Locked\+Pool} \&other)=delete
\item 
\textbf{ Locked\+Pool} \& \textbf{ operator=} (const \textbf{ Locked\+Pool} \&)=delete
\item 
void $\ast$ \textbf{ alloc} (size\+\_\+t size)
\item 
void \textbf{ free} (void $\ast$ptr)
\item 
\textbf{ Stats} \textbf{ stats} () const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \textbf{ Locked\+Pool}}
\begin{DoxyCompactItemize}
\item 
static const size\+\_\+t \textbf{ ARENA\+\_\+\+SIZE} = 256$\ast$1024
\item 
static const size\+\_\+t \textbf{ ARENA\+\_\+\+ALIGN} = 16
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Singleton class to keep track of locked (ie, non-\/swappable) memory, for use in std\+::allocator templates.

Some implementations of the STL allocate memory in some constructors (i.\+e., see MSVC\textquotesingle{}s vector$<$\+T$>$ implementation where it allocates 1 byte of memory in the allocator.) Due to the unpredictable order of static initializers, we have to make sure the \doxyref{Locked\+Pool\+Manager}{p.}{class_locked_pool_manager} instance exists before any other STL-\/based objects that use \doxyref{secure\+\_\+allocator}{p.}{structsecure__allocator} are created. So instead of having \doxyref{Locked\+Pool\+Manager}{p.}{class_locked_pool_manager} also be static-\/initialized, it is created on demand. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{LockedPoolManager@{LockedPoolManager}!Instance@{Instance}}
\index{Instance@{Instance}!LockedPoolManager@{LockedPoolManager}}
\doxysubsubsection{Instance()}
{\footnotesize\ttfamily \label{class_locked_pool_manager_a3385c588448c861d49d6ca1082d576c0} 
\textbf{ Locked\+Pool\+Manager} \& Instance (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Return the current instance, or create it once 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/support/\textbf{ lockedpool.\+h}\item 
src/support/\textbf{ lockedpool.\+cpp}\end{DoxyCompactItemize}
