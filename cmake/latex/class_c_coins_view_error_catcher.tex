\doxysection{CCoins\+View\+Error\+Catcher Class Reference}
\label{class_c_coins_view_error_catcher}\index{CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}}


{\ttfamily \#include $<$coins.\+h$>$}

Inheritance diagram for CCoins\+View\+Error\+Catcher\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_c_coins_view_error_catcher}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCoins\+View\+Error\+Catcher} (\textbf{ CCoins\+View} $\ast$view)
\item 
void \textbf{ Add\+Read\+Err\+Callback} (std\+::function$<$ void()$>$ f)
\item 
std\+::optional$<$ \textbf{ Coin} $>$ \textbf{ Get\+Coin} (const \textbf{ COut\+Point} \&outpoint) const override
\begin{DoxyCompactList}\small\item\em Retrieve the \doxyref{Coin}{p.}{class_coin} (unspent transaction output) for a given outpoint. \end{DoxyCompactList}\item 
bool \textbf{ Have\+Coin} (const \textbf{ COut\+Point} \&outpoint) const override
\begin{DoxyCompactList}\small\item\em Just check whether a given outpoint is unspent. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ CCoins\+View\+Backed}}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCoins\+View\+Backed} (\textbf{ CCoins\+View} $\ast$view\+In)
\item 
\textbf{ uint256} \textbf{ Get\+Best\+Block} () const override
\begin{DoxyCompactList}\small\item\em Retrieve the block hash whose state this \doxyref{CCoins\+View}{p.}{class_c_coins_view} currently represents. \end{DoxyCompactList}\item 
std\+::vector$<$ \textbf{ uint256} $>$ \textbf{ Get\+Head\+Blocks} () const override
\item 
void \textbf{ Set\+Backend} (\textbf{ CCoins\+View} \&view\+In)
\item 
bool \textbf{ Batch\+Write} (\textbf{ Coins\+View\+Cache\+Cursor} \&cursor, const \textbf{ uint256} \&hash\+Block) override
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ CCoins\+View\+Cursor} $>$ \textbf{ Cursor} () const override
\begin{DoxyCompactList}\small\item\em Get a cursor to iterate over the whole state. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Estimate\+Size} () const override
\begin{DoxyCompactList}\small\item\em Estimate database size (0 if not implemented). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ CCoins\+View}}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+CCoins\+View} ()=default
\begin{DoxyCompactList}\small\item\em As we use CCoins\+Views polymorphically, have a virtual destructor. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Protected Attributes inherited from \textbf{ CCoins\+View\+Backed}}
\begin{DoxyCompactItemize}
\item 
\textbf{ CCoins\+View} $\ast$ \textbf{ base}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This is a minimally invasive approach to shutdown on Level\+DB read errors from the chainstate, while keeping user interface out of the common library, which is shared between bitcoind, and bitcoin-\/qt and non-\/server tools.

Writes do not need similar protection, as failure to write is handled by the caller. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}!CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}}
\index{CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}!CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}}
\doxysubsubsection{CCoinsViewErrorCatcher()}
{\footnotesize\ttfamily \label{class_c_coins_view_error_catcher_a75f0bfa576d3918d5e2e4071090a5414} 
\textbf{ CCoins\+View\+Error\+Catcher} (\begin{DoxyParamCaption}\item[{\textbf{ CCoins\+View} $\ast$}]{view}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}!AddReadErrCallback@{AddReadErrCallback}}
\index{AddReadErrCallback@{AddReadErrCallback}!CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}}
\doxysubsubsection{AddReadErrCallback()}
{\footnotesize\ttfamily \label{class_c_coins_view_error_catcher_a13973056a9b53959d28396ba3d0d1512} 
void Add\+Read\+Err\+Callback (\begin{DoxyParamCaption}\item[{std\+::function$<$ void()$>$}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}!GetCoin@{GetCoin}}
\index{GetCoin@{GetCoin}!CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}}
\doxysubsubsection{GetCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_error_catcher_a053700fd896babb8aa62fc7c53dd27f6} 
std\+::optional$<$ \textbf{ Coin} $>$ Get\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Retrieve the \doxyref{Coin}{p.}{class_coin} (unspent transaction output) for a given outpoint. 



Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a053700fd896babb8aa62fc7c53dd27f6}.

\index{CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}!HaveCoin@{HaveCoin}}
\index{HaveCoin@{HaveCoin}!CCoinsViewErrorCatcher@{CCoinsViewErrorCatcher}}
\doxysubsubsection{HaveCoin()}
{\footnotesize\ttfamily \label{class_c_coins_view_error_catcher_a57c7063d0b2cb3900509d8a9e91a8459} 
bool Have\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Just check whether a given outpoint is unspent. 



Reimplemented from \textbf{ CCoins\+View\+Backed} \doxyref{}{p.}{class_c_coins_view_backed_a57c7063d0b2cb3900509d8a9e91a8459}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ coins.\+h}\item 
src/\textbf{ coins.\+cpp}\end{DoxyCompactItemize}
