\doxysection{Epoch Class Reference}
\label{class_epoch}\index{Epoch@{Epoch}}


{\ttfamily \#include $<$epochguard.\+h$>$}

\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Marker}
\item 
class \textbf{ Guard}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Epoch} ()=default
\item 
\textbf{ Epoch} (const \textbf{ Epoch} \&)=delete
\item 
\textbf{ Epoch} \& \textbf{ operator=} (const \textbf{ Epoch} \&)=delete
\item 
\textbf{ Epoch} (\textbf{ Epoch} \&\&)=delete
\item 
\textbf{ Epoch} \& \textbf{ operator=} (\textbf{ Epoch} \&\&)=delete
\item 
\textbf{ $\sim$\+Epoch} ()=default
\item 
bool \textbf{ guarded} () const
\item 
bool \textbf{ visited} (\textbf{ Marker} \&marker) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}($\ast$this)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxyref{Epoch}{p.}{class_epoch}\+: RAII-\/style guard for using epoch-\/based graph traversal algorithms. When walking ancestors or descendants, we generally want to avoid visiting the same transactions twice. Some traversal algorithms use std\+::set (or set\+Entries) to deduplicate the transaction we visit. However, use of std\+::set is algorithmically undesirable because it both adds an asymptotic factor of O(log n) to traversals cost and triggers O(n) more dynamic memory allocations. In many algorithms we can replace std\+::set with an internal mempool counter to track the time (or, "{}epoch"{}) that we began a traversal, and check + update a per-\/transaction epoch for each transaction we look at to determine if that transaction has not yet been visited during the current traversal\textquotesingle{}s epoch. Algorithms using std\+::set can be replaced on a one by one basis. Both techniques are not fundamentally incompatible across the codebase. Generally speaking, however, the remaining use of std\+::set for mempool traversal should be viewed as a TODO for replacement with an epoch based traversal, rather than a preference for std\+::set over epochs in that algorithm. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Epoch@{Epoch}!Epoch@{Epoch}}
\index{Epoch@{Epoch}!Epoch@{Epoch}}
\doxysubsubsection{Epoch()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{class_epoch_a0f329154e2f4b4821fc8ac27b71249ae} 
\textbf{ Epoch} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

\index{Epoch@{Epoch}!Epoch@{Epoch}}
\index{Epoch@{Epoch}!Epoch@{Epoch}}
\doxysubsubsection{Epoch()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{class_epoch_afa3d238e46b911a1710736f8cf612615} 
\textbf{ Epoch} (\begin{DoxyParamCaption}\item[{const \textbf{ Epoch} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{Epoch@{Epoch}!Epoch@{Epoch}}
\index{Epoch@{Epoch}!Epoch@{Epoch}}
\doxysubsubsection{Epoch()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{class_epoch_a4f183e31420f79483f73d1cbd93d9b97} 
\textbf{ Epoch} (\begin{DoxyParamCaption}\item[{\textbf{ Epoch} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{Epoch@{Epoch}!````~Epoch@{$\sim$Epoch}}
\index{````~Epoch@{$\sim$Epoch}!Epoch@{Epoch}}
\doxysubsubsection{$\sim$Epoch()}
{\footnotesize\ttfamily \label{class_epoch_aaa5e2d8414ef0c7e3c5fa0b8598a2004} 
$\sim$\textbf{ Epoch} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Epoch@{Epoch}!guarded@{guarded}}
\index{guarded@{guarded}!Epoch@{Epoch}}
\doxysubsubsection{guarded()}
{\footnotesize\ttfamily \label{class_epoch_a06d58f7eb6c0fc1043d1e9a6e5a61bdd} 
bool guarded (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{Epoch@{Epoch}!operator=@{operator=}}
\index{operator=@{operator=}!Epoch@{Epoch}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_epoch_a2d6696c6a404aa0224e5397e8419598d} 
\textbf{ Epoch} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Epoch} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{Epoch@{Epoch}!operator=@{operator=}}
\index{operator=@{operator=}!Epoch@{Epoch}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_epoch_a0226b23515def2c858b112f34b7fc4f3} 
\textbf{ Epoch} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ Epoch} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{Epoch@{Epoch}!visited@{visited}}
\index{visited@{visited}!Epoch@{Epoch}}
\doxysubsubsection{visited()}
{\footnotesize\ttfamily \label{class_epoch_affd9150d452a9950db12318be619dd1a} 
bool visited (\begin{DoxyParamCaption}\item[{\textbf{ Marker} \&}]{marker}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/util/\textbf{ epochguard.\+h}\end{DoxyCompactItemize}
