\doxysection{Dyn\+Sock\+::Pipe Class Reference}
\label{class_dyn_sock_1_1_pipe}\index{DynSock::Pipe@{DynSock::Pipe}}


{\ttfamily \#include $<$net.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
ssize\+\_\+t \textbf{ Get\+Bytes} (void $\ast$buf, size\+\_\+t len, int \textbf{ flags}=0) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\item 
std\+::optional$<$ \textbf{ CNet\+Message} $>$ \textbf{ Get\+Net\+Msg} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\item 
void \textbf{ Push\+Bytes} (const void $\ast$buf, size\+\_\+t len) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\item 
{\footnotesize template$<$typename... Args$>$ }\\void \textbf{ Push\+Net\+Msg} (const std\+::string \&type, Args \&\&... payload) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\item 
void \textbf{ Eof} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+mutex)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Unidirectional bytes or \doxyref{CNet\+Message}{p.}{class_c_net_message} queue (FIFO). 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{DynSock::Pipe@{DynSock::Pipe}!Eof@{Eof}}
\index{Eof@{Eof}!DynSock::Pipe@{DynSock::Pipe}}
\doxysubsubsection{Eof()}
{\footnotesize\ttfamily \label{class_dyn_sock_1_1_pipe_a1f4d4e97fdc6b20d7da01cea65f3fa6c} 
void Eof (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Signal end-\/of-\/file on the receiving end ({\ttfamily \doxyref{Get\+Bytes()}{p.}{class_dyn_sock_1_1_pipe_abd101ceb3b30109dad0280139fa5afa2}} or {\ttfamily \doxyref{Get\+Net\+Msg()}{p.}{class_dyn_sock_1_1_pipe_a45a40d959c432aec9fe9702d18b0af05}}). \index{DynSock::Pipe@{DynSock::Pipe}!GetBytes@{GetBytes}}
\index{GetBytes@{GetBytes}!DynSock::Pipe@{DynSock::Pipe}}
\doxysubsubsection{GetBytes()}
{\footnotesize\ttfamily \label{class_dyn_sock_1_1_pipe_abd101ceb3b30109dad0280139fa5afa2} 
ssize\+\_\+t Get\+Bytes (\begin{DoxyParamCaption}\item[{void $\ast$}]{buf}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

Get bytes and remove them from the pipe. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em buf} & Destination to write bytes to. \\
\hline
\mbox{\texttt{in}}  & {\em len} & Write up to this number of bytes. \\
\hline
\mbox{\texttt{in}}  & {\em flags} & Same as the flags of {\ttfamily recv(2)}. Just {\ttfamily MSG\+\_\+\+PEEK} is honored. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to {\ttfamily buf}. {\ttfamily 0} if {\ttfamily \doxyref{Eof()}{p.}{class_dyn_sock_1_1_pipe_a1f4d4e97fdc6b20d7da01cea65f3fa6c}} has been called. If no bytes are available then {\ttfamily -\/1} is returned and {\ttfamily errno} is set to {\ttfamily EAGAIN}. 
\end{DoxyReturn}
\index{DynSock::Pipe@{DynSock::Pipe}!GetNetMsg@{GetNetMsg}}
\index{GetNetMsg@{GetNetMsg}!DynSock::Pipe@{DynSock::Pipe}}
\doxysubsubsection{GetNetMsg()}
{\footnotesize\ttfamily \label{class_dyn_sock_1_1_pipe_a45a40d959c432aec9fe9702d18b0af05} 
std\+::optional$<$ \textbf{ CNet\+Message} $>$ Get\+Net\+Msg (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Deserialize a {\ttfamily \doxyref{CNet\+Message}{p.}{class_c_net_message}} and remove it from the pipe. If not enough bytes are available then the function will wait. If parsing fails or EOF is signaled to the pipe, then {\ttfamily std\+::nullopt} is returned. \index{DynSock::Pipe@{DynSock::Pipe}!PushBytes@{PushBytes}}
\index{PushBytes@{PushBytes}!DynSock::Pipe@{DynSock::Pipe}}
\doxysubsubsection{PushBytes()}
{\footnotesize\ttfamily \label{class_dyn_sock_1_1_pipe_a2764431e2e0ea25b35beabcc1dab0ca1} 
void Push\+Bytes (\begin{DoxyParamCaption}\item[{const void $\ast$}]{buf}{, }\item[{size\+\_\+t}]{len}{}\end{DoxyParamCaption})}

Push bytes to the pipe. \index{DynSock::Pipe@{DynSock::Pipe}!PushNetMsg@{PushNetMsg}}
\index{PushNetMsg@{PushNetMsg}!DynSock::Pipe@{DynSock::Pipe}}
\doxysubsubsection{PushNetMsg()}
{\footnotesize\ttfamily \label{class_dyn_sock_1_1_pipe_afb25e44054f943a7cbffeed3ba336ec5} 
template$<$typename... Args$>$ \\
void Push\+Net\+Msg (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{type}{, }\item[{Args \&\&...}]{payload}{}\end{DoxyParamCaption})}

Construct and push \doxyref{CNet\+Message}{p.}{class_c_net_message} to the pipe. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/test/util/\textbf{ net.\+h}\item 
src/test/util/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
