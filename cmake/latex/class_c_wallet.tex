\doxysection{CWallet Class Reference}
\label{class_c_wallet}\index{CWallet@{CWallet}}


{\ttfamily \#include $<$wallet.\+h$>$}

Inheritance diagram for CWallet\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_wallet}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Scan\+Result}
\item 
struct \textbf{ Addr\+Book\+Filter}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::map$<$ unsigned int, CMaster\+Key $>$ \textbf{ Master\+Key\+Map}
\item 
typedef std\+::multimap$<$ int64\+\_\+t, \textbf{ CWallet\+Tx} $\ast$ $>$ \textbf{ Tx\+Items}
\item 
using \textbf{ Update\+Wallet\+Tx\+Fn} = std\+::function$<$bool(\textbf{ CWallet\+Tx}\& wtx, bool new\+\_\+tx)$>$
\item 
using \textbf{ List\+Addr\+Book\+Func} = std\+::function$<$void(const \textbf{ CTx\+Destination}\& dest, const std\+::string\& label, bool is\+\_\+change, const std\+::optional$<$Address\+Purpose$>$ purpose)$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::unordered\+\_\+map$<$ \textbf{ Txid}, \textbf{ CWallet\+Tx}, \textbf{ Salted\+Txid\+Hasher} $>$ map\+Wallet \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+wallet})
\item 
int64\+\_\+t n\+Order\+Pos\+Next \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+wallet})=0
\item 
std\+::map$<$ \textbf{ CTx\+Destination}, CAddress\+Book\+Data $>$ m\+\_\+address\+\_\+book \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+wallet})
\item 
std\+::map$<$ \textbf{ COut\+Point}, bool $>$ m\+\_\+locked\+\_\+coins \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+wallet})
\item 
int64\+\_\+t n\+Relock\+Time \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Holds a timestamp at which point the wallet is scheduled (externally) to be relocked. Caller must arrange for actual relocking to occur via \doxyref{Lock()}{p.}{class_c_wallet_a747fd95916e116a6ed37cc641e394c69}. \end{DoxyCompactList}\item 
bool \textbf{ Unlock} (const \textbf{ Secure\+String} \&str\+Wallet\+Passphrase)
\item 
Wallet\+Database \& \textbf{ Get\+Database} () const override
\item 
const std\+::string \& \textbf{ Get\+Name} () const
\item 
\textbf{ CWallet} (\textbf{ interfaces\+::\+Chain} $\ast$\textbf{ chain}, const std\+::string \&\textbf{ name}, std\+::unique\+\_\+ptr$<$ Wallet\+Database $>$ database)
\item 
\textbf{ $\sim$\+CWallet} ()
\item 
bool \textbf{ Is\+Crypted} () const
\item 
bool \textbf{ Is\+Locked} () const override
\item 
bool \textbf{ Lock} ()
\item 
bool \textbf{ Have\+Chain} () const
\item 
const CAddress\+Book\+Data $\ast$ \textbf{ Find\+Address\+Book\+Entry} (const \textbf{ CTx\+Destination} \&, bool allow\+\_\+change=false) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
\textbf{ interfaces\+::\+Chain} \& \textbf{ chain} () const
\item 
const \textbf{ CWallet\+Tx} $\ast$ \textbf{ Get\+Wallet\+Tx} (const \textbf{ Txid} \&hash) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
std\+::set$<$ \textbf{ Txid} $>$ \textbf{ Get\+Tx\+Conflicts} (const \textbf{ CWallet\+Tx} \&wtx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
const std\+::unordered\+\_\+map$<$ \textbf{ COut\+Point}, Wallet\+TXO, \textbf{ Salted\+Outpoint\+Hasher} $>$ \& \textbf{ Get\+TXOs} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
std\+::optional$<$ Wallet\+TXO $>$ \textbf{ Get\+TXO} (const \textbf{ COut\+Point} \&outpoint) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Refresh\+TXOs\+From\+Tx} (const \textbf{ CWallet\+Tx} \&wtx) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Refresh\+All\+TXOs} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
int \textbf{ Get\+Tx\+Depth\+In\+Main\+Chain} (const \textbf{ CWallet\+Tx} \&wtx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
int \textbf{ Get\+Tx\+Blocks\+To\+Maturity} (const \textbf{ CWallet\+Tx} \&wtx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Tx\+Immature\+Coin\+Base} (const \textbf{ CWallet\+Tx} \&wtx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Spent} (const \textbf{ COut\+Point} \&outpoint) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Spent\+Key} (const \textbf{ CScript} \&script\+Pub\+Key) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Set\+Spent\+Key\+State} (Wallet\+Batch \&batch, const \textbf{ Txid} \&hash, unsigned int n, bool used, std\+::set$<$ \textbf{ CTx\+Destination} $>$ \&tx\+\_\+destinations) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
\textbf{ util\+::\+Result}$<$ void $>$ \textbf{ Display\+Address} (const \textbf{ CTx\+Destination} \&dest) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Locked\+Coin} (const \textbf{ COut\+Point} \&output) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Load\+Locked\+Coin} (const \textbf{ COut\+Point} \&coin, bool persistent) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Lock\+Coin} (const \textbf{ COut\+Point} \&output, bool persist) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Unlock\+Coin} (const \textbf{ COut\+Point} \&output) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Unlock\+All\+Coins} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ List\+Locked\+Coins} (std\+::vector$<$ \textbf{ COut\+Point} $>$ \&v\+Outpts) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Abort\+Rescan} ()
\item 
bool \textbf{ Is\+Aborting\+Rescan} () const
\item 
bool \textbf{ Is\+Scanning} () const
\item 
bool \textbf{ Is\+Scanning\+With\+Passphrase} () const
\item 
Steady\+Clock\+::duration \textbf{ Scanning\+Duration} () const
\item 
double \textbf{ Scanning\+Progress} () const
\item 
void \textbf{ Upgrade\+Descriptor\+Cache} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Upgrade Descriptor\+Caches. \end{DoxyCompactList}\item 
void \textbf{ Load\+Address\+Previously\+Spent} (const \textbf{ CTx\+Destination} \&dest) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Marks destination as previously spent. \end{DoxyCompactList}\item 
void \textbf{ Load\+Address\+Receive\+Request} (const \textbf{ CTx\+Destination} \&dest, const std\+::string \&id, const std\+::string \&request) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Appends payment request to destination. \end{DoxyCompactList}\item 
bool \textbf{ Change\+Wallet\+Passphrase} (const \textbf{ Secure\+String} \&str\+Old\+Wallet\+Passphrase, const \textbf{ Secure\+String} \&str\+New\+Wallet\+Passphrase)
\item 
bool \textbf{ Encrypt\+Wallet} (const \textbf{ Secure\+String} \&str\+Wallet\+Passphrase)
\item 
unsigned int \textbf{ Compute\+Time\+Smart} (const \textbf{ CWallet\+Tx} \&wtx, bool rescanning\+\_\+old\+\_\+block) const
\item 
int64\+\_\+t \textbf{ Inc\+Order\+Pos\+Next} (Wallet\+Batch $\ast$batch=nullptr) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
DBErrors \textbf{ Reorder\+Transactions} ()
\item 
void \textbf{ Mark\+Dirty} ()
\item 
\textbf{ CWallet\+Tx} $\ast$ \textbf{ Add\+To\+Wallet} (\textbf{ CTransaction\+Ref} tx, const Tx\+State \&state, const \textbf{ Update\+Wallet\+Tx\+Fn} \&update\+\_\+wtx=nullptr, bool rescanning\+\_\+old\+\_\+block=false)
\item 
bool \textbf{ Load\+To\+Wallet} (const \textbf{ Txid} \&hash, const \textbf{ Update\+Wallet\+Tx\+Fn} \&fill\+\_\+wtx) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ transaction\+Added\+To\+Mempool} (const \textbf{ CTransaction\+Ref} \&tx) override
\item 
void \textbf{ block\+Connected} (const \textbf{ kernel\+::\+Chainstate\+Role} \&role, const \textbf{ interfaces\+::\+Block\+Info} \&block) override
\item 
void \textbf{ block\+Disconnected} (const \textbf{ interfaces\+::\+Block\+Info} \&block) override
\item 
void \textbf{ updated\+Block\+Tip} () override
\item 
int64\+\_\+t \textbf{ Rescan\+From\+Time} (int64\+\_\+t start\+Time, const \textbf{ Wallet\+Rescan\+Reserver} \&reserver, bool update)
\item 
\textbf{ Scan\+Result} \textbf{ Scan\+For\+Wallet\+Transactions} (const \textbf{ uint256} \&start\+\_\+block, int start\+\_\+height, std\+::optional$<$ int $>$ max\+\_\+height, const \textbf{ Wallet\+Rescan\+Reserver} \&reserver, bool f\+Update, const bool save\+\_\+progress)
\item 
void \textbf{ transaction\+Removed\+From\+Mempool} (const \textbf{ CTransaction\+Ref} \&tx, \textbf{ Mem\+Pool\+Removal\+Reason} reason) override
\item 
void \textbf{ Set\+Next\+Resend} ()
\item 
bool \textbf{ Should\+Resend} () const
\item 
void \textbf{ Resubmit\+Wallet\+Transactions} (\textbf{ node\+::\+Tx\+Broadcast} broadcast\+\_\+method, bool force)
\item 
\textbf{ Output\+Type} \textbf{ Transaction\+Change\+Type} (const std\+::optional$<$ \textbf{ Output\+Type} $>$ \&change\+\_\+type, const std\+::vector$<$ \textbf{ CRecipient} $>$ \&vec\+Send) const
\item 
bool \textbf{ Sign\+Transaction} (\textbf{ CMutable\+Transaction} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Sign\+Transaction} (\textbf{ CMutable\+Transaction} \&tx, const std\+::map$<$ \textbf{ COut\+Point}, \textbf{ Coin} $>$ \&coins, int sighash, std\+::map$<$ int, \textbf{ bilingual\+\_\+str} $>$ \&input\+\_\+errors) const
\item 
\textbf{ Signing\+Result} \textbf{ Sign\+Message} (const std\+::string \&message, const \textbf{ PKHash} \&pkhash, std\+::string \&str\+\_\+sig) const
\item 
std\+::optional$<$ \textbf{ common\+::\+PSBTError} $>$ \textbf{ Fill\+PSBT} (\textbf{ Partially\+Signed\+Transaction} \&psbtx, bool \&complete, std\+::optional$<$ int $>$ sighash\+\_\+type=std\+::nullopt, bool sign=true, bool bip32derivs=true, size\+\_\+t $\ast$n\+\_\+signed=nullptr, bool finalize=true) const
\item 
void \textbf{ Commit\+Transaction} (\textbf{ CTransaction\+Ref} tx, map\+Value\+\_\+t map\+Value, std\+::vector$<$ std\+::pair$<$ std\+::string, std\+::string $>$ $>$ order\+Form)
\item 
bool \textbf{ Submit\+Tx\+Memory\+Pool\+And\+Relay} (\textbf{ CWallet\+Tx} \&wtx, std\+::string \&err\+\_\+string, \textbf{ node\+::\+Tx\+Broadcast} broadcast\+\_\+method) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Maybe\+Update\+Birth\+Time} (int64\+\_\+t time)
\item 
size\+\_\+t \textbf{ Keypool\+Count\+External\+Keys} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Top\+Up\+Key\+Pool} (unsigned int kp\+Size=0)
\item 
std\+::vector$<$ \textbf{ CTx\+Destination} $>$ \textbf{ List\+Addr\+Book\+Addresses} (const std\+::optional$<$ \textbf{ Addr\+Book\+Filter} $>$ \&filter) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
std\+::set$<$ std\+::string $>$ \textbf{ List\+Addr\+Book\+Labels} (const std\+::optional$<$ Address\+Purpose $>$ purpose) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ For\+Each\+Addr\+Book\+Entry} (const \textbf{ List\+Addr\+Book\+Func} \&func) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Mark\+Destinations\+Dirty} (const std\+::set$<$ \textbf{ CTx\+Destination} $>$ \&destinations) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
\textbf{ util\+::\+Result}$<$ \textbf{ CTx\+Destination} $>$ \textbf{ Get\+New\+Destination} (const \textbf{ Output\+Type} type, const std\+::string label)
\item 
\textbf{ util\+::\+Result}$<$ \textbf{ CTx\+Destination} $>$ \textbf{ Get\+New\+Change\+Destination} (const \textbf{ Output\+Type} type)
\item 
bool \textbf{ Is\+Mine} (const \textbf{ CTx\+Destination} \&dest) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Mine} (const \textbf{ CScript} \&\textbf{ script}) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Mine} (const \textbf{ CTx\+Out} \&txout) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Mine} (const \textbf{ CTransaction} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Is\+Mine} (const \textbf{ COut\+Point} \&outpoint) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
\textbf{ CAmount} \textbf{ Get\+Debit} (const \textbf{ CTx\+In} \&txin) const
\item 
\textbf{ CAmount} \textbf{ Get\+Debit} (const \textbf{ CTransaction} \&tx) const
\item 
bool \textbf{ Is\+From\+Me} (const \textbf{ CTransaction} \&tx) const
\item 
DBErrors \textbf{ Load\+Wallet} ()
\item 
\textbf{ util\+::\+Result}$<$ void $>$ \textbf{ Remove\+Txs} (std\+::vector$<$ \textbf{ Txid} $>$ \&txs\+\_\+to\+\_\+remove) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
\textbf{ util\+::\+Result}$<$ void $>$ \textbf{ Remove\+Txs} (Wallet\+Batch \&batch, std\+::vector$<$ \textbf{ Txid} $>$ \&txs\+\_\+to\+\_\+remove) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Set\+Address\+Book} (const \textbf{ CTx\+Destination} \&address, const std\+::string \&str\+Name, const std\+::optional$<$ Address\+Purpose $>$ \&purpose)
\item 
bool \textbf{ Del\+Address\+Book} (const \textbf{ CTx\+Destination} \&address)
\item 
bool \textbf{ Del\+Address\+Book\+With\+DB} (Wallet\+Batch \&batch, const \textbf{ CTx\+Destination} \&address)
\item 
bool \textbf{ Is\+Address\+Previously\+Spent} (const \textbf{ CTx\+Destination} \&dest) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Set\+Address\+Previously\+Spent} (Wallet\+Batch \&batch, const \textbf{ CTx\+Destination} \&dest, bool used) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
std\+::vector$<$ std\+::string $>$ \textbf{ Get\+Address\+Receive\+Requests} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Set\+Address\+Receive\+Request} (Wallet\+Batch \&batch, const \textbf{ CTx\+Destination} \&dest, const std\+::string \&id, const std\+::string \&value) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Erase\+Address\+Receive\+Request} (Wallet\+Batch \&batch, const \textbf{ CTx\+Destination} \&dest, const std\+::string \&id) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
unsigned int \textbf{ Get\+Key\+Pool\+Size} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
std\+::set$<$ \textbf{ Txid} $>$ \textbf{ Get\+Conflicts} (const \textbf{ Txid} \&txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Get wallet transactions that conflict with given transaction (spend same outputs). \end{DoxyCompactList}\item 
bool \textbf{ Has\+Wallet\+Spend} (const \textbf{ CTransaction\+Ref} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Check if a given transaction has any of its outputs spent by another transaction in the wallet. \end{DoxyCompactList}\item 
void \textbf{ Close} ()
\begin{DoxyCompactList}\small\item\em Close wallet database. \end{DoxyCompactList}\item 
bool \textbf{ Get\+Broadcast\+Transactions} () const
\item 
void \textbf{ Set\+Broadcast\+Transactions} (bool broadcast)
\item 
bool \textbf{ Transaction\+Can\+Be\+Abandoned} (const \textbf{ Txid} \&hash\+Tx) const
\item 
bool \textbf{ Abandon\+Transaction} (const \textbf{ Txid} \&hash\+Tx)
\item 
bool \textbf{ Abandon\+Transaction} (\textbf{ CWallet\+Tx} \&tx) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Mark\+Replaced} (const \textbf{ Txid} \&original\+Hash, const \textbf{ Txid} \&new\+Hash)
\item 
void \textbf{ post\+Init\+Process} ()
\item 
bool \textbf{ Backup\+Wallet} (const std\+::string \&str\+Dest) const
\item 
bool \textbf{ Is\+HDEnabled} () const
\item 
bool \textbf{ Can\+Get\+Addresses} (bool internal=false) const
\item 
int64\+\_\+t \textbf{ Get\+Birth\+Time} () const
\item 
void Block\+Until\+Synced\+To\+Current\+Chain() const \textbf{ LOCKS\+\_\+\+EXCLUDED}(void \textbf{ Set\+Wallet\+Flag} (uint64\+\_\+t \textbf{ flags})
\item 
void \textbf{ Unset\+Wallet\+Flag} (uint64\+\_\+t flag)
\item 
bool \textbf{ Is\+Wallet\+Flag\+Set} (uint64\+\_\+t flag) const override
\item 
void \textbf{ Init\+Wallet\+Flags} (uint64\+\_\+t \textbf{ flags})
\item 
bool \textbf{ Load\+Wallet\+Flags} (uint64\+\_\+t \textbf{ flags})
\item 
uint64\+\_\+t \textbf{ Get\+Wallet\+Flags} () const
\begin{DoxyCompactList}\small\item\em Retrieve all of the wallet\textquotesingle{}s flags. \end{DoxyCompactList}\item 
std\+::string \textbf{ Log\+Name} () const override
\item 
std\+::string \textbf{ Display\+Name} () const
\item 
{\footnotesize template$<$typename... Params$>$ }\\void \textbf{ Wallet\+Log\+Printf} (\textbf{ util\+::\+Consteval\+Format\+String}$<$ sizeof...(\textbf{ Params})$>$ wallet\+\_\+fmt, const \textbf{ Params} \&... params) const
\item 
std\+::set$<$ Script\+Pub\+Key\+Man $\ast$ $>$ \textbf{ Get\+Active\+Script\+Pub\+Key\+Mans} () const
\begin{DoxyCompactList}\small\item\em Returns all unique Script\+Pub\+Key\+Mans in m\+\_\+internal\+\_\+spk\+\_\+managers and m\+\_\+external\+\_\+spk\+\_\+managers. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Active\+Script\+Pub\+Key\+Man} (const Script\+Pub\+Key\+Man \&spkm) const
\item 
std\+::set$<$ Script\+Pub\+Key\+Man $\ast$ $>$ \textbf{ Get\+All\+Script\+Pub\+Key\+Mans} () const
\begin{DoxyCompactList}\small\item\em Returns all unique Script\+Pub\+Key\+Mans. \end{DoxyCompactList}\item 
Script\+Pub\+Key\+Man $\ast$ \textbf{ Get\+Script\+Pub\+Key\+Man} (const \textbf{ Output\+Type} \&type, bool internal) const
\begin{DoxyCompactList}\small\item\em Get the Script\+Pub\+Key\+Man for the given \doxyref{Output\+Type}{p.}{outputtype_8h_a4e0517338e6c4a31a2addafc06d4f3a3} and internal/external chain. \end{DoxyCompactList}\item 
Script\+Pub\+Key\+Man $\ast$ \textbf{ Get\+Script\+Pub\+Key\+Man} (const \textbf{ uint256} \&id) const
\begin{DoxyCompactList}\small\item\em Get the Script\+Pub\+Key\+Man by id. \end{DoxyCompactList}\item 
std\+::set$<$ Script\+Pub\+Key\+Man $\ast$ $>$ \textbf{ Get\+Script\+Pub\+Key\+Mans} (const \textbf{ CScript} \&\textbf{ script}) const
\begin{DoxyCompactList}\small\item\em Get all the Script\+Pub\+Key\+Mans for a script. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Signing\+Provider} $>$ \textbf{ Get\+Solving\+Provider} (const \textbf{ CScript} \&\textbf{ script}) const
\begin{DoxyCompactList}\small\item\em Get the \doxyref{Signing\+Provider}{p.}{class_signing_provider} for a script. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Signing\+Provider} $>$ \textbf{ Get\+Solving\+Provider} (const \textbf{ CScript} \&\textbf{ script}, \textbf{ Signature\+Data} \&sigdata) const
\item 
std\+::vector$<$ \textbf{ Wallet\+Descriptor} $>$ \textbf{ Get\+Wallet\+Descriptors} (const \textbf{ CScript} \&\textbf{ script}) const
\begin{DoxyCompactList}\small\item\em Get the wallet descriptors for a script. \end{DoxyCompactList}\item 
Legacy\+Data\+SPKM $\ast$ \textbf{ Get\+Legacy\+Data\+SPKM} () const
\begin{DoxyCompactList}\small\item\em Get the Legacy\+Script\+Pub\+Key\+Man which is used for all types, internal, and external. \end{DoxyCompactList}\item 
Legacy\+Data\+SPKM $\ast$ \textbf{ Get\+Or\+Create\+Legacy\+Data\+SPKM} ()
\item 
void \textbf{ Setup\+Legacy\+Script\+Pub\+Key\+Man} ()
\begin{DoxyCompactList}\small\item\em Make a Legacy(\+Data)SPKM and set it for all types, internal, and external. \end{DoxyCompactList}\item 
bool \textbf{ With\+Encryption\+Key} (std\+::function$<$ bool(const CKeying\+Material \&)$>$ cb) const override
\item 
bool \textbf{ Has\+Encryption\+Keys} () const override
\item 
bool \textbf{ Have\+Crypted\+Keys} () const
\item 
int \textbf{ Get\+Last\+Block\+Height} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
\textbf{ uint256} \textbf{ Get\+Last\+Block\+Hash} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Set\+Last\+Block\+Processed} (int block\+\_\+height, \textbf{ uint256} block\+\_\+hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Write\+Best\+Block} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Connect\+Script\+Pub\+Key\+Man\+Notifiers} ()
\begin{DoxyCompactList}\small\item\em Connect the signals from Script\+Pub\+Key\+Mans to the signals in \doxyref{CWallet}{p.}{class_c_wallet}. \end{DoxyCompactList}\item 
Descriptor\+Script\+Pub\+Key\+Man \& \textbf{ Load\+Descriptor\+Script\+Pub\+Key\+Man} (\textbf{ uint256} id, \textbf{ Wallet\+Descriptor} \&desc)
\begin{DoxyCompactList}\small\item\em Instantiate a descriptor Script\+Pub\+Key\+Man from the \doxyref{Wallet\+Descriptor}{p.}{class_wallet_descriptor} and load it. \end{DoxyCompactList}\item 
void \textbf{ Add\+Active\+Script\+Pub\+Key\+Man} (\textbf{ uint256} id, \textbf{ Output\+Type} type, bool internal)
\item 
void \textbf{ Load\+Active\+Script\+Pub\+Key\+Man} (\textbf{ uint256} id, \textbf{ Output\+Type} type, bool internal)
\item 
void \textbf{ Deactivate\+Script\+Pub\+Key\+Man} (\textbf{ uint256} id, \textbf{ Output\+Type} type, bool internal)
\item 
Descriptor\+Script\+Pub\+Key\+Man \& \textbf{ Setup\+Descriptor\+Script\+Pub\+Key\+Man} (Wallet\+Batch \&batch, const \textbf{ CExt\+Key} \&master\+\_\+key, const \textbf{ Output\+Type} \&output\+\_\+type, bool internal) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Create new Descriptor\+Script\+Pub\+Key\+Man and add it to the wallet. \end{DoxyCompactList}\item 
void \textbf{ Setup\+Descriptor\+Script\+Pub\+Key\+Mans} (Wallet\+Batch \&batch, const \textbf{ CExt\+Key} \&master\+\_\+key) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Create new Descriptor\+Script\+Pub\+Key\+Mans and add them to the wallet. \end{DoxyCompactList}\item 
void \textbf{ Setup\+Descriptor\+Script\+Pub\+Key\+Mans} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
void \textbf{ Setup\+Own\+Descriptor\+Script\+Pub\+Key\+Mans} (Wallet\+Batch \&batch) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Create new seed and default Descriptor\+Script\+Pub\+Key\+Mans for this wallet. \end{DoxyCompactList}\item 
Descriptor\+Script\+Pub\+Key\+Man $\ast$ \textbf{ Get\+Descriptor\+Script\+Pub\+Key\+Man} (const \textbf{ Wallet\+Descriptor} \&desc) const
\begin{DoxyCompactList}\small\item\em Return the Descriptor\+Script\+Pub\+Key\+Man for a \doxyref{Wallet\+Descriptor}{p.}{class_wallet_descriptor} if it is already in the wallet. \end{DoxyCompactList}\item 
std\+::optional$<$ bool $>$ \textbf{ Is\+Internal\+Script\+Pub\+Key\+Man} (Script\+Pub\+Key\+Man $\ast$spk\+\_\+man) const
\item 
\textbf{ util\+::\+Result}$<$ std\+::reference\+\_\+wrapper$<$ Descriptor\+Script\+Pub\+Key\+Man $>$ $>$ \textbf{ Add\+Wallet\+Descriptor} (\textbf{ Wallet\+Descriptor} \&desc, const \textbf{ Flat\+Signing\+Provider} \&signing\+\_\+provider, const std\+::string \&label, bool internal) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Add a descriptor to the wallet, return a Script\+Pub\+Key\+Man \& associated output type. \end{DoxyCompactList}\item 
bool \textbf{ Migrate\+To\+SQLite} (\textbf{ bilingual\+\_\+str} \&error) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
std\+::optional$<$ Migration\+Data $>$ \textbf{ Get\+Descriptors\+For\+Legacy} (\textbf{ bilingual\+\_\+str} \&error) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Get all of the descriptors from a legacy wallet. \end{DoxyCompactList}\item 
\textbf{ util\+::\+Result}$<$ void $>$ \textbf{ Apply\+Migration\+Data} (Wallet\+Batch \&local\+\_\+wallet\+\_\+batch, Migration\+Data \&data) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\item 
bool \textbf{ Can\+GrindR} () const
\begin{DoxyCompactList}\small\item\em Whether the (external) signer performs R-\/value signature grinding. \end{DoxyCompactList}\item 
void \textbf{ Cache\+New\+Script\+Pub\+Keys} (const std\+::set$<$ \textbf{ CScript} $>$ \&spks, Script\+Pub\+Key\+Man $\ast$spkm)
\begin{DoxyCompactList}\small\item\em Add script\+Pub\+Keys for this Script\+Pub\+Key\+Man into the script\+Pub\+Key cache. \end{DoxyCompactList}\item 
void \textbf{ Top\+Up\+Callback} (const std\+::set$<$ \textbf{ CScript} $>$ \&spks, Script\+Pub\+Key\+Man $\ast$spkm) override
\item 
std\+::set$<$ \textbf{ CExt\+Pub\+Key} $>$ \textbf{ Get\+Active\+HDPub\+Keys} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+wallet})
\begin{DoxyCompactList}\small\item\em Retrieve the xpubs in use by the active descriptors. \end{DoxyCompactList}\item 
std\+::optional$<$ \textbf{ CKey} $>$ \textbf{ Get\+Key} (const \textbf{ CKey\+ID} \&keyid) const
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Wallet\+Storage}}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+Wallet\+Storage} ()=default
\item 
virtual void \textbf{ Unset\+Blank\+Wallet\+Flag} (\textbf{ Wallet\+Batch} \&)=0
\item 
virtual bool \textbf{ With\+Encryption\+Key} (std\+::function$<$ bool(const \textbf{ CKeying\+Material} \&)$>$ cb) const =0
\begin{DoxyCompactList}\small\item\em Pass the encryption key to cb(). \end{DoxyCompactList}\item 
virtual void \textbf{ Top\+Up\+Callback} (const std\+::set$<$ \textbf{ CScript} $>$ \&, \textbf{ Script\+Pub\+Key\+Man} $\ast$)=0
\begin{DoxyCompactList}\small\item\em Callback function for after Top\+Up completes containing any scripts that were added by a SPKMan. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Chain\+::\+Notifications}}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+Notifications} ()=default
\item 
virtual void \textbf{ chain\+State\+Flushed} (const \textbf{ kernel\+::\+Chainstate\+Role} \&role, const \textbf{ CBlock\+Locator} \&locator)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::shared\+\_\+ptr$<$ \textbf{ CWallet} $>$ \textbf{ Create} (\textbf{ Wallet\+Context} \&context, const std\+::string \&\textbf{ name}, std\+::unique\+\_\+ptr$<$ Wallet\+Database $>$ database, uint64\+\_\+t wallet\+\_\+creation\+\_\+flags, \textbf{ bilingual\+\_\+str} \&error, std\+::vector$<$ \textbf{ bilingual\+\_\+str} $>$ \&warnings)
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\textbf{ Recursive\+Mutex} \textbf{ cs\+\_\+wallet}
\item 
\textbf{ Master\+Key\+Map} \textbf{ map\+Master\+Keys}
\item 
unsigned int \textbf{ n\+Master\+Key\+Max\+ID} = 0
\item 
\textbf{ Tx\+Items} \textbf{ wtx\+Ordered}
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ interfaces\+::\+Handler} $>$ \textbf{ m\+\_\+chain\+\_\+notifications\+\_\+handler}
\item 
\textbf{ Mutex} \textbf{ m\+\_\+unlock\+\_\+mutex}
\item 
\textbf{ Recursive\+Mutex} \textbf{ m\+\_\+relock\+\_\+mutex}
\item 
\textbf{ CFee\+Rate} \textbf{ m\+\_\+pay\+\_\+tx\+\_\+fee} \{\textbf{ DEFAULT\+\_\+\+PAY\+\_\+\+TX\+\_\+\+FEE}\}
\item 
unsigned int \textbf{ m\+\_\+confirm\+\_\+target} \{DEFAULT\+\_\+\+TX\+\_\+\+CONFIRM\+\_\+\+TARGET\}
\item 
bool \textbf{ m\+\_\+spend\+\_\+zero\+\_\+conf\+\_\+change} \{DEFAULT\+\_\+\+SPEND\+\_\+\+ZEROCONF\+\_\+\+CHANGE\}
\item 
bool \textbf{ m\+\_\+signal\+\_\+rbf} \{DEFAULT\+\_\+\+WALLET\+\_\+\+RBF\}
\item 
bool \textbf{ m\+\_\+allow\+\_\+fallback\+\_\+fee} \{true\}
\begin{DoxyCompactList}\small\item\em will be false if -\/fallbackfee=0 \end{DoxyCompactList}\item 
\textbf{ CFee\+Rate} \textbf{ m\+\_\+min\+\_\+fee} \{DEFAULT\+\_\+\+TRANSACTION\+\_\+\+MINFEE\}
\begin{DoxyCompactList}\small\item\em Override with -\/mintxfee. \end{DoxyCompactList}\item 
\textbf{ CFee\+Rate} \textbf{ m\+\_\+fallback\+\_\+fee} \{DEFAULT\+\_\+\+FALLBACK\+\_\+\+FEE\}
\item 
\textbf{ CFee\+Rate} \textbf{ m\+\_\+discard\+\_\+rate} \{DEFAULT\+\_\+\+DISCARD\+\_\+\+FEE\}
\item 
\textbf{ CFee\+Rate} \textbf{ m\+\_\+consolidate\+\_\+feerate} \{DEFAULT\+\_\+\+CONSOLIDATE\+\_\+\+FEERATE\}
\item 
\textbf{ CAmount} \textbf{ m\+\_\+max\+\_\+aps\+\_\+fee} \{DEFAULT\+\_\+\+MAX\+\_\+\+AVOIDPARTIALSPEND\+\_\+\+FEE\}
\begin{DoxyCompactList}\small\item\em note\+: this is absolute fee, not fee rate \end{DoxyCompactList}\item 
\textbf{ Output\+Type} \textbf{ m\+\_\+default\+\_\+address\+\_\+type} \{DEFAULT\+\_\+\+ADDRESS\+\_\+\+TYPE\}
\item 
std\+::optional$<$ \textbf{ Output\+Type} $>$ \textbf{ m\+\_\+default\+\_\+change\+\_\+type} \{\}
\item 
\textbf{ CAmount} \textbf{ m\+\_\+default\+\_\+max\+\_\+tx\+\_\+fee} \{DEFAULT\+\_\+\+TRANSACTION\+\_\+\+MAXFEE\}
\item 
int64\+\_\+t \textbf{ m\+\_\+keypool\+\_\+size} \{DEFAULT\+\_\+\+KEYPOOL\+\_\+\+SIZE\}
\item 
std\+::string \textbf{ m\+\_\+notify\+\_\+tx\+\_\+changed\+\_\+script}
\item 
boost\+::signals2\+::signal$<$ void()$>$ \textbf{ Notify\+Unload}
\item 
boost\+::signals2\+::signal$<$ void(const \textbf{ CTx\+Destination} \&address, const std\+::string \&label, bool is\+Mine, Address\+Purpose purpose, \textbf{ Change\+Type} status)$>$ \textbf{ Notify\+Address\+Book\+Changed}
\item 
boost\+::signals2\+::signal$<$ void(const \textbf{ Txid} \&hash\+Tx, \textbf{ Change\+Type} status)$>$ \textbf{ Notify\+Transaction\+Changed}
\item 
boost\+::signals2\+::signal$<$ void(const std\+::string \&title, int n\+Progress)$>$ \textbf{ Show\+Progress}
\item 
boost\+::signals2\+::signal$<$ void()$>$ \textbf{ Notify\+Can\+Get\+Addresses\+Changed}
\item 
boost\+::signals2\+::signal$<$ void(\textbf{ CWallet} $\ast$\textbf{ wallet})$>$ \textbf{ Notify\+Status\+Changed}
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Wallet\+Rescan\+Reserver}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A \doxyref{CWallet}{p.}{class_c_wallet} maintains a set of transactions and balances, and provides the ability to create new transactions. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{CWallet@{CWallet}!ListAddrBookFunc@{ListAddrBookFunc}}
\index{ListAddrBookFunc@{ListAddrBookFunc}!CWallet@{CWallet}}
\doxysubsubsection{ListAddrBookFunc}
{\footnotesize\ttfamily \label{class_c_wallet_ab088099303fdfded45713af2db4037fb} 
using \textbf{ List\+Addr\+Book\+Func} = std\+::function$<$void(const \textbf{ CTx\+Destination}\& dest, const std\+::string\& label, bool is\+\_\+change, const std\+::optional$<$Address\+Purpose$>$ purpose)$>$}

Walk-\/through the address book entries. Stops when the provided \textquotesingle{}\doxyref{List\+Addr\+Book\+Func}{p.}{class_c_wallet_ab088099303fdfded45713af2db4037fb}\textquotesingle{} returns false. \index{CWallet@{CWallet}!MasterKeyMap@{MasterKeyMap}}
\index{MasterKeyMap@{MasterKeyMap}!CWallet@{CWallet}}
\doxysubsubsection{MasterKeyMap}
{\footnotesize\ttfamily \label{class_c_wallet_a17d1aa687d03beac4506d2678e200373} 
typedef std\+::map$<$unsigned int, CMaster\+Key$>$ \textbf{ Master\+Key\+Map}}

\index{CWallet@{CWallet}!TxItems@{TxItems}}
\index{TxItems@{TxItems}!CWallet@{CWallet}}
\doxysubsubsection{TxItems}
{\footnotesize\ttfamily \label{class_c_wallet_a6c93c8d57d5b988a63b93fa6cd488d8c} 
typedef std\+::multimap$<$int64\+\_\+t, \textbf{ CWallet\+Tx}$\ast$$>$ \textbf{ Tx\+Items}}

\index{CWallet@{CWallet}!UpdateWalletTxFn@{UpdateWalletTxFn}}
\index{UpdateWalletTxFn@{UpdateWalletTxFn}!CWallet@{CWallet}}
\doxysubsubsection{UpdateWalletTxFn}
{\footnotesize\ttfamily \label{class_c_wallet_a160850c1e7624d67567718775aaf3d73} 
using \textbf{ Update\+Wallet\+Tx\+Fn} = std\+::function$<$bool(\textbf{ CWallet\+Tx}\& wtx, bool new\+\_\+tx)$>$}

Callback for updating transaction metadata in map\+Wallet.


\begin{DoxyParams}{Parameters}
{\em wtx} & -\/ reference to map\+Wallet transaction to update \\
\hline
{\em new\+\_\+tx} & -\/ true if wtx is newly inserted, false if it previously existed\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if wtx is changed and needs to be saved to disk, otherwise false 
\end{DoxyReturn}


\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CWallet@{CWallet}!CWallet@{CWallet}}
\index{CWallet@{CWallet}!CWallet@{CWallet}}
\doxysubsubsection{CWallet()}
{\footnotesize\ttfamily \label{class_c_wallet_af0de5ee53ff10ea7bc58cd8cf502fa73} 
\textbf{ CWallet} (\begin{DoxyParamCaption}\item[{\textbf{ interfaces\+::\+Chain} $\ast$}]{chain}{, }\item[{const std\+::string \&}]{name}{, }\item[{std\+::unique\+\_\+ptr$<$ Wallet\+Database $>$}]{database}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Construct wallet with specified name and database implementation. \index{CWallet@{CWallet}!````~CWallet@{$\sim$CWallet}}
\index{````~CWallet@{$\sim$CWallet}!CWallet@{CWallet}}
\doxysubsubsection{$\sim$CWallet()}
{\footnotesize\ttfamily \label{class_c_wallet_a3bcbda7cf97b5eac4dec2ccae289be33} 
$\sim$\textbf{ CWallet} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CWallet@{CWallet}!AbortRescan@{AbortRescan}}
\index{AbortRescan@{AbortRescan}!CWallet@{CWallet}}
\doxysubsubsection{AbortRescan()}
{\footnotesize\ttfamily \label{class_c_wallet_ad1048bc3f0c085adf74882f26002ca39} 
void Abort\+Rescan (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!AddActiveScriptPubKeyMan@{AddActiveScriptPubKeyMan}}
\index{AddActiveScriptPubKeyMan@{AddActiveScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{AddActiveScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_a12d4a4a3bf39aebea046b8eb4e472483} 
void Add\+Active\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{\textbf{ uint256}}]{id}{, }\item[{\textbf{ Output\+Type}}]{type}{, }\item[{bool}]{internal}{}\end{DoxyParamCaption})}

Adds the active Script\+Pub\+Key\+Man for the specified type and internal. Writes it to the wallet file 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em id} & The unique id for the Script\+Pub\+Key\+Man \\
\hline
\mbox{\texttt{in}}  & {\em type} & The \doxyref{Output\+Type}{p.}{outputtype_8h_a4e0517338e6c4a31a2addafc06d4f3a3} this Script\+Pub\+Key\+Man provides addresses for \\
\hline
\mbox{\texttt{in}}  & {\em internal} & Whether this Script\+Pub\+Key\+Man provides change addresses \\
\hline
\end{DoxyParams}
\index{CWallet@{CWallet}!AddWalletDescriptor@{AddWalletDescriptor}}
\index{AddWalletDescriptor@{AddWalletDescriptor}!CWallet@{CWallet}}
\doxysubsubsection{AddWalletDescriptor()}
{\footnotesize\ttfamily \label{class_c_wallet_a0ed89b6d35124fe56a4f13b1a9e54572} 
\textbf{ util\+::\+Result}$<$ std\+::reference\+\_\+wrapper$<$ Descriptor\+Script\+Pub\+Key\+Man $>$ $>$ Add\+Wallet\+Descriptor (\begin{DoxyParamCaption}\item[{\textbf{ Wallet\+Descriptor} \&}]{desc}{, }\item[{const \textbf{ Flat\+Signing\+Provider} \&}]{signing\+\_\+provider}{, }\item[{const std\+::string \&}]{label}{, }\item[{bool}]{internal}{}\end{DoxyParamCaption})}



Add a descriptor to the wallet, return a Script\+Pub\+Key\+Man \& associated output type. 

\index{CWallet@{CWallet}!ApplyMigrationData@{ApplyMigrationData}}
\index{ApplyMigrationData@{ApplyMigrationData}!CWallet@{CWallet}}
\doxysubsubsection{ApplyMigrationData()}
{\footnotesize\ttfamily \label{class_c_wallet_a2d6d0f8ff87def9d9d865a1521addee3} 
\textbf{ util\+::\+Result}$<$ void $>$ Apply\+Migration\+Data (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{local\+\_\+wallet\+\_\+batch}{, }\item[{Migration\+Data \&}]{data}{}\end{DoxyParamCaption})}

Adds the Script\+Pub\+Key\+Mans given in Migration\+Data to this wallet, removes Legacy\+Script\+Pub\+Key\+Man, and where needed, moves tx and address book entries to watchonly\+\_\+wallet or solvable\+\_\+wallet \index{CWallet@{CWallet}!BackupWallet@{BackupWallet}}
\index{BackupWallet@{BackupWallet}!CWallet@{CWallet}}
\doxysubsubsection{BackupWallet()}
{\footnotesize\ttfamily \label{class_c_wallet_aaedbff50a91c14aa1b2cac623b2b595c} 
bool Backup\+Wallet (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str\+Dest}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!CacheNewScriptPubKeys@{CacheNewScriptPubKeys}}
\index{CacheNewScriptPubKeys@{CacheNewScriptPubKeys}!CWallet@{CWallet}}
\doxysubsubsection{CacheNewScriptPubKeys()}
{\footnotesize\ttfamily \label{class_c_wallet_a66958068737b63d53a1b04b39e977cf0} 
void Cache\+New\+Script\+Pub\+Keys (\begin{DoxyParamCaption}\item[{const std\+::set$<$ \textbf{ CScript} $>$ \&}]{spks}{, }\item[{Script\+Pub\+Key\+Man $\ast$}]{spkm}{}\end{DoxyParamCaption})}



Add script\+Pub\+Keys for this Script\+Pub\+Key\+Man into the script\+Pub\+Key cache. 

\index{CWallet@{CWallet}!CanGrindR@{CanGrindR}}
\index{CanGrindR@{CanGrindR}!CWallet@{CWallet}}
\doxysubsubsection{CanGrindR()}
{\footnotesize\ttfamily \label{class_c_wallet_a01cf7e800191cb1c505002e3b2dee27b} 
bool Can\+GrindR (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Whether the (external) signer performs R-\/value signature grinding. 

\index{CWallet@{CWallet}!chain@{chain}}
\index{chain@{chain}!CWallet@{CWallet}}
\doxysubsubsection{chain()}
{\footnotesize\ttfamily \label{class_c_wallet_a1f5907b528877be5bb376b6e2adae077} 
\textbf{ interfaces\+::\+Chain} \& chain (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Interface for accessing chain state. \index{CWallet@{CWallet}!CommitTransaction@{CommitTransaction}}
\index{CommitTransaction@{CommitTransaction}!CWallet@{CWallet}}
\doxysubsubsection{CommitTransaction()}
{\footnotesize\ttfamily \label{class_c_wallet_ad87a31315d1db7981bcb870972c23e38} 
void Commit\+Transaction (\begin{DoxyParamCaption}\item[{\textbf{ CTransaction\+Ref}}]{tx}{, }\item[{map\+Value\+\_\+t}]{map\+Value}{, }\item[{std\+::vector$<$ std\+::pair$<$ std\+::string, std\+::string $>$ $>$}]{order\+Form}{}\end{DoxyParamCaption})}

Submit the transaction to the node\textquotesingle{}s mempool and then relay to peers. Should be called after Create\+Transaction unless you want to abort broadcasting the transaction.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em tx} & The transaction to be broadcast. \\
\hline
\mbox{\texttt{in}}  & {\em map\+Value} & key-\/values to be set on the transaction. \\
\hline
\mbox{\texttt{in}}  & {\em order\+Form} & BIP 70 / BIP 21 order form details to be set on the transaction. \\
\hline
\end{DoxyParams}
\index{CWallet@{CWallet}!ComputeTimeSmart@{ComputeTimeSmart}}
\index{ComputeTimeSmart@{ComputeTimeSmart}!CWallet@{CWallet}}
\doxysubsubsection{ComputeTimeSmart()}
{\footnotesize\ttfamily \label{class_c_wallet_a9d8e66b7e1b10865f03af5a1f8331e3f} 
unsigned int Compute\+Time\+Smart (\begin{DoxyParamCaption}\item[{const \textbf{ CWallet\+Tx} \&}]{wtx}{, }\item[{bool}]{rescanning\+\_\+old\+\_\+block}{}\end{DoxyParamCaption}) const}

Compute smart timestamp for a transaction being added to the wallet.

Logic\+:
\begin{DoxyItemize}
\item If sending a transaction, assign its timestamp to the current time.
\item If receiving a transaction outside a block, assign its timestamp to the current time.
\item If receiving a transaction during a rescanning process, assign all its (not already known) transactions\textquotesingle{} timestamps to the block time.
\item If receiving a block with a future timestamp, assign all its (not already known) transactions\textquotesingle{} timestamps to the current time.
\item If receiving a block with a past timestamp, before the most recent known transaction (that we care about), assign all its (not already known) transactions\textquotesingle{} timestamps to the same timestamp as that most-\/recent-\/known transaction.
\item If receiving a block with a past timestamp, but after the most recent known transaction, assign all its (not already known) transactions\textquotesingle{} timestamps to the block time.
\end{DoxyItemize}

For more information see \doxyref{CWallet\+Tx\+::n\+Time\+Smart}{p.}{class_c_wallet_tx_a4c49d370af578b863cfd5923ecbb3345}, {\texttt{https\+://bitcointalk.\+org/?topic=54527}}, or {\texttt{https\+://github.\+com/bitcoin/bitcoin/pull/1393}}. \index{CWallet@{CWallet}!ConnectScriptPubKeyManNotifiers@{ConnectScriptPubKeyManNotifiers}}
\index{ConnectScriptPubKeyManNotifiers@{ConnectScriptPubKeyManNotifiers}!CWallet@{CWallet}}
\doxysubsubsection{ConnectScriptPubKeyManNotifiers()}
{\footnotesize\ttfamily \label{class_c_wallet_a7edf7eb82d09981313df1ebacc1aa97c} 
void Connect\+Script\+Pub\+Key\+Man\+Notifiers (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Connect the signals from Script\+Pub\+Key\+Mans to the signals in \doxyref{CWallet}{p.}{class_c_wallet}. 

\index{CWallet@{CWallet}!Create@{Create}}
\index{Create@{Create}!CWallet@{CWallet}}
\doxysubsubsection{Create()}
{\footnotesize\ttfamily \label{class_c_wallet_a783d8ef1bf2a4beb80bc122a8efbd2fd} 
std\+::shared\+\_\+ptr$<$ \textbf{ CWallet} $>$ Create (\begin{DoxyParamCaption}\item[{\textbf{ Wallet\+Context} \&}]{context}{, }\item[{const std\+::string \&}]{name}{, }\item[{std\+::unique\+\_\+ptr$<$ Wallet\+Database $>$}]{database}{, }\item[{uint64\+\_\+t}]{wallet\+\_\+creation\+\_\+flags}{, }\item[{\textbf{ bilingual\+\_\+str} \&}]{error}{, }\item[{std\+::vector$<$ \textbf{ bilingual\+\_\+str} $>$ \&}]{warnings}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\index{CWallet@{CWallet}!DeactivateScriptPubKeyMan@{DeactivateScriptPubKeyMan}}
\index{DeactivateScriptPubKeyMan@{DeactivateScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{DeactivateScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_a239841167b9f50d3b077c6f22e406cdc} 
void Deactivate\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{\textbf{ uint256}}]{id}{, }\item[{\textbf{ Output\+Type}}]{type}{, }\item[{bool}]{internal}{}\end{DoxyParamCaption})}

Remove specified Script\+Pub\+Key\+Man from set of active SPK managers. Writes the change to the wallet file. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em id} & The unique id for the Script\+Pub\+Key\+Man \\
\hline
\mbox{\texttt{in}}  & {\em type} & The \doxyref{Output\+Type}{p.}{outputtype_8h_a4e0517338e6c4a31a2addafc06d4f3a3} this Script\+Pub\+Key\+Man provides addresses for \\
\hline
\mbox{\texttt{in}}  & {\em internal} & Whether this Script\+Pub\+Key\+Man provides change addresses \\
\hline
\end{DoxyParams}
\index{CWallet@{CWallet}!DelAddressBook@{DelAddressBook}}
\index{DelAddressBook@{DelAddressBook}!CWallet@{CWallet}}
\doxysubsubsection{DelAddressBook()}
{\footnotesize\ttfamily \label{class_c_wallet_abe8e90b07a5005d8e6442e4d9efed07f} 
bool Del\+Address\+Book (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{address}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!DelAddressBookWithDB@{DelAddressBookWithDB}}
\index{DelAddressBookWithDB@{DelAddressBookWithDB}!CWallet@{CWallet}}
\doxysubsubsection{DelAddressBookWithDB()}
{\footnotesize\ttfamily \label{class_c_wallet_a960238cac6cb20f4e82363f94626460c} 
bool Del\+Address\+Book\+With\+DB (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{const \textbf{ CTx\+Destination} \&}]{address}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!DisplayAddress@{DisplayAddress}}
\index{DisplayAddress@{DisplayAddress}!CWallet@{CWallet}}
\doxysubsubsection{DisplayAddress()}
{\footnotesize\ttfamily \label{class_c_wallet_ac32dff38082df7387ddf533070216724} 
\textbf{ util\+::\+Result}$<$ void $>$ Display\+Address (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{dest}{}\end{DoxyParamCaption})}

Display address on an external signer. \index{CWallet@{CWallet}!DisplayName@{DisplayName}}
\index{DisplayName@{DisplayName}!CWallet@{CWallet}}
\doxysubsubsection{DisplayName()}
{\footnotesize\ttfamily \label{class_c_wallet_a8e1c7ae181bae4bffd8930dc2ba01102} 
std\+::string Display\+Name (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return wallet name for display, like \doxyref{Log\+Name()}{p.}{class_c_wallet_aa385db590bc0eed2616a0ea9db5ab946} but translates "{}default wallet"{} string. \index{CWallet@{CWallet}!EraseAddressReceiveRequest@{EraseAddressReceiveRequest}}
\index{EraseAddressReceiveRequest@{EraseAddressReceiveRequest}!CWallet@{CWallet}}
\doxysubsubsection{EraseAddressReceiveRequest()}
{\footnotesize\ttfamily \label{class_c_wallet_a9c60d1e4a2d273157ce8b9fec0e885ad} 
bool Erase\+Address\+Receive\+Request (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{const \textbf{ CTx\+Destination} \&}]{dest}{, }\item[{const std\+::string \&}]{id}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!FillPSBT@{FillPSBT}}
\index{FillPSBT@{FillPSBT}!CWallet@{CWallet}}
\doxysubsubsection{FillPSBT()}
{\footnotesize\ttfamily \label{class_c_wallet_a734069327310f3524ccfa901ccb61a09} 
std\+::optional$<$ \textbf{ PSBTError} $>$ Fill\+PSBT (\begin{DoxyParamCaption}\item[{\textbf{ Partially\+Signed\+Transaction} \&}]{psbtx}{, }\item[{bool \&}]{complete}{, }\item[{std\+::optional$<$ int $>$}]{sighash\+\_\+type}{ = {\ttfamily std\+:\+:nullopt}, }\item[{bool}]{sign}{ = {\ttfamily true}, }\item[{bool}]{bip32derivs}{ = {\ttfamily true}, }\item[{size\+\_\+t $\ast$}]{n\+\_\+signed}{ = {\ttfamily nullptr}, }\item[{bool}]{finalize}{ = {\ttfamily true}}\end{DoxyParamCaption}) const}

Fills out a PSBT with information from the wallet. Fills in UTXOs if we have them. Tries to sign if sign=true. Sets {\ttfamily complete} if the PSBT is now complete (i.\+e. has all required signatures or signature-\/parts, and is ready to finalize.) Sets {\ttfamily error} and returns false if something goes wrong.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em psbtx} & \doxyref{Partially\+Signed\+Transaction}{p.}{struct_partially_signed_transaction} to fill in \\
\hline
\mbox{\texttt{out}}  & {\em complete} & indicates whether the PSBT is now complete \\
\hline
\mbox{\texttt{in}}  & {\em sighash\+\_\+type} & the sighash type to use when signing (if PSBT does not specify) \\
\hline
\mbox{\texttt{in}}  & {\em sign} & whether to sign or not \\
\hline
\mbox{\texttt{in}}  & {\em bip32derivs} & whether to fill in bip32 derivation information if available \\
\hline
\mbox{\texttt{out}}  & {\em n\+\_\+signed} & the number of inputs signed by this wallet \\
\hline
\mbox{\texttt{in}}  & {\em finalize} & whether to create the final script\+Sig or script\+Witness if possible return error \\
\hline
\end{DoxyParams}
\index{CWallet@{CWallet}!FindAddressBookEntry@{FindAddressBookEntry}}
\index{FindAddressBookEntry@{FindAddressBookEntry}!CWallet@{CWallet}}
\doxysubsubsection{FindAddressBookEntry()}
{\footnotesize\ttfamily \label{class_c_wallet_ad4493951e4a5fe4e76787823a34761c8} 
const CAddress\+Book\+Data $\ast$ Find\+Address\+Book\+Entry (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{dest}{, }\item[{bool}]{allow\+\_\+change}{ = {\ttfamily false}}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!ForEachAddrBookEntry@{ForEachAddrBookEntry}}
\index{ForEachAddrBookEntry@{ForEachAddrBookEntry}!CWallet@{CWallet}}
\doxysubsubsection{ForEachAddrBookEntry()}
{\footnotesize\ttfamily \label{class_c_wallet_a2dd078d68c8ef75b1217f6769befdc01} 
void For\+Each\+Addr\+Book\+Entry (\begin{DoxyParamCaption}\item[{const \textbf{ List\+Addr\+Book\+Func} \&}]{func}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!GetActiveHDPubKeys@{GetActiveHDPubKeys}}
\index{GetActiveHDPubKeys@{GetActiveHDPubKeys}!CWallet@{CWallet}}
\doxysubsubsection{GetActiveHDPubKeys()}
{\footnotesize\ttfamily \label{class_c_wallet_aca33fd72edba2a2ee56c6c2737dc983d} 
std\+::set$<$ \textbf{ CExt\+Pub\+Key} $>$ Get\+Active\+HDPub\+Keys (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Retrieve the xpubs in use by the active descriptors. 

\index{CWallet@{CWallet}!GetActiveScriptPubKeyMans@{GetActiveScriptPubKeyMans}}
\index{GetActiveScriptPubKeyMans@{GetActiveScriptPubKeyMans}!CWallet@{CWallet}}
\doxysubsubsection{GetActiveScriptPubKeyMans()}
{\footnotesize\ttfamily \label{class_c_wallet_a24bb40b37a08f7fee61f4847012bd67e} 
std\+::set$<$ Script\+Pub\+Key\+Man $\ast$ $>$ Get\+Active\+Script\+Pub\+Key\+Mans (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Returns all unique Script\+Pub\+Key\+Mans in m\+\_\+internal\+\_\+spk\+\_\+managers and m\+\_\+external\+\_\+spk\+\_\+managers. 

\index{CWallet@{CWallet}!GetAddressReceiveRequests@{GetAddressReceiveRequests}}
\index{GetAddressReceiveRequests@{GetAddressReceiveRequests}!CWallet@{CWallet}}
\doxysubsubsection{GetAddressReceiveRequests()}
{\footnotesize\ttfamily \label{class_c_wallet_af568eeef5cde2bd4d4ae7b31c3921411} 
std\+::vector$<$ std\+::string $>$ Get\+Address\+Receive\+Requests (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!GetAllScriptPubKeyMans@{GetAllScriptPubKeyMans}}
\index{GetAllScriptPubKeyMans@{GetAllScriptPubKeyMans}!CWallet@{CWallet}}
\doxysubsubsection{GetAllScriptPubKeyMans()}
{\footnotesize\ttfamily \label{class_c_wallet_ae978e6134f8e5704070f47d086a59d1b} 
std\+::set$<$ Script\+Pub\+Key\+Man $\ast$ $>$ Get\+All\+Script\+Pub\+Key\+Mans (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Returns all unique Script\+Pub\+Key\+Mans. 

\index{CWallet@{CWallet}!GetBirthTime@{GetBirthTime}}
\index{GetBirthTime@{GetBirthTime}!CWallet@{CWallet}}
\doxysubsubsection{GetBirthTime()}
{\footnotesize\ttfamily \label{class_c_wallet_adcfe82b14de8f2298ab229f2bbcc7476} 
int64\+\_\+t Get\+Birth\+Time (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!GetBroadcastTransactions@{GetBroadcastTransactions}}
\index{GetBroadcastTransactions@{GetBroadcastTransactions}!CWallet@{CWallet}}
\doxysubsubsection{GetBroadcastTransactions()}
{\footnotesize\ttfamily \label{class_c_wallet_ae7a35eb343e0820b87b68b102864f49a} 
bool Get\+Broadcast\+Transactions (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Inquire whether this wallet broadcasts transactions. \index{CWallet@{CWallet}!GetDatabase@{GetDatabase}}
\index{GetDatabase@{GetDatabase}!CWallet@{CWallet}}
\doxysubsubsection{GetDatabase()}
{\footnotesize\ttfamily \label{class_c_wallet_ab8988e53bad24fcbf1b8ddb4aece5ea0} 
Wallet\+Database \& Get\+Database (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \textbf{ Wallet\+Storage} \doxyref{}{p.}{classwallet_1_1_wallet_storage_a3d655ffff7290e1454b42041b73595f2}.

\index{CWallet@{CWallet}!GetDescriptorScriptPubKeyMan@{GetDescriptorScriptPubKeyMan}}
\index{GetDescriptorScriptPubKeyMan@{GetDescriptorScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{GetDescriptorScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_a9cb954f08618ec323f938bdf77ad9e8a} 
Descriptor\+Script\+Pub\+Key\+Man $\ast$ Get\+Descriptor\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{const \textbf{ Wallet\+Descriptor} \&}]{desc}{}\end{DoxyParamCaption}) const}



Return the Descriptor\+Script\+Pub\+Key\+Man for a \doxyref{Wallet\+Descriptor}{p.}{class_wallet_descriptor} if it is already in the wallet. 

\index{CWallet@{CWallet}!GetDescriptorsForLegacy@{GetDescriptorsForLegacy}}
\index{GetDescriptorsForLegacy@{GetDescriptorsForLegacy}!CWallet@{CWallet}}
\doxysubsubsection{GetDescriptorsForLegacy()}
{\footnotesize\ttfamily \label{class_c_wallet_a2a7131e25ec9d466bc321ca08724fc8e} 
std\+::optional$<$ Migration\+Data $>$ Get\+Descriptors\+For\+Legacy (\begin{DoxyParamCaption}\item[{\textbf{ bilingual\+\_\+str} \&}]{error}{}\end{DoxyParamCaption}) const}



Get all of the descriptors from a legacy wallet. 

\index{CWallet@{CWallet}!GetKey@{GetKey}}
\index{GetKey@{GetKey}!CWallet@{CWallet}}
\doxysubsubsection{GetKey()}
{\footnotesize\ttfamily \label{class_c_wallet_a81f0bce5008b530f1a257c6a0e529f09} 
std\+::optional$<$ \textbf{ CKey} $>$ Get\+Key (\begin{DoxyParamCaption}\item[{const \textbf{ CKey\+ID} \&}]{keyid}{}\end{DoxyParamCaption}) const}

Find the private key for the given key id from the wallet\textquotesingle{}s descriptors, if available Returns nullopt when no descriptor has the key or if the wallet is locked. \index{CWallet@{CWallet}!GetKeyPoolSize@{GetKeyPoolSize}}
\index{GetKeyPoolSize@{GetKeyPoolSize}!CWallet@{CWallet}}
\doxysubsubsection{GetKeyPoolSize()}
{\footnotesize\ttfamily \label{class_c_wallet_ad544f8dfa6d0fe049b2edb3799d658aa} 
unsigned int Get\+Key\+Pool\+Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!GetLastBlockHash@{GetLastBlockHash}}
\index{GetLastBlockHash@{GetLastBlockHash}!CWallet@{CWallet}}
\doxysubsubsection{GetLastBlockHash()}
{\footnotesize\ttfamily \label{class_c_wallet_ae4aae02d86f37feb601da45b8a73c8b1} 
\textbf{ uint256} Get\+Last\+Block\+Hash (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!GetLastBlockHeight@{GetLastBlockHeight}}
\index{GetLastBlockHeight@{GetLastBlockHeight}!CWallet@{CWallet}}
\doxysubsubsection{GetLastBlockHeight()}
{\footnotesize\ttfamily \label{class_c_wallet_a7c5f36c554e29922d6b11a57d49323d1} 
int Get\+Last\+Block\+Height (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get last block processed height \index{CWallet@{CWallet}!GetLegacyDataSPKM@{GetLegacyDataSPKM}}
\index{GetLegacyDataSPKM@{GetLegacyDataSPKM}!CWallet@{CWallet}}
\doxysubsubsection{GetLegacyDataSPKM()}
{\footnotesize\ttfamily \label{class_c_wallet_acb89a9268d90671cb9403a77695cbda1} 
Legacy\+Data\+SPKM $\ast$ Get\+Legacy\+Data\+SPKM (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Get the Legacy\+Script\+Pub\+Key\+Man which is used for all types, internal, and external. 

\index{CWallet@{CWallet}!GetName@{GetName}}
\index{GetName@{GetName}!CWallet@{CWallet}}
\doxysubsubsection{GetName()}
{\footnotesize\ttfamily \label{class_c_wallet_a55466a39638bb671b24a82941aa37d77} 
const std\+::string \& Get\+Name (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get a name for this wallet for logging/debugging purposes. \index{CWallet@{CWallet}!GetNewChangeDestination@{GetNewChangeDestination}}
\index{GetNewChangeDestination@{GetNewChangeDestination}!CWallet@{CWallet}}
\doxysubsubsection{GetNewChangeDestination()}
{\footnotesize\ttfamily \label{class_c_wallet_a66a2b349adf99ad61abe03e503ba3a5a} 
\textbf{ util\+::\+Result}$<$ \textbf{ CTx\+Destination} $>$ Get\+New\+Change\+Destination (\begin{DoxyParamCaption}\item[{const \textbf{ Output\+Type}}]{type}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!GetNewDestination@{GetNewDestination}}
\index{GetNewDestination@{GetNewDestination}!CWallet@{CWallet}}
\doxysubsubsection{GetNewDestination()}
{\footnotesize\ttfamily \label{class_c_wallet_adfd7d630b6063248704b10cfae2e6825} 
\textbf{ util\+::\+Result}$<$ \textbf{ CTx\+Destination} $>$ Get\+New\+Destination (\begin{DoxyParamCaption}\item[{const \textbf{ Output\+Type}}]{type}{, }\item[{const std\+::string}]{label}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!GetOrCreateLegacyDataSPKM@{GetOrCreateLegacyDataSPKM}}
\index{GetOrCreateLegacyDataSPKM@{GetOrCreateLegacyDataSPKM}!CWallet@{CWallet}}
\doxysubsubsection{GetOrCreateLegacyDataSPKM()}
{\footnotesize\ttfamily \label{class_c_wallet_a2ace9aaf5f5886833d8cc346ddd3f027} 
Legacy\+Data\+SPKM $\ast$ Get\+Or\+Create\+Legacy\+Data\+SPKM (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!GetScriptPubKeyMan@{GetScriptPubKeyMan}}
\index{GetScriptPubKeyMan@{GetScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{GetScriptPubKeyMan()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_af39c08c39c6c3267a2b397151ebf9b77} 
Script\+Pub\+Key\+Man $\ast$ Get\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{const \textbf{ Output\+Type} \&}]{type}{, }\item[{bool}]{internal}{}\end{DoxyParamCaption}) const}



Get the Script\+Pub\+Key\+Man for the given \doxyref{Output\+Type}{p.}{outputtype_8h_a4e0517338e6c4a31a2addafc06d4f3a3} and internal/external chain. 

\index{CWallet@{CWallet}!GetScriptPubKeyMan@{GetScriptPubKeyMan}}
\index{GetScriptPubKeyMan@{GetScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{GetScriptPubKeyMan()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_a84afa1fa32ff87d260c0dfbbef12d145} 
Script\+Pub\+Key\+Man $\ast$ Get\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{id}{}\end{DoxyParamCaption}) const}



Get the Script\+Pub\+Key\+Man by id. 

\index{CWallet@{CWallet}!GetScriptPubKeyMans@{GetScriptPubKeyMans}}
\index{GetScriptPubKeyMans@{GetScriptPubKeyMans}!CWallet@{CWallet}}
\doxysubsubsection{GetScriptPubKeyMans()}
{\footnotesize\ttfamily \label{class_c_wallet_a0446c2b5da7f63cfe0570d0132f87193} 
std\+::set$<$ Script\+Pub\+Key\+Man $\ast$ $>$ Get\+Script\+Pub\+Key\+Mans (\begin{DoxyParamCaption}\item[{const \textbf{ CScript} \&}]{script}{}\end{DoxyParamCaption}) const}



Get all the Script\+Pub\+Key\+Mans for a script. 

\index{CWallet@{CWallet}!GetSolvingProvider@{GetSolvingProvider}}
\index{GetSolvingProvider@{GetSolvingProvider}!CWallet@{CWallet}}
\doxysubsubsection{GetSolvingProvider()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_aacc3abbc4afa39016beb6cb8690887b1} 
std\+::unique\+\_\+ptr$<$ \textbf{ Signing\+Provider} $>$ Get\+Solving\+Provider (\begin{DoxyParamCaption}\item[{const \textbf{ CScript} \&}]{script}{}\end{DoxyParamCaption}) const}



Get the \doxyref{Signing\+Provider}{p.}{class_signing_provider} for a script. 

\index{CWallet@{CWallet}!GetSolvingProvider@{GetSolvingProvider}}
\index{GetSolvingProvider@{GetSolvingProvider}!CWallet@{CWallet}}
\doxysubsubsection{GetSolvingProvider()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_a3f7a5206ec854438647566b799b75bb4} 
std\+::unique\+\_\+ptr$<$ \textbf{ Signing\+Provider} $>$ Get\+Solving\+Provider (\begin{DoxyParamCaption}\item[{const \textbf{ CScript} \&}]{script}{, }\item[{\textbf{ Signature\+Data} \&}]{sigdata}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!GetTxBlocksToMaturity@{GetTxBlocksToMaturity}}
\index{GetTxBlocksToMaturity@{GetTxBlocksToMaturity}!CWallet@{CWallet}}
\doxysubsubsection{GetTxBlocksToMaturity()}
{\footnotesize\ttfamily \label{class_c_wallet_ac69675080c605001a50f08888882eded} 
int Get\+Tx\+Blocks\+To\+Maturity (\begin{DoxyParamCaption}\item[{const \textbf{ CWallet\+Tx} \&}]{wtx}{}\end{DoxyParamCaption}) const}

\begin{DoxyReturn}{Returns}
number of blocks to maturity for this transaction\+: 0 \+: is not a coinbase transaction, or is a mature coinbase transaction $>$0 \+: is a coinbase transaction which matures in this many blocks 
\end{DoxyReturn}
\index{CWallet@{CWallet}!GetTxDepthInMainChain@{GetTxDepthInMainChain}}
\index{GetTxDepthInMainChain@{GetTxDepthInMainChain}!CWallet@{CWallet}}
\doxysubsubsection{GetTxDepthInMainChain()}
{\footnotesize\ttfamily \label{class_c_wallet_a01c6bf8ec9f4e1d3ec3e634035128922} 
int Get\+Tx\+Depth\+In\+Main\+Chain (\begin{DoxyParamCaption}\item[{const \textbf{ CWallet\+Tx} \&}]{wtx}{}\end{DoxyParamCaption}) const}

Return depth of transaction in blockchain\+: $<$0 \+: conflicts with a transaction this deep in the blockchain 0 \+: in memory pool, waiting to be included in a block $>$=1 \+: this many blocks deep in the main chain

Preconditions\+: it is only valid to call this function when the wallet is online and the block index is loaded. So this cannot be called by bitcoin-\/wallet tool code or by wallet migration code. If this is called without the wallet being online, it won\textquotesingle{}t be able able to determine the the height of the last block processed, or the heights of blocks referenced in transaction, and might cause assert failures. \index{CWallet@{CWallet}!GetTXO@{GetTXO}}
\index{GetTXO@{GetTXO}!CWallet@{CWallet}}
\doxysubsubsection{GetTXO()}
{\footnotesize\ttfamily \label{class_c_wallet_af00aa17e58b06da8aebe1ab3aa878725} 
std\+::optional$<$ Wallet\+TXO $>$ Get\+TXO (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{outpoint}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!GetTXOs@{GetTXOs}}
\index{GetTXOs@{GetTXOs}!CWallet@{CWallet}}
\doxysubsubsection{GetTXOs()}
{\footnotesize\ttfamily \label{class_c_wallet_aac64bc8584daabfb5cd1053c8b5ac642} 
const std\+::unordered\+\_\+map$<$ \textbf{ COut\+Point}, Wallet\+TXO, \textbf{ Salted\+Outpoint\+Hasher} $>$ \& Get\+TXOs (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!GetWalletDescriptors@{GetWalletDescriptors}}
\index{GetWalletDescriptors@{GetWalletDescriptors}!CWallet@{CWallet}}
\doxysubsubsection{GetWalletDescriptors()}
{\footnotesize\ttfamily \label{class_c_wallet_a1f8c0f9c60ebe70148145d9539ecf6ee} 
std\+::vector$<$ \textbf{ Wallet\+Descriptor} $>$ Get\+Wallet\+Descriptors (\begin{DoxyParamCaption}\item[{const \textbf{ CScript} \&}]{script}{}\end{DoxyParamCaption}) const}



Get the wallet descriptors for a script. 

\index{CWallet@{CWallet}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CWallet@{CWallet}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily \label{class_c_wallet_a018b4f2201779d9749f474b918a68d4c} 
int64\+\_\+t n\+Relock\+Time GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+wallet}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Holds a timestamp at which point the wallet is scheduled (externally) to be relocked. Caller must arrange for actual relocking to occur via \doxyref{Lock()}{p.}{class_c_wallet_a747fd95916e116a6ed37cc641e394c69}. 

\index{CWallet@{CWallet}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CWallet@{CWallet}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily \label{class_c_wallet_a104d8a888b3df79b63580eefa1d67109} 
std\+::map$<$ \textbf{ COut\+Point}, bool $>$ m\+\_\+locked\+\_\+coins GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+wallet}}]{}{}\end{DoxyParamCaption})}

Set of Coins owned by this wallet that we won\textquotesingle{}t try to spend from. A \doxyref{Coin}{p.}{class_coin} may be locked if it has already been used to fund a transaction that hasn\textquotesingle{}t confirmed yet. We wouldn\textquotesingle{}t consider the \doxyref{Coin}{p.}{class_coin} spent already, but also shouldn\textquotesingle{}t try to use it again. bool to track whether this locked coin is persisted to disk. \index{CWallet@{CWallet}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CWallet@{CWallet}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily \label{class_c_wallet_a5cd58892264e970c05db83b99427d99d} 
std\+::map$<$ \textbf{ CTx\+Destination}, CAddress\+Book\+Data $>$ m\+\_\+address\+\_\+book GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+wallet}}]{}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CWallet@{CWallet}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily \label{class_c_wallet_a156ae35fdedf79b34a49faf9cc671c4c} 
std\+::unordered\+\_\+map$<$ \textbf{ Txid}, \textbf{ CWallet\+Tx}, \textbf{ Salted\+Txid\+Hasher} $>$ map\+Wallet GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+wallet}}]{}{}\end{DoxyParamCaption})}

Map from txid to \doxyref{CWallet\+Tx}{p.}{class_c_wallet_tx} for all transactions this wallet is interested in, including received and sent transactions. \index{CWallet@{CWallet}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CWallet@{CWallet}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily \label{class_c_wallet_a9bd71c72cfe6893b4fc7eecf0c3c7b79} 
int64\+\_\+t n\+Order\+Pos\+Next GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+wallet}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

\index{CWallet@{CWallet}!HasEncryptionKeys@{HasEncryptionKeys}}
\index{HasEncryptionKeys@{HasEncryptionKeys}!CWallet@{CWallet}}
\doxysubsubsection{HasEncryptionKeys()}
{\footnotesize\ttfamily \label{class_c_wallet_ac7ac1dc9170d774b4dfcf87bc0138e1b} 
bool Has\+Encryption\+Keys (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \textbf{ Wallet\+Storage} \doxyref{}{p.}{classwallet_1_1_wallet_storage_a2b13770749ea5b14609b668e9ad49003}.

\index{CWallet@{CWallet}!HaveChain@{HaveChain}}
\index{HaveChain@{HaveChain}!CWallet@{CWallet}}
\doxysubsubsection{HaveChain()}
{\footnotesize\ttfamily \label{class_c_wallet_ae613c369401f6513e32a069eee4023a3} 
bool Have\+Chain (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Interface to assert chain access \index{CWallet@{CWallet}!HaveCryptedKeys@{HaveCryptedKeys}}
\index{HaveCryptedKeys@{HaveCryptedKeys}!CWallet@{CWallet}}
\doxysubsubsection{HaveCryptedKeys()}
{\footnotesize\ttfamily \label{class_c_wallet_aa91eb20a55ac482526f10351db0c47fe} 
bool Have\+Crypted\+Keys (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!IsAbortingRescan@{IsAbortingRescan}}
\index{IsAbortingRescan@{IsAbortingRescan}!CWallet@{CWallet}}
\doxysubsubsection{IsAbortingRescan()}
{\footnotesize\ttfamily \label{class_c_wallet_ae24c5c694bc55ca31175b90fde59f5e2} 
bool Is\+Aborting\+Rescan (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!IsActiveScriptPubKeyMan@{IsActiveScriptPubKeyMan}}
\index{IsActiveScriptPubKeyMan@{IsActiveScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{IsActiveScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_ac47270ae850ee23706d699701f102d25} 
bool Is\+Active\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{const Script\+Pub\+Key\+Man \&}]{spkm}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!IsAddressPreviouslySpent@{IsAddressPreviouslySpent}}
\index{IsAddressPreviouslySpent@{IsAddressPreviouslySpent}!CWallet@{CWallet}}
\doxysubsubsection{IsAddressPreviouslySpent()}
{\footnotesize\ttfamily \label{class_c_wallet_a6bf473dec5c080d6418f1a80542be188} 
bool Is\+Address\+Previously\+Spent (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{dest}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!IsCrypted@{IsCrypted}}
\index{IsCrypted@{IsCrypted}!CWallet@{CWallet}}
\doxysubsubsection{IsCrypted()}
{\footnotesize\ttfamily \label{class_c_wallet_a052e358d44d29074784be6fb57a7d06f} 
bool Is\+Crypted (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!IsInternalScriptPubKeyMan@{IsInternalScriptPubKeyMan}}
\index{IsInternalScriptPubKeyMan@{IsInternalScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{IsInternalScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_a046bec6756ca55d8fb375f2b174ea69e} 
std\+::optional$<$ bool $>$ Is\+Internal\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{Script\+Pub\+Key\+Man $\ast$}]{spk\+\_\+man}{}\end{DoxyParamCaption}) const}

Returns whether the provided Script\+Pub\+Key\+Man is internal 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em spk\+\_\+man} & The Script\+Pub\+Key\+Man to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
contains value only for active Descriptor\+Script\+Pub\+Key\+Man, otherwise undefined 
\end{DoxyReturn}
\index{CWallet@{CWallet}!IsLocked@{IsLocked}}
\index{IsLocked@{IsLocked}!CWallet@{CWallet}}
\doxysubsubsection{IsLocked()}
{\footnotesize\ttfamily \label{class_c_wallet_ae2da09e4c159fa756de98a82eef53fff} 
bool Is\+Locked (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \textbf{ Wallet\+Storage} \doxyref{}{p.}{classwallet_1_1_wallet_storage_ae7bc78361f30bfda0286c8af11392f2d}.

\index{CWallet@{CWallet}!IsLockedCoin@{IsLockedCoin}}
\index{IsLockedCoin@{IsLockedCoin}!CWallet@{CWallet}}
\doxysubsubsection{IsLockedCoin()}
{\footnotesize\ttfamily \label{class_c_wallet_a3aab9bc2e11bbeec847e19eafff2c9d2} 
bool Is\+Locked\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{output}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!IsScanning@{IsScanning}}
\index{IsScanning@{IsScanning}!CWallet@{CWallet}}
\doxysubsubsection{IsScanning()}
{\footnotesize\ttfamily \label{class_c_wallet_a90202be35a4a6a81d447fb288e73f00a} 
bool Is\+Scanning (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!IsScanningWithPassphrase@{IsScanningWithPassphrase}}
\index{IsScanningWithPassphrase@{IsScanningWithPassphrase}!CWallet@{CWallet}}
\doxysubsubsection{IsScanningWithPassphrase()}
{\footnotesize\ttfamily \label{class_c_wallet_af65d5de8f70a62c6985f149ca9d088e9} 
bool Is\+Scanning\+With\+Passphrase (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!IsTxImmatureCoinBase@{IsTxImmatureCoinBase}}
\index{IsTxImmatureCoinBase@{IsTxImmatureCoinBase}!CWallet@{CWallet}}
\doxysubsubsection{IsTxImmatureCoinBase()}
{\footnotesize\ttfamily \label{class_c_wallet_a5af4dabf48f7115ad92e38b0bcf9e5f2} 
bool Is\+Tx\+Immature\+Coin\+Base (\begin{DoxyParamCaption}\item[{const \textbf{ CWallet\+Tx} \&}]{wtx}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!KeypoolCountExternalKeys@{KeypoolCountExternalKeys}}
\index{KeypoolCountExternalKeys@{KeypoolCountExternalKeys}!CWallet@{CWallet}}
\doxysubsubsection{KeypoolCountExternalKeys()}
{\footnotesize\ttfamily \label{class_c_wallet_a543b23fc38cee37e44d7a3ba1209c6cc} 
size\+\_\+t Keypool\+Count\+External\+Keys (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!ListAddrBookAddresses@{ListAddrBookAddresses}}
\index{ListAddrBookAddresses@{ListAddrBookAddresses}!CWallet@{CWallet}}
\doxysubsubsection{ListAddrBookAddresses()}
{\footnotesize\ttfamily \label{class_c_wallet_a8e8b197d1cebeb2a76318ccbd317066b} 
std\+::vector$<$ \textbf{ CTx\+Destination} $>$ List\+Addr\+Book\+Addresses (\begin{DoxyParamCaption}\item[{const std\+::optional$<$ \textbf{ Addr\+Book\+Filter} $>$ \&}]{filter}{}\end{DoxyParamCaption}) const}

Filter and retrieve destinations stored in the addressbook \index{CWallet@{CWallet}!ListAddrBookLabels@{ListAddrBookLabels}}
\index{ListAddrBookLabels@{ListAddrBookLabels}!CWallet@{CWallet}}
\doxysubsubsection{ListAddrBookLabels()}
{\footnotesize\ttfamily \label{class_c_wallet_a8ac1986ddd18f71dff3f7e0594cd4160} 
std\+::set$<$ std\+::string $>$ List\+Addr\+Book\+Labels (\begin{DoxyParamCaption}\item[{const std\+::optional$<$ Address\+Purpose $>$}]{purpose}{}\end{DoxyParamCaption}) const}

Retrieve all the known labels in the address book \index{CWallet@{CWallet}!ListLockedCoins@{ListLockedCoins}}
\index{ListLockedCoins@{ListLockedCoins}!CWallet@{CWallet}}
\doxysubsubsection{ListLockedCoins()}
{\footnotesize\ttfamily \label{class_c_wallet_aa682905b4cd7a27f9da221debe60407e} 
void List\+Locked\+Coins (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \textbf{ COut\+Point} $>$ \&}]{v\+Outpts}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!LoadActiveScriptPubKeyMan@{LoadActiveScriptPubKeyMan}}
\index{LoadActiveScriptPubKeyMan@{LoadActiveScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{LoadActiveScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_a10143ba1c0a65f839411f7b4e5280e39} 
void Load\+Active\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{\textbf{ uint256}}]{id}{, }\item[{\textbf{ Output\+Type}}]{type}{, }\item[{bool}]{internal}{}\end{DoxyParamCaption})}

Loads an active Script\+Pub\+Key\+Man for the specified type and internal. (used by Load\+Wallet) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em id} & The unique id for the Script\+Pub\+Key\+Man \\
\hline
\mbox{\texttt{in}}  & {\em type} & The \doxyref{Output\+Type}{p.}{outputtype_8h_a4e0517338e6c4a31a2addafc06d4f3a3} this Script\+Pub\+Key\+Man provides addresses for \\
\hline
\mbox{\texttt{in}}  & {\em internal} & Whether this Script\+Pub\+Key\+Man provides change addresses \\
\hline
\end{DoxyParams}
\index{CWallet@{CWallet}!LoadAddressPreviouslySpent@{LoadAddressPreviouslySpent}}
\index{LoadAddressPreviouslySpent@{LoadAddressPreviouslySpent}!CWallet@{CWallet}}
\doxysubsubsection{LoadAddressPreviouslySpent()}
{\footnotesize\ttfamily \label{class_c_wallet_a2c70fb1c7967a97c18c5cc0c4663af36} 
void Load\+Address\+Previously\+Spent (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{dest}{}\end{DoxyParamCaption})}



Marks destination as previously spent. 

\index{CWallet@{CWallet}!LoadAddressReceiveRequest@{LoadAddressReceiveRequest}}
\index{LoadAddressReceiveRequest@{LoadAddressReceiveRequest}!CWallet@{CWallet}}
\doxysubsubsection{LoadAddressReceiveRequest()}
{\footnotesize\ttfamily \label{class_c_wallet_a65346421da77b95ac454e24559f4994e} 
void Load\+Address\+Receive\+Request (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{dest}{, }\item[{const std\+::string \&}]{id}{, }\item[{const std\+::string \&}]{request}{}\end{DoxyParamCaption})}



Appends payment request to destination. 

\index{CWallet@{CWallet}!LoadDescriptorScriptPubKeyMan@{LoadDescriptorScriptPubKeyMan}}
\index{LoadDescriptorScriptPubKeyMan@{LoadDescriptorScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{LoadDescriptorScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_ab7241f8831a3b878f4a11aa6c91ba80a} 
Descriptor\+Script\+Pub\+Key\+Man \& Load\+Descriptor\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{\textbf{ uint256}}]{id}{, }\item[{\textbf{ Wallet\+Descriptor} \&}]{desc}{}\end{DoxyParamCaption})}



Instantiate a descriptor Script\+Pub\+Key\+Man from the \doxyref{Wallet\+Descriptor}{p.}{class_wallet_descriptor} and load it. 

\index{CWallet@{CWallet}!LoadLockedCoin@{LoadLockedCoin}}
\index{LoadLockedCoin@{LoadLockedCoin}!CWallet@{CWallet}}
\doxysubsubsection{LoadLockedCoin()}
{\footnotesize\ttfamily \label{class_c_wallet_ac52d0c4c4aeb443b9c877c9b585cb523} 
void Load\+Locked\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{coin}{, }\item[{bool}]{persistent}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!LoadWallet@{LoadWallet}}
\index{LoadWallet@{LoadWallet}!CWallet@{CWallet}}
\doxysubsubsection{LoadWallet()}
{\footnotesize\ttfamily \label{class_c_wallet_a0f26754363eb38ed45aa44e9781409fe} 
DBErrors Load\+Wallet (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!Lock@{Lock}}
\index{Lock@{Lock}!CWallet@{CWallet}}
\doxysubsubsection{Lock()}
{\footnotesize\ttfamily \label{class_c_wallet_a747fd95916e116a6ed37cc641e394c69} 
bool Lock (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!LockCoin@{LockCoin}}
\index{LockCoin@{LockCoin}!CWallet@{CWallet}}
\doxysubsubsection{LockCoin()}
{\footnotesize\ttfamily \label{class_c_wallet_aafce10897dd88084f60c277836bf8439} 
bool Lock\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{output}{, }\item[{bool}]{persist}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!LogName@{LogName}}
\index{LogName@{LogName}!CWallet@{CWallet}}
\doxysubsubsection{LogName()}
{\footnotesize\ttfamily \label{class_c_wallet_aa385db590bc0eed2616a0ea9db5ab946} 
std\+::string Log\+Name (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Return wallet name for use in logs, will return "{}default wallet"{} if the wallet has no name. 

Implements \textbf{ Wallet\+Storage} \doxyref{}{p.}{classwallet_1_1_wallet_storage_ad324bcc4895a73c0076895674a0961d4}.

\index{CWallet@{CWallet}!MarkDestinationsDirty@{MarkDestinationsDirty}}
\index{MarkDestinationsDirty@{MarkDestinationsDirty}!CWallet@{CWallet}}
\doxysubsubsection{MarkDestinationsDirty()}
{\footnotesize\ttfamily \label{class_c_wallet_afc165a4df3ac5278937028376f04f011} 
void Mark\+Destinations\+Dirty (\begin{DoxyParamCaption}\item[{const std\+::set$<$ \textbf{ CTx\+Destination} $>$ \&}]{destinations}{}\end{DoxyParamCaption})}

Marks all outputs in each one of the destinations dirty, so their cache is reset and does not return outdated information. \index{CWallet@{CWallet}!MigrateToSQLite@{MigrateToSQLite}}
\index{MigrateToSQLite@{MigrateToSQLite}!CWallet@{CWallet}}
\doxysubsubsection{MigrateToSQLite()}
{\footnotesize\ttfamily \label{class_c_wallet_a9ab4ad1f8f8170dfd2635a3c5b7ea13c} 
bool Migrate\+To\+SQLite (\begin{DoxyParamCaption}\item[{\textbf{ bilingual\+\_\+str} \&}]{error}{}\end{DoxyParamCaption})}

Move all records from the BDB database to a new SQLite database for storage. The original BDB file will be deleted and replaced with a new SQLite file. A backup is not created. May crash if something unexpected happens in the filesystem. \index{CWallet@{CWallet}!postInitProcess@{postInitProcess}}
\index{postInitProcess@{postInitProcess}!CWallet@{CWallet}}
\doxysubsubsection{postInitProcess()}
{\footnotesize\ttfamily \label{class_c_wallet_afe4abb209a471081ebcbdb43d6d3f083} 
void post\+Init\+Process (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\doxyref{Wallet}{p.}{class_wallet} post-\/init setup Gives the wallet a chance to register repetitive tasks and complete post-\/init tasks \index{CWallet@{CWallet}!RefreshAllTXOs@{RefreshAllTXOs}}
\index{RefreshAllTXOs@{RefreshAllTXOs}!CWallet@{CWallet}}
\doxysubsubsection{RefreshAllTXOs()}
{\footnotesize\ttfamily \label{class_c_wallet_a80fbef7fd4f9421632b4221ae5608dd3} 
void Refresh\+All\+TXOs (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\doxyref{Cache}{p.}{class_cache} outputs that belong to the wallet for all transactions in the wallet \index{CWallet@{CWallet}!RefreshTXOsFromTx@{RefreshTXOsFromTx}}
\index{RefreshTXOsFromTx@{RefreshTXOsFromTx}!CWallet@{CWallet}}
\doxysubsubsection{RefreshTXOsFromTx()}
{\footnotesize\ttfamily \label{class_c_wallet_a61bbd97a401e6a9a00311d41548fbb8f} 
void Refresh\+TXOs\+From\+Tx (\begin{DoxyParamCaption}\item[{const \textbf{ CWallet\+Tx} \&}]{wtx}{}\end{DoxyParamCaption})}

\doxyref{Cache}{p.}{class_cache} outputs that belong to the wallet from a single transaction \index{CWallet@{CWallet}!RemoveTxs@{RemoveTxs}}
\index{RemoveTxs@{RemoveTxs}!CWallet@{CWallet}}
\doxysubsubsection{RemoveTxs()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_a6be6d6a31222c9e29af17687341a255b} 
\textbf{ util\+::\+Result}$<$ void $>$ Remove\+Txs (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \textbf{ Txid} $>$ \&}]{txs\+\_\+to\+\_\+remove}{}\end{DoxyParamCaption})}

Erases the provided transactions from the wallet. \index{CWallet@{CWallet}!RemoveTxs@{RemoveTxs}}
\index{RemoveTxs@{RemoveTxs}!CWallet@{CWallet}}
\doxysubsubsection{RemoveTxs()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_ab576f27d87d1c19d311d3f7537e88865} 
\textbf{ util\+::\+Result}$<$ void $>$ Remove\+Txs (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{std\+::vector$<$ \textbf{ Txid} $>$ \&}]{txs\+\_\+to\+\_\+remove}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!ScanningDuration@{ScanningDuration}}
\index{ScanningDuration@{ScanningDuration}!CWallet@{CWallet}}
\doxysubsubsection{ScanningDuration()}
{\footnotesize\ttfamily \label{class_c_wallet_a3855a7cd3860207e699caa5e3c68efd0} 
Steady\+Clock\+::duration Scanning\+Duration (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!ScanningProgress@{ScanningProgress}}
\index{ScanningProgress@{ScanningProgress}!CWallet@{CWallet}}
\doxysubsubsection{ScanningProgress()}
{\footnotesize\ttfamily \label{class_c_wallet_a5621196430a699dd10d59bc9e236b071} 
double Scanning\+Progress (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CWallet@{CWallet}!SetAddressBook@{SetAddressBook}}
\index{SetAddressBook@{SetAddressBook}!CWallet@{CWallet}}
\doxysubsubsection{SetAddressBook()}
{\footnotesize\ttfamily \label{class_c_wallet_a3fd036c5725be1ffab80b54b0a20dad5} 
bool Set\+Address\+Book (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{address}{, }\item[{const std\+::string \&}]{str\+Name}{, }\item[{const std\+::optional$<$ Address\+Purpose $>$ \&}]{purpose}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!SetAddressPreviouslySpent@{SetAddressPreviouslySpent}}
\index{SetAddressPreviouslySpent@{SetAddressPreviouslySpent}!CWallet@{CWallet}}
\doxysubsubsection{SetAddressPreviouslySpent()}
{\footnotesize\ttfamily \label{class_c_wallet_af6bcc8943d5cdb92fc8911f6281afd18} 
bool Set\+Address\+Previously\+Spent (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{const \textbf{ CTx\+Destination} \&}]{dest}{, }\item[{bool}]{used}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!SetAddressReceiveRequest@{SetAddressReceiveRequest}}
\index{SetAddressReceiveRequest@{SetAddressReceiveRequest}!CWallet@{CWallet}}
\doxysubsubsection{SetAddressReceiveRequest()}
{\footnotesize\ttfamily \label{class_c_wallet_a651115338c4bcec1c8a311218ea4d849} 
bool Set\+Address\+Receive\+Request (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{const \textbf{ CTx\+Destination} \&}]{dest}{, }\item[{const std\+::string \&}]{id}{, }\item[{const std\+::string \&}]{value}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!SetBroadcastTransactions@{SetBroadcastTransactions}}
\index{SetBroadcastTransactions@{SetBroadcastTransactions}!CWallet@{CWallet}}
\doxysubsubsection{SetBroadcastTransactions()}
{\footnotesize\ttfamily \label{class_c_wallet_a554e9646017278a96994a73a739bc410} 
void Set\+Broadcast\+Transactions (\begin{DoxyParamCaption}\item[{bool}]{broadcast}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Set whether this wallet broadcasts transactions. \index{CWallet@{CWallet}!SetNextResend@{SetNextResend}}
\index{SetNextResend@{SetNextResend}!CWallet@{CWallet}}
\doxysubsubsection{SetNextResend()}
{\footnotesize\ttfamily \label{class_c_wallet_a5370c00fa1971e834f6219c6aba1f6fc} 
void Set\+Next\+Resend (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Set the next time this wallet should resend transactions to 12-\/36 hours from now, $\sim$1 day on average. \index{CWallet@{CWallet}!SetupDescriptorScriptPubKeyMan@{SetupDescriptorScriptPubKeyMan}}
\index{SetupDescriptorScriptPubKeyMan@{SetupDescriptorScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{SetupDescriptorScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_aedc47a732a577a61d47a9769e943967f} 
Descriptor\+Script\+Pub\+Key\+Man \& Setup\+Descriptor\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{const \textbf{ CExt\+Key} \&}]{master\+\_\+key}{, }\item[{const \textbf{ Output\+Type} \&}]{output\+\_\+type}{, }\item[{bool}]{internal}{}\end{DoxyParamCaption})}



Create new Descriptor\+Script\+Pub\+Key\+Man and add it to the wallet. 

\index{CWallet@{CWallet}!SetupDescriptorScriptPubKeyMans@{SetupDescriptorScriptPubKeyMans}}
\index{SetupDescriptorScriptPubKeyMans@{SetupDescriptorScriptPubKeyMans}!CWallet@{CWallet}}
\doxysubsubsection{SetupDescriptorScriptPubKeyMans()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_a0914db7e21654e8cd140d5b7a5df3573} 
void Setup\+Descriptor\+Script\+Pub\+Key\+Mans (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!SetupDescriptorScriptPubKeyMans@{SetupDescriptorScriptPubKeyMans}}
\index{SetupDescriptorScriptPubKeyMans@{SetupDescriptorScriptPubKeyMans}!CWallet@{CWallet}}
\doxysubsubsection{SetupDescriptorScriptPubKeyMans()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_a06475a310bfaed171630e5903374375b} 
void Setup\+Descriptor\+Script\+Pub\+Key\+Mans (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{, }\item[{const \textbf{ CExt\+Key} \&}]{master\+\_\+key}{}\end{DoxyParamCaption})}



Create new Descriptor\+Script\+Pub\+Key\+Mans and add them to the wallet. 

\index{CWallet@{CWallet}!SetupLegacyScriptPubKeyMan@{SetupLegacyScriptPubKeyMan}}
\index{SetupLegacyScriptPubKeyMan@{SetupLegacyScriptPubKeyMan}!CWallet@{CWallet}}
\doxysubsubsection{SetupLegacyScriptPubKeyMan()}
{\footnotesize\ttfamily \label{class_c_wallet_a42e7171b6364ff12e3f2b81b5b84cc94} 
void Setup\+Legacy\+Script\+Pub\+Key\+Man (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Make a Legacy(\+Data)SPKM and set it for all types, internal, and external. 

\index{CWallet@{CWallet}!SetupOwnDescriptorScriptPubKeyMans@{SetupOwnDescriptorScriptPubKeyMans}}
\index{SetupOwnDescriptorScriptPubKeyMans@{SetupOwnDescriptorScriptPubKeyMans}!CWallet@{CWallet}}
\doxysubsubsection{SetupOwnDescriptorScriptPubKeyMans()}
{\footnotesize\ttfamily \label{class_c_wallet_adbe4e3ca74af3a85f21caf43c8b71c02} 
void Setup\+Own\+Descriptor\+Script\+Pub\+Key\+Mans (\begin{DoxyParamCaption}\item[{Wallet\+Batch \&}]{batch}{}\end{DoxyParamCaption})}



Create new seed and default Descriptor\+Script\+Pub\+Key\+Mans for this wallet. 

\index{CWallet@{CWallet}!SignMessage@{SignMessage}}
\index{SignMessage@{SignMessage}!CWallet@{CWallet}}
\doxysubsubsection{SignMessage()}
{\footnotesize\ttfamily \label{class_c_wallet_a42dea9d4afe23b378ce40712d431e154} 
\textbf{ Signing\+Result} Sign\+Message (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{message}{, }\item[{const \textbf{ PKHash} \&}]{pkhash}{, }\item[{std\+::string \&}]{str\+\_\+sig}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!SignTransaction@{SignTransaction}}
\index{SignTransaction@{SignTransaction}!CWallet@{CWallet}}
\doxysubsubsection{SignTransaction()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_aa8bc87176f5112fb747680c3f449083d} 
bool Sign\+Transaction (\begin{DoxyParamCaption}\item[{\textbf{ CMutable\+Transaction} \&}]{tx}{}\end{DoxyParamCaption}) const}

Fetch the inputs and sign with SIGHASH\+\_\+\+ALL. \index{CWallet@{CWallet}!SignTransaction@{SignTransaction}}
\index{SignTransaction@{SignTransaction}!CWallet@{CWallet}}
\doxysubsubsection{SignTransaction()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_wallet_a872f79a2f644abe28af2108119b6a01b} 
bool Sign\+Transaction (\begin{DoxyParamCaption}\item[{\textbf{ CMutable\+Transaction} \&}]{tx}{, }\item[{const std\+::map$<$ \textbf{ COut\+Point}, \textbf{ Coin} $>$ \&}]{coins}{, }\item[{int}]{sighash}{, }\item[{std\+::map$<$ int, \textbf{ bilingual\+\_\+str} $>$ \&}]{input\+\_\+errors}{}\end{DoxyParamCaption}) const}

Sign the tx given the input coins and sighash. \index{CWallet@{CWallet}!TopUpCallback@{TopUpCallback}}
\index{TopUpCallback@{TopUpCallback}!CWallet@{CWallet}}
\doxysubsubsection{TopUpCallback()}
{\footnotesize\ttfamily \label{class_c_wallet_a093c331dde7347a38872f3e43936d939} 
void Top\+Up\+Callback (\begin{DoxyParamCaption}\item[{const std\+::set$<$ \textbf{ CScript} $>$ \&}]{spks}{, }\item[{Script\+Pub\+Key\+Man $\ast$}]{spkm}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}}

\index{CWallet@{CWallet}!TopUpKeyPool@{TopUpKeyPool}}
\index{TopUpKeyPool@{TopUpKeyPool}!CWallet@{CWallet}}
\doxysubsubsection{TopUpKeyPool()}
{\footnotesize\ttfamily \label{class_c_wallet_a7b7dda1afc261b6e0f25fe554990ca4e} 
bool Top\+Up\+Key\+Pool (\begin{DoxyParamCaption}\item[{unsigned int}]{kp\+Size}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!TransactionChangeType@{TransactionChangeType}}
\index{TransactionChangeType@{TransactionChangeType}!CWallet@{CWallet}}
\doxysubsubsection{TransactionChangeType()}
{\footnotesize\ttfamily \label{class_c_wallet_a075a1d14681e61ebbe4669a20de165cf} 
\textbf{ Output\+Type} Transaction\+Change\+Type (\begin{DoxyParamCaption}\item[{const std\+::optional$<$ \textbf{ Output\+Type} $>$ \&}]{change\+\_\+type}{, }\item[{const std\+::vector$<$ \textbf{ CRecipient} $>$ \&}]{vec\+Send}{}\end{DoxyParamCaption}) const}

\index{CWallet@{CWallet}!UnlockAllCoins@{UnlockAllCoins}}
\index{UnlockAllCoins@{UnlockAllCoins}!CWallet@{CWallet}}
\doxysubsubsection{UnlockAllCoins()}
{\footnotesize\ttfamily \label{class_c_wallet_a11db7a247cf82b02679ad3b9ff077074} 
bool Unlock\+All\+Coins (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!UnlockCoin@{UnlockCoin}}
\index{UnlockCoin@{UnlockCoin}!CWallet@{CWallet}}
\doxysubsubsection{UnlockCoin()}
{\footnotesize\ttfamily \label{class_c_wallet_a85a9c76561eb52deb1ef3e1bcf1101e9} 
bool Unlock\+Coin (\begin{DoxyParamCaption}\item[{const \textbf{ COut\+Point} \&}]{output}{}\end{DoxyParamCaption})}

\index{CWallet@{CWallet}!WalletLogPrintf@{WalletLogPrintf}}
\index{WalletLogPrintf@{WalletLogPrintf}!CWallet@{CWallet}}
\doxysubsubsection{WalletLogPrintf()}
{\footnotesize\ttfamily \label{class_c_wallet_ab231740b5fcabd8da3c6eda6cf1cfd06} 
template$<$typename... Params$>$ \\
void Wallet\+Log\+Printf (\begin{DoxyParamCaption}\item[{\textbf{ util\+::\+Consteval\+Format\+String}$<$ sizeof...(\textbf{ Params})$>$}]{wallet\+\_\+fmt}{, }\item[{const \textbf{ Params} \&...}]{params}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Prepends the wallet name in logging output to ease debugging in multi-\/wallet use cases \index{CWallet@{CWallet}!WithEncryptionKey@{WithEncryptionKey}}
\index{WithEncryptionKey@{WithEncryptionKey}!CWallet@{CWallet}}
\doxysubsubsection{WithEncryptionKey()}
{\footnotesize\ttfamily \label{class_c_wallet_a5ffa05f033f466c0ee78c740a3ddc7db} 
bool With\+Encryption\+Key (\begin{DoxyParamCaption}\item[{std\+::function$<$ bool(const CKeying\+Material \&)$>$}]{cb}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}}

\index{CWallet@{CWallet}!WriteBestBlock@{WriteBestBlock}}
\index{WriteBestBlock@{WriteBestBlock}!CWallet@{CWallet}}
\doxysubsubsection{WriteBestBlock()}
{\footnotesize\ttfamily \label{class_c_wallet_a8ecbd65706f18505307d222e2b1e520f} 
void Write\+Best\+Block (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Write the current best block to database 

\label{doc-related-members}
\doxysubsection{Friends And Related Symbol Documentation}
\index{CWallet@{CWallet}!WalletRescanReserver@{WalletRescanReserver}}
\index{WalletRescanReserver@{WalletRescanReserver}!CWallet@{CWallet}}
\doxysubsubsection{WalletRescanReserver}
{\footnotesize\ttfamily \label{class_c_wallet_add744ad51ccb588bc7e404cf0ab3d77e} 
friend class \textbf{ Wallet\+Rescan\+Reserver}\hspace{0.3cm}{\ttfamily [friend]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CWallet@{CWallet}!cs\_wallet@{cs\_wallet}}
\index{cs\_wallet@{cs\_wallet}!CWallet@{CWallet}}
\doxysubsubsection{cs\_wallet}
{\footnotesize\ttfamily \label{class_c_wallet_a923b5c6bdb86562f8e91dbecb2eaf6a1} 
\textbf{ Recursive\+Mutex} cs\+\_\+wallet\hspace{0.3cm}{\ttfamily [mutable]}}

Main wallet lock. This lock protects all the fields added by \doxyref{CWallet}{p.}{class_c_wallet}. \index{CWallet@{CWallet}!m\_allow\_fallback\_fee@{m\_allow\_fallback\_fee}}
\index{m\_allow\_fallback\_fee@{m\_allow\_fallback\_fee}!CWallet@{CWallet}}
\doxysubsubsection{m\_allow\_fallback\_fee}
{\footnotesize\ttfamily \label{class_c_wallet_a8abebc10a356260c20c78753c7e39895} 
bool m\+\_\+allow\+\_\+fallback\+\_\+fee \{true\}}



will be false if -\/fallbackfee=0 

\index{CWallet@{CWallet}!m\_chain\_notifications\_handler@{m\_chain\_notifications\_handler}}
\index{m\_chain\_notifications\_handler@{m\_chain\_notifications\_handler}!CWallet@{CWallet}}
\doxysubsubsection{m\_chain\_notifications\_handler}
{\footnotesize\ttfamily \label{class_c_wallet_accd1a3b8612ecc7991bf7d47841a0f67} 
std\+::unique\+\_\+ptr$<$\textbf{ interfaces\+::\+Handler}$>$ m\+\_\+chain\+\_\+notifications\+\_\+handler}

Registered \doxyref{interfaces\+::\+Chain\+::\+Notifications}{p.}{classinterfaces_1_1_chain_1_1_notifications} handler. \index{CWallet@{CWallet}!m\_confirm\_target@{m\_confirm\_target}}
\index{m\_confirm\_target@{m\_confirm\_target}!CWallet@{CWallet}}
\doxysubsubsection{m\_confirm\_target}
{\footnotesize\ttfamily \label{class_c_wallet_a952e803e8113ec49ed3d3edb30a989a5} 
unsigned int m\+\_\+confirm\+\_\+target \{DEFAULT\+\_\+\+TX\+\_\+\+CONFIRM\+\_\+\+TARGET\}}

\index{CWallet@{CWallet}!m\_consolidate\_feerate@{m\_consolidate\_feerate}}
\index{m\_consolidate\_feerate@{m\_consolidate\_feerate}!CWallet@{CWallet}}
\doxysubsubsection{m\_consolidate\_feerate}
{\footnotesize\ttfamily \label{class_c_wallet_abeb7a55de7b481ea67770dade613bbd3} 
\textbf{ CFee\+Rate} m\+\_\+consolidate\+\_\+feerate \{DEFAULT\+\_\+\+CONSOLIDATE\+\_\+\+FEERATE\}}

When the actual feerate is less than the consolidate feerate, we will tend to make transactions which consolidate inputs. When the actual feerate is greater than the consolidate feerate, we will tend to make transactions which have the lowest fees. \index{CWallet@{CWallet}!m\_default\_address\_type@{m\_default\_address\_type}}
\index{m\_default\_address\_type@{m\_default\_address\_type}!CWallet@{CWallet}}
\doxysubsubsection{m\_default\_address\_type}
{\footnotesize\ttfamily \label{class_c_wallet_ac3607758a2a270a215b1af018977e828} 
\textbf{ Output\+Type} m\+\_\+default\+\_\+address\+\_\+type \{DEFAULT\+\_\+\+ADDRESS\+\_\+\+TYPE\}}

\index{CWallet@{CWallet}!m\_default\_change\_type@{m\_default\_change\_type}}
\index{m\_default\_change\_type@{m\_default\_change\_type}!CWallet@{CWallet}}
\doxysubsubsection{m\_default\_change\_type}
{\footnotesize\ttfamily \label{class_c_wallet_a096b545ad56787ee3656cf0ed06db79b} 
std\+::optional$<$\textbf{ Output\+Type}$>$ m\+\_\+default\+\_\+change\+\_\+type \{\}}

Default output type for change outputs. When unset, automatically choose type based on address type setting and the types other of non-\/change outputs (see -\/changetype option documentation and implementation in \doxyref{CWallet\+::\+Transaction\+Change\+Type}{p.}{class_c_wallet_a075a1d14681e61ebbe4669a20de165cf} for details). \index{CWallet@{CWallet}!m\_default\_max\_tx\_fee@{m\_default\_max\_tx\_fee}}
\index{m\_default\_max\_tx\_fee@{m\_default\_max\_tx\_fee}!CWallet@{CWallet}}
\doxysubsubsection{m\_default\_max\_tx\_fee}
{\footnotesize\ttfamily \label{class_c_wallet_a86bc21e49ac31e7ab1a148b0ff051255} 
\textbf{ CAmount} m\+\_\+default\+\_\+max\+\_\+tx\+\_\+fee \{DEFAULT\+\_\+\+TRANSACTION\+\_\+\+MAXFEE\}}

Absolute maximum transaction fee (in satoshis) used by default for the wallet \index{CWallet@{CWallet}!m\_discard\_rate@{m\_discard\_rate}}
\index{m\_discard\_rate@{m\_discard\_rate}!CWallet@{CWallet}}
\doxysubsubsection{m\_discard\_rate}
{\footnotesize\ttfamily \label{class_c_wallet_a91ccd20ccc280820ea4d9a3600ff2959} 
\textbf{ CFee\+Rate} m\+\_\+discard\+\_\+rate \{DEFAULT\+\_\+\+DISCARD\+\_\+\+FEE\}}

If the cost to spend a change output at this feerate is greater than the value of the output itself, just drop it to fees. \index{CWallet@{CWallet}!m\_fallback\_fee@{m\_fallback\_fee}}
\index{m\_fallback\_fee@{m\_fallback\_fee}!CWallet@{CWallet}}
\doxysubsubsection{m\_fallback\_fee}
{\footnotesize\ttfamily \label{class_c_wallet_a2cca81e2fd4a628073ac959cf3a24d82} 
\textbf{ CFee\+Rate} m\+\_\+fallback\+\_\+fee \{DEFAULT\+\_\+\+FALLBACK\+\_\+\+FEE\}}

If fee estimation does not have enough data to provide estimates, use this fee instead. Has no effect if not using fee estimation Override with -\/fallbackfee \index{CWallet@{CWallet}!m\_keypool\_size@{m\_keypool\_size}}
\index{m\_keypool\_size@{m\_keypool\_size}!CWallet@{CWallet}}
\doxysubsubsection{m\_keypool\_size}
{\footnotesize\ttfamily \label{class_c_wallet_adb8e3a53f42c0025ee1364486a76a251} 
int64\+\_\+t m\+\_\+keypool\+\_\+size \{DEFAULT\+\_\+\+KEYPOOL\+\_\+\+SIZE\}}

Number of pre-\/generated keys/scripts by each spkm (part of the look-\/ahead process, used to detect payments) \index{CWallet@{CWallet}!m\_max\_aps\_fee@{m\_max\_aps\_fee}}
\index{m\_max\_aps\_fee@{m\_max\_aps\_fee}!CWallet@{CWallet}}
\doxysubsubsection{m\_max\_aps\_fee}
{\footnotesize\ttfamily \label{class_c_wallet_a991ff968afce9be4d74da0c01a4322d0} 
\textbf{ CAmount} m\+\_\+max\+\_\+aps\+\_\+fee \{DEFAULT\+\_\+\+MAX\+\_\+\+AVOIDPARTIALSPEND\+\_\+\+FEE\}}



note\+: this is absolute fee, not fee rate 

The maximum fee amount we\textquotesingle{}re willing to pay to prioritize partial spend avoidance. \index{CWallet@{CWallet}!m\_min\_fee@{m\_min\_fee}}
\index{m\_min\_fee@{m\_min\_fee}!CWallet@{CWallet}}
\doxysubsubsection{m\_min\_fee}
{\footnotesize\ttfamily \label{class_c_wallet_a8e322b589d52e7c3396880cf46ec0aac} 
\textbf{ CFee\+Rate} m\+\_\+min\+\_\+fee \{DEFAULT\+\_\+\+TRANSACTION\+\_\+\+MINFEE\}}



Override with -\/mintxfee. 

\index{CWallet@{CWallet}!m\_notify\_tx\_changed\_script@{m\_notify\_tx\_changed\_script}}
\index{m\_notify\_tx\_changed\_script@{m\_notify\_tx\_changed\_script}!CWallet@{CWallet}}
\doxysubsubsection{m\_notify\_tx\_changed\_script}
{\footnotesize\ttfamily \label{class_c_wallet_a65b2dcca5c8a23bcd65c2bf8bda552e0} 
std\+::string m\+\_\+notify\+\_\+tx\+\_\+changed\+\_\+script}

Notify external script when a wallet transaction comes in or is updated (handled by -\/walletnotify) \index{CWallet@{CWallet}!m\_pay\_tx\_fee@{m\_pay\_tx\_fee}}
\index{m\_pay\_tx\_fee@{m\_pay\_tx\_fee}!CWallet@{CWallet}}
\doxysubsubsection{m\_pay\_tx\_fee}
{\footnotesize\ttfamily \label{class_c_wallet_a61c1187becd7d4751e83704c749c5315} 
\textbf{ CFee\+Rate} m\+\_\+pay\+\_\+tx\+\_\+fee \{\textbf{ DEFAULT\+\_\+\+PAY\+\_\+\+TX\+\_\+\+FEE}\}}

\index{CWallet@{CWallet}!m\_relock\_mutex@{m\_relock\_mutex}}
\index{m\_relock\_mutex@{m\_relock\_mutex}!CWallet@{CWallet}}
\doxysubsubsection{m\_relock\_mutex}
{\footnotesize\ttfamily \label{class_c_wallet_ac66b7a1989f5ffc39523887153141ffc} 
\textbf{ Recursive\+Mutex} m\+\_\+relock\+\_\+mutex}

\index{CWallet@{CWallet}!m\_signal\_rbf@{m\_signal\_rbf}}
\index{m\_signal\_rbf@{m\_signal\_rbf}!CWallet@{CWallet}}
\doxysubsubsection{m\_signal\_rbf}
{\footnotesize\ttfamily \label{class_c_wallet_ade3e7a21e4e1fce7a28269d8bd9edbcb} 
bool m\+\_\+signal\+\_\+rbf \{DEFAULT\+\_\+\+WALLET\+\_\+\+RBF\}}

\index{CWallet@{CWallet}!m\_spend\_zero\_conf\_change@{m\_spend\_zero\_conf\_change}}
\index{m\_spend\_zero\_conf\_change@{m\_spend\_zero\_conf\_change}!CWallet@{CWallet}}
\doxysubsubsection{m\_spend\_zero\_conf\_change}
{\footnotesize\ttfamily \label{class_c_wallet_a4f0685c16116a40bff01d284556f4f7f} 
bool m\+\_\+spend\+\_\+zero\+\_\+conf\+\_\+change \{DEFAULT\+\_\+\+SPEND\+\_\+\+ZEROCONF\+\_\+\+CHANGE\}}

Allow \doxyref{Coin}{p.}{class_coin} Selection to pick unconfirmed UTXOs that were sent from our own wallet if it cannot fund the transaction otherwise. \index{CWallet@{CWallet}!m\_unlock\_mutex@{m\_unlock\_mutex}}
\index{m\_unlock\_mutex@{m\_unlock\_mutex}!CWallet@{CWallet}}
\doxysubsubsection{m\_unlock\_mutex}
{\footnotesize\ttfamily \label{class_c_wallet_ae44bd556be5ee9d50d0104935c029281} 
\textbf{ Mutex} m\+\_\+unlock\+\_\+mutex}

\index{CWallet@{CWallet}!mapMasterKeys@{mapMasterKeys}}
\index{mapMasterKeys@{mapMasterKeys}!CWallet@{CWallet}}
\doxysubsubsection{mapMasterKeys}
{\footnotesize\ttfamily \label{class_c_wallet_acd187867ecbf213198f6deb79f8ca0c8} 
\textbf{ Master\+Key\+Map} map\+Master\+Keys}

\index{CWallet@{CWallet}!nMasterKeyMaxID@{nMasterKeyMaxID}}
\index{nMasterKeyMaxID@{nMasterKeyMaxID}!CWallet@{CWallet}}
\doxysubsubsection{nMasterKeyMaxID}
{\footnotesize\ttfamily \label{class_c_wallet_afa8f785043098bea4bed47fe9be01bd8} 
unsigned int n\+Master\+Key\+Max\+ID = 0}

\index{CWallet@{CWallet}!NotifyAddressBookChanged@{NotifyAddressBookChanged}}
\index{NotifyAddressBookChanged@{NotifyAddressBookChanged}!CWallet@{CWallet}}
\doxysubsubsection{NotifyAddressBookChanged}
{\footnotesize\ttfamily \label{class_c_wallet_ad756f492b82b8402023224a2af26ff11} 
boost\+::signals2\+::signal$<$void(const \textbf{ CTx\+Destination}\& address, const std\+::string\& label, bool is\+Mine, Address\+Purpose purpose, \textbf{ Change\+Type} status)$>$ Notify\+Address\+Book\+Changed}

Address book entry changed. \begin{DoxyNote}{Note}
called without lock cs\+\_\+wallet held. 
\end{DoxyNote}
\index{CWallet@{CWallet}!NotifyCanGetAddressesChanged@{NotifyCanGetAddressesChanged}}
\index{NotifyCanGetAddressesChanged@{NotifyCanGetAddressesChanged}!CWallet@{CWallet}}
\doxysubsubsection{NotifyCanGetAddressesChanged}
{\footnotesize\ttfamily \label{class_c_wallet_a909c982de74e0eb5c51f57b161ae6352} 
boost\+::signals2\+::signal$<$void ()$>$ Notify\+Can\+Get\+Addresses\+Changed}

Keypool has new keys \index{CWallet@{CWallet}!NotifyStatusChanged@{NotifyStatusChanged}}
\index{NotifyStatusChanged@{NotifyStatusChanged}!CWallet@{CWallet}}
\doxysubsubsection{NotifyStatusChanged}
{\footnotesize\ttfamily \label{class_c_wallet_ab98dd8ac2afc8846cca32c6d2a368984} 
boost\+::signals2\+::signal$<$void (\textbf{ CWallet}$\ast$ \textbf{ wallet})$>$ Notify\+Status\+Changed}

\doxyref{Wallet}{p.}{class_wallet} status (encrypted, locked) changed. Note\+: Called without locks held. \index{CWallet@{CWallet}!NotifyTransactionChanged@{NotifyTransactionChanged}}
\index{NotifyTransactionChanged@{NotifyTransactionChanged}!CWallet@{CWallet}}
\doxysubsubsection{NotifyTransactionChanged}
{\footnotesize\ttfamily \label{class_c_wallet_af0438e3e4c388c32d9780aea830231e9} 
boost\+::signals2\+::signal$<$void(const \textbf{ Txid}\& hash\+Tx, \textbf{ Change\+Type} status)$>$ Notify\+Transaction\+Changed}

\doxyref{Wallet}{p.}{class_wallet} transaction added, removed or updated. \begin{DoxyNote}{Note}
called with lock cs\+\_\+wallet held. 
\end{DoxyNote}
\index{CWallet@{CWallet}!NotifyUnload@{NotifyUnload}}
\index{NotifyUnload@{NotifyUnload}!CWallet@{CWallet}}
\doxysubsubsection{NotifyUnload}
{\footnotesize\ttfamily \label{class_c_wallet_ac048f4a1feba4e42ed106b2ea6cd9e6b} 
boost\+::signals2\+::signal$<$void ()$>$ Notify\+Unload}

\doxyref{Wallet}{p.}{class_wallet} is about to be unloaded \index{CWallet@{CWallet}!ShowProgress@{ShowProgress}}
\index{ShowProgress@{ShowProgress}!CWallet@{CWallet}}
\doxysubsubsection{ShowProgress}
{\footnotesize\ttfamily \label{class_c_wallet_a6abd6d9bb196b68480bbaf59c3d01870} 
boost\+::signals2\+::signal$<$void (const std\+::string \&title, int n\+Progress)$>$ Show\+Progress}

Show progress e.\+g. for rescan \index{CWallet@{CWallet}!wtxOrdered@{wtxOrdered}}
\index{wtxOrdered@{wtxOrdered}!CWallet@{CWallet}}
\doxysubsubsection{wtxOrdered}
{\footnotesize\ttfamily \label{class_c_wallet_ab270a4be824cbeb43426ba9054648166} 
\textbf{ Tx\+Items} wtx\+Ordered}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/wallet/\textbf{ wallet.\+h}\item 
src/wallet/\textbf{ wallet.\+cpp}\end{DoxyCompactItemize}
