\doxysection{Zero\+Sock Class Reference}
\label{class_zero_sock}\index{ZeroSock@{ZeroSock}}


{\ttfamily \#include $<$net.\+h$>$}

Inheritance diagram for Zero\+Sock\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_zero_sock}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Zero\+Sock} ()
\item 
\textbf{ $\sim$\+Zero\+Sock} () override
\item 
ssize\+\_\+t \textbf{ Send} (const void $\ast$, size\+\_\+t len, int) const override
\item 
ssize\+\_\+t \textbf{ Recv} (void $\ast$buf, size\+\_\+t len, int \textbf{ flags}) const override
\item 
int \textbf{ Connect} (const sockaddr $\ast$, socklen\+\_\+t) const override
\item 
int \textbf{ Bind} (const sockaddr $\ast$, socklen\+\_\+t) const override
\item 
int \textbf{ Listen} (int) const override
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ \textbf{ Accept} (sockaddr $\ast$addr, socklen\+\_\+t $\ast$addr\+\_\+len) const override
\item 
int \textbf{ Get\+Sock\+Opt} (int level, int opt\+\_\+name, void $\ast$opt\+\_\+val, socklen\+\_\+t $\ast$opt\+\_\+len) const override
\item 
int \textbf{ Set\+Sock\+Opt} (int, int, const void $\ast$, socklen\+\_\+t) const override
\item 
int \textbf{ Get\+Sock\+Name} (sockaddr $\ast$\textbf{ name}, socklen\+\_\+t $\ast$name\+\_\+len) const override
\item 
bool \textbf{ Set\+Non\+Blocking} () const override
\item 
bool \textbf{ Is\+Selectable} () const override
\item 
bool \textbf{ Wait} (std\+::chrono\+::milliseconds timeout, \textbf{ Event} requested, \textbf{ Event} $\ast$occurred=nullptr) const override
\item 
bool \textbf{ Wait\+Many} (std\+::chrono\+::milliseconds timeout, \textbf{ Events\+Per\+Sock} \&events\+\_\+per\+\_\+sock) const override
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Sock} ()=delete
\item 
\textbf{ Sock} (\textbf{ SOCKET} s)
\item 
\textbf{ Sock} (const \textbf{ Sock} \&)=delete
\item 
\textbf{ Sock} (\textbf{ Sock} \&\&other)
\item 
virtual \textbf{ $\sim$\+Sock} ()
\item 
\textbf{ Sock} \& \textbf{ operator=} (const \textbf{ Sock} \&)=delete
\item 
virtual void \textbf{ Send\+Complete} (std\+::span$<$ const unsigned char $>$ data, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt) const
\item 
virtual void \textbf{ Send\+Complete} (std\+::span$<$ const char $>$ data, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt) const
\item 
virtual std\+::string \textbf{ Recv\+Until\+Terminator} (uint8\+\_\+t terminator, std\+::chrono\+::milliseconds timeout, \textbf{ CThread\+Interrupt} \&interrupt, size\+\_\+t max\+\_\+data) const
\item 
virtual bool \textbf{ Is\+Connected} (std\+::string \&errmsg) const
\item 
bool \textbf{ operator==} (\textbf{ SOCKET} s) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Event} = uint8\+\_\+t
\item 
using \textbf{ Events\+Per\+Sock} = std\+::unordered\+\_\+map$<$std\+::shared\+\_\+ptr$<$const \textbf{ Sock}$>$, \textbf{ Events}, \textbf{ Hash\+Shared\+Ptr\+Sock}, \textbf{ Equal\+Shared\+Ptr\+Sock}$>$
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
static constexpr \textbf{ Event} \textbf{ RECV} = 0b001
\item 
static constexpr \textbf{ Event} \textbf{ SEND} = 0b010
\item 
static constexpr \textbf{ Event} \textbf{ ERR} = 0b100
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \textbf{ Sock}}
\begin{DoxyCompactItemize}
\item 
\textbf{ SOCKET} \textbf{ m\+\_\+socket}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A mocked \doxyref{Sock}{p.}{class_sock} alternative that succeeds on all operations. Returns infinite amount of 0x0 bytes on reads. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{ZeroSock@{ZeroSock}!ZeroSock@{ZeroSock}}
\index{ZeroSock@{ZeroSock}!ZeroSock@{ZeroSock}}
\doxysubsubsection{ZeroSock()}
{\footnotesize\ttfamily \label{class_zero_sock_aefa860e8fb68c2d8a73ec71f10b27895} 
\textbf{ Zero\+Sock} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{ZeroSock@{ZeroSock}!````~ZeroSock@{$\sim$ZeroSock}}
\index{````~ZeroSock@{$\sim$ZeroSock}!ZeroSock@{ZeroSock}}
\doxysubsubsection{$\sim$ZeroSock()}
{\footnotesize\ttfamily \label{class_zero_sock_af2fee29bcc7448c2d5d3acc995be6bd8} 
$\sim$\textbf{ Zero\+Sock} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{ZeroSock@{ZeroSock}!Accept@{Accept}}
\index{Accept@{Accept}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Accept()}
{\footnotesize\ttfamily \label{class_zero_sock_a36b4abe351193181c883d465020aa101} 
std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ Accept (\begin{DoxyParamCaption}\item[{sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t $\ast$}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

accept(2) wrapper. Equivalent to {\ttfamily std\+::make\+\_\+unique$<$\doxyref{Sock}{p.}{class_sock}$>$(accept(m\+\_\+socket, addr, addr\+\_\+len))}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. The returned unique\+\_\+ptr is empty if {\ttfamily accept()} failed in which case errno will be set. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a0478fe1f85686563dafce68f30878fa6}.

\index{ZeroSock@{ZeroSock}!Bind@{Bind}}
\index{Bind@{Bind}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Bind()}
{\footnotesize\ttfamily \label{class_zero_sock_ab8f4fedff95b14573fabc05c019f9f8e} 
int Bind (\begin{DoxyParamCaption}\item[{const sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

bind(2) wrapper. Equivalent to {\ttfamily bind(m\+\_\+socket, addr, addr\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_ae84297efb7d81f94d5c839a4b3b2abd8}.

\index{ZeroSock@{ZeroSock}!Connect@{Connect}}
\index{Connect@{Connect}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Connect()}
{\footnotesize\ttfamily \label{class_zero_sock_a2a2d42283320a5a051f301933328ad09} 
int Connect (\begin{DoxyParamCaption}\item[{const sockaddr $\ast$}]{addr}{, }\item[{socklen\+\_\+t}]{addr\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

connect(2) wrapper. Equivalent to {\ttfamily connect(m\+\_\+socket, addr, addrlen)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a5f5be77492fb494cd6b2effd50d18435}.

\index{ZeroSock@{ZeroSock}!GetSockName@{GetSockName}}
\index{GetSockName@{GetSockName}!ZeroSock@{ZeroSock}}
\doxysubsubsection{GetSockName()}
{\footnotesize\ttfamily \label{class_zero_sock_a16930ee6ded3a8fe47a7adaf178affff} 
int Get\+Sock\+Name (\begin{DoxyParamCaption}\item[{sockaddr $\ast$}]{name}{, }\item[{socklen\+\_\+t $\ast$}]{name\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

getsockname(2) wrapper. Equivalent to {\ttfamily getsockname(m\+\_\+socket, name, name\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a8544fa939816100e03ecba0a79fde2b1}.

\index{ZeroSock@{ZeroSock}!GetSockOpt@{GetSockOpt}}
\index{GetSockOpt@{GetSockOpt}!ZeroSock@{ZeroSock}}
\doxysubsubsection{GetSockOpt()}
{\footnotesize\ttfamily \label{class_zero_sock_a5b5845e5aca634a6f79c82afecbc37fd} 
int Get\+Sock\+Opt (\begin{DoxyParamCaption}\item[{int}]{level}{, }\item[{int}]{opt\+\_\+name}{, }\item[{void $\ast$}]{opt\+\_\+val}{, }\item[{socklen\+\_\+t $\ast$}]{opt\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

getsockopt(2) wrapper. Equivalent to {\ttfamily getsockopt(m\+\_\+socket, level, opt\+\_\+name, opt\+\_\+val, opt\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a36a481d2609f5c4626a8c6136ee1f26f}.

\index{ZeroSock@{ZeroSock}!IsSelectable@{IsSelectable}}
\index{IsSelectable@{IsSelectable}!ZeroSock@{ZeroSock}}
\doxysubsubsection{IsSelectable()}
{\footnotesize\ttfamily \label{class_zero_sock_a598fdcc705deaa438fba72650d51fe20} 
bool Is\+Selectable (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Check if the underlying socket can be used for {\ttfamily select(2)} (or the {\ttfamily \doxyref{Wait()}{p.}{class_zero_sock_aa9d44903b57505d9f8765404cb04f35f}} method). \begin{DoxyReturn}{Returns}
true if selectable 
\end{DoxyReturn}


Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a39fd9751352b6030c42c342066a1b887}.

\index{ZeroSock@{ZeroSock}!Listen@{Listen}}
\index{Listen@{Listen}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Listen()}
{\footnotesize\ttfamily \label{class_zero_sock_a172d2ef5e777674d5445aac1387bab41} 
int Listen (\begin{DoxyParamCaption}\item[{int}]{backlog}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

listen(2) wrapper. Equivalent to {\ttfamily listen(m\+\_\+socket, backlog)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a88c18587b3e874ee2a5fde74d6bb3cc2}.

\index{ZeroSock@{ZeroSock}!Recv@{Recv}}
\index{Recv@{Recv}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Recv()}
{\footnotesize\ttfamily \label{class_zero_sock_acc57da900d09bf26675b155ff9f4ac89} 
ssize\+\_\+t Recv (\begin{DoxyParamCaption}\item[{void $\ast$}]{buf}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

recv(2) wrapper. Equivalent to {\ttfamily recv(m\+\_\+socket, buf, len, flags);}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_ad5d478226aba69810d73757744e13317}.

\index{ZeroSock@{ZeroSock}!Send@{Send}}
\index{Send@{Send}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Send()}
{\footnotesize\ttfamily \label{class_zero_sock_a9261d901e7024d8f9678d2fb9b0e1788} 
ssize\+\_\+t Send (\begin{DoxyParamCaption}\item[{const void $\ast$}]{data}{, }\item[{size\+\_\+t}]{len}{, }\item[{int}]{flags}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

send(2) wrapper. Equivalent to {\ttfamily send(m\+\_\+socket, data, len, flags);}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_ad50f4b43d2b968d64162193e9254d6b5}.

\index{ZeroSock@{ZeroSock}!SetNonBlocking@{SetNonBlocking}}
\index{SetNonBlocking@{SetNonBlocking}!ZeroSock@{ZeroSock}}
\doxysubsubsection{SetNonBlocking()}
{\footnotesize\ttfamily \label{class_zero_sock_a8a6517d31b9c4c9a895c1cbb83387c86} 
bool Set\+Non\+Blocking (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Set the non-\/blocking option on the socket. \begin{DoxyReturn}{Returns}
true if set successfully 
\end{DoxyReturn}


Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a11c30b8078693d82b98b44a8b81bb71d}.

\index{ZeroSock@{ZeroSock}!SetSockOpt@{SetSockOpt}}
\index{SetSockOpt@{SetSockOpt}!ZeroSock@{ZeroSock}}
\doxysubsubsection{SetSockOpt()}
{\footnotesize\ttfamily \label{class_zero_sock_a94f895afc687c06525ac15ccb10ce2b0} 
int Set\+Sock\+Opt (\begin{DoxyParamCaption}\item[{int}]{level}{, }\item[{int}]{opt\+\_\+name}{, }\item[{const void $\ast$}]{opt\+\_\+val}{, }\item[{socklen\+\_\+t}]{opt\+\_\+len}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

setsockopt(2) wrapper. Equivalent to {\ttfamily setsockopt(m\+\_\+socket, level, opt\+\_\+name, opt\+\_\+val, opt\+\_\+len)}. Code that uses this wrapper can be unit tested if this method is overridden by a mock \doxyref{Sock}{p.}{class_sock} implementation. 

Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a72351052778d8f7107546f9e32159dc9}.

\index{ZeroSock@{ZeroSock}!Wait@{Wait}}
\index{Wait@{Wait}!ZeroSock@{ZeroSock}}
\doxysubsubsection{Wait()}
{\footnotesize\ttfamily \label{class_zero_sock_aa9d44903b57505d9f8765404cb04f35f} 
bool Wait (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ Event}}]{requested}{, }\item[{\textbf{ Event} $\ast$}]{occurred}{ = {\ttfamily nullptr}}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Wait for readiness for input (recv) or output (send). 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em timeout} & Wait this much for at least one of the requested events to occur. \\
\hline
\mbox{\texttt{in}}  & {\em requested} & Wait for those events, bitwise-\/or of {\ttfamily \doxyref{RECV}{p.}{class_sock_ae15d539512bccb6583fc75310b0d2f86}} and {\ttfamily \doxyref{SEND}{p.}{class_sock_ac739f9398eaa67718961a5ac331fba4a}}. \\
\hline
\mbox{\texttt{out}}  & {\em occurred} & If not nullptr and the function returns {\ttfamily true}, then this indicates which of the requested events occurred ({\ttfamily \doxyref{ERR}{p.}{class_sock_a2d9bf7f3d9855e98e28b9224cab3920e}} will be added, even if not requested, if an exceptional event occurs on the socket). A timeout is indicated by return value of {\ttfamily true} and {\ttfamily occurred} being set to 0. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success (or timeout, if {\ttfamily occurred} of 0 is returned), false otherwise 
\end{DoxyReturn}


Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a851a09613d347a157da032137020065a}.

\index{ZeroSock@{ZeroSock}!WaitMany@{WaitMany}}
\index{WaitMany@{WaitMany}!ZeroSock@{ZeroSock}}
\doxysubsubsection{WaitMany()}
{\footnotesize\ttfamily \label{class_zero_sock_af35a7663942bba32c947f387114bc068} 
bool Wait\+Many (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{timeout}{, }\item[{\textbf{ Events\+Per\+Sock} \&}]{events\+\_\+per\+\_\+sock}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Same as {\ttfamily \doxyref{Wait()}{p.}{class_zero_sock_aa9d44903b57505d9f8765404cb04f35f}}, but wait on many sockets within the same timeout. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em timeout} & Wait this long for at least one of the requested events to occur. \\
\hline
\mbox{\texttt{in,out}}  & {\em events\+\_\+per\+\_\+sock} & Wait for the requested events on these sockets and set {\ttfamily occurred} for the events that actually occurred. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success (or timeout, if all {\ttfamily what[].occurred} are returned as 0), false otherwise 
\end{DoxyReturn}


Reimplemented from \textbf{ Sock} \doxyref{}{p.}{class_sock_a6ec7a34cbf87594ed9b7eac590cf965f}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/test/util/\textbf{ net.\+h}\item 
src/test/util/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
