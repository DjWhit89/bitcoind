\doxysection{Thread\+Context Struct Reference}
\label{structmp_1_1_thread_context}\index{ThreadContext@{ThreadContext}}


{\ttfamily \#include $<$proxy-\/io.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Conn\+Threads} callback\+\_\+threads \textbf{ MP\+\_\+\+GUARDED\+\_\+\+BY} (\textbf{ waiter}-\/$>$m\+\_\+mutex)
\item 
\textbf{ Conn\+Threads} request\+\_\+threads \textbf{ MP\+\_\+\+GUARDED\+\_\+\+BY} (\textbf{ waiter}-\/$>$m\+\_\+mutex)
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ thread\+\_\+name}
\begin{DoxyCompactList}\small\item\em Identifying string for debug. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Waiter} $>$ \textbf{ waiter} = nullptr
\item 
bool \textbf{ loop\+\_\+thread} = false
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The thread\+\_\+local \doxyref{Thread\+Context}{p.}{structmp_1_1_thread_context} g\+\_\+thread\+\_\+context struct provides information about individual threads and a way of communicating between them. Because it\textquotesingle{}s a thread local struct, each \doxyref{Thread\+Context}{p.}{structmp_1_1_thread_context} instance is initialized by the thread that owns it.

\doxyref{Thread\+Context}{p.}{structmp_1_1_thread_context} is used for any client threads created externally which make IPC calls, and for server threads created by \doxyref{Proxy\+Server$<$\+Thread\+Map$>$\+::make\+Thread()}{p.}{structmp_1_1_proxy_server_3_01_thread_map_01_4_a9019e0dfdcbbdf27a37291c74ee5da21} which execute IPC calls for clients.

In both cases, the struct holds information like the thread name, and a \doxyref{Waiter}{p.}{structmp_1_1_waiter} object where the \doxyref{Event\+Loop}{p.}{classmp_1_1_event_loop} can post incoming IPC requests to execute on the thread. The struct also holds \doxyref{Conn\+Thread}{p.}{namespacemp_a4c23514105673e30f7c1f46afc594ece} maps associating the thread with local and remote \doxyref{Proxy\+Client$<$\+Thread$>$}{p.}{structmp_1_1_proxy_client_3_01_thread_01_4} objects. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{ThreadContext@{ThreadContext}!MP\_GUARDED\_BY@{MP\_GUARDED\_BY}}
\index{MP\_GUARDED\_BY@{MP\_GUARDED\_BY}!ThreadContext@{ThreadContext}}
\doxysubsubsection{MP\_GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{structmp_1_1_thread_context_ad7d4449836b9c614cb977a93f75c4290} 
\textbf{ Conn\+Threads} request\+\_\+threads MP\+\_\+\+GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ waiter}-\/$>$}]{m\+\_\+mutex}{}\end{DoxyParamCaption})}

When client is making a request to a server, this is the {\ttfamily thread} argument it passes in the request, used to control which thread on server will be responsible for executing it. If client call is being made from a local thread, this will be a remote thread object returned by make\+Thread. If a client call is being made from a thread currently handling a server request, this will be set to the {\ttfamily callback\+Thread} request thread argument passed in that request.

Synchronization note\+: callback\+\_\+threads note applies here as well. \index{ThreadContext@{ThreadContext}!MP\_GUARDED\_BY@{MP\_GUARDED\_BY}}
\index{MP\_GUARDED\_BY@{MP\_GUARDED\_BY}!ThreadContext@{ThreadContext}}
\doxysubsubsection{MP\_GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{structmp_1_1_thread_context_a9c938bed0c537f793043396cf41dfeab} 
\textbf{ Conn\+Threads} callback\+\_\+threads MP\+\_\+\+GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ waiter}-\/$>$}]{m\+\_\+mutex}{}\end{DoxyParamCaption})}

When client is making a request to a server, this is the {\ttfamily callback\+Thread} argument it passes in the request, used by the server in case it needs to make callbacks into the client that need to execute while the client is waiting. This will be set to a local thread object.

Synchronization note\+: The callback\+\_\+thread and request\+\_\+thread maps are only ever accessed internally by this thread\textquotesingle{}s destructor and externally by Cap\textquotesingle{}n Proto event loop threads. Since it\textquotesingle{}s possible for IPC client threads to make calls over different connections that could have different event loops, these maps are guarded by \doxyref{Waiter\+::m\+\_\+mutex}{p.}{structmp_1_1_waiter_a71aaf23d91d7b7a5611738c4f06e3577} in case different event loop threads add or remove map entries simultaneously. However, individual \doxyref{Proxy\+Client$<$\+Thread$>$}{p.}{structmp_1_1_proxy_client_3_01_thread_01_4} objects in the maps will only be associated with one event loop and guarded by \doxyref{Event\+Loop\+::m\+\_\+mutex}{p.}{classmp_1_1_event_loop_a71aaf23d91d7b7a5611738c4f06e3577}. So \doxyref{Waiter\+::m\+\_\+mutex}{p.}{structmp_1_1_waiter_a71aaf23d91d7b7a5611738c4f06e3577} does not need to be held while accessing individual \doxyref{Proxy\+Client$<$\+Thread$>$}{p.}{structmp_1_1_proxy_client_3_01_thread_01_4} instances, and may even need to be released to respect lock order and avoid locking \doxyref{Waiter\+::m\+\_\+mutex}{p.}{structmp_1_1_waiter_a71aaf23d91d7b7a5611738c4f06e3577} before \doxyref{Event\+Loop\+::m\+\_\+mutex}{p.}{classmp_1_1_event_loop_a71aaf23d91d7b7a5611738c4f06e3577}. 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{ThreadContext@{ThreadContext}!loop\_thread@{loop\_thread}}
\index{loop\_thread@{loop\_thread}!ThreadContext@{ThreadContext}}
\doxysubsubsection{loop\_thread}
{\footnotesize\ttfamily \label{structmp_1_1_thread_context_a370e26772b89031ea6428652997e3c91} 
bool loop\+\_\+thread = false}

Whether this thread is a capnp event loop thread. Not really used except to assert false if there\textquotesingle{}s an attempt to execute a blocking operation which could deadlock the thread. \index{ThreadContext@{ThreadContext}!thread\_name@{thread\_name}}
\index{thread\_name@{thread\_name}!ThreadContext@{ThreadContext}}
\doxysubsubsection{thread\_name}
{\footnotesize\ttfamily \label{structmp_1_1_thread_context_af22159ec9e33831372abc5e43e4944f9} 
std\+::string thread\+\_\+name}



Identifying string for debug. 

\index{ThreadContext@{ThreadContext}!waiter@{waiter}}
\index{waiter@{waiter}!ThreadContext@{ThreadContext}}
\doxysubsubsection{waiter}
{\footnotesize\ttfamily \label{structmp_1_1_thread_context_ab283ccca525d24f19bd1860fa2836783} 
std\+::unique\+\_\+ptr$<$\textbf{ Waiter}$>$ waiter = nullptr}

\doxyref{Waiter}{p.}{structmp_1_1_waiter} object used to allow remote clients to execute code on this thread. For server threads created by \doxyref{Proxy\+Server$<$\+Thread\+Map$>$\+::make\+Thread()}{p.}{structmp_1_1_proxy_server_3_01_thread_map_01_4_a9019e0dfdcbbdf27a37291c74ee5da21}, this is initialized in that function. Otherwise, for client threads created externally, this is initialized the first time the thread tries to make an IPC call. Having a waiter is necessary for threads making IPC calls in case a server they are calling expects them to execute a callback during the call, before it sends a response.

For IPC client threads, the \doxyref{Waiter}{p.}{structmp_1_1_waiter} pointer is never cleared and the \doxyref{Waiter}{p.}{structmp_1_1_waiter} just gets destroyed when the thread does. For server threads created by make\+Thread(), this pointer is set to null in the $\sim$\+Proxy\+Server$<$\+Thread$>$ as a signal for the thread to exit and destroy itself. In both cases, the same \doxyref{Waiter}{p.}{structmp_1_1_waiter} object is used across different calls and only created and destroyed once for the lifetime of the thread. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/ipc/libmultiprocess/include/mp/\textbf{ proxy-\/io.\+h}\end{DoxyCompactItemize}
