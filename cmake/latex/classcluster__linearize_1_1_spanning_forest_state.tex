\doxysection{Spanning\+Forest\+State$<$ Set\+Type $>$ Class Template Reference}
\label{classcluster__linearize_1_1_spanning_forest_state}\index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}


{\ttfamily \#include $<$cluster\+\_\+linearize.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Spanning\+Forest\+State} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph, uint64\+\_\+t rng\+\_\+seed) noexcept
\item 
void \textbf{ Load\+Linearization} (std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$ old\+\_\+linearization) noexcept
\item 
void \textbf{ Make\+Topological} () noexcept
\item 
void \textbf{ Start\+Optimizing} () noexcept
\item 
bool \textbf{ Optimize\+Step} () noexcept
\item 
std\+::vector$<$ \textbf{ Dep\+Graph\+Index} $>$ \textbf{ Get\+Linearization} () noexcept
\item 
std\+::vector$<$ \textbf{ Fee\+Frac} $>$ \textbf{ Get\+Diagram} () const noexcept
\item 
uint64\+\_\+t \textbf{ Get\+Cost} () const noexcept
\item 
void \textbf{ Sanity\+Check} (const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&depgraph) const
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Set\+Type$>$\newline
class cluster\+\_\+linearize\+::\+Spanning\+Forest\+State$<$ Set\+Type $>$}
Class to represent the internal state of the spanning-\/forest linearization (SFL) algorithm.

At all times, each dependency is marked as either "{}active"{} or "{}inactive"{}. The subset of active dependencies is the state of the SFL algorithm. The implementation maintains several other values to speed up operations, but everything is ultimately a function of what that subset of active dependencies is.

Given such a subset, define a chunk as the set of transactions that are connected through active dependencies (ignoring their parent/child direction). Thus, every state implies a particular partitioning of the graph into chunks (including potential singletons). In the extreme, each transaction may be in its own chunk, or in the other extreme all transactions may form a single chunk. A chunk\textquotesingle{}s feerate is its total fee divided by its total size.

The algorithm consists of switching dependencies between active and inactive. The final linearization that is produced at the end consists of these chunks, sorted from high to low feerate, each individually sorted in an arbitrary but topological (= no child before parent) way.

We define three quality properties the state can have, each being stronger than the previous\+:


\begin{DoxyItemize}
\item acyclic\+: The state is acyclic whenever no cycle of active dependencies exists within the graph, ignoring the parent/child direction. This is equivalent to saying that within each chunk the set of active dependencies form a tree, and thus the overall set of active dependencies in the graph form a spanning forest, giving the algorithm its name. Being acyclic is also equivalent to every chunk of N transactions having exactly N-\/1 active dependencies.

For example in a diamond graph, D-\/$>$\{B,C\}-\/$>$A, the 4 dependencies cannot be simultaneously active. If at least one is inactive, the state is acyclic.

The algorithm maintains an acyclic state at {\itshape all} times as an invariant. This implies that activating a dependency always corresponds to merging two chunks, and that deactivating one always corresponds to splitting two chunks.
\item topological\+: We say the state is topological whenever it is acyclic and no inactive dependency exists between two distinct chunks such that the child chunk has higher or equal feerate than the parent chunk.

The relevance is that whenever the state is topological, the produced output linearization will be topological too (i.\+e., not have children before parents). Note that the "{}or equal"{} part of the definition matters\+: if not, one can end up in a situation with mutually-\/dependent equal-\/feerate chunks that cannot be linearized. For example C-\/$>$\{A,B\} and D-\/$>$\{A,B\}, with C-\/$>$A and D-\/$>$B active. The AC chunk depends on \doxyref{DB}{p.}{class_d_b} through C-\/$>$B, and the BD chunk depends on AC through D-\/$>$A. Merging them into a single ABCD chunk fixes this.

The algorithm attempts to keep the state topological as much as possible, so it can be interrupted to produce an output whenever, but will sometimes need to temporarily deviate from it when improving the state.
\item optimal\+: For every active dependency, define its top and bottom set as the set of transactions in the chunks that would result if the dependency were deactivated; the top being the one with the dependency\textquotesingle{}s parent, and the bottom being the one with the child. Note that due to acyclicity, every deactivation splits a chunk exactly in two.

We say the state is optimal whenever it is topological and it has no active dependency whose top feerate is strictly higher than its bottom feerate. The relevance is that it can be proven that whenever the state is optimal, the produced linearization will also be optimal (in the convexified feerate diagram sense). It can also be proven that for every graph at least one optimal state exists.

Note that it is possible for the SFL state to not be optimal, but the produced linearization to still be optimal. This happens when the chunks of a state are identical to those of an optimal state, but the exact set of active dependencies within a chunk differ in such a way that the state optimality condition is not satisfied. Thus, the state being optimal is more a "{}the eventual output is $\ast$known$\ast$            to be optimal"{}.

The algorithm terminates whenever an optimal state is reached.
\end{DoxyItemize}

This leads to the following high-\/level algorithm\+:
\begin{DoxyItemize}
\item Start with all dependencies inactive, and thus all transactions in their own chunk. This is definitely acyclic.
\item Activate dependencies (merging chunks) until the state is topological.
\item Loop until optimal (no dependencies with higher-\/feerate top than bottom), or time runs out\+:
\begin{DoxyItemize}
\item Deactivate a violating dependency, potentially making the state non-\/topological.
\item Activate other dependencies to make the state topological again.
\end{DoxyItemize}
\item Output the chunks from high to low feerate, each internally sorted topologically.
\end{DoxyItemize}

When merging, we always either\+:
\begin{DoxyItemize}
\item Merge upwards\+: merge a chunk with the lowest-\/feerate other chunk it depends on, among those with lower or equal feerate than itself.
\item Merge downwards\+: merge a chunk with the highest-\/feerate other chunk that depends on it, among those with higher or equal feerate than itself.
\end{DoxyItemize}

Using these strategies in the improvement loop above guarantees that the output linearization after a deactivate + merge step is never worse or incomparable (in the convexified feerate diagram sense) than the output linearization that would be produced before the step. With that, we can refine the high-\/level algorithm to\+:
\begin{DoxyItemize}
\item Start with all dependencies inactive.
\item Perform merges as described until none are possible anymore, making the state topological.
\item Loop until optimal or time runs out\+:
\begin{DoxyItemize}
\item Pick a dependency D to deactivate among those with higher feerate top than bottom.
\item Deactivate D, causing the chunk it is in to split into top T and bottom B.
\item Do an upwards merge of T, if possible. If so, repeat the same with the merged result.
\item Do a downwards merge of B, if possible. If so, repeat the same with the merged result.
\end{DoxyItemize}
\item Output the chunks from high to low feerate, each internally sorted topologically.
\end{DoxyItemize}

Instead of performing merges arbitrarily to make the initial state topological, it is possible to do so guided by an existing linearization. This has the advantage that the state\textquotesingle{}s would-\/be output linearization is immediately as good as the existing linearization it was based on\+:
\begin{DoxyItemize}
\item Start with all dependencies inactive.
\item For each transaction t in the existing linearization\+:
\begin{DoxyItemize}
\item Find the chunk C that transaction is in (which will be singleton).
\item Do an upwards merge of C, if possible. If so, repeat the same with the merged result. No downwards merges are needed in this case.
\end{DoxyItemize}
\end{DoxyItemize}

What remains to be specified are a number of heuristics\+:


\begin{DoxyItemize}
\item How to decide which chunks to merge\+:
\begin{DoxyItemize}
\item The merge upwards and downward rules specify that the lowest-\/feerate respectively highest-\/feerate candidate chunk is merged with, but if there are multiple equal-\/feerate candidates, a uniformly random one among them is picked.
\end{DoxyItemize}
\item How to decide what dependency to activate (when merging chunks)\+:
\begin{DoxyItemize}
\item After picking two chunks to be merged (see above), a uniformly random dependency between the two chunks is activated.
\end{DoxyItemize}
\item How to decide which chunk to find a dependency to split in\+:
\begin{DoxyItemize}
\item A round-\/robin queue of chunks to improve is maintained. The initial ordering of this queue is uniformly randomly permuted.
\end{DoxyItemize}
\item How to decide what dependency to deactivate (when splitting chunks)\+:
\begin{DoxyItemize}
\item Inside the selected chunk (see above), among the dependencies whose top feerate is strictly higher than its bottom feerate in the selected chunk, if any, a uniformly random dependency is deactivated.
\end{DoxyItemize}
\item How to decide the exact output linearization\+:
\begin{DoxyItemize}
\item When there are multiple equal-\/feerate chunks with no dependencies between them, output a uniformly random one among the ones with no missing dependent chunks first.
\item Within chunks, repeatedly pick a uniformly random transaction among those with no missing dependencies. 
\end{DoxyItemize}
\end{DoxyItemize}

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!SpanningForestState@{SpanningForestState}}
\index{SpanningForestState@{SpanningForestState}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{SpanningForestState()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_a99e10087e4faff7a5779e76f0f90100f} 
template$<$typename Set\+Type$>$ \\
Spanning\+Forest\+State (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{, }\item[{uint64\+\_\+t}]{rng\+\_\+seed}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}, {\ttfamily [noexcept]}}

Construct a spanning forest for the given \doxyref{Dep\+Graph}{p.}{classcluster__linearize_1_1_dep_graph}, with every transaction in its own chunk (not topological). 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!GetCost@{GetCost}}
\index{GetCost@{GetCost}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{GetCost()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_a3f2da53fd4decdf7cfaa45d15b50fe3d} 
template$<$typename Set\+Type$>$ \\
uint64\+\_\+t Get\+Cost (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Determine how much work was performed so far. \index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!GetDiagram@{GetDiagram}}
\index{GetDiagram@{GetDiagram}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{GetDiagram()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_af0e6a44de93624003ce97ebf594aae4e} 
template$<$typename Set\+Type$>$ \\
std\+::vector$<$ \textbf{ Fee\+Frac} $>$ Get\+Diagram (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Get the diagram for the current state, which must be topological. Test-\/only.

The linearization produced by \doxyref{Get\+Linearization()}{p.}{classcluster__linearize_1_1_spanning_forest_state_a444fd02b9f97e5d7f97fa42965d721ec} is always at least as good (in the \doxyref{Compare\+Chunks()}{p.}{util_2feefrac_8cpp_ac6b51471a8ec142402968632e02bbfe5} sense) as this diagram, but may be better.

After an \doxyref{Optimize\+Step()}{p.}{classcluster__linearize_1_1_spanning_forest_state_af6b5a7d19cadd4d6a59d0caa63cd03b6}, the diagram will always be at least as good as before. Once \doxyref{Optimize\+Step()}{p.}{classcluster__linearize_1_1_spanning_forest_state_af6b5a7d19cadd4d6a59d0caa63cd03b6} returns false, the diagram will be equivalent to that produced by \doxyref{Get\+Linearization()}{p.}{classcluster__linearize_1_1_spanning_forest_state_a444fd02b9f97e5d7f97fa42965d721ec}, and optimal. \index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!GetLinearization@{GetLinearization}}
\index{GetLinearization@{GetLinearization}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{GetLinearization()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_a444fd02b9f97e5d7f97fa42965d721ec} 
template$<$typename Set\+Type$>$ \\
std\+::vector$<$ \textbf{ Dep\+Graph\+Index} $>$ Get\+Linearization (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Construct a topologically-\/valid linearization from the current forest state. Must be topological. The output linearization.

A heap with all chunks (by representative) that can currently be included, sorted by chunk feerate and a random tie-\/breaker.

Information about chunks\+:
\begin{DoxyItemize}
\item The first value is only used for chunk representatives, and counts the number of unmet dependencies this chunk has on other chunks (not including dependencies within the chunk itself).
\item The second value is the number of unmet dependencies overall.
\end{DoxyItemize}

The set of all chunk representatives.

A list with all transactions within the current chunk that can be included.

Comparison function for the heap.\index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!LoadLinearization@{LoadLinearization}}
\index{LoadLinearization@{LoadLinearization}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{LoadLinearization()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_a6fd1ccc234cce3b9aaa7738e0d2fb364} 
template$<$typename Set\+Type$>$ \\
void Load\+Linearization (\begin{DoxyParamCaption}\item[{std\+::span$<$ const \textbf{ Dep\+Graph\+Index} $>$}]{old\+\_\+linearization}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Load an existing linearization. Must be called immediately after constructor. The result is topological if the linearization is valid. Otherwise, Make\+Topological still needs to be called. \index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!MakeTopological@{MakeTopological}}
\index{MakeTopological@{MakeTopological}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{MakeTopological()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_aee465890767b94947e60205811ec4885} 
template$<$typename Set\+Type$>$ \\
void Make\+Topological (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Make state topological. Can be called after constructing, or after Load\+Linearization. \index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!OptimizeStep@{OptimizeStep}}
\index{OptimizeStep@{OptimizeStep}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{OptimizeStep()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_af6b5a7d19cadd4d6a59d0caa63cd03b6} 
template$<$typename Set\+Type$>$ \\
bool Optimize\+Step (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Try to improve the forest. Returns false if it is optimal, true otherwise. \index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!SanityCheck@{SanityCheck}}
\index{SanityCheck@{SanityCheck}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{SanityCheck()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_a9b196bf02d22db423ce35383355824ed} 
template$<$typename Set\+Type$>$ \\
void Sanity\+Check (\begin{DoxyParamCaption}\item[{const \textbf{ Dep\+Graph}$<$ Set\+Type $>$ \&}]{depgraph}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Verify internal consistency of the data structure. \index{SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}!StartOptimizing@{StartOptimizing}}
\index{StartOptimizing@{StartOptimizing}!SpanningForestState$<$ SetType $>$@{SpanningForestState$<$ SetType $>$}}
\doxysubsubsection{StartOptimizing()}
{\footnotesize\ttfamily \label{classcluster__linearize_1_1_spanning_forest_state_a803f9f1a5a058d2b363b4ed1b8b7e4fa} 
template$<$typename Set\+Type$>$ \\
void Start\+Optimizing (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Initialize the data structure for optimization. It must be topological already. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ cluster\+\_\+linearize.\+h}\end{DoxyCompactItemize}
