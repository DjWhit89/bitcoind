\doxysection{Mu\+Hash3072 Class Reference}
\label{class_mu_hash3072}\index{MuHash3072@{MuHash3072}}


{\ttfamily \#include $<$muhash.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Mu\+Hash3072} () noexcept=default
\item 
\textbf{ Mu\+Hash3072} (std\+::span$<$ const unsigned char $>$ in) noexcept
\item 
\textbf{ Mu\+Hash3072} \& \textbf{ Insert} (std\+::span$<$ const unsigned char $>$ in) noexcept
\item 
\textbf{ Mu\+Hash3072} \& \textbf{ Remove} (std\+::span$<$ const unsigned char $>$ in) noexcept
\item 
\textbf{ Mu\+Hash3072} \& \textbf{ operator$\ast$=} (const \textbf{ Mu\+Hash3072} \&mul) noexcept
\item 
\textbf{ Mu\+Hash3072} \& \textbf{ operator/=} (const \textbf{ Mu\+Hash3072} \&div) noexcept
\item 
void \textbf{ Finalize} (\textbf{ uint256} \&out) noexcept
\item 
\textbf{ SERIALIZE\+\_\+\+METHODS} (\textbf{ Mu\+Hash3072}, obj)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A class representing Mu\+Hash sets

Mu\+Hash is a hashing algorithm that supports adding set elements in any order but also deleting in any order. As a result, it can maintain a running sum for a set of data as a whole, and add/remove when data is added to or removed from it. A downside of Mu\+Hash is that computing an inverse is relatively expensive. This is solved by representing the running value as a fraction, and multiplying added elements into the numerator and removed elements into the denominator. Only when the final hash is desired, a single modular inverse and multiplication is needed to combine the two. The combination is also run on serialization to allow for space-\/efficient storage on disk.

As the update operations are also associative, H(a)+H(b)+H(c)+H(d) can in fact be computed as (H(a)+H(b)) + (H(c)+H(d)). This implies that all of this is perfectly parallellizable\+: each thread can process an arbitrary subset of the update operations, allowing them to be efficiently combined later.

Mu\+Hash does not support checking if an element is already part of the set. That is why this class does not enforce the use of a set as the data it represents because there is no efficient way to do so. It is possible to add elements more than once and also to remove elements that have not been added before. However, this implementation is intended to represent a set of elements.

See also {\texttt{https\+://cseweb.\+ucsd.\+edu/$\sim$mihir/papers/inchash.\+pdf}} and {\texttt{https\+://lists.\+linuxfoundation.\+org/pipermail/bitcoin-\/dev/2017-\/\+May/014337.\+html}}. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{MuHash3072@{MuHash3072}!MuHash3072@{MuHash3072}}
\index{MuHash3072@{MuHash3072}!MuHash3072@{MuHash3072}}
\doxysubsubsection{MuHash3072()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_mu_hash3072_a16e7a7077e689885dd9e3ea6640d876c} 
\textbf{ Mu\+Hash3072} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{MuHash3072@{MuHash3072}!MuHash3072@{MuHash3072}}
\index{MuHash3072@{MuHash3072}!MuHash3072@{MuHash3072}}
\doxysubsubsection{MuHash3072()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_mu_hash3072_a7a34e945e30839e4ab8b4d0ab93faaeb} 
\textbf{ Mu\+Hash3072} (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{in}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}, {\ttfamily [noexcept]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{MuHash3072@{MuHash3072}!Finalize@{Finalize}}
\index{Finalize@{Finalize}!MuHash3072@{MuHash3072}}
\doxysubsubsection{Finalize()}
{\footnotesize\ttfamily \label{class_mu_hash3072_aaf553bdcaf192d70d6aee9e3d1398591} 
void Finalize (\begin{DoxyParamCaption}\item[{\textbf{ uint256} \&}]{out}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{MuHash3072@{MuHash3072}!Insert@{Insert}}
\index{Insert@{Insert}!MuHash3072@{MuHash3072}}
\doxysubsubsection{Insert()}
{\footnotesize\ttfamily \label{class_mu_hash3072_a9264c355b28413b53ee52cb7329c50e9} 
\textbf{ Mu\+Hash3072} \& Insert (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{in}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{MuHash3072@{MuHash3072}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!MuHash3072@{MuHash3072}}
\doxysubsubsection{operator$\ast$=()}
{\footnotesize\ttfamily \label{class_mu_hash3072_a0de74337c40572d25edba079a61c68af} 
\textbf{ Mu\+Hash3072} \& operator$\ast$= (\begin{DoxyParamCaption}\item[{const \textbf{ Mu\+Hash3072} \&}]{mul}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{MuHash3072@{MuHash3072}!operator/=@{operator/=}}
\index{operator/=@{operator/=}!MuHash3072@{MuHash3072}}
\doxysubsubsection{operator/=()}
{\footnotesize\ttfamily \label{class_mu_hash3072_a74d9dd32a7557167eaa1a0e0ee80bc65} 
\textbf{ Mu\+Hash3072} \& operator/= (\begin{DoxyParamCaption}\item[{const \textbf{ Mu\+Hash3072} \&}]{div}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{MuHash3072@{MuHash3072}!Remove@{Remove}}
\index{Remove@{Remove}!MuHash3072@{MuHash3072}}
\doxysubsubsection{Remove()}
{\footnotesize\ttfamily \label{class_mu_hash3072_a4f02b7cb787350911ac2e7814b245b53} 
\textbf{ Mu\+Hash3072} \& Remove (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{in}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{MuHash3072@{MuHash3072}!SERIALIZE\_METHODS@{SERIALIZE\_METHODS}}
\index{SERIALIZE\_METHODS@{SERIALIZE\_METHODS}!MuHash3072@{MuHash3072}}
\doxysubsubsection{SERIALIZE\_METHODS()}
{\footnotesize\ttfamily \label{class_mu_hash3072_a334a84f41b9d0342cc99dc5103c10d9a} 
SERIALIZE\+\_\+\+METHODS (\begin{DoxyParamCaption}\item[{\textbf{ Mu\+Hash3072}}]{}{, }\item[{obj}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/crypto/\textbf{ muhash.\+h}\item 
src/crypto/\textbf{ muhash.\+cpp}\end{DoxyCompactItemize}
