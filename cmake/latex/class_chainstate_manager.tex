\doxysection{Chainstate\+Manager Class Reference}
\label{class_chainstate_manager}\index{ChainstateManager@{ChainstateManager}}


{\ttfamily \#include $<$validation.\+h$>$}

Inheritance diagram for Chainstate\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_chainstate_manager}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Options} = \textbf{ kernel\+::\+Chainstate\+Manager\+Opts}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Chainstate\+Manager} (const \textbf{ util\+::\+Signal\+Interrupt} \&interrupt, \textbf{ Options}\textbf{ Options} options, \textbf{ node\+::\+Block\+Manager\+::\+Options} blockman\+\_\+options)
\item 
const \textbf{ CChain\+Params} \& \textbf{ Get\+Params} () const
\item 
const \textbf{ Consensus\+::\+Params} \& \textbf{ Get\+Consensus} () const
\item 
bool \textbf{ Should\+Check\+Block\+Index} () const
\item 
const \textbf{ arith\+\_\+uint256} \& \textbf{ Minimum\+Chain\+Work} () const
\item 
const \textbf{ uint256} \& \textbf{ Assumed\+Valid\+Block} () const
\item 
\textbf{ kernel\+::\+Notifications} \& \textbf{ Get\+Notifications} () const
\item 
void \textbf{ Check\+Block\+Index} () const
\item 
\textbf{ Recursive\+Mutex} \& \textbf{ Get\+Mutex} () const \textbf{ LOCK\+\_\+\+RETURNED}(
\item 
int32\+\_\+t n\+Block\+Sequence\+Id \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
void \textbf{ Reset\+Block\+Sequence\+Counters} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\item 
\textbf{ CBlock\+Index} $\ast$m\+\_\+best\+\_\+header \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
\textbf{ Chainstate} $\ast$ \textbf{ Historical\+Chainstate} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\begin{DoxyCompactList}\small\item\em Return historical chainstate targeting a specific block, if any. \end{DoxyCompactList}\item 
\textbf{ Chainstate} \& \textbf{ Validated\+Chainstate} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Chainstate} $>$ \textbf{ Remove\+Chainstate} (\textbf{ Chainstate} \&chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\begin{DoxyCompactList}\small\item\em Remove a chainstate. \end{DoxyCompactList}\item 
\textbf{ node\+::\+Block\+Map} \& \textbf{ Block\+Index} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(
\item 
bool \textbf{ Is\+Initial\+Block\+Download} () const
\item 
double \textbf{ Guess\+Verification\+Progress} (const \textbf{ CBlock\+Index} $\ast$pindex) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\item 
void \textbf{ Load\+External\+Block\+File} (\textbf{ Auto\+File} \&file\+\_\+in, \textbf{ Flat\+File\+Pos} $\ast$dbp=nullptr, std\+::multimap$<$ \textbf{ uint256}, \textbf{ Flat\+File\+Pos} $>$ $\ast$blocks\+\_\+with\+\_\+unknown\+\_\+parent=nullptr)
\item 
bool \textbf{ Process\+New\+Block} (const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block, bool force\+\_\+processing, bool min\+\_\+pow\+\_\+checked, bool $\ast$new\+\_\+block) \textbf{ LOCKS\+\_\+\+EXCLUDED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ Process\+New\+Block\+Headers} (std\+::span$<$ const \textbf{ CBlock\+Header} $>$ headers, bool min\+\_\+pow\+\_\+checked, \textbf{ Block\+Validation\+State} \&state, const \textbf{ CBlock\+Index} $\ast$$\ast$ppindex=nullptr) \textbf{ LOCKS\+\_\+\+EXCLUDED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ Accept\+Block} (const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&pblock, \textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} $\ast$$\ast$ppindex, bool f\+Requested, const \textbf{ Flat\+File\+Pos} $\ast$dbp, bool $\ast$f\+New\+Block, bool min\+\_\+pow\+\_\+checked) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Received\+Block\+Transactions} (const \textbf{ CBlock} \&block, \textbf{ CBlock\+Index} $\ast$pindex\+New, const \textbf{ Flat\+File\+Pos} \&pos) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
\textbf{ Mempool\+Accept\+Result} \textbf{ Process\+Transaction} (const \textbf{ CTransaction\+Ref} \&tx, bool test\+\_\+accept=false) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool \textbf{ Load\+Block\+Index} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\begin{DoxyCompactList}\small\item\em Load the block tree and coins database from disk, initializing state if we\textquotesingle{}re running with -\/reindex. \end{DoxyCompactList}\item 
void Maybe\+Rebalance\+Caches() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void \textbf{ Update\+Uncommitted\+Block\+Structures} (\textbf{ CBlock} \&block, const \textbf{ CBlock\+Index} $\ast$pindex\+Prev) const
\item 
std\+::vector$<$ unsigned char $>$ \textbf{ Generate\+Coinbase\+Commitment} (\textbf{ CBlock} \&block, const \textbf{ CBlock\+Index} $\ast$pindex\+Prev) const
\item 
void \textbf{ Report\+Headers\+Presync} (const \textbf{ arith\+\_\+uint256} \&work, int64\+\_\+t height, int64\+\_\+t timestamp)
\item 
\textbf{ $\sim$\+Chainstate\+Manager} ()
\item 
std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \textbf{ Chainstate} $>$ $>$ m\+\_\+chainstates \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\end{DoxyCompactItemize}
\textbf{ }\par
\begin{DoxyCompactItemize}
\item 
\textbf{ Chainstate} \& \textbf{ Active\+Chainstate} () const
\item 
\textbf{ CChain} \& \textbf{ Active\+Chain} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\item 
int \textbf{ Active\+Height} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\item 
\textbf{ CBlock\+Index} $\ast$ \textbf{ Active\+Tip} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\end{DoxyCompactItemize}

\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
std\+::function$<$ void()$>$ \textbf{ snapshot\+\_\+download\+\_\+completed} = std\+::function$<$void()$>$()
\item 
const \textbf{ util\+::\+Signal\+Interrupt} \& \textbf{ m\+\_\+interrupt}
\item 
const \textbf{ Options}\textbf{ Options} \textbf{ m\+\_\+options}
\item 
\textbf{ node\+::\+Block\+Manager} \textbf{ m\+\_\+blockman}
\item 
\textbf{ Validation\+Cache} \textbf{ m\+\_\+validation\+\_\+cache}
\item 
std\+::atomic$<$ bool $>$ \textbf{ m\+\_\+cached\+\_\+finished\+\_\+ibd} \{false\}
\item 
int32\+\_\+t \textbf{ n\+Block\+Reverse\+Sequence\+Id} = -\/1
\item 
\textbf{ arith\+\_\+uint256} \textbf{ n\+Last\+Precious\+Chainwork} = 0
\item 
size\+\_\+t \textbf{ m\+\_\+total\+\_\+coinstip\+\_\+cache} \{0\}
\item 
size\+\_\+t \textbf{ m\+\_\+total\+\_\+coinsdb\+\_\+cache} \{0\}
\item 
\textbf{ Chainstate} \&Initialize\+Chainstate(\textbf{ CTx\+Mem\+Pool} $\ast$mempool) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ util\+::\+Result}$<$ \textbf{ CBlock\+Index} $\ast$ \textbf{ Activate\+Snapshot} )(\textbf{ Auto\+File} \&coins\+\_\+file, const \textbf{ node\+::\+Snapshot\+Metadata} \&metadata, bool in\+\_\+memory)
\item 
\textbf{ Snapshot\+Completion\+Result} Maybe\+Validate\+Snapshot(\textbf{ Chainstate} \&validated\+\_\+cs, \textbf{ Chainstate} \&unvalidated\+\_\+cs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Chainstate} \textbf{ Current\+Chainstate} )() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())
\begin{DoxyCompactList}\small\item\em Return current chainstate targeting the most-\/work, network tip. \end{DoxyCompactList}\item 
\textbf{ Version\+Bits\+Cache} \textbf{ m\+\_\+versionbitscache}
\item 
\textbf{ Chainstate} $\ast$Load\+Assumeutxo\+Chainstate() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Chainstate} \&Add\+Chainstate(std\+::unique\+\_\+ptr$<$ \textbf{ Chainstate} $>$ chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Reset\+Chainstates() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Delete\+Chainstate(\textbf{ Chainstate} \&chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Validated\+Snapshot\+Cleanup(\textbf{ Chainstate} \&validated\+\_\+cs, \textbf{ Chainstate} \&unvalidated\+\_\+cs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::optional$<$ std\+::pair$<$ const \textbf{ CBlock\+Index} $\ast$, const \textbf{ CBlock\+Index} $\ast$ $>$ $>$ Get\+Historical\+Block\+Range() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ util\+::\+Result}$<$ void $>$ Activate\+Best\+Chains() \textbf{ LOCKS\+\_\+\+EXCLUDED}(void Recalculate\+Best\+Header() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ CCheck\+Queue}$<$ \textbf{ CScript\+Check} $>$ \textbf{ Get\+Check\+Queue} )()
\begin{DoxyCompactList}\small\item\em Add new chainstate. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CBlock\+Index} $\ast$m\+\_\+best\+\_\+invalid \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Interface for managing multiple \doxyref{Chainstate}{p.}{class_chainstate} objects, where each chainstate is associated with chainstate$\ast$ subdirectory in the data directory and contains a database of UTXOs existing at a different point in history. (See \doxyref{Chainstate}{p.}{class_chainstate} class for more information.)

Normally there is exactly one \doxyref{Chainstate}{p.}{class_chainstate}, which contains the UTXO set of chain tip if syncing is completed, or the UTXO set the most recent validated block if the initial sync is still in progress.

However, if an assumeutxo snapshot is loaded before syncing is completed, there will be two chainstates. The original fully validated chainstate will continue to exist and download new blocks in the background. But the new snapshot which is loaded will become a second chainstate. The second chainstate will be used as the chain tip for the wallet and RPCs even though it is only assumed to be valid. When the initial chainstate catches up to the snapshot height and confirms that the assumeutxo snapshot is actually valid, the second chainstate will be marked validated and become the only chainstate again. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{ChainstateManager@{ChainstateManager}!Options@{Options}}
\index{Options@{Options}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{Options}
{\footnotesize\ttfamily \label{class_chainstate_manager_a66bc0ee7102eaf1cbd62d3a9d7087e52} 
using \textbf{ Options}\textbf{ Options} = \textbf{ kernel\+::\+Chainstate\+Manager\+Opts}}



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{ChainstateManager@{ChainstateManager}!ChainstateManager@{ChainstateManager}}
\index{ChainstateManager@{ChainstateManager}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ChainstateManager()}
{\footnotesize\ttfamily \label{class_chainstate_manager_abf64809b392636e77309f8ad9a1e633a} 
\textbf{ Chainstate\+Manager} (\begin{DoxyParamCaption}\item[{const \textbf{ util\+::\+Signal\+Interrupt} \&}]{interrupt}{, }\item[{\textbf{ Options}\textbf{ Options}}]{options}{, }\item[{\textbf{ node\+::\+Block\+Manager\+::\+Options}}]{blockman\+\_\+options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

\index{ChainstateManager@{ChainstateManager}!````~ChainstateManager@{$\sim$ChainstateManager}}
\index{````~ChainstateManager@{$\sim$ChainstateManager}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{$\sim$ChainstateManager()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a30c226700bb0b48363077aab63be6074} 
$\sim$\textbf{ Chainstate\+Manager} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{ChainstateManager@{ChainstateManager}!AcceptBlock@{AcceptBlock}}
\index{AcceptBlock@{AcceptBlock}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{AcceptBlock()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a27cda33d02b54068c879b5889f6557f3} 
bool Accept\+Block (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&}]{pblock}{, }\item[{\textbf{ Block\+Validation\+State} \&}]{state}{, }\item[{\textbf{ CBlock\+Index} $\ast$$\ast$}]{ppindex}{, }\item[{bool}]{f\+Requested}{, }\item[{const \textbf{ Flat\+File\+Pos} $\ast$}]{dbp}{, }\item[{bool $\ast$}]{f\+New\+Block}{, }\item[{bool}]{min\+\_\+pow\+\_\+checked}{}\end{DoxyParamCaption})}

Sufficiently validate a block for disk storage (and store on disk).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em pblock} & The block we want to process. \\
\hline
\mbox{\texttt{in}}  & {\em f\+Requested} & Whether we requested this block from a peer. \\
\hline
\mbox{\texttt{in}}  & {\em dbp} & The location on disk, if we are importing this block from prior storage. \\
\hline
\mbox{\texttt{in}}  & {\em min\+\_\+pow\+\_\+checked} & True if proof-\/of-\/work anti-\/\+DoS checks have been done by caller for headers chain\\
\hline
\mbox{\texttt{out}}  & {\em state} & The state of the block validation. \\
\hline
\mbox{\texttt{out}}  & {\em ppindex} & Optional return parameter to get the \doxyref{CBlock\+Index}{p.}{class_c_block_index} pointer for this block. \\
\hline
\mbox{\texttt{out}}  & {\em f\+New\+Block} & Optional return parameter to indicate if the block is new to our storage.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
False if the block or header is invalid, or if saving to disk fails (likely a fatal error); true otherwise.
\end{DoxyReturn}
Store block on disk. If dbp is non-\/nullptr, the file is known to already reside on disk \index{ChainstateManager@{ChainstateManager}!ActiveChain@{ActiveChain}}
\index{ActiveChain@{ActiveChain}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ActiveChain()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a8090a09f21aff3aa747263ae6b8268c1} 
\textbf{ CChain} \& Active\+Chain (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!ActiveChainstate@{ActiveChainstate}}
\index{ActiveChainstate@{ActiveChainstate}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ActiveChainstate()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a0ed46908ea52e17d172f2fcc0ceb9964} 
\textbf{ Chainstate} \& Active\+Chainstate (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Alternatives to \doxyref{Current\+Chainstate()}{p.}{class_chainstate_manager_a8d39d359e6ed774815dc8d31f326ff82} used by older code to query latest chainstate information without locking cs\+\_\+main. Newer code should avoid querying \doxyref{Chainstate\+Manager}{p.}{class_chainstate_manager} and use \doxyref{Chainstate}{p.}{class_chainstate} objects directly, or should use \doxyref{Current\+Chainstate()}{p.}{class_chainstate_manager_a8d39d359e6ed774815dc8d31f326ff82} instead. \index{ChainstateManager@{ChainstateManager}!ActiveHeight@{ActiveHeight}}
\index{ActiveHeight@{ActiveHeight}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ActiveHeight()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a02754cb19c22c28f3092a18a70d9dec4} 
int Active\+Height (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!ActiveTip@{ActiveTip}}
\index{ActiveTip@{ActiveTip}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ActiveTip()}
{\footnotesize\ttfamily \label{class_chainstate_manager_ac8dc81d17ce18093b02ef600686870b3} 
\textbf{ CBlock\+Index} $\ast$ Active\+Tip (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!AssumedValidBlock@{AssumedValidBlock}}
\index{AssumedValidBlock@{AssumedValidBlock}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{AssumedValidBlock()}
{\footnotesize\ttfamily \label{class_chainstate_manager_abce720b3a0e16a563e8f78ac92686646} 
const \textbf{ uint256} \& Assumed\+Valid\+Block (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!BlockIndex@{BlockIndex}}
\index{BlockIndex@{BlockIndex}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{BlockIndex()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a1568d8e47259466ecafd9ed7b411873a} 
\textbf{ node\+::\+Block\+Map} \& Block\+Index (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!CheckBlockIndex@{CheckBlockIndex}}
\index{CheckBlockIndex@{CheckBlockIndex}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{CheckBlockIndex()}
{\footnotesize\ttfamily \label{class_chainstate_manager_abcf4d55acb00543c3d57d5fb532bc8f6} 
void Check\+Block\+Index (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Make various assertions about the state of the block index.

By default this only executes fully when using the Regtest chain; see\+: m\+\_\+options.\+check\+\_\+block\+\_\+index. \index{ChainstateManager@{ChainstateManager}!GenerateCoinbaseCommitment@{GenerateCoinbaseCommitment}}
\index{GenerateCoinbaseCommitment@{GenerateCoinbaseCommitment}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GenerateCoinbaseCommitment()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a4f87fc79002ca74320f13bcc7b709f3b} 
std\+::vector$<$ unsigned char $>$ Generate\+Coinbase\+Commitment (\begin{DoxyParamCaption}\item[{\textbf{ CBlock} \&}]{block}{, }\item[{const \textbf{ CBlock\+Index} $\ast$}]{pindex\+Prev}{}\end{DoxyParamCaption}) const}

Produce the necessary coinbase commitment for a block (modifies the hash, don\textquotesingle{}t call for mined blocks). \index{ChainstateManager@{ChainstateManager}!GetConsensus@{GetConsensus}}
\index{GetConsensus@{GetConsensus}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GetConsensus()}
{\footnotesize\ttfamily \label{class_chainstate_manager_ae77f209722ff1370ed18dc073d3d373f} 
const \textbf{ Consensus\+::\+Params} \& Get\+Consensus (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!GetMutex@{GetMutex}}
\index{GetMutex@{GetMutex}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GetMutex()}
{\footnotesize\ttfamily \label{class_chainstate_manager_af99ab8783b483abe3fef8ab596a3e6b6} 
\textbf{ Recursive\+Mutex} \& Get\+Mutex (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Alias for \doxyref{cs\+\_\+main}{p.}{cs__main_8cpp_ab88a4b9173207cf250ece7820db1f36d}. Should be used in new code to make it easier to make \doxyref{cs\+\_\+main}{p.}{cs__main_8cpp_ab88a4b9173207cf250ece7820db1f36d} a member of this class. Generally, methods of this class should be annotated to require this mutex. This will make calling code more verbose, but also help to\+:
\begin{DoxyItemize}
\item Clarify that the method will acquire a mutex that heavily affects overall performance.
\item Force call sites to think how long they need to acquire the mutex to get consistent results. 
\end{DoxyItemize}\index{ChainstateManager@{ChainstateManager}!GetNotifications@{GetNotifications}}
\index{GetNotifications@{GetNotifications}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GetNotifications()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a30d910c43e6619c9596c077fd1e5518d} 
\textbf{ kernel\+::\+Notifications} \& Get\+Notifications (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!GetParams@{GetParams}}
\index{GetParams@{GetParams}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GetParams()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a9fc4893dda46aba09dbcd01e3387ca6f} 
const \textbf{ CChain\+Params} \& Get\+Params (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{class_chainstate_manager_a6331a57c72ec2af500332ada6568449c} 
std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \textbf{ Chainstate} $>$ $>$ m\+\_\+chainstates GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

List of chainstates. Note\+: in general, it is not safe to delete \doxyref{Chainstate}{p.}{class_chainstate} objects once they are added to this list because there is no mutex that can be locked to prevent \doxyref{Chainstate}{p.}{class_chainstate} pointers from being used while they are deleted. (cs\+\_\+main doesn\textquotesingle{}t work because it is too narrow and is released in the middle of Chainstate\+::\+Activate\+Best\+Chain to let notifications be processed. m\+\_\+chainstate\+\_\+mutex doesn\textquotesingle{}t work because it is not locked at other times when the chainstate is in use.) \index{ChainstateManager@{ChainstateManager}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{class_chainstate_manager_ae266294cbd8e70cc91fd28a77fd45625} 
\textbf{ CBlock\+Index} $\ast$m\+\_\+best\+\_\+header GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Best header we\textquotesingle{}ve seen so far for which the block is not known to be invalid (used, among others, for getheaders queries\textquotesingle{} starting points). In case of multiple best headers with the same work, it could point to any because \doxyref{CBlock\+Index\+Work\+Comparator}{p.}{struct_c_block_index_work_comparator} tiebreaker rules are not applied. \index{ChainstateManager@{ChainstateManager}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{class_chainstate_manager_aa035a00d9fc943b069c0a2c73c0c4c5f} 
int32\+\_\+t n\+Block\+Sequence\+Id GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

Every received block is assigned a unique and increasing identifier, so we know which one to give priority in case of a fork. Blocks loaded from disk are assigned id SEQ\+\_\+\+ID\+\_\+\+INIT\+\_\+\+FROM\+\_\+\+DISK\{1\} (SEQ\+\_\+\+ID\+\_\+\+BEST\+\_\+\+CHAIN\+\_\+\+FROM\+\_\+\+DISK\{0\} if they belong to the best chain loaded from disk), so start the counter after that. \index{ChainstateManager@{ChainstateManager}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{class_chainstate_manager_a19574d54ea135906c021a7a5d537da5f} 
\textbf{ CBlock\+Index} $\ast$m\+\_\+best\+\_\+invalid GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

\index{ChainstateManager@{ChainstateManager}!GuessVerificationProgress@{GuessVerificationProgress}}
\index{GuessVerificationProgress@{GuessVerificationProgress}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GuessVerificationProgress()}
{\footnotesize\ttfamily \label{class_chainstate_manager_ab95b248ecacf42357d9d4ea19e696ff7} 
double Guess\+Verification\+Progress (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Index} $\ast$}]{pindex}{}\end{DoxyParamCaption}) const}

Guess verification progress (as a fraction between 0.\+0=genesis and 1.\+0=current tip). \index{ChainstateManager@{ChainstateManager}!HistoricalChainstate@{HistoricalChainstate}}
\index{HistoricalChainstate@{HistoricalChainstate}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{HistoricalChainstate()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a1140f6d8b807be5796827fc4f7be03d7} 
\textbf{ Chainstate} $\ast$ Historical\+Chainstate (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return historical chainstate targeting a specific block, if any. 

\index{ChainstateManager@{ChainstateManager}!IsInitialBlockDownload@{IsInitialBlockDownload}}
\index{IsInitialBlockDownload@{IsInitialBlockDownload}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{IsInitialBlockDownload()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a312bb1a2008bae3205f4699b90880d66} 
bool Is\+Initial\+Block\+Download (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Check whether we are doing an initial block download (synchronizing from disk or network) \index{ChainstateManager@{ChainstateManager}!LoadBlockIndex@{LoadBlockIndex}}
\index{LoadBlockIndex@{LoadBlockIndex}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{LoadBlockIndex()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a665765220796597313f5ea2daa980354} 
bool Load\+Block\+Index (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Load the block tree and coins database from disk, initializing state if we\textquotesingle{}re running with -\/reindex. 

\index{ChainstateManager@{ChainstateManager}!LoadExternalBlockFile@{LoadExternalBlockFile}}
\index{LoadExternalBlockFile@{LoadExternalBlockFile}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{LoadExternalBlockFile()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a7fa295c24afe0ecd3e603b695fae303c} 
void Load\+External\+Block\+File (\begin{DoxyParamCaption}\item[{\textbf{ Auto\+File} \&}]{file\+\_\+in}{, }\item[{\textbf{ Flat\+File\+Pos} $\ast$}]{dbp}{ = {\ttfamily nullptr}, }\item[{std\+::multimap$<$ \textbf{ uint256}, \textbf{ Flat\+File\+Pos} $>$ $\ast$}]{blocks\+\_\+with\+\_\+unknown\+\_\+parent}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Import blocks from an external file

During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat). It reads all blocks contained in the given file and attempts to process them (add them to the block index). The blocks may be out of order within each file and across files. Often this function reads a block but finds that its parent hasn\textquotesingle{}t been read yet, so the block can\textquotesingle{}t be processed yet. The function will add an entry to the blocks\+\_\+with\+\_\+unknown\+\_\+parent map (which is passed as an argument), so that when the block\textquotesingle{}s parent is later read and processed, this function can re-\/read the child block from disk and process it.

Because a block\textquotesingle{}s parent may be in a later file, not just later in the same file, the blocks\+\_\+with\+\_\+unknown\+\_\+parent map must be passed in and out with each call. It\textquotesingle{}s a multimap, rather than just a map, because multiple blocks may have the same parent (when chain splits or stale blocks exist). It maps from parent-\/hash to child-\/disk-\/position.

This function can also be used to read blocks from user-\/specified block files using the -\/loadblock= option. There\textquotesingle{}s no unknown-\/parent tracking, so the last two arguments are omitted.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em file\+\_\+in} & File containing blocks to read \\
\hline
\mbox{\texttt{in}}  & {\em dbp} & (optional) Disk block position (only for reindex) \\
\hline
\mbox{\texttt{in,out}}  & {\em blocks\+\_\+with\+\_\+unknown\+\_\+parent} & (optional) Map of disk positions for blocks with unknown parent, key is parent block hash (only used for reindex) \\
\hline
\end{DoxyParams}
\index{ChainstateManager@{ChainstateManager}!MinimumChainWork@{MinimumChainWork}}
\index{MinimumChainWork@{MinimumChainWork}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{MinimumChainWork()}
{\footnotesize\ttfamily \label{class_chainstate_manager_af6689b42eea6a15ba7e5409ea374cdb4} 
const \textbf{ arith\+\_\+uint256} \& Minimum\+Chain\+Work (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!ProcessNewBlock@{ProcessNewBlock}}
\index{ProcessNewBlock@{ProcessNewBlock}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ProcessNewBlock()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a1e0c145b7a823316fb026a73d305a049} 
bool Process\+New\+Block (\begin{DoxyParamCaption}\item[{const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&}]{block}{, }\item[{bool}]{force\+\_\+processing}{, }\item[{bool}]{min\+\_\+pow\+\_\+checked}{, }\item[{bool $\ast$}]{new\+\_\+block}{}\end{DoxyParamCaption})}

Process an incoming block. This only returns after the best known valid block is made active. Note that it does not, however, guarantee that the specific block passed to it has been checked for validity!

If you want to {\itshape possibly} get feedback on whether block is valid, you must install a \doxyref{CValidation\+Interface}{p.}{class_c_validation_interface} (see \doxyref{validationinterface.\+h}{p.}{validationinterface_8h}) -\/ this will have its Block\+Checked method called whenever {\itshape any} block completes validation.

Note that we guarantee that either the proof-\/of-\/work is valid on block, or (and possibly also) Block\+Checked will have been called.

May not be called in a validationinterface callback.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em block} & The block we want to process. \\
\hline
\mbox{\texttt{in}}  & {\em force\+\_\+processing} & Process this block even if unrequested; used for non-\/network block sources. \\
\hline
\mbox{\texttt{in}}  & {\em min\+\_\+pow\+\_\+checked} & True if proof-\/of-\/work anti-\/\+DoS checks have been done by caller for headers chain (note\+: only affects headers acceptance; if block header is already present in block index then this parameter has no effect) \\
\hline
\mbox{\texttt{out}}  & {\em new\+\_\+block} & A boolean which is set to indicate if the block was first received via this call \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If the block was processed, independently of block validity 
\end{DoxyReturn}
\index{ChainstateManager@{ChainstateManager}!ProcessNewBlockHeaders@{ProcessNewBlockHeaders}}
\index{ProcessNewBlockHeaders@{ProcessNewBlockHeaders}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ProcessNewBlockHeaders()}
{\footnotesize\ttfamily \label{class_chainstate_manager_ae76ff7fc56e3342ba5a97ca33ec5aa37} 
bool Process\+New\+Block\+Headers (\begin{DoxyParamCaption}\item[{std\+::span$<$ const \textbf{ CBlock\+Header} $>$}]{headers}{, }\item[{bool}]{min\+\_\+pow\+\_\+checked}{, }\item[{\textbf{ Block\+Validation\+State} \&}]{state}{, }\item[{const \textbf{ CBlock\+Index} $\ast$$\ast$}]{ppindex}{ = {\ttfamily nullptr}}\end{DoxyParamCaption})}

Process incoming block headers.

May not be called in a validationinterface callback.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em headers} & The block headers themselves \\
\hline
\mbox{\texttt{in}}  & {\em min\+\_\+pow\+\_\+checked} & True if proof-\/of-\/work anti-\/\+DoS checks have been done by caller for headers chain \\
\hline
\mbox{\texttt{out}}  & {\em state} & This may be set to an Error state if any error occurred processing them \\
\hline
\mbox{\texttt{out}}  & {\em ppindex} & If set, the pointer will be set to point to the last new block index object for the given headers \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if Accept\+Block\+Header fails on any of the headers, true otherwise (including if headers were already known) 
\end{DoxyReturn}
\index{ChainstateManager@{ChainstateManager}!ProcessTransaction@{ProcessTransaction}}
\index{ProcessTransaction@{ProcessTransaction}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ProcessTransaction()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a9c7d6797a606a08696d722e7489b6d4d} 
\textbf{ Mempool\+Accept\+Result} Process\+Transaction (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction\+Ref} \&}]{tx}{, }\item[{bool}]{test\+\_\+accept}{ = {\ttfamily false}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

Try to add a transaction to the memory pool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em tx} & The transaction to submit for mempool acceptance. \\
\hline
\mbox{\texttt{in}}  & {\em test\+\_\+accept} & When true, run validation checks but don\textquotesingle{}t submit to mempool. \\
\hline
\end{DoxyParams}
\index{ChainstateManager@{ChainstateManager}!ReceivedBlockTransactions@{ReceivedBlockTransactions}}
\index{ReceivedBlockTransactions@{ReceivedBlockTransactions}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ReceivedBlockTransactions()}
{\footnotesize\ttfamily \label{class_chainstate_manager_aacf45b730328d8aa968302758c45adf0} 
void Received\+Block\+Transactions (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock} \&}]{block}{, }\item[{\textbf{ CBlock\+Index} $\ast$}]{pindex\+New}{, }\item[{const \textbf{ Flat\+File\+Pos} \&}]{pos}{}\end{DoxyParamCaption})}

Mark a block as having its data received and checked (up to BLOCK\+\_\+\+VALID\+\_\+\+TRANSACTIONS). \index{ChainstateManager@{ChainstateManager}!RemoveChainstate@{RemoveChainstate}}
\index{RemoveChainstate@{RemoveChainstate}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{RemoveChainstate()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a3548c5d82213aaa9daaf0ac46482e8ce} 
std\+::unique\+\_\+ptr$<$ \textbf{ Chainstate} $>$ Remove\+Chainstate (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate} \&}]{chainstate}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Remove a chainstate. 

\index{ChainstateManager@{ChainstateManager}!ReportHeadersPresync@{ReportHeadersPresync}}
\index{ReportHeadersPresync@{ReportHeadersPresync}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ReportHeadersPresync()}
{\footnotesize\ttfamily \label{class_chainstate_manager_afbdf3e3590aa0d6082ea2105a70bd91e} 
void Report\+Headers\+Presync (\begin{DoxyParamCaption}\item[{const \textbf{ arith\+\_\+uint256} \&}]{work}{, }\item[{int64\+\_\+t}]{height}{, }\item[{int64\+\_\+t}]{timestamp}{}\end{DoxyParamCaption})}

This is used by net\+\_\+processing to report pre-\/synchronization progress of headers, as headers are not yet fed to validation during that time, but validation is (for now) responsible for logging and signalling through Notify\+Header\+Tip, so it needs this information. \index{ChainstateManager@{ChainstateManager}!ResetBlockSequenceCounters@{ResetBlockSequenceCounters}}
\index{ResetBlockSequenceCounters@{ResetBlockSequenceCounters}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ResetBlockSequenceCounters()}
{\footnotesize\ttfamily \label{class_chainstate_manager_af18f65bf1a2c0d6ae376e70ba3bad7d3} 
void Reset\+Block\+Sequence\+Counters (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ChainstateManager@{ChainstateManager}!ShouldCheckBlockIndex@{ShouldCheckBlockIndex}}
\index{ShouldCheckBlockIndex@{ShouldCheckBlockIndex}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ShouldCheckBlockIndex()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a7d9fee7d87790307d9de8daa34d0bb76} 
bool Should\+Check\+Block\+Index (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{ChainstateManager@{ChainstateManager}!UpdateUncommittedBlockStructures@{UpdateUncommittedBlockStructures}}
\index{UpdateUncommittedBlockStructures@{UpdateUncommittedBlockStructures}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{UpdateUncommittedBlockStructures()}
{\footnotesize\ttfamily \label{class_chainstate_manager_ab221269ee84206666a6cf6d27a9c25fc} 
void Update\+Uncommitted\+Block\+Structures (\begin{DoxyParamCaption}\item[{\textbf{ CBlock} \&}]{block}{, }\item[{const \textbf{ CBlock\+Index} $\ast$}]{pindex\+Prev}{}\end{DoxyParamCaption}) const}

Check to see if caches are out of balance and if so, call Resize\+Coins\+Caches() as needed. Update uncommitted block structures (currently\+: only the witness reserved value). This is safe for submitted blocks as long as they honor default\+\_\+witness\+\_\+commitment from the template. \index{ChainstateManager@{ChainstateManager}!ValidatedChainstate@{ValidatedChainstate}}
\index{ValidatedChainstate@{ValidatedChainstate}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ValidatedChainstate()}
{\footnotesize\ttfamily \label{class_chainstate_manager_a91044f53af4185cf8bc3870bc2a3ea6a} 
\textbf{ Chainstate} \& Validated\+Chainstate (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return fully validated chainstate that should be used for indexing, to support indexes that need to index blocks in order and can\textquotesingle{}t start from the snapshot block. 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{ChainstateManager@{ChainstateManager}!ActivateSnapshot@{ActivateSnapshot}}
\index{ActivateSnapshot@{ActivateSnapshot}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{ActivateSnapshot}
{\footnotesize\ttfamily \label{class_chainstate_manager_ad1791e4f65d252d4163bca3d75e8e418} 
\textbf{ util\+::\+Result}$<$ \textbf{ CBlock\+Index} $\ast$ $>$ Activate\+Snapshot\hspace{0.3cm}{\ttfamily [nodiscard]}}

Instantiate a new chainstate.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em mempool} & The mempool to pass to the chainstate\\
\hline
\end{DoxyParams}
Construct and activate a \doxyref{Chainstate}{p.}{class_chainstate} on the basis of UTXO snapshot data.

Steps\+:


\begin{DoxyItemize}
\item Initialize an unused \doxyref{Chainstate}{p.}{class_chainstate}.
\item Load its {\ttfamily \doxyref{Coins\+Views}{p.}{class_coins_views}} contents from {\ttfamily coins\+\_\+file}.
\item Verify that the hash of the resulting coinsdb matches the expected hash per assumeutxo chain parameters.
\item Wait for our headers chain to include the base block of the snapshot.
\item "{}\+Fast forward"{} the tip of the new chainstate to the base of the snapshot.
\item Construct the new \doxyref{Chainstate}{p.}{class_chainstate} and add it to m\+\_\+chainstates. 
\end{DoxyItemize}\index{ChainstateManager@{ChainstateManager}!CurrentChainstate@{CurrentChainstate}}
\index{CurrentChainstate@{CurrentChainstate}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{CurrentChainstate}
{\footnotesize\ttfamily \label{class_chainstate_manager_a8d39d359e6ed774815dc8d31f326ff82} 
\textbf{ Snapshot\+Completion\+Result} Maybe\+Validate\+Snapshot(\textbf{ Chainstate} \&validated\+\_\+cs, \textbf{ Chainstate} \&unvalidated\+\_\+cs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Chainstate} Current\+Chainstate) () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Get\+Mutex}())\hspace{0.3cm}{\ttfamily [inline]}}



Return current chainstate targeting the most-\/work, network tip. 

Try to validate an assumeutxo snapshot by using a validated historical chainstate targeted at the snapshot block. When the target block is reached, the UTXO hash is computed and saved to {\ttfamily validated\+\_\+cs.\+m\+\_\+target\+\_\+utxohash}, and {\ttfamily unvalidated\+\_\+cs.\+m\+\_\+assumeutxo} will be updated from UNVALIDATED to either VALIDATED or INVALID depending on whether the hash matches. The INVALID case should not happen in practice because the software should refuse to load unrecognized snapshots, but if it does happen, it is a fatal error. \index{ChainstateManager@{ChainstateManager}!GetCheckQueue@{GetCheckQueue}}
\index{GetCheckQueue@{GetCheckQueue}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{GetCheckQueue}
{\footnotesize\ttfamily \label{class_chainstate_manager_a950b9831cc7770fa5c00402406560433} 
\textbf{ Chainstate} $\ast$Load\+Assumeutxo\+Chainstate() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Chainstate} \&Add\+Chainstate(std\+::unique\+\_\+ptr$<$ \textbf{ Chainstate} $>$ chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Reset\+Chainstates() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Delete\+Chainstate(\textbf{ Chainstate} \&chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Validated\+Snapshot\+Cleanup(\textbf{ Chainstate} \&validated\+\_\+cs, \textbf{ Chainstate} \&unvalidated\+\_\+cs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::optional$<$ std\+::pair$<$ const \textbf{ CBlock\+Index} $\ast$, const \textbf{ CBlock\+Index} $\ast$ $>$ $>$ Get\+Historical\+Block\+Range() const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ util\+::\+Result}$<$ void $>$ Activate\+Best\+Chains() \textbf{ LOCKS\+\_\+\+EXCLUDED}(void Recalculate\+Best\+Header() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ CCheck\+Queue}$<$ \textbf{ CScript\+Check} $>$ Get\+Check\+Queue) ()\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}



Add new chainstate. 

When starting up, search the datadir for a chainstate based on a UTXO snapshot that is in the process of being validated and load it if found. Return pointer to the \doxyref{Chainstate}{p.}{class_chainstate} if it is loaded.

Remove the chainstate and all on-\/disk artifacts. Used when reindex\{-\/chainstate\} is called during snapshot use.

If we have validated a snapshot chain during this runtime, copy its chainstate directory over to the main {\ttfamily chainstate} location, completing validation of the snapshot.

If the cleanup succeeds, the caller will need to ensure chainstates are reinitialized, since Reset\+Chainstates() will be called before leveldb directories are moved or deleted.

\begin{DoxySeeAlso}{See also}
node/chainstate\+:\doxyref{Load\+Chainstate()}{p.}{init_8cpp_a2d650cf978844ae65f6667c85fc53ede} Get range of historical blocks to download. Call Activate\+Best\+Chain() on every chainstate.
\end{DoxySeeAlso}
If, due to invalidation / reconsideration of blocks, the previous best header is no longer valid / guaranteed to be the most-\/work header in our block-\/index not known to be invalid, recalculate it. \index{ChainstateManager@{ChainstateManager}!m\_blockman@{m\_blockman}}
\index{m\_blockman@{m\_blockman}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_blockman}
{\footnotesize\ttfamily \label{class_chainstate_manager_a0ffb06ca51d81edfc4488da3aad6718e} 
\textbf{ node\+::\+Block\+Manager} m\+\_\+blockman}

A single \doxyref{Block\+Manager}{p.}{class_block_manager} instance is shared across each constructed chainstate to avoid duplicating block metadata. \index{ChainstateManager@{ChainstateManager}!m\_cached\_finished\_ibd@{m\_cached\_finished\_ibd}}
\index{m\_cached\_finished\_ibd@{m\_cached\_finished\_ibd}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_cached\_finished\_ibd}
{\footnotesize\ttfamily \label{class_chainstate_manager_aeef634a7b2cca41e9465fb47ea4a4e5e} 
std\+::atomic$<$bool$>$ m\+\_\+cached\+\_\+finished\+\_\+ibd \{false\}\hspace{0.3cm}{\ttfamily [mutable]}}

Whether initial block download has ended and Is\+Initial\+Block\+Download should return false from now on.

Mutable because we need to be able to mark \doxyref{Is\+Initial\+Block\+Download()}{p.}{class_chainstate_manager_a312bb1a2008bae3205f4699b90880d66} const, which latches this for caching purposes. \index{ChainstateManager@{ChainstateManager}!m\_interrupt@{m\_interrupt}}
\index{m\_interrupt@{m\_interrupt}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_interrupt}
{\footnotesize\ttfamily \label{class_chainstate_manager_a2163d8ef789c585b196a3ec7f468244b} 
const \textbf{ util\+::\+Signal\+Interrupt}\& m\+\_\+interrupt}

\index{ChainstateManager@{ChainstateManager}!m\_options@{m\_options}}
\index{m\_options@{m\_options}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_options}
{\footnotesize\ttfamily \label{class_chainstate_manager_a012c0463bd17a2be6045a0d62e8b0fd4} 
const \textbf{ Options}\textbf{ Options} m\+\_\+options}

\index{ChainstateManager@{ChainstateManager}!m\_total\_coinsdb\_cache@{m\_total\_coinsdb\_cache}}
\index{m\_total\_coinsdb\_cache@{m\_total\_coinsdb\_cache}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_total\_coinsdb\_cache}
{\footnotesize\ttfamily \label{class_chainstate_manager_ab8e486d36525b789f3858281b2b142f7} 
size\+\_\+t m\+\_\+total\+\_\+coinsdb\+\_\+cache \{0\}}

The total number of bytes available for us to use across all leveldb coins databases. This will be split somehow across chainstates. \index{ChainstateManager@{ChainstateManager}!m\_total\_coinstip\_cache@{m\_total\_coinstip\_cache}}
\index{m\_total\_coinstip\_cache@{m\_total\_coinstip\_cache}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_total\_coinstip\_cache}
{\footnotesize\ttfamily \label{class_chainstate_manager_a1193672873da4f09b48291890d0b523a} 
size\+\_\+t m\+\_\+total\+\_\+coinstip\+\_\+cache \{0\}}

The total number of bytes available for us to use across all in-\/memory coins caches. This will be split somehow across chainstates. \index{ChainstateManager@{ChainstateManager}!m\_validation\_cache@{m\_validation\_cache}}
\index{m\_validation\_cache@{m\_validation\_cache}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_validation\_cache}
{\footnotesize\ttfamily \label{class_chainstate_manager_a8b9f7384fea98b58e40ac219adbe246e} 
\textbf{ Validation\+Cache} m\+\_\+validation\+\_\+cache}

\index{ChainstateManager@{ChainstateManager}!m\_versionbitscache@{m\_versionbitscache}}
\index{m\_versionbitscache@{m\_versionbitscache}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{m\_versionbitscache}
{\footnotesize\ttfamily \label{class_chainstate_manager_ad854ac2aa6fccfd247fabfdbd1a0b89b} 
\textbf{ Version\+Bits\+Cache} m\+\_\+versionbitscache\hspace{0.3cm}{\ttfamily [mutable]}}

Track versionbit status \index{ChainstateManager@{ChainstateManager}!nBlockReverseSequenceId@{nBlockReverseSequenceId}}
\index{nBlockReverseSequenceId@{nBlockReverseSequenceId}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{nBlockReverseSequenceId}
{\footnotesize\ttfamily \label{class_chainstate_manager_a3a98f74d304164590a715c14320a7f34} 
int32\+\_\+t n\+Block\+Reverse\+Sequence\+Id = -\/1}

Decreasing counter (used by subsequent preciousblock calls). \index{ChainstateManager@{ChainstateManager}!nLastPreciousChainwork@{nLastPreciousChainwork}}
\index{nLastPreciousChainwork@{nLastPreciousChainwork}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{nLastPreciousChainwork}
{\footnotesize\ttfamily \label{class_chainstate_manager_a13a75b7d6fb732fb84ea1ca75e5c3b4d} 
\textbf{ arith\+\_\+uint256} n\+Last\+Precious\+Chainwork = 0}

chainwork for the last block that preciousblock has been applied to. \index{ChainstateManager@{ChainstateManager}!snapshot\_download\_completed@{snapshot\_download\_completed}}
\index{snapshot\_download\_completed@{snapshot\_download\_completed}!ChainstateManager@{ChainstateManager}}
\doxysubsubsection{snapshot\_download\_completed}
{\footnotesize\ttfamily \label{class_chainstate_manager_a36ac8c09fb965b0d78d5f12d1cac9f95} 
std\+::function$<$void()$>$ snapshot\+\_\+download\+\_\+completed = std\+::function$<$void()$>$()}

Function to restart active indexes; set dynamically to avoid a circular dependency on {\ttfamily base/index.\+cpp}. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ validation.\+h}\item 
src/\textbf{ validation.\+cpp}\end{DoxyCompactItemize}
