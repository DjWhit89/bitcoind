\doxysection{Mem\+Pool\+Test Class Reference}
\label{class_mem_pool_test}\index{MemPoolTest@{MemPoolTest}}
Inheritance diagram for Mem\+Pool\+Test\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_mem_pool_test}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CFee\+Rate} \textbf{ Get\+Min\+Fee} (size\+\_\+t sizelimit) const
\item 
\textbf{ CFee\+Rate} \textbf{ Get\+Min\+Fee} () const
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ CTx\+Mem\+Pool}}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Graph} $>$ m\+\_\+txgraph \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Graph\+::\+Block\+Builder} $>$ m\+\_\+builder \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ indexed\+\_\+transaction\+\_\+set} map\+Tx \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
std\+::vector$<$ std\+::pair$<$ \textbf{ Wtxid}, \textbf{ txiter} $>$ $>$ txns\+\_\+randomized \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em All transactions in map\+Tx with their wtxids, in arbitrary order. \end{DoxyCompactList}\item 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, \textbf{ CAmount} $>$ \textbf{ Calculate\+Ancestor\+Data} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::tuple$<$ size\+\_\+t, size\+\_\+t, \textbf{ CAmount} $>$ \textbf{ Calculate\+Descendant\+Data} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
int64\+\_\+t \textbf{ Get\+Descendant\+Count} (\textbf{ txiter} \textbf{ it}) const
\item 
int64\+\_\+t \textbf{ Get\+Descendant\+Count} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&e) const
\item 
int64\+\_\+t \textbf{ Get\+Ancestor\+Count} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&e) const
\item 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \textbf{ Get\+Children} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const
\item 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \textbf{ Get\+Parents} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const
\item 
\textbf{ indirectmap}$<$ \textbf{ COut\+Point}, \textbf{ txiter} $>$ map\+Next\+Tx \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
std\+::map$<$ \textbf{ Txid}, \textbf{ CAmount} $>$ map\+Deltas \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ CTx\+Mem\+Pool} (\textbf{ Options}\textbf{ Options} opts, \textbf{ bilingual\+\_\+str} \&error)
\item 
void \textbf{ remove\+For\+Reorg} (\textbf{ CChain} \&chain, std\+::function$<$ bool(\textbf{ txiter})$>$ filter\+\_\+final\+\_\+and\+\_\+mature) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
void \textbf{ remove\+For\+Block} (const std\+::vector$<$ \textbf{ CTransaction\+Ref} $>$ \&vtx, unsigned int n\+Block\+Height) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ Compare\+Mining\+Score\+With\+Topology} (const \textbf{ Wtxid} \&hasha, const \textbf{ Wtxid} \&hashb) const
\item 
bool \textbf{ is\+Spent} (const \textbf{ COut\+Point} \&outpoint) const
\item 
unsigned int \textbf{ Get\+Transactions\+Updated} () const
\item 
void \textbf{ Add\+Transactions\+Updated} (unsigned int n)
\item 
bool \textbf{ Has\+No\+Inputs\+Of} (const \textbf{ CTransaction} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Prioritise\+Transaction} (const \textbf{ Txid} \&hash, const \textbf{ CAmount} \&n\+Fee\+Delta)
\item 
void \textbf{ Apply\+Delta} (const \textbf{ Txid} \&hash, \textbf{ CAmount} \&n\+Fee\+Delta) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Clear\+Prioritisation} (const \textbf{ Txid} \&hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ \textbf{ delta\+\_\+info} $>$ \textbf{ Get\+Prioritised\+Transactions} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!\textbf{ cs})
\item 
const \textbf{ CTransaction} $\ast$ \textbf{ Get\+Conflict\+Tx} (const \textbf{ COut\+Point} \&prevout) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::optional$<$ \textbf{ txiter} $>$ \textbf{ Get\+Iter} (const \textbf{ Txid} \&txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::optional$<$ \textbf{ txiter} $>$ \textbf{ Get\+Iter} (const \textbf{ Wtxid} \&wtxid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ set\+Entries} \textbf{ Get\+Iter\+Set} (const std\+::set$<$ \textbf{ Txid} $>$ \&hashes) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ \textbf{ txiter} $>$ \textbf{ Get\+Iter\+Vec} (const std\+::vector$<$ \textbf{ Txid} $>$ \&txids) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Update\+Transactions\+From\+Block} (const std\+::vector$<$ \textbf{ Txid} $>$ \&v\+Hashes\+To\+Update) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
void \textbf{ cs\+\_\+main} \textbf{ LOCKS\+\_\+\+EXCLUDED} (\textbf{ m\+\_\+epoch})
\item 
std\+::vector$<$ \textbf{ Fee\+Per\+Weight} $>$ \textbf{ Get\+Feerate\+Diagram} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ Fee\+Per\+Weight} \textbf{ Get\+Main\+Chunk\+Feerate} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&tx) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ const \textbf{ CTx\+Mem\+Pool\+Entry} $\ast$ $>$ \textbf{ Get\+Cluster} (\textbf{ Txid} txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
size\+\_\+t \textbf{ Get\+Unique\+Cluster\+Count} (const \textbf{ set\+Entries} \&iters\+\_\+conflicting) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ set\+Entries} \textbf{ Calculate\+Mem\+Pool\+Ancestors} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ Has\+Descendants} (const \textbf{ Txid} \&txid) const
\item 
std\+::vector$<$ \textbf{ txiter} $>$ \textbf{ Gather\+Clusters} (const std\+::vector$<$ \textbf{ Txid} $>$ \&txids) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Calculate\+Descendants} (\textbf{ txiter} \textbf{ it}, \textbf{ set\+Entries} \&set\+Descendants) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CTx\+Mem\+Pool\+::txiter} \textbf{ Calculate\+Descendants} (const \textbf{ CTx\+Mem\+Pool\+Entry} \&entry, \textbf{ set\+Entries} \&set\+Descendants) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CFee\+Rate} \textbf{ Get\+Min\+Fee} () const
\item 
void \textbf{ Trim\+To\+Size} (size\+\_\+t sizelimit, std\+::vector$<$ \textbf{ COut\+Point} $>$ $\ast$pv\+No\+Spends\+Remaining=nullptr) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
int \textbf{ Expire} (std\+::chrono\+::seconds time) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Get\+Transaction\+Ancestry} (const \textbf{ Txid} \&txid, size\+\_\+t \&ancestors, size\+\_\+t \&cluster\+\_\+count, size\+\_\+t $\ast$ancestorsize=nullptr, \textbf{ CAmount} $\ast$ancestorfees=nullptr) const
\item 
bool \textbf{ Get\+Load\+Tried} () const
\item 
void \textbf{ Set\+Load\+Tried} (bool load\+\_\+tried)
\item 
unsigned long \textbf{ size} () const
\item 
uint64\+\_\+t \textbf{ Get\+Total\+Tx\+Size} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CAmount} \textbf{ Get\+Total\+Fee} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ exists} (const \textbf{ Txid} \&txid) const
\item 
bool \textbf{ exists} (const \textbf{ Wtxid} \&wtxid) const
\item 
const \textbf{ CTx\+Mem\+Pool\+Entry} $\ast$ \textbf{ Get\+Entry} (const \textbf{ Txid} \&txid) const \textbf{ LIFETIMEBOUND} \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ CTransaction\+Ref} \textbf{ get} (const \textbf{ Txid} \&hash) const
\item 
{\footnotesize template$<$\textbf{ Txid\+Or\+Wtxid} T$>$ }\\\textbf{ Tx\+Mempool\+Info} \textbf{ info} (const \textbf{ T} \&id) const
\item 
{\footnotesize template$<$\textbf{ Txid\+Or\+Wtxid} T$>$ }\\\textbf{ Tx\+Mempool\+Info} \textbf{ info\+\_\+for\+\_\+relay} (const \textbf{ T} \&id, uint64\+\_\+t last\+\_\+sequence) const
\item 
std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+Ref} $>$ \textbf{ entry\+All} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
std\+::vector$<$ \textbf{ Tx\+Mempool\+Info} $>$ \textbf{ info\+All} () const
\item 
size\+\_\+t \textbf{ Dynamic\+Memory\+Usage} () const
\item 
void \textbf{ Add\+Unbroadcast\+Tx} (const \textbf{ Txid} \&txid)
\item 
bool \textbf{ Check\+Policy\+Limits} (const \textbf{ CTransaction\+Ref} \&tx)
\item 
void \textbf{ Remove\+Unbroadcast\+Tx} (const \textbf{ Txid} \&txid, const bool unchecked=false)
\item 
std\+::set$<$ \textbf{ Txid} $>$ \textbf{ Get\+Unbroadcast\+Txs} () const
\item 
bool \textbf{ Is\+Unbroadcast\+Tx} (const \textbf{ Txid} \&txid) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
uint64\+\_\+t \textbf{ Get\+And\+Increment\+Sequence} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
uint64\+\_\+t \textbf{ Get\+Sequence} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool \textbf{ visited} (const \textbf{ txiter} \textbf{ it}) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
bool \textbf{ visited} (std\+::optional$<$ \textbf{ txiter} $>$ \textbf{ it}) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs}
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Change\+Set} $>$ \textbf{ Get\+Change\+Set} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool m\+\_\+have\+\_\+changeset \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
void \textbf{ Start\+Block\+Building} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
\textbf{ Fee\+Per\+Weight} \textbf{ Get\+Block\+Builder\+Chunk} (std\+::vector$<$ \textbf{ CTx\+Mem\+Pool\+Entry\+::\+CTx\+Mem\+Pool\+Entry\+Ref} $>$ \&entries) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Include\+Builder\+Chunk} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Skip\+Builder\+Chunk} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ Stop\+Block\+Building} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ CTx\+Mem\+Pool}}
\begin{DoxyCompactItemize}
\item 
typedef boost\+::multi\+\_\+index\+\_\+container$<$ \textbf{ CTx\+Mem\+Pool\+Entry}, \textbf{ CTx\+Mem\+Pool\+Entry\+\_\+\+Indices} $>$ \textbf{ indexed\+\_\+transaction\+\_\+set}
\item 
using \textbf{ txiter} = indexed\+\_\+transaction\+\_\+set\+::nth\+\_\+index$<$0$>$\+::type\+::const\+\_\+iterator
\item 
typedef std\+::set$<$ \textbf{ txiter}, \textbf{ Compare\+Iterator\+By\+Hash} $>$ \textbf{ set\+Entries}
\item 
using \textbf{ Limits} = \textbf{ kernel\+::\+Mem\+Pool\+Limits}
\item 
using \textbf{ Options} = \textbf{ kernel\+::\+Mem\+Pool\+Options}
\end{DoxyCompactItemize}
\doxysubsection*{Data Fields inherited from \textbf{ CTx\+Mem\+Pool}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Recursive\+Mutex} \textbf{ cs}
\item 
const \textbf{ Options}\textbf{ Options} \textbf{ m\+\_\+opts}
\item 
void check(const \textbf{ CCoins\+View\+Cache} \&active\+\_\+coins\+\_\+tip, int64\+\_\+t spendheight) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(voi \textbf{ remove\+Recursive} )(const \textbf{ CTransaction} \&tx, \textbf{ Mem\+Pool\+Removal\+Reason} reason) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
void \textbf{ cs\+\_\+main}
\item 
bool \textbf{ m\+\_\+epoch}
\item 
return !it \textbf{ visited} $\ast$ \textbf{ it}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes inherited from \textbf{ CTx\+Mem\+Pool}}
\begin{DoxyCompactItemize}
\item 
static const int \textbf{ ROLLING\+\_\+\+FEE\+\_\+\+HALFLIFE} = 60 $\ast$ 60 $\ast$ 12
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \textbf{ CTx\+Mem\+Pool}}
\begin{DoxyCompactItemize}
\item 
uint64\+\_\+t total\+Tx\+Size \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ CAmount} m\+\_\+total\+\_\+fee \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em sum of all mempool tx\textquotesingle{}s virtual sizes. Differs from serialized tx size since witness data is discounted. Defined in BIP 141. \end{DoxyCompactList}\item 
uint64\+\_\+t cached\+Inner\+Usage \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em sum of all mempool tx\textquotesingle{}s fees (NOT modified fee) \end{DoxyCompactList}\item 
int64\+\_\+t last\+Rolling\+Fee\+Update \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em sum of dynamic memory usage of all the map elements (NOT the maps themselves) \end{DoxyCompactList}\item 
bool block\+Since\+Last\+Rolling\+Fee\+Bump \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
double rolling\+Minimum\+Fee\+Rate \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ Epoch} \textbf{ m\+\_\+epoch} \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\begin{DoxyCompactList}\small\item\em minimum fee to get into the pool, decreases exponentially \end{DoxyCompactList}\item 
uint64\+\_\+t m\+\_\+sequence\+\_\+number \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
void \textbf{ track\+Package\+Removed} (const \textbf{ CFee\+Rate} \&rate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs})
\item 
bool m\+\_\+load\+\_\+tried \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs})
\item 
\textbf{ CFee\+Rate} \textbf{ Get\+Min\+Fee} (size\+\_\+t sizelimit) const
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \textbf{ CTx\+Mem\+Pool}}
\begin{DoxyCompactItemize}
\item 
std\+::atomic$<$ unsigned int $>$ \textbf{ n\+Transactions\+Updated} \{0\}
\begin{DoxyCompactList}\small\item\em Used by getblocktemplate to trigger Create\+New\+Block() invocation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{MemPoolTest@{MemPoolTest}!GetMinFee@{GetMinFee}}
\index{GetMinFee@{GetMinFee}!MemPoolTest@{MemPoolTest}}
\doxysubsubsection{GetMinFee()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_mem_pool_test_a75775c43d0d75f872ffecfd91650e116} 
\textbf{ CFee\+Rate} Get\+Min\+Fee (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

The minimum fee to get into the mempool, which may itself not be enough for larger-\/sized transactions. The m\+\_\+incremental\+\_\+relay\+\_\+feerate policy variable is used to bound the time it takes the fee rate to go back down all the way to 0. When the feerate would otherwise be half of this, it is set to 0 instead. \index{MemPoolTest@{MemPoolTest}!GetMinFee@{GetMinFee}}
\index{GetMinFee@{GetMinFee}!MemPoolTest@{MemPoolTest}}
\doxysubsubsection{GetMinFee()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_mem_pool_test_a7afb20886dc0488c9f76578b16b4faad} 
\textbf{ CFee\+Rate} Get\+Min\+Fee (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{sizelimit}{}\end{DoxyParamCaption}) const}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/test/\textbf{ mempool\+\_\+tests.\+cpp}\end{DoxyCompactItemize}
