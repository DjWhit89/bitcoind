\doxysection{Rng Class Reference}
\label{classankerl_1_1nanobench_1_1_rng}\index{Rng@{Rng}}


{\ttfamily \#include $<$nanobench.\+h$>$}

\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \textbf{ result\+\_\+type} = uint64\+\_\+t
\begin{DoxyCompactList}\small\item\em This RNG provides 64bit randomness. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Rng} (Rng const \&)=delete
\item 
\textbf{ Rng} \& \textbf{ operator=} (\textbf{ Rng} const \&)=delete
\item 
\textbf{ Rng} (Rng \&\&) noexcept=default
\item 
\textbf{ Rng} \& \textbf{ operator=} (\textbf{ Rng} \&\&) noexcept=default
\item 
\textbf{ $\sim$\+Rng} () noexcept=default
\item 
\textbf{ Rng} ()
\begin{DoxyCompactList}\small\item\em Creates a new Random generator with random seed. \end{DoxyCompactList}\item 
\textbf{ Rng} (uint64\+\_\+t seed) noexcept
\item 
\textbf{ Rng} (uint64\+\_\+t x, uint64\+\_\+t y) noexcept
\item 
\textbf{ Rng} (std\+::vector$<$ uint64\+\_\+t $>$ const \&data)
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) \textbf{ Rng} copy() const noexcept
\item 
uint64\+\_\+t \textbf{ operator()} () noexcept
\begin{DoxyCompactList}\small\item\em Produces a 64bit random value. This should be very fast, thus it is marked as inline. In my benchmark, this is $\sim$46 times faster than {\ttfamily std\+::default\+\_\+random\+\_\+engine} for producing 64bit random values. It seems that the fastest std contender is {\ttfamily std\+::mt19937\+\_\+64}. Still, this RNG is 2-\/3 times as fast. \end{DoxyCompactList}\item 
uint32\+\_\+t \textbf{ bounded} (uint32\+\_\+t range) noexcept
\item 
double \textbf{ uniform01} () noexcept
\item 
{\footnotesize template$<$typename Container$>$ }\\void \textbf{ shuffle} (Container \&container) noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr uint64\+\_\+t \textbf{ min} ()
\item 
static constexpr uint64\+\_\+t \textbf{ max} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
An extremely fast random generator. Currently, this implements {\itshape Romu\+Duo\+Jr}, developed by Mark Overton. Source\+: {\texttt{http\+://www.\+romu-\/random.\+org/}}

Romu\+Duo\+Jr is extremely fast and provides reasonable good randomness. Not enough for large jobs, but definitely good enough for a benchmarking framework.


\begin{DoxyItemize}
\item Estimated capacity\+: $ 2^{51} $ bytes
\item Register pressure\+: 4
\item \doxyref{State}{p.}{headers__sync__chainwork__tests_8cpp_ae883f65c4951396ab945f766e09e3c94} size\+: 128 bits
\end{DoxyItemize}

This random generator is a drop-\/in replacement for the generators supplied by {\ttfamily $<$random$>$}. It is not cryptographically secure. It\textquotesingle{}s intended purpose is to be very fast so that benchmarks that make use of randomness are not distorted too much by the random generator.

\doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng} also provides a few non-\/standard helpers, optimized for speed. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{Rng@{Rng}!result\_type@{result\_type}}
\index{result\_type@{result\_type}!Rng@{Rng}}
\doxysubsubsection{result\_type}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_ae09bda5b21273560a98edf490a2a1172} 
using \textbf{ result\+\_\+type} = uint64\+\_\+t}



This RNG provides 64bit randomness. 



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Rng@{Rng}!Rng@{Rng}}
\index{Rng@{Rng}!Rng@{Rng}}
\doxysubsubsection{Rng()\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a4f9307a675ebaa03bf39e53f471c4c5b} 
Rng (\begin{DoxyParamCaption}\item[{Rng const \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

As a safety precaution, we don\textquotesingle{}t allow copying. Copying a PRNG would mean you would have two random generators that produce the same sequence, which is generally not what one wants. Instead create a new rng with the default constructor \doxyref{Rng()}{p.}{classankerl_1_1nanobench_1_1_rng_a86f83b16aa4240810ebd8142c2bd984c}, which is automatically seeded from {\ttfamily std\+::random\+\_\+device}. If you really need a copy, use {\ttfamily copy()}. \index{Rng@{Rng}!Rng@{Rng}}
\index{Rng@{Rng}!Rng@{Rng}}
\doxysubsubsection{Rng()\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a4dd1c2f4418bca511ebd3e0f737ddef6} 
Rng (\begin{DoxyParamCaption}\item[{Rng \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{Rng@{Rng}!````~Rng@{$\sim$Rng}}
\index{````~Rng@{$\sim$Rng}!Rng@{Rng}}
\doxysubsubsection{$\sim$Rng()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a77dfb47bddc83f5127f45ac593b111c2} 
$\sim$\textbf{ Rng} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{Rng@{Rng}!Rng@{Rng}}
\index{Rng@{Rng}!Rng@{Rng}}
\doxysubsubsection{Rng()\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a86f83b16aa4240810ebd8142c2bd984c} 
Rng (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Creates a new Random generator with random seed. 

Instead of a default seed (as the random generators from the STD), this properly seeds the random generator from {\ttfamily std\+::random\+\_\+device}. It guarantees correct seeding. Note that seeding can be relatively slow, depending on the source of randomness used. So it is best to create a \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng} once and use it for all your randomness purposes. \index{Rng@{Rng}!Rng@{Rng}}
\index{Rng@{Rng}!Rng@{Rng}}
\doxysubsubsection{Rng()\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_aa975b23f442b880e0464b983cbfaa913} 
Rng (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{seed}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}, {\ttfamily [noexcept]}}

Creates a new \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng} that is seeded with a specific seed. Each \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng} created from the same seed will produce the same randomness sequence. This can be useful for deterministic behavior.

\begin{DoxyVerb}embed:rst
.. note::

   The random algorithm might change between nanobench releases. Whenever a faster and/or better random
   generator becomes available, I will switch the implementation.
\end{DoxyVerb}


As per the Romu paper, this seeds the \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng} with split\+Mix64 algorithm and performs 10 initial rounds for further mixing up of the internal state.


\begin{DoxyParams}{Parameters}
{\em seed} & The 64bit seed. All values are allowed, even 0. \\
\hline
\end{DoxyParams}
\index{Rng@{Rng}!Rng@{Rng}}
\index{Rng@{Rng}!Rng@{Rng}}
\doxysubsubsection{Rng()\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_ae23864321191c777758e0054e5c81038} 
Rng (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{x}{, }\item[{uint64\+\_\+t}]{y}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Rng@{Rng}!Rng@{Rng}}
\index{Rng@{Rng}!Rng@{Rng}}
\doxysubsubsection{Rng()\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a377e53f0579d0c9742d3a8e5b458b5e7} 
Rng (\begin{DoxyParamCaption}\item[{std\+::vector$<$ uint64\+\_\+t $>$ const \&}]{data}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Rng@{Rng}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Rng@{Rng}}
\doxysubsubsection{ANKERL\_NANOBENCH()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_ade63acbfc2122333ce5b5d070c036a38} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Creates a copy of the \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng}, thus the copy provides exactly the same random sequence as the original. \index{Rng@{Rng}!bounded@{bounded}}
\index{bounded@{bounded}!Rng@{Rng}}
\doxysubsubsection{bounded()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a017c38492f5151d4f5a8566909ca236c} 
uint32\+\_\+t bounded (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{range}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Generates a random number between 0 and range (excluding range).

The algorithm only produces 32bit numbers, and is slightly biased. The effect is quite small unless your range is close to the maximum value of an integer. It is possible to correct the bias with rejection sampling (see {\texttt{here}}, but this is most likely irrelevant in practices for the purposes of this \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng}.

See Daniel Lemire\textquotesingle{}s blog post {\texttt{A fast alternative to the modulo reduction}}


\begin{DoxyParams}{Parameters}
{\em range} & Upper exclusive range. E.\+g a value of 3 will generate random numbers 0, 1, 2. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint32\+\_\+t Generated random values in range [0, range(. 
\end{DoxyReturn}
\index{Rng@{Rng}!max@{max}}
\index{max@{max}!Rng@{Rng}}
\doxysubsubsection{max()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_ad9793b70696830eb34deaf0acdf55126} 
uint64\+\_\+t max (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

\index{Rng@{Rng}!min@{min}}
\index{min@{min}!Rng@{Rng}}
\doxysubsubsection{min()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a1f7b8e49e5d1e5dbc26ec3440312c373} 
uint64\+\_\+t min (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

\index{Rng@{Rng}!operator()@{operator()}}
\index{operator()@{operator()}!Rng@{Rng}}
\doxysubsubsection{operator()()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_aa25a7475df9e61004f5c8dc7a950a6a2} 
uint64\+\_\+t operator() (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}



Produces a 64bit random value. This should be very fast, thus it is marked as inline. In my benchmark, this is $\sim$46 times faster than {\ttfamily std\+::default\+\_\+random\+\_\+engine} for producing 64bit random values. It seems that the fastest std contender is {\ttfamily std\+::mt19937\+\_\+64}. Still, this RNG is 2-\/3 times as fast. 

\begin{DoxyReturn}{Returns}
uint64\+\_\+t The next 64 bit random value. 
\end{DoxyReturn}
\index{Rng@{Rng}!operator=@{operator=}}
\index{operator=@{operator=}!Rng@{Rng}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a37cba82ca15ef6a85a942c5c21e15d88} 
\textbf{ Rng} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ Rng} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{Rng@{Rng}!operator=@{operator=}}
\index{operator=@{operator=}!Rng@{Rng}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a7949f4d69fee86ad2fc555447f2d54bd} 
\textbf{ Rng} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ Rng} const \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

Same as \doxyref{Rng(\+Rng const\&)}{p.}{classankerl_1_1nanobench_1_1_rng_a4f9307a675ebaa03bf39e53f471c4c5b}, we don\textquotesingle{}t allow assignment. If you need a new \doxyref{Rng}{p.}{classankerl_1_1nanobench_1_1_rng} create one with the default constructor \doxyref{Rng()}{p.}{classankerl_1_1nanobench_1_1_rng_a86f83b16aa4240810ebd8142c2bd984c}. \index{Rng@{Rng}!shuffle@{shuffle}}
\index{shuffle@{shuffle}!Rng@{Rng}}
\doxysubsubsection{shuffle()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a2dce85d19b09e36c22400ac47a38ce54} 
template$<$typename Container$>$ \\
void shuffle (\begin{DoxyParamCaption}\item[{Container \&}]{container}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Shuffles all entries in the given container. Although this has a slight bias due to the implementation of \doxyref{bounded()}{p.}{classankerl_1_1nanobench_1_1_rng_a017c38492f5151d4f5a8566909ca236c}, this is preferable to {\ttfamily std\+::shuffle} because it is over 5 times faster. See Daniel Lemire\textquotesingle{}s blog post {\texttt{Fast random shuffling}}.


\begin{DoxyParams}{Parameters}
{\em container} & The whole container will be shuffled. \\
\hline
\end{DoxyParams}
\index{Rng@{Rng}!uniform01@{uniform01}}
\index{uniform01@{uniform01}!Rng@{Rng}}
\doxysubsubsection{uniform01()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_rng_a7b7654f256407efb2c3ca964fb1c6d45} 
double uniform01 (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Provides a random uniform double value between 0 and 1. This uses the method described in {\texttt{Generating uniform doubles in the unit interval}}, and is extremely fast.

\begin{DoxyReturn}{Returns}
double Uniformly distributed double value in range [0,1(, excluding 1. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/bench/\textbf{ nanobench.\+h}\end{DoxyCompactItemize}
