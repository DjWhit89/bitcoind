\doxysection{CBlock\+Policy\+Estimator Class Reference}
\label{class_c_block_policy_estimator}\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}}


{\ttfamily \#include $<$block\+\_\+policy\+\_\+estimator.\+h$>$}

Inheritance diagram for CBlock\+Policy\+Estimator\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_block_policy_estimator}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CBlock\+Policy\+Estimator} (const \textbf{ fs\+::path} \&estimation\+\_\+filepath, const bool read\+\_\+stale\+\_\+estimates)
\item 
virtual \textbf{ $\sim$\+CBlock\+Policy\+Estimator} ()
\item 
void \textbf{ process\+Block} (const std\+::vector$<$ \textbf{ Removed\+Mempool\+Transaction\+Info} $>$ \&txs\+\_\+removed\+\_\+for\+\_\+block, unsigned int n\+Block\+Height) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
void \textbf{ process\+Transaction} (const \textbf{ New\+Mempool\+Transaction\+Info} \&tx) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
bool \textbf{ remove\+Tx} (\textbf{ Txid} hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
\textbf{ CFee\+Rate} \textbf{ estimate\+Fee} (int conf\+Target) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
virtual \textbf{ CFee\+Rate} \textbf{ estimate\+Smart\+Fee} (int conf\+Target, \textbf{ Fee\+Calculation} $\ast$fee\+Calc, bool conservative) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
\textbf{ CFee\+Rate} \textbf{ estimate\+Raw\+Fee} (int conf\+Target, double success\+Threshold, \textbf{ Fee\+Estimate\+Horizon} horizon, \textbf{ Estimation\+Result} $\ast$result=nullptr) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
bool \textbf{ Write} (\textbf{ Auto\+File} \&fileout) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
bool \textbf{ Read} (\textbf{ Auto\+File} \&filein) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
void \textbf{ Flush\+Unconfirmed} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
virtual unsigned int \textbf{ Highest\+Target\+Tracked} (\textbf{ Fee\+Estimate\+Horizon} horizon) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
void \textbf{ Flush} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
void \textbf{ Flush\+Fee\+Estimates} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
std\+::chrono\+::hours \textbf{ Get\+Fee\+Estimator\+File\+Age} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Transaction\+Added\+To\+Mempool} (const \textbf{ New\+Mempool\+Transaction\+Info} \&tx, uint64\+\_\+t) override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
void \textbf{ Transaction\+Removed\+From\+Mempool} (const \textbf{ CTransaction\+Ref} \&tx, \textbf{ Mem\+Pool\+Removal\+Reason}, uint64\+\_\+t) override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\item 
void \textbf{ Mempool\+Transactions\+Removed\+For\+Block} (const std\+::vector$<$ \textbf{ Removed\+Mempool\+Transaction\+Info} $>$ \&txs\+\_\+removed\+\_\+for\+\_\+block, unsigned int n\+Block\+Height) override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+cs\+\_\+fee\+\_\+estimator)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \textbf{ CValidation\+Interface}}
\begin{DoxyCompactItemize}
\item 
\textbf{ $\sim$\+CValidation\+Interface} ()=default
\item 
virtual void \textbf{ Updated\+Block\+Tip} (const \textbf{ CBlock\+Index} $\ast$pindex\+New, const \textbf{ CBlock\+Index} $\ast$pindex\+Fork, bool f\+Initial\+Download)
\item 
virtual void \textbf{ Active\+Tip\+Change} (const \textbf{ CBlock\+Index} \&new\+\_\+tip, bool is\+\_\+ibd)
\item 
virtual void \textbf{ Block\+Connected} (const \textbf{ kernel\+::\+Chainstate\+Role} \&role, const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block, const \textbf{ CBlock\+Index} $\ast$pindex)
\item 
virtual void \textbf{ Block\+Disconnected} (const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block, const \textbf{ CBlock\+Index} $\ast$pindex)
\item 
virtual void \textbf{ Chain\+State\+Flushed} (const \textbf{ kernel\+::\+Chainstate\+Role} \&role, const \textbf{ CBlock\+Locator} \&locator)
\item 
virtual void \textbf{ Block\+Checked} (const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&, const \textbf{ Block\+Validation\+State} \&)
\item 
virtual void \textbf{ New\+Po\+WValid\+Block} (const \textbf{ CBlock\+Index} $\ast$pindex, const std\+::shared\+\_\+ptr$<$ const \textbf{ CBlock} $>$ \&block)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
The Block\+Policy\+Estimator is used for estimating the feerate needed for a transaction to be included in a block within a certain number of blocks.

At a high level the algorithm works by grouping transactions into buckets based on having similar feerates and then tracking how long it takes transactions in the various buckets to be mined. It operates under the assumption that in general transactions of higher feerate will be included in blocks before transactions of lower feerate. So for example if you wanted to know what feerate you should put on a transaction to be included in a block within the next 5 blocks, you would start by looking at the bucket with the highest feerate transactions and verifying that a sufficiently high percentage of them were confirmed within 5 blocks and then you would look at the next highest feerate bucket, and so on, stopping at the last bucket to pass the test. The average feerate of transactions in this bucket will give you an indication of the lowest feerate you can put on a transaction and still have a sufficiently high chance of being confirmed within your desired 5 blocks.

Here is a brief description of the implementation\+: When a transaction enters the mempool, we track the height of the block chain at entry. All further calculations are conducted only on this set of "{}seen"{} transactions. Whenever a block comes in, we count the number of transactions in each bucket and the total amount of feerate paid in each bucket. Then we calculate how many blocks Y it took each transaction to be mined. We convert from a number of blocks to a number of periods Y\textquotesingle{} each encompassing "{}scale"{} blocks. This is tracked in 3 different data sets each up to a maximum number of periods. Within each data set we have an array of counters in each feerate bucket and we increment all the counters from Y\textquotesingle{} up to max periods representing that a tx was successfully confirmed in less than or equal to that many periods. We want to save a history of this information, so at any time we have a counter of the total number of transactions that happened in a given feerate bucket and the total number that were confirmed in each of the periods or less for any bucket. We save this history by keeping an exponentially decaying moving average of each one of these stats. This is done for a different decay in each of the 3 data sets to keep relevant data from different time horizons. Furthermore we also keep track of the number unmined (in mempool or left mempool without being included in a block) transactions in each bucket and for how many blocks they have been outstanding and use both of these numbers to increase the number of transactions we\textquotesingle{}ve seen in that feerate bucket when calculating an estimate for any number of confirmations below the number of blocks they\textquotesingle{}ve been outstanding.

We want to be able to estimate feerates that are needed on tx\textquotesingle{}s to be included in a certain number of blocks. Every time a block is added to the best chain, this class records stats on the transactions included in that block 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{CBlockPolicyEstimator()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a815227f17255990ccf29ea25464c043c} 
\textbf{ CBlock\+Policy\+Estimator} (\begin{DoxyParamCaption}\item[{const \textbf{ fs\+::path} \&}]{estimation\+\_\+filepath}{, }\item[{const bool}]{read\+\_\+stale\+\_\+estimates}{}\end{DoxyParamCaption})}

Create new Block\+Policy\+Estimator and initialize stats tracking classes with default values \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!````~CBlockPolicyEstimator@{$\sim$CBlockPolicyEstimator}}
\index{````~CBlockPolicyEstimator@{$\sim$CBlockPolicyEstimator}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{$\sim$CBlockPolicyEstimator()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a47ebc7133c7fddd3bc81483c1741d690} 
$\sim$\textbf{ CBlock\+Policy\+Estimator} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!estimateFee@{estimateFee}}
\index{estimateFee@{estimateFee}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{estimateFee()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_ad080776568edc383fecca04b03922daa} 
\textbf{ CFee\+Rate} estimate\+Fee (\begin{DoxyParamCaption}\item[{int}]{conf\+Target}{}\end{DoxyParamCaption}) const}

DEPRECATED. Return a feerate estimate \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!estimateRawFee@{estimateRawFee}}
\index{estimateRawFee@{estimateRawFee}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{estimateRawFee()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_aebb09054edb6c8141fd011472b7913d7} 
\textbf{ CFee\+Rate} estimate\+Raw\+Fee (\begin{DoxyParamCaption}\item[{int}]{conf\+Target}{, }\item[{double}]{success\+Threshold}{, }\item[{\textbf{ Fee\+Estimate\+Horizon}}]{horizon}{, }\item[{\textbf{ Estimation\+Result} $\ast$}]{result}{ = {\ttfamily nullptr}}\end{DoxyParamCaption}) const}

Return a specific fee estimate calculation with a given success threshold and time horizon, and optionally return detailed data about calculation \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!estimateSmartFee@{estimateSmartFee}}
\index{estimateSmartFee@{estimateSmartFee}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{estimateSmartFee()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a91a7a3600d2d4ed050dddc8af78344d4} 
\textbf{ CFee\+Rate} estimate\+Smart\+Fee (\begin{DoxyParamCaption}\item[{int}]{conf\+Target}{, }\item[{\textbf{ Fee\+Calculation} $\ast$}]{fee\+Calc}{, }\item[{bool}]{conservative}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Estimate feerate needed to get be included in a block within conf\+Target blocks. If no answer can be given at conf\+Target, return an estimate at the closest target where one can be given. \textquotesingle{}conservative\textquotesingle{} estimates are valid over longer time horizons also.

estimate\+Smart\+Fee returns the max of the feerates calculated with a 60\% threshold required at target / 2, an 85\% threshold required at target and a 95\% threshold required at 2 $\ast$ target. Each calculation is performed at the shortest time horizon which tracks the required target. Conservative estimates, however, required the 95\% threshold at 2 $\ast$ target be met for any longer time horizons also. true is passed to estimate\+Combined fee for target/2 and target so that we check the max confirms for shorter time horizons as well. This is necessary to preserve monotonically increasing estimates. For non-\/conservative estimates we do the same thing for 2$\ast$target, but for conservative estimates we want to skip these shorter horizons checks for 2$\ast$target because we are taking the max over all time horizons so we already have monotonically increasing estimates and the purpose of conservative estimates is not to let short term fluctuations lower our estimates by too much.

Note\+: In certain rare edge cases, monotonically increasing estimates may not be guaranteed. Specifically, given two targets N and M, where M $>$ N, if a sub-\/estimate for target N fails to return a valid fee rate, while target M has valid fee rate for that sub-\/estimate, target M may result in a higher fee rate estimate than target N.

See\+: {\texttt{https\+://github.\+com/bitcoin/bitcoin/issues/11800\#issuecomment-\/349697807}}\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!Flush@{Flush}}
\index{Flush@{Flush}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{Flush()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_aeccd7769dcdae47867184fd809016799} 
void Flush (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Drop still unconfirmed transactions and record current estimations, if the fee estimation file is present. \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!FlushFeeEstimates@{FlushFeeEstimates}}
\index{FlushFeeEstimates@{FlushFeeEstimates}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{FlushFeeEstimates()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a39973876d07137743f37456b71c5711b} 
void Flush\+Fee\+Estimates (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Record current fee estimations. \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!FlushUnconfirmed@{FlushUnconfirmed}}
\index{FlushUnconfirmed@{FlushUnconfirmed}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{FlushUnconfirmed()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a0814f91b291e30546df18c6831b3ae8b} 
void Flush\+Unconfirmed (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!GetFeeEstimatorFileAge@{GetFeeEstimatorFileAge}}
\index{GetFeeEstimatorFileAge@{GetFeeEstimatorFileAge}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{GetFeeEstimatorFileAge()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a7767edfa6aa286e24a456adf484e6860} 
std\+::chrono\+::hours Get\+Fee\+Estimator\+File\+Age (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Calculates the age of the file, since last modified \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!HighestTargetTracked@{HighestTargetTracked}}
\index{HighestTargetTracked@{HighestTargetTracked}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{HighestTargetTracked()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a3efe98e3f82015824278af45fb8d07e5} 
unsigned int Highest\+Target\+Tracked (\begin{DoxyParamCaption}\item[{\textbf{ Fee\+Estimate\+Horizon}}]{horizon}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Calculation of highest target that estimates are tracked for \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!MempoolTransactionsRemovedForBlock@{MempoolTransactionsRemovedForBlock}}
\index{MempoolTransactionsRemovedForBlock@{MempoolTransactionsRemovedForBlock}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{MempoolTransactionsRemovedForBlock()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a011805724fc262857fa82f49186c7455} 
void Mempool\+Transactions\+Removed\+For\+Block (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ Removed\+Mempool\+Transaction\+Info} $>$ \&}]{txs\+\_\+removed\+\_\+for\+\_\+block}{, }\item[{unsigned int}]{n\+Block\+Height}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



Reimplemented from \textbf{ CValidation\+Interface} \doxyref{}{p.}{class_c_validation_interface_a5a935698165aa2894a458e663be2f0db}.

\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!processBlock@{processBlock}}
\index{processBlock@{processBlock}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{processBlock()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a65f0b56680542778f34609dca718e8c6} 
void process\+Block (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ Removed\+Mempool\+Transaction\+Info} $>$ \&}]{txs\+\_\+removed\+\_\+for\+\_\+block}{, }\item[{unsigned int}]{n\+Block\+Height}{}\end{DoxyParamCaption})}

Process all the transactions that have been included in a block \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!processTransaction@{processTransaction}}
\index{processTransaction@{processTransaction}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{processTransaction()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a77dd2df6a56ac08a4da69d9a14c565f1} 
void process\+Transaction (\begin{DoxyParamCaption}\item[{const \textbf{ New\+Mempool\+Transaction\+Info} \&}]{tx}{}\end{DoxyParamCaption})}

Process a transaction accepted to the mempool \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!Read@{Read}}
\index{Read@{Read}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{Read()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_ad3295f8549a3322f053137055a15ecf9} 
bool Read (\begin{DoxyParamCaption}\item[{\textbf{ Auto\+File} \&}]{filein}{}\end{DoxyParamCaption})}

Read estimation data from a file \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!removeTx@{removeTx}}
\index{removeTx@{removeTx}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{removeTx()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_ae527d524ab2393114960a1dd71bc9fac} 
bool remove\+Tx (\begin{DoxyParamCaption}\item[{\textbf{ Txid}}]{hash}{}\end{DoxyParamCaption})}

Remove a transaction from the mempool tracking stats for non BLOCK removal reasons \index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!TransactionAddedToMempool@{TransactionAddedToMempool}}
\index{TransactionAddedToMempool@{TransactionAddedToMempool}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{TransactionAddedToMempool()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a82ce5bcdb57e2684d50b589d18e82624} 
void Transaction\+Added\+To\+Mempool (\begin{DoxyParamCaption}\item[{const \textbf{ New\+Mempool\+Transaction\+Info} \&}]{tx}{, }\item[{uint64\+\_\+t}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Overridden from \doxyref{CValidation\+Interface}{p.}{class_c_validation_interface}. 

Reimplemented from \textbf{ CValidation\+Interface} \doxyref{}{p.}{class_c_validation_interface_a7a2ce3dce287e7b5ec214b4bcfe05a99}.

\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!TransactionRemovedFromMempool@{TransactionRemovedFromMempool}}
\index{TransactionRemovedFromMempool@{TransactionRemovedFromMempool}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{TransactionRemovedFromMempool()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a0aa4813d9d5f3e8f4c71be5f205b8f20} 
void Transaction\+Removed\+From\+Mempool (\begin{DoxyParamCaption}\item[{const \textbf{ CTransaction\+Ref} \&}]{tx}{, }\item[{\textbf{ Mem\+Pool\+Removal\+Reason}}]{reason}{, }\item[{uint64\+\_\+t}]{mempool\+\_\+sequence}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Notifies listeners of a transaction leaving mempool.

This notification fires for transactions that are removed from the mempool for the following reasons\+:


\begin{DoxyItemize}
\item EXPIRY (expired from mempool after -\/mempoolexpiry hours)
\item SIZELIMIT (removed in size limiting if the mempool exceeds -\/maxmempool megabytes)
\item REORG (removed during a reorg)
\item CONFLICT (removed because it conflicts with in-\/block transaction)
\item REPLACED (removed due to RBF replacement)
\end{DoxyItemize}

This does not fire for transactions that are removed from the mempool because they have been included in a block. Any client that is interested in transactions removed from the mempool for inclusion in a block can learn about those transactions from the Mempool\+Transactions\+Removed\+For\+Block notification.

Transactions that are removed from the mempool because they conflict with a transaction in the new block will have Transaction\+Removed\+From\+Mempool events fired {\itshape before} the Block\+Connected event is fired. If multiple blocks are connected in one step, then the ordering could be\+:


\begin{DoxyItemize}
\item Transaction\+Removed\+From\+Mempool(tx1 from block A)
\item Transaction\+Removed\+From\+Mempool(tx2 from block A)
\item Transaction\+Removed\+From\+Mempool(tx1 from block B)
\item Transaction\+Removed\+From\+Mempool(tx2 from block B)
\item Block\+Connected(\+A)
\item Block\+Connected(\+B)
\end{DoxyItemize}

Called on a background thread. 

Reimplemented from \textbf{ CValidation\+Interface} \doxyref{}{p.}{class_c_validation_interface_a34351b1a3571af34d86d50d96c1c7b01}.

\index{CBlockPolicyEstimator@{CBlockPolicyEstimator}!Write@{Write}}
\index{Write@{Write}!CBlockPolicyEstimator@{CBlockPolicyEstimator}}
\doxysubsubsection{Write()}
{\footnotesize\ttfamily \label{class_c_block_policy_estimator_a38b652a99060c3e2ec89ce60f1c3b71a} 
bool Write (\begin{DoxyParamCaption}\item[{\textbf{ Auto\+File} \&}]{fileout}{}\end{DoxyParamCaption}) const}

Write estimation data to a file 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/policy/fees/\textbf{ block\+\_\+policy\+\_\+estimator.\+h}\item 
src/policy/fees/\textbf{ block\+\_\+policy\+\_\+estimator.\+cpp}\end{DoxyCompactItemize}
