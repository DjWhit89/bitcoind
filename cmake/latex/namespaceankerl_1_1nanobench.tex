\doxysection{ankerl\+::nanobench Namespace Reference}
\label{namespaceankerl_1_1nanobench}\index{ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ templates}
\item 
namespace \textbf{ detail}
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Config}
\item 
class \textbf{ Result}
\item 
class \textbf{ Rng}
\item 
class \textbf{ Bench}
\begin{DoxyCompactList}\small\item\em Main entry point to nanobench\textquotesingle{}s benchmarking facility. \end{DoxyCompactList}\item 
class \textbf{ BigO}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Clock}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ render} (char const $\ast$mustache\+Template, \textbf{ Bench} const \&bench, std\+::ostream \&out)
\begin{DoxyCompactList}\small\item\em Renders output from a mustache-\/like template and benchmark results. \end{DoxyCompactList}\item 
void \textbf{ render} (std\+::string const \&mustache\+Template, \textbf{ Bench} const \&bench, std\+::ostream \&out)
\item 
void \textbf{ render} (char const $\ast$mustache\+Template, std\+::vector$<$ \textbf{ Result} $>$ const \&results, std\+::ostream \&out)
\item 
void \textbf{ render} (std\+::string const \&mustache\+Template, std\+::vector$<$ \textbf{ Result} $>$ const \&results, std\+::ostream \&out)
\item 
{\footnotesize template$<$typename Arg$>$ }\\void \textbf{ do\+Not\+Optimize\+Away} (Arg \&\&arg)
\begin{DoxyCompactList}\small\item\em Makes sure none of the given arguments are optimized away by the compiler. \end{DoxyCompactList}\item 
std\+::ostream \& \textbf{ operator$<$$<$} (std\+::ostream \&os, \textbf{ BigO} const \&bigO)
\item 
std\+::ostream \& \textbf{ operator$<$$<$} (std\+::ostream \&os, std\+::vector$<$ \textbf{ ankerl\+::nanobench\+::\+BigO} $>$ const \&big\+Os)
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{ankerl::nanobench@{ankerl::nanobench}!Clock@{Clock}}
\index{Clock@{Clock}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{Clock}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_a75c517a490cc337babc53b6c5008cdb5} 
using \textbf{ Clock}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::conditional<std::chrono::high\_resolution\_clock::is\_steady,\ std::chrono::high\_resolution\_clock,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::chrono::steady\_clock>::type}

\end{DoxyCode}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{ankerl::nanobench@{ankerl::nanobench}!doNotOptimizeAway@{doNotOptimizeAway}}
\index{doNotOptimizeAway@{doNotOptimizeAway}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{doNotOptimizeAway()}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_a3212d2fb3075373651a84b10c6e27f5a} 
template$<$typename Arg$>$ \\
void do\+Not\+Optimize\+Away (\begin{DoxyParamCaption}\item[{Arg \&\&}]{arg}{}\end{DoxyParamCaption})}



Makes sure none of the given arguments are optimized away by the compiler. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Arg} & Type of the argument that shouldn\textquotesingle{}t be optimized away. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em arg} & The input that we mark as being used, even though we don\textquotesingle{}t do anything with it. \\
\hline
\end{DoxyParams}
\index{ankerl::nanobench@{ankerl::nanobench}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{operator$<$$<$()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_ac6dfa99fbb0ccc7e9057b5fccef501d8} 
std\+::ostream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{, }\item[{\textbf{ BigO} const \&}]{bigO}{}\end{DoxyParamCaption})}

\index{ankerl::nanobench@{ankerl::nanobench}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{operator$<$$<$()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_a3f1e3dca5735b98bda904a5bb78fff2c} 
std\+::ostream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{, }\item[{std\+::vector$<$ \textbf{ ankerl\+::nanobench\+::\+BigO} $>$ const \&}]{big\+Os}{}\end{DoxyParamCaption})}

\index{ankerl::nanobench@{ankerl::nanobench}!render@{render}}
\index{render@{render}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{render()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_aa8b83321afa5228fa13d67157ad8657e} 
void render (\begin{DoxyParamCaption}\item[{char const $\ast$}]{mustache\+Template}{, }\item[{\textbf{ Bench} const \&}]{bench}{, }\item[{std\+::ostream \&}]{out}{}\end{DoxyParamCaption})}



Renders output from a mustache-\/like template and benchmark results. 

The templating facility here is heavily inspired by {\texttt{mustache -\/ logic-\/less templates}}. It adds a few more features that are necessary to get all of the captured data out of nanobench. Please read the excellent {\texttt{mustache manual}} to see what this is all about.

nanobench output has two nested layers, {\itshape result} and {\itshape measurement}. Here is a hierarchy of the allowed tags\+:


\begin{DoxyItemize}
\item {\ttfamily \{\{\#result\}\}} Marks the begin of the result layer. Whatever comes after this will be instantiated as often as a benchmark result is available. Within it, you can use these tags\+:
\begin{DoxyItemize}
\item {\ttfamily \{\{title\}\}} See \doxyref{Bench\+::title}{p.}{classankerl_1_1nanobench_1_1_bench_a4e7209cd88a09e1e2278f0d506dd3aa3}.
\item {\ttfamily \{\{\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}\}\}} Benchmark name, usually directly provided with \doxyref{Bench\+::run}{p.}{classankerl_1_1nanobench_1_1_bench_ae0f1d3ec977f3733d457b759b1f08e9e}, but can also be set with \doxyref{Bench\+::name}{p.}{classankerl_1_1nanobench_1_1_bench_a8a87b6c0978c4d69179ee249beb86c0c}.
\item {\ttfamily \{\{unit\}\}} Unit, e.\+g. {\ttfamily byte}. Defaults to {\ttfamily op}, see \doxyref{Bench\+::unit}{p.}{classankerl_1_1nanobench_1_1_bench_a7fada6f805f9af86b8508e8ef028d936}.
\item {\ttfamily \{\{batch\}\}} Batch size, see \doxyref{Bench\+::batch}{p.}{classankerl_1_1nanobench_1_1_bench_a37d376bc0b00680fc13656e4761f8168}.
\item {\ttfamily \{\{complexityN\}\}} Value used for asymptotic complexity calculation. See \doxyref{Bench\+::complexityN}{p.}{classankerl_1_1nanobench_1_1_bench_a4c2fa1375c3a79a88cfb8532b4017f69}.
\item {\ttfamily \{\{epochs\}\}} Number of epochs, see \doxyref{Bench\+::epochs}{p.}{classankerl_1_1nanobench_1_1_bench_a2aace9b04e1962c6490d7b2bbcbf0269}.
\item {\ttfamily \{\{clock\+Resolution\}\}} Accuracy of the clock, i.\+e. what\textquotesingle{}s the smallest time possible to measure with the clock. For modern systems, this can be around 20 ns. This value is automatically determined by nanobench at the first benchmark that is run, and used as a static variable throughout the application\textquotesingle{}s runtime.
\item {\ttfamily \{\{clock\+Resolution\+Multiple\}\}} Configuration multiplier for {\ttfamily clock\+Resolution}. See \doxyref{Bench\+::clock\+Resolution\+Multiple}{p.}{classankerl_1_1nanobench_1_1_bench_a92b3a1e3050c61c1e24e42a116b92a87}. This is the target runtime for each measurement (epoch). That means the more accurate your clock is, the faster will be the benchmark. Basing the measurement\textquotesingle{}s runtime on the clock resolution is the main reason why nanobench is so fast.
\item {\ttfamily \{\{max\+Epoch\+Time\}\}} Configuration for a maximum time each measurement (epoch) is allowed to take. Note that at least a single iteration will be performed, even when that takes longer than max\+Epoch\+Time. See \doxyref{Bench\+::max\+Epoch\+Time}{p.}{classankerl_1_1nanobench_1_1_bench_abb7e4067323a8d7569e9867b03a35b39}.
\item {\ttfamily \{\{min\+Epoch\+Time\}\}} Minimum epoch time, defaults to 1ms. See \doxyref{Bench\+::min\+Epoch\+Time}{p.}{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf}.
\item {\ttfamily \{\{min\+Epoch\+Iterations\}\}} See \doxyref{Bench\+::min\+Epoch\+Iterations}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034}.
\item {\ttfamily \{\{epoch\+Iterations\}\}} See \doxyref{Bench\+::epoch\+Iterations}{p.}{classankerl_1_1nanobench_1_1_bench_ae084f501a2a3c61c1d128a519d4a38ae}.
\item {\ttfamily \{\{warmup\}\}} Number of iterations used before measuring starts. See \doxyref{Bench\+::warmup}{p.}{classankerl_1_1nanobench_1_1_bench_ae48156567cac1e76706ac0ce076894b7}.
\item {\ttfamily \{\{relative\}\}} True or false, depending on the setting you have used. See \doxyref{Bench\+::relative}{p.}{classankerl_1_1nanobench_1_1_bench_a2b35462c62dcf9e55bf31618dd8008e0}.
\item {\ttfamily \{\{context(variable\+Name)\}\}} See \doxyref{Bench\+::context}{p.}{classankerl_1_1nanobench_1_1_bench_a6c5c13becb6edb48ef7d02cc8caab1bb}.
\end{DoxyItemize}

Apart from these tags, it is also possible to use some mathematical operations on the measurement data. The operations are of the form {\ttfamily \{\{\doxyref{command(name)}{p.}{bitcoin-wallet_8cpp_a64b0c5844a38fc862dcb5b4e30b1ca49}\}\}}. Currently {\ttfamily \doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}} can be one of {\ttfamily elapsed}, {\ttfamily iterations}. If performance counters are available (currently only on current Linux systems), you also have {\ttfamily pagefaults}, {\ttfamily cpucycles}, {\ttfamily contextswitches}, {\ttfamily instructions}, {\ttfamily branchinstructions}, and {\ttfamily branchmisses}. All the measures (except {\ttfamily iterations}) are provided for a single iteration (so {\ttfamily elapsed} is the time a single iteration took). The following tags are available\+:
\begin{DoxyItemize}
\item {\ttfamily \{\{median($<$\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}$>$)\}\}} Calculate median of a measurement data set, e.\+g. {\ttfamily \{\{median(elapsed)\}\}}.
\item {\ttfamily \{\{average($<$\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}$>$)\}\}} Average (mean) calculation.
\item {\ttfamily \{\{median\+Absolute\+Percent\+Error($<$\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}$>$)\}\}} Calculates Md\+APE, the Median Absolute Percentage Error. The Md\+APE is an excellent metric for the variation of measurements. It is more robust to outliers than the {\texttt{Mean absolute percentage error (M-\/\+APE)}}.   \[      \mathrm{MdAPE}(e) = \mathrm{med}\{| \frac{e_i - \mathrm{med}\{e\}}{e_i}| \}
\] E.\+g. for {\itshape elapsed}\+: First, $ \mathrm{med}\{e\} $ calculates the median by sorting and then taking the middle element of all {\itshape elapsed} measurements. This is used to calculate the absolute percentage error to this median for each measurement, as in $ | \frac{e_i - \mathrm{med}\{e\}}{e_i}| $. All these results are sorted, and the middle value is chosen as the median absolute percent error.

This measurement is a bit hard to interpret, but it is very robust against outliers. E.\+g. a value of 5\% means that half of the measurements deviate less than 5\% from the median, and the other deviate more than 5\% from the median.
\item {\ttfamily \{\{\doxyref{sum}{p.}{examples_8cpp_a936f4b586a8f869a9d0d197cc5110653}($<$\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}$>$)\}\}} Sum of all the measurements. E.\+g. {\ttfamily \{\{\doxyref{sum(iterations)}{p.}{examples_8cpp_a936f4b586a8f869a9d0d197cc5110653}\}\}} will give you the total number of iterations measured in this benchmark.
\item {\ttfamily \{\{minimum($<$\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}$>$)\}\}} Minimum of all measurements.
\item {\ttfamily \{\{maximum($<$\doxyref{name}{p.}{rest_8cpp_a8f8f80d37794cde9472343e4487ba3eb}$>$)\}\}} Maximum of all measurements.
\item {\ttfamily \{\{sum\+Product($<$first$>$, $<$second$>$)\}\}} Calculates the sum of the products of corresponding measures\+:   \[         \mathrm{sumProduct}(a,b) = \sum_{i=1}^{n}a_i\cdot b_i
\] E.\+g. to calculate total runtime of the benchmark, you multiply iterations with elapsed time for each measurement, and sum these results up\+: {\ttfamily \{\{sum\+Product(iterations, elapsed)\}\}}.
\item {\ttfamily \{\{\#measurement\}\}} To access individual measurement results, open the begin tag for measurements.
\begin{DoxyItemize}
\item {\ttfamily \{\{elapsed\}\}} Average elapsed wall clock time per iteration, in seconds.
\item {\ttfamily \{\{iterations\}\}} Number of iterations in the measurement. The number of iterations will fluctuate due to some applied randomness, to enhance accuracy.
\item {\ttfamily \{\{pagefaults\}\}} Average number of pagefaults per iteration.
\item {\ttfamily \{\{cpucycles\}\}} Average number of CPU cycles processed per iteration.
\item {\ttfamily \{\{contextswitches\}\}} Average number of context switches per iteration.
\item {\ttfamily \{\{instructions\}\}} Average number of retired instructions per iteration.
\item {\ttfamily \{\{branchinstructions\}\}} Average number of branches executed per iteration.
\item {\ttfamily \{\{branchmisses\}\}} Average number of branches that were missed per iteration.
\end{DoxyItemize}
\item {\ttfamily \{\{/measurement\}\}} Ends the measurement tag.
\end{DoxyItemize}
\item {\ttfamily \{\{/result\}\}} Marks the end of the result layer. This is the end marker for the template part that will be instantiated for each benchmark result.

For the layer tags {\itshape result} and {\itshape measurement} you additionally can use these special markers\+:
\begin{DoxyItemize}
\item {\ttfamily \{\{\#-\/first\}\}} -\/ Begin marker of a template that will be instantiated {\itshape only for the first} entry in the layer. Use is only allowed between the begin and end marker of the layer. So between {\ttfamily \{\{\#result\}\}} and {\ttfamily \{\{/result\}\}}, or between {\ttfamily \{\{\#measurement\}\}} and {\ttfamily \{\{/measurement\}\}}. Finish the template with {\ttfamily \{\{/-\/first\}\}}.
\item {\ttfamily \{\{$^\wedge$-\/first\}\}} -\/ Begin marker of a template that will be instantiated {\itshape for each except the first} entry in the layer. This, this is basically the inversion of {\ttfamily \{\{\#-\/first\}\}}. Use is only allowed between the begin and end marker of the layer. So between {\ttfamily \{\{\#result\}\}} and {\ttfamily \{\{/result\}\}}, or between {\ttfamily \{\{\#measurement\}\}} and {\ttfamily \{\{/measurement\}\}}.
\item {\ttfamily \{\{/-\/first\}\}} -\/ End marker for either {\ttfamily \{\{\#-\/first\}\}} or {\ttfamily \{\{$^\wedge$-\/first\}\}}.
\item {\ttfamily \{\{\#-\/last\}\}} -\/ Begin marker of a template that will be instantiated {\itshape only for the last} entry in the layer. Use is only allowed between the begin and end marker of the layer. So between {\ttfamily \{\{\#result\}\}} and {\ttfamily \{\{/result\}\}}, or between {\ttfamily \{\{\#measurement\}\}} and {\ttfamily \{\{/measurement\}\}}. Finish the template with {\ttfamily \{\{/-\/last\}\}}.
\item {\ttfamily \{\{$^\wedge$-\/last\}\}} -\/ Begin marker of a template that will be instantiated {\itshape for each except the last} entry in the layer. This, this is basically the inversion of {\ttfamily \{\{\#-\/last\}\}}. Use is only allowed between the begin and end marker of the layer. So between {\ttfamily \{\{\#result\}\}} and {\ttfamily \{\{/result\}\}}, or between {\ttfamily \{\{\#measurement\}\}} and {\ttfamily \{\{/measurement\}\}}.
\item {\ttfamily \{\{/-\/last\}\}} -\/ End marker for either {\ttfamily \{\{\#-\/last\}\}} or {\ttfamily \{\{$^\wedge$-\/last\}\}}.
\end{DoxyItemize}
\end{DoxyItemize}

\begin{DoxyVerb}embed:rst

For an overview of all the possible data you can get out of nanobench, please see the tutorial at :ref:`tutorial-template-json`.

The templates that ship with nanobench are:

* :cpp:func:`templates::csv() <ankerl::nanobench::templates::csv()>`
* :cpp:func:`templates::json() <ankerl::nanobench::templates::json()>`
* :cpp:func:`templates::htmlBoxplot() <ankerl::nanobench::templates::htmlBoxplot()>`
* :cpp:func:`templates::pyperf() <ankerl::nanobench::templates::pyperf()>`
\end{DoxyVerb}



\begin{DoxyParams}{Parameters}
{\em mustache\+Template} & The template. \\
\hline
{\em bench} & Benchmark, containing all the results. \\
\hline
{\em out} & Output for the generated output. \\
\hline
\end{DoxyParams}
\index{ankerl::nanobench@{ankerl::nanobench}!render@{render}}
\index{render@{render}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{render()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_a2ceb04bb3be4bfefdb350794d870c601} 
void render (\begin{DoxyParamCaption}\item[{char const $\ast$}]{mustache\+Template}{, }\item[{std\+::vector$<$ \textbf{ Result} $>$ const \&}]{results}{, }\item[{std\+::ostream \&}]{out}{}\end{DoxyParamCaption})}

Same as \doxyref{render(char const$\ast$ mustache\+Template, Bench const\& bench, std\+::ostream\& out)}{p.}{namespaceankerl_1_1nanobench_aa8b83321afa5228fa13d67157ad8657e}, but for when you only have results available.


\begin{DoxyParams}{Parameters}
{\em mustache\+Template} & The template. \\
\hline
{\em results} & All the results to be used for rendering. \\
\hline
{\em out} & Output for the generated output. \\
\hline
\end{DoxyParams}
\index{ankerl::nanobench@{ankerl::nanobench}!render@{render}}
\index{render@{render}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{render()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_aa1dec992ac1ca3b7f809b19f80731e5b} 
void render (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{mustache\+Template}{, }\item[{\textbf{ Bench} const \&}]{bench}{, }\item[{std\+::ostream \&}]{out}{}\end{DoxyParamCaption})}

\index{ankerl::nanobench@{ankerl::nanobench}!render@{render}}
\index{render@{render}!ankerl::nanobench@{ankerl::nanobench}}
\doxysubsubsection{render()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{namespaceankerl_1_1nanobench_a01eed06f15c6b472a066041a45bf5ce8} 
void render (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{mustache\+Template}{, }\item[{std\+::vector$<$ \textbf{ Result} $>$ const \&}]{results}{, }\item[{std\+::ostream \&}]{out}{}\end{DoxyParamCaption})}

