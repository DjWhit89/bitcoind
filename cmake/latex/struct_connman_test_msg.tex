\doxysection{Connman\+Test\+Msg Struct Reference}
\label{struct_connman_test_msg}\index{ConnmanTestMsg@{ConnmanTestMsg}}


{\ttfamily \#include $<$net.\+h$>$}

Inheritance diagram for Connman\+Test\+Msg\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{struct_connman_test_msg}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Set\+Msg\+Proc} (\textbf{ Net\+Events\+Interface} $\ast$msgproc)
\item 
void \textbf{ Set\+Peer\+Connect\+Timeout} (std\+::chrono\+::seconds timeout)
\item 
void \textbf{ Reset\+Addr\+Cache} ()
\item 
void \textbf{ Reset\+Max\+Outbound\+Cycle} ()
\item 
std\+::vector$<$ \textbf{ CNode} $\ast$ $>$ \textbf{ Test\+Nodes} ()
\item 
void \textbf{ Add\+Test\+Node} (\textbf{ CNode} \&\textbf{ node})
\item 
void \textbf{ Clear\+Test\+Nodes} ()
\item 
void \textbf{ Create\+Node\+From\+Accepted\+Socket\+Public} (std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$ sock, \textbf{ Net\+Permission\+Flags} permissions, const \textbf{ CAddress} \&addr\+\_\+bind, const \textbf{ CAddress} \&addr\+\_\+peer)
\item 
bool \textbf{ Init\+Binds\+Public} (const \textbf{ CConnman\+::\+Options} \&options)
\item 
void \textbf{ Socket\+Handler\+Public} ()
\item 
void \textbf{ Node\+Receive\+Msg\+Bytes} (\textbf{ CNode} \&\textbf{ node}, std\+::span$<$ const uint8\+\_\+t $>$ msg\+\_\+bytes, bool \&complete) const
\item 
bool \textbf{ Receive\+Msg\+From} (\textbf{ CNode} \&\textbf{ node}, \textbf{ CSerialized\+Net\+Msg} \&\&ser\+\_\+msg) const
\item 
void \textbf{ Flush\+Send\+Buffer} (\textbf{ CNode} \&\textbf{ node}) const
\item 
bool \textbf{ Already\+Connected\+To\+Address\+Public} (const \textbf{ CNet\+Addr} \&addr)
\item 
\textbf{ CNode} $\ast$ \textbf{ Connect\+Node\+Public} (\textbf{ Peer\+Manager} \&peerman, const char $\ast$psz\+Dest, \textbf{ Connection\+Type} conn\+\_\+type) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+unused\+\_\+i2p\+\_\+sessions\+\_\+mutex)
\item 
\textbf{ CConnman} (uint64\+\_\+t seed0, uint64\+\_\+t seed1, \textbf{ Addr\+Man} \&addrman, const \textbf{ Net\+Group\+Manager} \&netgroupman, const \textbf{ CChain\+Params} \&params, bool network\+\_\+active=true, std\+::shared\+\_\+ptr$<$ \textbf{ CThread\+Interrupt} $>$ interrupt\+\_\+net=std\+::make\+\_\+shared$<$ \textbf{ CThread\+Interrupt} $>$())
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ CConnman}}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Init} (const \textbf{ Options} \&conn\+Options) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex
\item 
const bool \textbf{ use\+\_\+v2transport} (\textbf{ Get\+Local\+Services}() \&\textbf{ NODE\+\_\+\+P2\+P\+\_\+\+V2})
\item 
\textbf{ for} (const std\+::string \&added\+\_\+node \+:conn\+Options.\+m\+\_\+added\+\_\+nodes)
\item 
void \textbf{ Set\+Capture\+Messages} (bool cap)
\item 
\textbf{ CConnman} (uint64\+\_\+t seed0, uint64\+\_\+t seed1, \textbf{ Addr\+Man} \&addrman, const \textbf{ Net\+Group\+Manager} \&netgroupman, const \textbf{ CChain\+Params} \&params, bool network\+\_\+active=true, std\+::shared\+\_\+ptr$<$ \textbf{ CThread\+Interrupt} $>$ interrupt\+\_\+net=std\+::make\+\_\+shared$<$ \textbf{ CThread\+Interrupt} $>$())
\item 
\textbf{ $\sim$\+CConnman} ()
\item 
bool \textbf{ Start} (\textbf{ CScheduler} \&scheduler, const \textbf{ Options} \&options) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex
\item 
void \textbf{ Stop\+Threads} ()
\item 
void \textbf{ Stop\+Nodes} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+reconnections\+\_\+mutex)
\item 
void \textbf{ Stop} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+reconnections\+\_\+mutex)
\item 
void \textbf{ Interrupt} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!mutex\+Msg\+Proc)
\item 
bool \textbf{ Get\+Network\+Active} () const
\item 
bool \textbf{ Get\+Use\+Addrman\+Outgoing} () const
\item 
void \textbf{ Set\+Network\+Active} (bool active)
\item 
bool \textbf{ Open\+Network\+Connection} (const \textbf{ CAddress} \&addr\+Connect, bool f\+Count\+Failure, \textbf{ Counting\+Semaphore\+Grant}$<$$>$ \&\&grant\+\_\+outbound, const char $\ast$psz\+Dest, \textbf{ Connection\+Type} conn\+\_\+type, bool \textbf{ use\+\_\+v2transport}, const std\+::optional$<$ \textbf{ Proxy} $>$ \&proxy\+\_\+override=std\+::nullopt) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+unused\+\_\+i2p\+\_\+sessions\+\_\+mutex)
\item 
bool \textbf{ Check\+Incoming\+Nonce} (uint64\+\_\+t \textbf{ nonce})
\item 
void \textbf{ ASMap\+Health\+Check} ()
\item 
\textbf{ Recursive\+Mutex} \& \textbf{ Get\+Nodes\+Mutex} () const \textbf{ LOCK\+\_\+\+RETURNED}(m\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ For\+Node} (\textbf{ Node\+Id} id, std\+::function$<$ bool(\textbf{ CNode} $\ast$pnode)$>$ func)
\item 
void \textbf{ Push\+Message} (\textbf{ CNode} $\ast$pnode, \textbf{ CSerialized\+Net\+Msg} \&\&msg) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
void \textbf{ For\+Each\+Node} (const \textbf{ Node\+Fn} \&func)
\item 
void \textbf{ For\+Each\+Node} (const \textbf{ Node\+Fn} \&func) const
\item 
std\+::vector$<$ \textbf{ CAddress} $>$ \textbf{ Get\+Addresses\+Unsafe} (size\+\_\+t max\+\_\+addresses, size\+\_\+t max\+\_\+pct, std\+::optional$<$ \textbf{ Network} $>$ network, const bool filtered=true) const
\item 
std\+::vector$<$ \textbf{ CAddress} $>$ \textbf{ Get\+Addresses} (\textbf{ CNode} \&requestor, size\+\_\+t max\+\_\+addresses, size\+\_\+t max\+\_\+pct)
\item 
void \textbf{ Set\+Try\+New\+Outbound\+Peer} (bool flag)
\item 
bool \textbf{ Get\+Try\+New\+Outbound\+Peer} () const
\item 
void \textbf{ Start\+Extra\+Block\+Relay\+Peers} ()
\item 
int \textbf{ Get\+Full\+Outbound\+Conn\+Count} () const
\item 
int \textbf{ Get\+Extra\+Full\+Outbound\+Count} () const
\item 
int \textbf{ Get\+Extra\+Block\+Relay\+Count} () const
\item 
bool \textbf{ Add\+Node} (const \textbf{ Added\+Node\+Params} \&add) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ Remove\+Added\+Node} (std\+::string\+\_\+view \textbf{ node}) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ Added\+Nodes\+Contain} (const \textbf{ CAddress} \&addr) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
std\+::vector$<$ \textbf{ Added\+Node\+Info} $>$ \textbf{ Get\+Added\+Node\+Info} (bool include\+\_\+connected) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ Add\+Connection} (const std\+::string \&address, \textbf{ Connection\+Type} conn\+\_\+type, bool \textbf{ use\+\_\+v2transport}) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+unused\+\_\+i2p\+\_\+sessions\+\_\+mutex)
\item 
size\+\_\+t \textbf{ Get\+Node\+Count} (\textbf{ Connection\+Direction}) const
\item 
std\+::map$<$ \textbf{ CNet\+Addr}, \textbf{ Local\+Service\+Info} $>$ \textbf{ get\+Net\+Local\+Addresses} () const
\item 
uint32\+\_\+t \textbf{ Get\+Mapped\+AS} (const \textbf{ CNet\+Addr} \&addr) const
\item 
void \textbf{ Get\+Node\+Stats} (std\+::vector$<$ \textbf{ CNode\+Stats} $>$ \&vstats) const
\item 
bool \textbf{ Disconnect\+Node} (std\+::string\+\_\+view \textbf{ node})
\item 
bool \textbf{ Disconnect\+Node} (const \textbf{ CSub\+Net} \&subnet)
\item 
bool \textbf{ Disconnect\+Node} (const \textbf{ CNet\+Addr} \&addr)
\item 
bool \textbf{ Disconnect\+Node} (\textbf{ Node\+Id} id)
\item 
\textbf{ Service\+Flags} \textbf{ Get\+Local\+Services} () const
\item 
void \textbf{ Add\+Local\+Services} (\textbf{ Service\+Flags} services)
\item 
void \textbf{ Remove\+Local\+Services} (\textbf{ Service\+Flags} services)
\item 
uint64\+\_\+t \textbf{ Get\+Max\+Outbound\+Target} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
std\+::chrono\+::seconds \textbf{ Get\+Max\+Outbound\+Timeframe} () const
\item 
bool \textbf{ Outbound\+Target\+Reached} (bool historical\+Block\+Serving\+Limit) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
uint64\+\_\+t \textbf{ Get\+Outbound\+Target\+Bytes\+Left} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
std\+::chrono\+::seconds \textbf{ Get\+Max\+Outbound\+Time\+Left\+In\+Cycle} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
uint64\+\_\+t \textbf{ Get\+Total\+Bytes\+Recv} () const
\item 
uint64\+\_\+t \textbf{ Get\+Total\+Bytes\+Sent} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
\textbf{ CSip\+Hasher} \textbf{ Get\+Deterministic\+Randomizer} (uint64\+\_\+t id) const
\item 
void \textbf{ Wake\+Message\+Handler} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!mutex\+Msg\+Proc)
\item 
bool \textbf{ Should\+Run\+Inactivity\+Checks} (const \textbf{ CNode} \&\textbf{ node}, std\+::chrono\+::microseconds now) const
\item 
bool \textbf{ Multiple\+Manual\+Or\+Full\+Outbound\+Conns} (\textbf{ Network} net) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(m\+\_\+nodes\+\_\+mutex)
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
void Handshake(\textbf{ CNode} \&\textbf{ node}, bool successfully\+\_\+connected, \textbf{ Service\+Flags} remote\+\_\+services, \textbf{ Service\+Flags} local\+\_\+services, int32\+\_\+t version, bool relay\+\_\+txs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Net\+Events\+Interface} boo \textbf{ Process\+Messages\+Once} )(\textbf{ CNode} \&\textbf{ node}) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Net\+Events\+Interface}
\end{DoxyCompactItemize}
\doxysubsection*{Data Fields inherited from \textbf{ CConnman}}
\begin{DoxyCompactItemize}
\item 
void \textbf{ !m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex}
\item 
\textbf{ m\+\_\+local\+\_\+services} = conn\+Options.\+m\+\_\+local\+\_\+services
\item 
\textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} = conn\+Options.\+m\+\_\+max\+\_\+automatic\+\_\+connections
\item 
\textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay} = std\+::min(MAX\+\_\+\+OUTBOUND\+\_\+\+FULL\+\_\+\+RELAY\+\_\+\+CONNECTIONS, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections})
\item 
\textbf{ m\+\_\+max\+\_\+outbound\+\_\+block\+\_\+relay} = std\+::min(MAX\+\_\+\+BLOCK\+\_\+\+RELAY\+\_\+\+ONLY\+\_\+\+CONNECTIONS, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} -\/ \textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay})
\item 
\textbf{ m\+\_\+max\+\_\+automatic\+\_\+outbound} = \textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay} + \textbf{ m\+\_\+max\+\_\+outbound\+\_\+block\+\_\+relay} + m\+\_\+max\+\_\+feeler
\item 
\textbf{ m\+\_\+max\+\_\+inbound} = std\+::max(0, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} -\/ \textbf{ m\+\_\+max\+\_\+automatic\+\_\+outbound})
\item 
\textbf{ m\+\_\+use\+\_\+addrman\+\_\+outgoing} = conn\+Options.\+m\+\_\+use\+\_\+addrman\+\_\+outgoing
\item 
\textbf{ m\+\_\+client\+\_\+interface} = conn\+Options.\+ui\+Interface
\item 
\textbf{ m\+\_\+banman} = conn\+Options.\+m\+\_\+banman
\item 
\textbf{ m\+\_\+msgproc} = conn\+Options.\+m\+\_\+msgproc
\item 
\textbf{ n\+Send\+Buffer\+Max\+Size} = conn\+Options.\+n\+Send\+Buffer\+Max\+Size
\item 
\textbf{ n\+Receive\+Flood\+Size} = conn\+Options.\+n\+Receive\+Flood\+Size
\item 
\textbf{ m\+\_\+peer\+\_\+connect\+\_\+timeout} = std\+::chrono\+::seconds\{conn\+Options.\+m\+\_\+peer\+\_\+connect\+\_\+timeout\}
\item 
\textbf{ n\+Max\+Outbound\+Limit} = conn\+Options.\+n\+Max\+Outbound\+Limit
\item 
\textbf{ v\+Whitelisted\+Range\+Incoming} = conn\+Options.\+v\+Whitelisted\+Range\+Incoming
\item 
\textbf{ v\+Whitelisted\+Range\+Outgoing} = conn\+Options.\+v\+Whitelisted\+Range\+Outgoing
\item 
\textbf{ m\+\_\+onion\+\_\+binds} = conn\+Options.\+onion\+\_\+binds
\item 
\textbf{ whitelist\+\_\+forcerelay} = conn\+Options.\+whitelist\+\_\+forcerelay
\item 
\textbf{ whitelist\+\_\+relay} = conn\+Options.\+whitelist\+\_\+relay
\item 
\textbf{ m\+\_\+capture\+\_\+messages} = conn\+Options.\+m\+\_\+capture\+\_\+messages
\item 
bool \textbf{ !m\+\_\+added\+\_\+nodes\+\_\+mutex}
\item 
bool \textbf{ !m\+\_\+addr\+\_\+fetches\+\_\+mutex}
\item 
bool \textbf{ !mutex\+Msg\+Proc}
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ CConnman}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Node\+Fn} = std\+::function$<$void(\textbf{ CNode}$\ast$)$>$
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{ConnmanTestMsg@{ConnmanTestMsg}!AddTestNode@{AddTestNode}}
\index{AddTestNode@{AddTestNode}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{AddTestNode()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a300c15c77cbcec491cfe027c336c344c} 
void Add\+Test\+Node (\begin{DoxyParamCaption}\item[{\textbf{ CNode} \&}]{node}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!AlreadyConnectedToAddressPublic@{AlreadyConnectedToAddressPublic}}
\index{AlreadyConnectedToAddressPublic@{AlreadyConnectedToAddressPublic}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{AlreadyConnectedToAddressPublic()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a1665f165dc5ca5ca4084737b8848e216} 
bool Already\+Connected\+To\+Address\+Public (\begin{DoxyParamCaption}\item[{const \textbf{ CNet\+Addr} \&}]{addr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!CConnman@{CConnman}}
\index{CConnman@{CConnman}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{CConnman()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a66c9578e34dbcf52608e3674b50007fb} 
\textbf{ CConnman} (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{seed0}{, }\item[{uint64\+\_\+t}]{seed1}{, }\item[{\textbf{ Addr\+Man} \&}]{addrman}{, }\item[{const \textbf{ Net\+Group\+Manager} \&}]{netgroupman}{, }\item[{const \textbf{ CChain\+Params} \&}]{params}{, }\item[{bool}]{network\+\_\+active}{ = {\ttfamily true}, }\item[{std\+::shared\+\_\+ptr$<$ \textbf{ CThread\+Interrupt} $>$}]{interrupt\+\_\+net}{ = {\ttfamily std\+:\+:make\+\_\+shared$<$\textbf{ CThread\+Interrupt}$>$()}}\end{DoxyParamCaption})}

\index{ConnmanTestMsg@{ConnmanTestMsg}!ClearTestNodes@{ClearTestNodes}}
\index{ClearTestNodes@{ClearTestNodes}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{ClearTestNodes()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a107405574cff2c65c86d4644de7ee5f7} 
void Clear\+Test\+Nodes (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!ConnectNodePublic@{ConnectNodePublic}}
\index{ConnectNodePublic@{ConnectNodePublic}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{ConnectNodePublic()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_aaa659a217263b27547380fb362dae866} 
\textbf{ CNode} $\ast$ Connect\+Node\+Public (\begin{DoxyParamCaption}\item[{\textbf{ Peer\+Manager} \&}]{peerman}{, }\item[{const char $\ast$}]{psz\+Dest}{, }\item[{\textbf{ Connection\+Type}}]{conn\+\_\+type}{}\end{DoxyParamCaption})}

\index{ConnmanTestMsg@{ConnmanTestMsg}!CreateNodeFromAcceptedSocketPublic@{CreateNodeFromAcceptedSocketPublic}}
\index{CreateNodeFromAcceptedSocketPublic@{CreateNodeFromAcceptedSocketPublic}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{CreateNodeFromAcceptedSocketPublic()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a5153951e5ffc700fba395cf939b90642} 
void Create\+Node\+From\+Accepted\+Socket\+Public (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \textbf{ Sock} $>$}]{sock}{, }\item[{\textbf{ Net\+Permission\+Flags}}]{permissions}{, }\item[{const \textbf{ CAddress} \&}]{addr\+\_\+bind}{, }\item[{const \textbf{ CAddress} \&}]{addr\+\_\+peer}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!FlushSendBuffer@{FlushSendBuffer}}
\index{FlushSendBuffer@{FlushSendBuffer}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{FlushSendBuffer()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a367b32b0f00c6b5bebd83a56f966e1ff} 
void Flush\+Send\+Buffer (\begin{DoxyParamCaption}\item[{\textbf{ CNode} \&}]{node}{}\end{DoxyParamCaption}) const}

\index{ConnmanTestMsg@{ConnmanTestMsg}!InitBindsPublic@{InitBindsPublic}}
\index{InitBindsPublic@{InitBindsPublic}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{InitBindsPublic()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a56c77f72b15549722da941a9ba172dfa} 
bool Init\+Binds\+Public (\begin{DoxyParamCaption}\item[{const \textbf{ CConnman\+::\+Options} \&}]{options}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!NodeReceiveMsgBytes@{NodeReceiveMsgBytes}}
\index{NodeReceiveMsgBytes@{NodeReceiveMsgBytes}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{NodeReceiveMsgBytes()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a2ac54be1577e5432356211d2cc55a6ab} 
void Node\+Receive\+Msg\+Bytes (\begin{DoxyParamCaption}\item[{\textbf{ CNode} \&}]{node}{, }\item[{std\+::span$<$ const uint8\+\_\+t $>$}]{msg\+\_\+bytes}{, }\item[{bool \&}]{complete}{}\end{DoxyParamCaption}) const}

\index{ConnmanTestMsg@{ConnmanTestMsg}!ReceiveMsgFrom@{ReceiveMsgFrom}}
\index{ReceiveMsgFrom@{ReceiveMsgFrom}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{ReceiveMsgFrom()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_ab7a2e92418fd119ebaaacf03a0ee8b38} 
bool Receive\+Msg\+From (\begin{DoxyParamCaption}\item[{\textbf{ CNode} \&}]{node}{, }\item[{\textbf{ CSerialized\+Net\+Msg} \&\&}]{ser\+\_\+msg}{}\end{DoxyParamCaption}) const}

\index{ConnmanTestMsg@{ConnmanTestMsg}!ResetAddrCache@{ResetAddrCache}}
\index{ResetAddrCache@{ResetAddrCache}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{ResetAddrCache()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a43ebaa92c9af1e98b775ae33c71c47fa} 
void Reset\+Addr\+Cache (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{ConnmanTestMsg@{ConnmanTestMsg}!ResetMaxOutboundCycle@{ResetMaxOutboundCycle}}
\index{ResetMaxOutboundCycle@{ResetMaxOutboundCycle}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{ResetMaxOutboundCycle()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a6d8a396cda4c4e7395a41bac2b3e7e57} 
void Reset\+Max\+Outbound\+Cycle (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{ConnmanTestMsg@{ConnmanTestMsg}!SetMsgProc@{SetMsgProc}}
\index{SetMsgProc@{SetMsgProc}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{SetMsgProc()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a31b7a51c30f5fafa6db4b9e3faabf963} 
void Set\+Msg\+Proc (\begin{DoxyParamCaption}\item[{\textbf{ Net\+Events\+Interface} $\ast$}]{msgproc}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!SetPeerConnectTimeout@{SetPeerConnectTimeout}}
\index{SetPeerConnectTimeout@{SetPeerConnectTimeout}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{SetPeerConnectTimeout()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a4227a2c77ff864b0ee310da5e076b616} 
void Set\+Peer\+Connect\+Timeout (\begin{DoxyParamCaption}\item[{std\+::chrono\+::seconds}]{timeout}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!SocketHandlerPublic@{SocketHandlerPublic}}
\index{SocketHandlerPublic@{SocketHandlerPublic}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{SocketHandlerPublic()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_aa2b0d6a39c7677333f642fdbfe9bba4a} 
void Socket\+Handler\+Public (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{ConnmanTestMsg@{ConnmanTestMsg}!TestNodes@{TestNodes}}
\index{TestNodes@{TestNodes}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{TestNodes()}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a7a34e72ee39de21edd45605dcf811c63} 
std\+::vector$<$ \textbf{ CNode} $\ast$ $>$ Test\+Nodes (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{ConnmanTestMsg@{ConnmanTestMsg}!ProcessMessagesOnce@{ProcessMessagesOnce}}
\index{ProcessMessagesOnce@{ProcessMessagesOnce}!ConnmanTestMsg@{ConnmanTestMsg}}
\doxysubsubsection{ProcessMessagesOnce}
{\footnotesize\ttfamily \label{struct_connman_test_msg_a6ad299f7c51836765f933a4ffea28807} 
void Handshake(\textbf{ CNode} \&\textbf{ node}, bool successfully\+\_\+connected, \textbf{ Service\+Flags} remote\+\_\+services, \textbf{ Service\+Flags} local\+\_\+services, int32\+\_\+t version, bool relay\+\_\+txs) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Net\+Events\+Interface} boo Process\+Messages\+Once) (\textbf{ CNode} \&\textbf{ node}) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ Net\+Events\+Interface}\hspace{0.3cm}{\ttfamily [inline]}}



The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/test/util/\textbf{ net.\+h}\item 
src/test/util/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
