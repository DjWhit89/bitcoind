\doxysection{node Namespace Reference}
\label{namespacenode}\index{node@{node}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Importing\+Now}
\item 
struct \textbf{ CBlock\+Index\+Work\+Comparator}
\item 
struct \textbf{ CBlock\+Index\+Height\+Only\+Comparator}
\item 
struct \textbf{ Prune\+Lock\+Info}
\item 
struct \textbf{ Blockfile\+Cursor}
\item 
class \textbf{ Block\+Manager}
\item 
struct \textbf{ Index\+Cache\+Sizes}
\item 
struct \textbf{ Cache\+Sizes}
\item 
struct \textbf{ Chainstate\+Load\+Options}
\item 
struct \textbf{ Node\+Context}
\item 
class \textbf{ Kernel\+Notifications}
\item 
struct \textbf{ Import\+Mempool\+Options}
\item 
struct \textbf{ CBlock\+Template}
\item 
class \textbf{ Block\+Assembler}
\item 
struct \textbf{ Ancestor\+Feerate\+Comparator}
\item 
class \textbf{ Mini\+Miner\+Mempool\+Entry}
\item 
struct \textbf{ Iterator\+Comparator}
\item 
class \textbf{ Mini\+Miner}
\item 
struct \textbf{ PSBTInput\+Analysis}
\item 
struct \textbf{ PSBTAnalysis}
\item 
struct \textbf{ Tx\+Download\+Options}
\item 
struct \textbf{ Tx\+Download\+Connection\+Info}
\item 
struct \textbf{ Package\+To\+Validate}
\item 
struct \textbf{ Rejected\+Tx\+Todo}
\item 
class \textbf{ Tx\+Download\+Manager}
\item 
class \textbf{ Tx\+Download\+Manager\+Impl}
\item 
class \textbf{ Tx\+Orphanage\+Impl}
\item 
class \textbf{ Tx\+Orphanage}
\item 
struct \textbf{ Block\+Create\+Options}
\item 
struct \textbf{ Block\+Wait\+Options}
\item 
struct \textbf{ Block\+Check\+Options}
\item 
class \textbf{ Snapshot\+Metadata}
\item 
class \textbf{ Warnings}
\begin{DoxyCompactList}\small\item\em Manages warning messages within a node. \end{DoxyCompactList}\item 
class \textbf{ CBlock\+File\+Info}
\item 
class \textbf{ Block\+Tree\+DB}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Block\+Map} = std\+::unordered\+\_\+map$<$\textbf{ uint256}, \textbf{ CBlock\+Index}, \textbf{ Block\+Hasher}$>$
\item 
using \textbf{ Chainstate\+Load\+Result} = std\+::tuple$<$\textbf{ Chainstate\+Load\+Status}, \textbf{ bilingual\+\_\+str}$>$
\begin{DoxyCompactList}\small\item\em \doxyref{Chainstate}{p.}{class_chainstate} load status code and optional error string. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Blockfile\+Type} \{ \textbf{ NORMAL} = 0
, \textbf{ ASSUMED} = 1
, \textbf{ NUM\+\_\+\+TYPES} = 2
 \}
\item 
enum class \textbf{ Read\+Raw\+Error} \{ \textbf{ IO}
, \textbf{ Bad\+Part\+Range}
 \}
\item 
enum class \textbf{ Chainstate\+Load\+Status} \{ \newline
\textbf{ SUCCESS}
, \textbf{ FAILURE}
, \textbf{ FAILURE\+\_\+\+FATAL}
, \textbf{ FAILURE\+\_\+\+INCOMPATIBLE\+\_\+\+DB}
, \newline
\textbf{ FAILURE\+\_\+\+INSUFFICIENT\+\_\+\+DBCACHE}
, \textbf{ INTERRUPTED}
 \}
\item 
enum class \textbf{ Transaction\+Error} \{ \newline
\textbf{ OK}
, \textbf{ MISSING\+\_\+\+INPUTS}
, \textbf{ ALREADY\+\_\+\+IN\+\_\+\+UTXO\+\_\+\+SET}
, \textbf{ MEMPOOL\+\_\+\+REJECTED}
, \newline
\textbf{ MEMPOOL\+\_\+\+ERROR}
, \textbf{ MAX\+\_\+\+FEE\+\_\+\+EXCEEDED}
, \textbf{ MAX\+\_\+\+BURN\+\_\+\+EXCEEDED}
, \textbf{ INVALID\+\_\+\+PACKAGE}
 \}
\item 
enum class \textbf{ Tx\+Broadcast} \+: uint8\+\_\+t \{ \textbf{ MEMPOOL\+\_\+\+AND\+\_\+\+BROADCAST\+\_\+\+TO\+\_\+\+ALL}
, \textbf{ MEMPOOL\+\_\+\+NO\+\_\+\+BROADCAST}
 \}
\item 
enum class \textbf{ Warning} \{ \textbf{ CLOCK\+\_\+\+OUT\+\_\+\+OF\+\_\+\+SYNC}
, \textbf{ PRE\+\_\+\+RELEASE\+\_\+\+TEST\+\_\+\+BUILD}
, \textbf{ FATAL\+\_\+\+INTERNAL\+\_\+\+ERROR}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Abort\+Node} (const std\+::function$<$ bool()$>$ \&shutdown\+\_\+request, std\+::atomic$<$ int $>$ \&\textbf{ exit\+\_\+status}, const \textbf{ bilingual\+\_\+str} \&message, \textbf{ node\+::\+Warnings} $\ast$warnings)
\item 
\textbf{ util\+::\+Result}$<$ void $>$ \textbf{ Apply\+Args\+Man\+Options} (const \textbf{ Args\+Manager} \&\textbf{ args}, \textbf{ Block\+Manager\+::\+Options} \&opts)
\item 
void \textbf{ Import\+Blocks} (\textbf{ Chainstate\+Manager} \&chainman, std\+::span$<$ const \textbf{ fs\+::path} $>$ import\+\_\+paths)
\item 
std\+::ostream \& \textbf{ operator$<$$<$} (std\+::ostream \&os, const \textbf{ Blockfile\+Type} \&type)
\item 
std\+::ostream \& \textbf{ operator$<$$<$} (std\+::ostream \&os, const \textbf{ Blockfile\+Cursor} \&cursor)
\item 
size\+\_\+t \textbf{ Calculate\+Db\+Cache\+Bytes} (const \textbf{ Args\+Manager} \&\textbf{ args})
\item 
\textbf{ Cache\+Sizes} \textbf{ Calculate\+Cache\+Sizes} (const \textbf{ Args\+Manager} \&\textbf{ args}, size\+\_\+t n\+\_\+indexes)
\item 
void \textbf{ Log\+Oversized\+Db\+Cache} (const \textbf{ Args\+Manager} \&\textbf{ args}) noexcept
\item 
constexpr bool \textbf{ Should\+Warn\+Oversized\+Db\+Cache} (size\+\_\+t dbcache, size\+\_\+t total\+\_\+ram) noexcept
\item 
\textbf{ Chainstate\+Load\+Result} \textbf{ Load\+Chainstate} (\textbf{ Chainstate\+Manager} \&chainman, const \textbf{ Cache\+Sizes} \&cache\+\_\+sizes, const \textbf{ Chainstate\+Load\+Options} \&options)
\item 
\textbf{ Chainstate\+Load\+Result} \textbf{ Verify\+Loaded\+Chainstate} (\textbf{ Chainstate\+Manager} \&chainman, const \textbf{ Chainstate\+Load\+Options} \&options)
\item 
\textbf{ Chainstate\+Load\+Result} \textbf{ Load\+Chainstate} (\textbf{ Chainstate\+Manager} \&chainman, const \textbf{ kernel\+::\+Cache\+Sizes} \&cache\+\_\+sizes, const \textbf{ Chainstate\+Load\+Options} \&options)
\item 
\textbf{ util\+::\+Result}$<$ void $>$ \textbf{ Apply\+Args\+Man\+Options} (const \textbf{ Args\+Manager} \&\textbf{ args}, \textbf{ Chainstate\+Manager\+::\+Options} \&opts)
\item 
void \textbf{ Find\+Coins} (const \textbf{ Node\+Context} \&\textbf{ node}, std\+::map$<$ \textbf{ COut\+Point}, \textbf{ Coin} $>$ \&coins)
\item 
void \textbf{ Read\+Coins\+View\+Args} (const \textbf{ Args\+Manager} \&\textbf{ args}, \textbf{ Coins\+View\+Options} \&options)
\item 
void \textbf{ Read\+Database\+Args} (const \textbf{ Args\+Manager} \&\textbf{ args}, \textbf{ DBOptions} \&options)
\item 
void \textbf{ Read\+Notification\+Args} (const \textbf{ Args\+Manager} \&\textbf{ args}, \textbf{ Kernel\+Notifications} \&notifications)
\item 
bool \textbf{ Load\+Mempool} (\textbf{ CTx\+Mem\+Pool} \&pool, const \textbf{ fs\+::path} \&load\+\_\+path, \textbf{ Chainstate} \&active\+\_\+chainstate, \textbf{ Import\+Mempool\+Options} \&\&opts)
\item 
bool \textbf{ Dump\+Mempool} (const \textbf{ CTx\+Mem\+Pool} \&pool, const \textbf{ fs\+::path} \&dump\+\_\+path, \textbf{ Fopen\+Fn} mockable\+\_\+fopen\+\_\+function, bool skip\+\_\+file\+\_\+commit)
\item 
bool \textbf{ Should\+Persist\+Mempool} (const \textbf{ Args\+Manager} \&argsman)
\item 
\textbf{ fs\+::path} \textbf{ Mempool\+Path} (const \textbf{ Args\+Manager} \&argsman)
\item 
int64\+\_\+t \textbf{ Get\+Minimum\+Time} (const \textbf{ CBlock\+Index} $\ast$pindex\+Prev, const int64\+\_\+t difficulty\+\_\+adjustment\+\_\+interval)
\item 
int64\+\_\+t \textbf{ Update\+Time} (\textbf{ CBlock\+Header} $\ast$pblock, const \textbf{ Consensus\+::\+Params} \&consensus\+Params, const \textbf{ CBlock\+Index} $\ast$pindex\+Prev)
\item 
void \textbf{ Regenerate\+Commitments} (\textbf{ CBlock} \&block, \textbf{ Chainstate\+Manager} \&chainman)
\item 
void \textbf{ Apply\+Args\+Man\+Options} (const \textbf{ Args\+Manager} \&\textbf{ args}, \textbf{ Block\+Assembler\+::\+Options} \&options)
\item 
void \textbf{ Add\+Merkle\+Root\+And\+Coinbase} (\textbf{ CBlock} \&block, \textbf{ CTransaction\+Ref} coinbase, uint32\+\_\+t version, uint32\+\_\+t timestamp, uint32\+\_\+t \textbf{ nonce})
\item 
void \textbf{ Interrupt\+Wait} (\textbf{ Kernel\+Notifications} \&kernel\+\_\+notifications, bool \&interrupt\+\_\+wait)
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ CBlock\+Template} $>$ \textbf{ Wait\+And\+Create\+New\+Block} (\textbf{ Chainstate\+Manager} \&chainman, \textbf{ Kernel\+Notifications} \&kernel\+\_\+notifications, \textbf{ CTx\+Mem\+Pool} $\ast$mempool, const std\+::unique\+\_\+ptr$<$ \textbf{ CBlock\+Template} $>$ \&block\+\_\+template, const \textbf{ Block\+Wait\+Options} \&options, const \textbf{ Block\+Assembler\+::\+Options} \&assemble\+\_\+options, bool \&interrupt\+\_\+wait)
\item 
std\+::optional$<$ \textbf{ Block\+Ref} $>$ \textbf{ Get\+Tip} (\textbf{ Chainstate\+Manager} \&chainman)
\item 
std\+::optional$<$ \textbf{ Block\+Ref} $>$ \textbf{ Wait\+Tip\+Changed} (\textbf{ Chainstate\+Manager} \&chainman, \textbf{ Kernel\+Notifications} \&kernel\+\_\+notifications, const \textbf{ uint256} \&current\+\_\+tip, \textbf{ Milliseconds\+Double} \&timeout)
\item 
Minisketch \textbf{ Make\+Minisketch32} (size\+\_\+t capacity)
\item 
Minisketch \textbf{ Make\+Minisketch32\+FP} (size\+\_\+t max\+\_\+elements, uint32\+\_\+t fpbits)
\item 
void \textbf{ Apply\+Args\+Man\+Options} (const \textbf{ Args\+Manager} \&argsman, \textbf{ Peer\+Manager\+::\+Options} \&options)
\item 
\textbf{ PSBTAnalysis} \textbf{ Analyze\+PSBT} (\textbf{ Partially\+Signed\+Transaction} psbtx)
\item 
\textbf{ Transaction\+Error} \textbf{ Broadcast\+Transaction} (\textbf{ Node\+Context} \&\textbf{ node}, const \textbf{ CTransaction\+Ref} tx, std\+::string \&err\+\_\+string, const \textbf{ CAmount} \&max\+\_\+tx\+\_\+fee, \textbf{ Tx\+Broadcast} broadcast\+\_\+method, bool wait\+\_\+callback)
\item 
\textbf{ CTransaction\+Ref} \textbf{ Get\+Transaction} (const \textbf{ CBlock\+Index} $\ast$const block\+\_\+index, const \textbf{ CTx\+Mem\+Pool} $\ast$const mempool, const \textbf{ Txid} \&hash, const \textbf{ Block\+Manager} \&blockman, \textbf{ uint256} \&hash\+Block)
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Orphanage} $>$ \textbf{ Make\+Tx\+Orphanage} () noexcept
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Orphanage} $>$ \textbf{ Make\+Tx\+Orphanage} (\textbf{ Tx\+Orphanage\+::\+Count} max\+\_\+global\+\_\+latency\+\_\+score, \textbf{ Tx\+Orphanage\+::\+Usage} reserved\+\_\+peer\+\_\+usage) noexcept
\item 
bool \textbf{ Write\+Snapshot\+Base\+Blockhash} (\textbf{ Chainstate} \&snapshot\+\_\+chainstate)
\item 
std\+::optional$<$ \textbf{ uint256} $>$ \textbf{ Read\+Snapshot\+Base\+Blockhash} (\textbf{ fs\+::path} chaindir)
\item 
std\+::optional$<$ \textbf{ fs\+::path} $>$ \textbf{ Find\+Assumeutxo\+Chainstate\+Dir} (const \textbf{ fs\+::path} \&data\+\_\+dir)
\begin{DoxyCompactList}\small\item\em Return a path to the snapshot-\/based chainstate dir, if one exists. \end{DoxyCompactList}\item 
\textbf{ Uni\+Value} \textbf{ Get\+Warnings\+For\+Rpc} (const \textbf{ Warnings} \&warnings, bool use\+\_\+deprecated)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const \textbf{ fs\+::path} \textbf{ SNAPSHOT\+\_\+\+BLOCKHASH\+\_\+\+FILENAME} \{"{}base\+\_\+blockhash"{}\}
\item 
bool \textbf{ Write\+Snapshot\+Base\+Blockhash}(\textbf{ Chainstate} \&snapshot\+\_\+chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::optional$<$ \textbf{ uint256} $>$ \textbf{ Read\+Snapshot\+Base\+Blockhash}(\textbf{ fs\+::path} chaindir) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(constexpr std\+::string\+\_\+vie \textbf{ SNAPSHOT\+\_\+\+CHAINSTATE\+\_\+\+SUFFIX} ) = "{}\+\_\+snapshot"{}
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{node@{node}!BlockMap@{BlockMap}}
\index{BlockMap@{BlockMap}!node@{node}}
\doxysubsubsection{BlockMap}
{\footnotesize\ttfamily \label{namespacenode_acee0086a0c833617dd1532caf93206a3} 
using \textbf{ Block\+Map} = std\+::unordered\+\_\+map$<$\textbf{ uint256}, \textbf{ CBlock\+Index}, \textbf{ Block\+Hasher}$>$}

\index{node@{node}!ChainstateLoadResult@{ChainstateLoadResult}}
\index{ChainstateLoadResult@{ChainstateLoadResult}!node@{node}}
\doxysubsubsection{ChainstateLoadResult}
{\footnotesize\ttfamily \label{namespacenode_a32a0f7eb760387e8c7bb445014017062} 
using \textbf{ Chainstate\+Load\+Result} = std\+::tuple$<$\textbf{ Chainstate\+Load\+Status}, \textbf{ bilingual\+\_\+str}$>$}



\doxyref{Chainstate}{p.}{class_chainstate} load status code and optional error string. 



\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{node@{node}!BlockfileType@{BlockfileType}}
\index{BlockfileType@{BlockfileType}!node@{node}}
\doxysubsubsection{BlockfileType}
{\footnotesize\ttfamily \label{namespacenode_a98a425e6239438bd079e4dff7f66122d} 
enum \textbf{ Blockfile\+Type}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{NORMAL@{NORMAL}!node@{node}}\index{node@{node}!NORMAL@{NORMAL}}}\label{namespacenode_a98a425e6239438bd079e4dff7f66122da50d1448013c6f17125caee18aa418af7} 
NORMAL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ASSUMED@{ASSUMED}!node@{node}}\index{node@{node}!ASSUMED@{ASSUMED}}}\label{namespacenode_a98a425e6239438bd079e4dff7f66122da35b41de7d517da5e92177e7e362bbc3d} 
ASSUMED&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_TYPES@{NUM\_TYPES}!node@{node}}\index{node@{node}!NUM\_TYPES@{NUM\_TYPES}}}\label{namespacenode_a98a425e6239438bd079e4dff7f66122da56b5eb4b51d971098daad29eb2c08aa7} 
NUM\+\_\+\+TYPES&\\
\hline

\end{DoxyEnumFields}
\index{node@{node}!ChainstateLoadStatus@{ChainstateLoadStatus}}
\index{ChainstateLoadStatus@{ChainstateLoadStatus}!node@{node}}
\doxysubsubsection{ChainstateLoadStatus}
{\footnotesize\ttfamily \label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9} 
enum class \textbf{ Chainstate\+Load\+Status}\hspace{0.3cm}{\ttfamily [strong]}}

\doxyref{Chainstate}{p.}{class_chainstate} load status. Simple applications can just check for the success case, and treat other cases as errors. More complex applications may want to try reindexing in the generic failure case, and pass an interrupt callback and exit cleanly in the interrupted case. \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{SUCCESS@{SUCCESS}!node@{node}}\index{node@{node}!SUCCESS@{SUCCESS}}}\label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9ad0749aaba8b833466dfcbb0428e4f89c} 
SUCCESS&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{FAILURE@{FAILURE}!node@{node}}\index{node@{node}!FAILURE@{FAILURE}}}\label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9a36fc6065a3e970bc3e6b2e59da52bf2a} 
FAILURE&Generic failure which reindexing may fix. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{FAILURE\_FATAL@{FAILURE\_FATAL}!node@{node}}\index{node@{node}!FAILURE\_FATAL@{FAILURE\_FATAL}}}\label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9a2fb05d7bdcda3f80f5e3004275f20d9e} 
FAILURE\+\_\+\+FATAL&Fatal error which should not prompt to reindex. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{FAILURE\_INCOMPATIBLE\_DB@{FAILURE\_INCOMPATIBLE\_DB}!node@{node}}\index{node@{node}!FAILURE\_INCOMPATIBLE\_DB@{FAILURE\_INCOMPATIBLE\_DB}}}\label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9a2b38124fce8a1f3817a166a8013baed6} 
FAILURE\+\_\+\+INCOMPATIBLE\+\_\+\+DB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{FAILURE\_INSUFFICIENT\_DBCACHE@{FAILURE\_INSUFFICIENT\_DBCACHE}!node@{node}}\index{node@{node}!FAILURE\_INSUFFICIENT\_DBCACHE@{FAILURE\_INSUFFICIENT\_DBCACHE}}}\label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9abe00d62a90b3cf19eb70f7aa77b4b2af} 
FAILURE\+\_\+\+INSUFFICIENT\+\_\+\+DBCACHE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{INTERRUPTED@{INTERRUPTED}!node@{node}}\index{node@{node}!INTERRUPTED@{INTERRUPTED}}}\label{namespacenode_a779805e7cdbdeb11f4034a67cffd8cc9a658f2cadfdf09b6046246e9314f7cd43} 
INTERRUPTED&\\
\hline

\end{DoxyEnumFields}
\index{node@{node}!ReadRawError@{ReadRawError}}
\index{ReadRawError@{ReadRawError}!node@{node}}
\doxysubsubsection{ReadRawError}
{\footnotesize\ttfamily \label{namespacenode_a0fe2809c313929ad0c569d9e1bdf3e90} 
enum class \textbf{ Read\+Raw\+Error}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{IO@{IO}!node@{node}}\index{node@{node}!IO@{IO}}}\label{namespacenode_a0fe2809c313929ad0c569d9e1bdf3e90acf3882f1c43ab22bff0bd9d82d83251b} 
IO&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{BadPartRange@{BadPartRange}!node@{node}}\index{node@{node}!BadPartRange@{BadPartRange}}}\label{namespacenode_a0fe2809c313929ad0c569d9e1bdf3e90a281702e2425e1275033f10a7c8b1cff1} 
Bad\+Part\+Range&\\
\hline

\end{DoxyEnumFields}
\index{node@{node}!TransactionError@{TransactionError}}
\index{TransactionError@{TransactionError}!node@{node}}
\doxysubsubsection{TransactionError}
{\footnotesize\ttfamily \label{namespacenode_a857c3bfc8da2a43cebacd0582cc867ac} 
enum class \textbf{ Transaction\+Error}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{OK@{OK}!node@{node}}\index{node@{node}!OK@{OK}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867acae0aa021e21dddbd6d8cecec71e9cf564} 
OK&No error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MISSING\_INPUTS@{MISSING\_INPUTS}!node@{node}}\index{node@{node}!MISSING\_INPUTS@{MISSING\_INPUTS}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867aca13c6cc69fcf1526c4cb5d1dc3cd983b2} 
MISSING\+\_\+\+INPUTS&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ALREADY\_IN\_UTXO\_SET@{ALREADY\_IN\_UTXO\_SET}!node@{node}}\index{node@{node}!ALREADY\_IN\_UTXO\_SET@{ALREADY\_IN\_UTXO\_SET}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867aca8690b0f0905e6221117ec85c96818031} 
ALREADY\+\_\+\+IN\+\_\+\+UTXO\+\_\+\+SET&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MEMPOOL\_REJECTED@{MEMPOOL\_REJECTED}!node@{node}}\index{node@{node}!MEMPOOL\_REJECTED@{MEMPOOL\_REJECTED}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867aca1deedb424b3597eb79cef9aa0e9a7984} 
MEMPOOL\+\_\+\+REJECTED&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MEMPOOL\_ERROR@{MEMPOOL\_ERROR}!node@{node}}\index{node@{node}!MEMPOOL\_ERROR@{MEMPOOL\_ERROR}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867aca466537a158d09305601cc6fd5abda0f3} 
MEMPOOL\+\_\+\+ERROR&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MAX\_FEE\_EXCEEDED@{MAX\_FEE\_EXCEEDED}!node@{node}}\index{node@{node}!MAX\_FEE\_EXCEEDED@{MAX\_FEE\_EXCEEDED}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867aca2d8cf211b3fe17b760bc0ef03ff34477} 
MAX\+\_\+\+FEE\+\_\+\+EXCEEDED&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MAX\_BURN\_EXCEEDED@{MAX\_BURN\_EXCEEDED}!node@{node}}\index{node@{node}!MAX\_BURN\_EXCEEDED@{MAX\_BURN\_EXCEEDED}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867aca39fa6b6a87d1a6af5d8ff4bc969e054a} 
MAX\+\_\+\+BURN\+\_\+\+EXCEEDED&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{INVALID\_PACKAGE@{INVALID\_PACKAGE}!node@{node}}\index{node@{node}!INVALID\_PACKAGE@{INVALID\_PACKAGE}}}\label{namespacenode_a857c3bfc8da2a43cebacd0582cc867acaa1d18e98c4cce4119dd68e92ce632b48} 
INVALID\+\_\+\+PACKAGE&\\
\hline

\end{DoxyEnumFields}
\index{node@{node}!TxBroadcast@{TxBroadcast}}
\index{TxBroadcast@{TxBroadcast}!node@{node}}
\doxysubsubsection{TxBroadcast}
{\footnotesize\ttfamily \label{namespacenode_a634bcbd7f41b10ba1c4e823cf2d0f3b0} 
enum class \textbf{ Tx\+Broadcast} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}

How to broadcast a local transaction. Used to influence {\ttfamily \doxyref{Broadcast\+Transaction()}{p.}{namespacenode_a370a682ed5a80a825a4fe2e54c13357e}} and its callers. \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{MEMPOOL\_AND\_BROADCAST\_TO\_ALL@{MEMPOOL\_AND\_BROADCAST\_TO\_ALL}!node@{node}}\index{node@{node}!MEMPOOL\_AND\_BROADCAST\_TO\_ALL@{MEMPOOL\_AND\_BROADCAST\_TO\_ALL}}}\label{namespacenode_a634bcbd7f41b10ba1c4e823cf2d0f3b0a4bc6ec227446e14232e4e38661e52eba} 
MEMPOOL\+\_\+\+AND\+\_\+\+BROADCAST\+\_\+\+TO\+\_\+\+ALL&Add the transaction to the mempool and broadcast to all peers for which tx relay is enabled. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MEMPOOL\_NO\_BROADCAST@{MEMPOOL\_NO\_BROADCAST}!node@{node}}\index{node@{node}!MEMPOOL\_NO\_BROADCAST@{MEMPOOL\_NO\_BROADCAST}}}\label{namespacenode_a634bcbd7f41b10ba1c4e823cf2d0f3b0ad51aa9b04491965f8671738a34151a04} 
MEMPOOL\+\_\+\+NO\+\_\+\+BROADCAST&Add the transaction to the mempool, but don\textquotesingle{}t broadcast to anybody. \\
\hline

\end{DoxyEnumFields}
\index{node@{node}!Warning@{Warning}}
\index{Warning@{Warning}!node@{node}}
\doxysubsubsection{Warning}
{\footnotesize\ttfamily \label{namespacenode_af6ea07812363481c623a23ea26fbf8ed} 
enum class \textbf{ Warning}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{CLOCK\_OUT\_OF\_SYNC@{CLOCK\_OUT\_OF\_SYNC}!node@{node}}\index{node@{node}!CLOCK\_OUT\_OF\_SYNC@{CLOCK\_OUT\_OF\_SYNC}}}\label{namespacenode_af6ea07812363481c623a23ea26fbf8eda6ea37e77d2663bc9c82859d27b4b5491} 
CLOCK\+\_\+\+OUT\+\_\+\+OF\+\_\+\+SYNC&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PRE\_RELEASE\_TEST\_BUILD@{PRE\_RELEASE\_TEST\_BUILD}!node@{node}}\index{node@{node}!PRE\_RELEASE\_TEST\_BUILD@{PRE\_RELEASE\_TEST\_BUILD}}}\label{namespacenode_af6ea07812363481c623a23ea26fbf8edaf5ca4b7a10867729ef12e80de51b879e} 
PRE\+\_\+\+RELEASE\+\_\+\+TEST\+\_\+\+BUILD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{FATAL\_INTERNAL\_ERROR@{FATAL\_INTERNAL\_ERROR}!node@{node}}\index{node@{node}!FATAL\_INTERNAL\_ERROR@{FATAL\_INTERNAL\_ERROR}}}\label{namespacenode_af6ea07812363481c623a23ea26fbf8edaefd83e29333c885fe842a464058a2730} 
FATAL\+\_\+\+INTERNAL\+\_\+\+ERROR&\\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{node@{node}!AbortNode@{AbortNode}}
\index{AbortNode@{AbortNode}!node@{node}}
\doxysubsubsection{AbortNode()}
{\footnotesize\ttfamily \label{namespacenode_a368871e388c86ded0c565744aea7a45f} 
void Abort\+Node (\begin{DoxyParamCaption}\item[{const std\+::function$<$ bool()$>$ \&}]{shutdown\+\_\+request}{, }\item[{std\+::atomic$<$ int $>$ \&}]{exit\+\_\+status}{, }\item[{const \textbf{ bilingual\+\_\+str} \&}]{message}{, }\item[{\textbf{ node\+::\+Warnings} $\ast$}]{warnings}{}\end{DoxyParamCaption})}

\index{node@{node}!AddMerkleRootAndCoinbase@{AddMerkleRootAndCoinbase}}
\index{AddMerkleRootAndCoinbase@{AddMerkleRootAndCoinbase}!node@{node}}
\doxysubsubsection{AddMerkleRootAndCoinbase()}
{\footnotesize\ttfamily \label{namespacenode_af655b23c126974dd09b63bb8c9333438} 
void Add\+Merkle\+Root\+And\+Coinbase (\begin{DoxyParamCaption}\item[{\textbf{ CBlock} \&}]{block}{, }\item[{\textbf{ CTransaction\+Ref}}]{coinbase}{, }\item[{uint32\+\_\+t}]{version}{, }\item[{uint32\+\_\+t}]{timestamp}{, }\item[{uint32\+\_\+t}]{nonce}{}\end{DoxyParamCaption})}

\index{node@{node}!AnalyzePSBT@{AnalyzePSBT}}
\index{AnalyzePSBT@{AnalyzePSBT}!node@{node}}
\doxysubsubsection{AnalyzePSBT()}
{\footnotesize\ttfamily \label{namespacenode_af950b4118f79793a4568d7252770fc0a} 
\textbf{ PSBTAnalysis} Analyze\+PSBT (\begin{DoxyParamCaption}\item[{\textbf{ Partially\+Signed\+Transaction}}]{psbtx}{}\end{DoxyParamCaption})}

Provides helpful miscellaneous information about where a PSBT is in the signing workflow.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em psbtx} & the PSBT to analyze \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \doxyref{PSBTAnalysis}{p.}{structnode_1_1_p_s_b_t_analysis} with information about the provided PSBT. 
\end{DoxyReturn}
\index{node@{node}!ApplyArgsManOptions@{ApplyArgsManOptions}}
\index{ApplyArgsManOptions@{ApplyArgsManOptions}!node@{node}}
\doxysubsubsection{ApplyArgsManOptions()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{namespacenode_aa0502f4c140961e55cf2ea92ffe97616} 
void Apply\+Args\+Man\+Options (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{g\+Args}{, }\item[{\textbf{ Block\+Assembler\+::\+Options} \&}]{options}{}\end{DoxyParamCaption})}

Apply -\/blockmintxfee and -\/blockmaxweight options from \doxyref{Args\+Manager}{p.}{class_args_manager} to \doxyref{Block\+Assembler}{p.}{classnode_1_1_block_assembler} options. \index{node@{node}!ApplyArgsManOptions@{ApplyArgsManOptions}}
\index{ApplyArgsManOptions@{ApplyArgsManOptions}!node@{node}}
\doxysubsubsection{ApplyArgsManOptions()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{namespacenode_a6426f2baab5b795996c215224a46506b} 
\textbf{ util\+::\+Result}$<$ void $>$ Apply\+Args\+Man\+Options (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{, }\item[{\textbf{ Block\+Manager\+::\+Options} \&}]{opts}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

\index{node@{node}!ApplyArgsManOptions@{ApplyArgsManOptions}}
\index{ApplyArgsManOptions@{ApplyArgsManOptions}!node@{node}}
\doxysubsubsection{ApplyArgsManOptions()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{namespacenode_a862701ebfab8fe9ffae6b0106682fa81} 
\textbf{ util\+::\+Result}$<$ void $>$ Apply\+Args\+Man\+Options (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{, }\item[{\textbf{ Chainstate\+Manager\+::\+Options} \&}]{opts}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

\index{node@{node}!ApplyArgsManOptions@{ApplyArgsManOptions}}
\index{ApplyArgsManOptions@{ApplyArgsManOptions}!node@{node}}
\doxysubsubsection{ApplyArgsManOptions()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{namespacenode_a19cd2a70ea6924b1caa287e972e7ab54} 
void Apply\+Args\+Man\+Options (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{argsman}{, }\item[{\textbf{ Peer\+Manager\+::\+Options} \&}]{options}{}\end{DoxyParamCaption})}

\index{node@{node}!BroadcastTransaction@{BroadcastTransaction}}
\index{BroadcastTransaction@{BroadcastTransaction}!node@{node}}
\doxysubsubsection{BroadcastTransaction()}
{\footnotesize\ttfamily \label{namespacenode_a370a682ed5a80a825a4fe2e54c13357e} 
\textbf{ Transaction\+Error} Broadcast\+Transaction (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Context} \&}]{node}{, }\item[{\textbf{ CTransaction\+Ref}}]{tx}{, }\item[{std\+::string \&}]{err\+\_\+string}{, }\item[{const \textbf{ CAmount} \&}]{max\+\_\+tx\+\_\+fee}{, }\item[{\textbf{ Tx\+Broadcast}}]{broadcast\+\_\+method}{, }\item[{bool}]{wait\+\_\+callback}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

Submit a transaction to the mempool and (optionally) relay it to all P2P peers.

Mempool submission can be synchronous (will await mempool entry notification over the \doxyref{CValidation\+Interface}{p.}{class_c_validation_interface}) or asynchronous (will submit and not wait for notification), depending on the value of wait\+\_\+callback. wait\+\_\+callback MUST NOT be set while cs\+\_\+main, cs\+\_\+mempool or cs\+\_\+wallet are held to avoid deadlock.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em node} & reference to node context \\
\hline
\mbox{\texttt{in}}  & {\em tx} & the transaction to broadcast \\
\hline
\mbox{\texttt{out}}  & {\em err\+\_\+string} & reference to std\+::string to fill with error string if available \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+tx\+\_\+fee} & reject txs with fees higher than this (if 0, accept any fee) \\
\hline
\mbox{\texttt{in}}  & {\em broadcast\+\_\+method} & whether to add the transaction to the mempool and how to broadcast it \\
\hline
\mbox{\texttt{in}}  & {\em wait\+\_\+callback} & wait until callbacks have been processed to avoid stale result due to a sequentially RPC. return error \\
\hline
\end{DoxyParams}
\index{node@{node}!CalculateCacheSizes@{CalculateCacheSizes}}
\index{CalculateCacheSizes@{CalculateCacheSizes}!node@{node}}
\doxysubsubsection{CalculateCacheSizes()}
{\footnotesize\ttfamily \label{namespacenode_aa1c9faa8f74afc4645721e442c54b9c6} 
\textbf{ Cache\+Sizes} Calculate\+Cache\+Sizes (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{, }\item[{size\+\_\+t}]{n\+\_\+indexes}{}\end{DoxyParamCaption})}

\index{node@{node}!CalculateDbCacheBytes@{CalculateDbCacheBytes}}
\index{CalculateDbCacheBytes@{CalculateDbCacheBytes}!node@{node}}
\doxysubsubsection{CalculateDbCacheBytes()}
{\footnotesize\ttfamily \label{namespacenode_a60050413c3759b24940261580a5bc25b} 
size\+\_\+t Calculate\+Db\+Cache\+Bytes (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{}\end{DoxyParamCaption})}

\index{node@{node}!DumpMempool@{DumpMempool}}
\index{DumpMempool@{DumpMempool}!node@{node}}
\doxysubsubsection{DumpMempool()}
{\footnotesize\ttfamily \label{namespacenode_ab50998edc0bcd4e1b0990d891b7ee90b} 
bool Dump\+Mempool (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Mem\+Pool} \&}]{pool}{, }\item[{const \textbf{ fs\+::path} \&}]{dump\+\_\+path}{, }\item[{\textbf{ fsbridge\+::\+Fopen\+Fn}}]{mockable\+\_\+fopen\+\_\+function}{ = {\ttfamily \textbf{ fsbridge\+::fopen}}, }\item[{bool}]{skip\+\_\+file\+\_\+commit}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Dump the mempool to a file. \index{node@{node}!FindAssumeutxoChainstateDir@{FindAssumeutxoChainstateDir}}
\index{FindAssumeutxoChainstateDir@{FindAssumeutxoChainstateDir}!node@{node}}
\doxysubsubsection{FindAssumeutxoChainstateDir()}
{\footnotesize\ttfamily \label{namespacenode_a5b64fe45690872d3bd11de86a157c931} 
std\+::optional$<$ \textbf{ fs\+::path} $>$ Find\+Assumeutxo\+Chainstate\+Dir (\begin{DoxyParamCaption}\item[{const \textbf{ fs\+::path} \&}]{data\+\_\+dir}{}\end{DoxyParamCaption})}



Return a path to the snapshot-\/based chainstate dir, if one exists. 

\index{node@{node}!FindCoins@{FindCoins}}
\index{FindCoins@{FindCoins}!node@{node}}
\doxysubsubsection{FindCoins()}
{\footnotesize\ttfamily \label{namespacenode_a7cbf0dd47c6f8c068e7604434f8e0457} 
void Find\+Coins (\begin{DoxyParamCaption}\item[{const \textbf{ node\+::\+Node\+Context} \&}]{node}{, }\item[{std\+::map$<$ \textbf{ COut\+Point}, \textbf{ Coin} $>$ \&}]{coins}{}\end{DoxyParamCaption})}

Look up unspent output information. Returns coins in the mempool and in the current chain UTXO set. Iterates through all the keys in the map and populates the values.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em node} & The node context to use for lookup \\
\hline
\mbox{\texttt{in,out}}  & {\em coins} & map to fill \\
\hline
\end{DoxyParams}
\index{node@{node}!GetMinimumTime@{GetMinimumTime}}
\index{GetMinimumTime@{GetMinimumTime}!node@{node}}
\doxysubsubsection{GetMinimumTime()}
{\footnotesize\ttfamily \label{namespacenode_ab0a9f566c87d8e762f84ad2ccc060177} 
int64\+\_\+t Get\+Minimum\+Time (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Index} $\ast$}]{pindex\+Prev}{, }\item[{const int64\+\_\+t}]{difficulty\+\_\+adjustment\+\_\+interval}{}\end{DoxyParamCaption})}

Get the minimum time a miner should use in the next block. This always accounts for the BIP94 timewarp rule, so does not necessarily reflect the consensus limit. \index{node@{node}!GetTip@{GetTip}}
\index{GetTip@{GetTip}!node@{node}}
\doxysubsubsection{GetTip()}
{\footnotesize\ttfamily \label{namespacenode_a222c68c9ae42bc5fcea6ce1726dacfc4} 
std\+::optional$<$ \textbf{ Block\+Ref} $>$ Get\+Tip (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{}\end{DoxyParamCaption})}

\index{node@{node}!GetTransaction@{GetTransaction}}
\index{GetTransaction@{GetTransaction}!node@{node}}
\doxysubsubsection{GetTransaction()}
{\footnotesize\ttfamily \label{namespacenode_a5164d41fdf8e6d77e7a7a4e94041e537} 
\textbf{ CTransaction\+Ref} Get\+Transaction (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Index} $\ast$const}]{block\+\_\+index}{, }\item[{const \textbf{ CTx\+Mem\+Pool} $\ast$const}]{mempool}{, }\item[{const \textbf{ Txid} \&}]{hash}{, }\item[{const \textbf{ Block\+Manager} \&}]{blockman}{, }\item[{\textbf{ uint256} \&}]{hash\+Block}{}\end{DoxyParamCaption})}

Return transaction with a given hash. If mempool is provided and block\+\_\+index is not provided, check it first for the tx. If -\/txindex is available, check it next for the tx. Finally, if block\+\_\+index is provided, check for tx by reading entire block from disk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em block\+\_\+index} & The block to read from disk, or nullptr \\
\hline
\mbox{\texttt{in}}  & {\em mempool} & If provided, check mempool for tx \\
\hline
\mbox{\texttt{in}}  & {\em hash} & The txid \\
\hline
\mbox{\texttt{in}}  & {\em blockman} & Used to access and read blocks from disk \\
\hline
\mbox{\texttt{out}}  & {\em hash\+Block} & The block hash, if the tx was found via -\/txindex or block\+\_\+index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The tx if found, otherwise nullptr 
\end{DoxyReturn}
\index{node@{node}!GetWarningsForRpc@{GetWarningsForRpc}}
\index{GetWarningsForRpc@{GetWarningsForRpc}!node@{node}}
\doxysubsubsection{GetWarningsForRpc()}
{\footnotesize\ttfamily \label{namespacenode_ace8af9650a423663c58e95ef395a37a1} 
\textbf{ Uni\+Value} Get\+Warnings\+For\+Rpc (\begin{DoxyParamCaption}\item[{const \textbf{ Warnings} \&}]{warnings}{, }\item[{bool}]{use\+\_\+deprecated}{}\end{DoxyParamCaption})}

RPC helper function that wraps warnings.\+Get\+Messages().

Returns a \doxyref{Uni\+Value\+::\+VSTR}{p.}{class_uni_value_a28a778aedb7441c6b9755e1882b58dc9ad7eb819329aa2eae7e825f6f7a8f4efc} with the latest warning if use\+\_\+deprecated is set to true, or a \doxyref{Uni\+Value\+::\+VARR}{p.}{class_uni_value_a28a778aedb7441c6b9755e1882b58dc9a29e09364a716e7f1500adfc15d206e78} with all warnings otherwise. \index{node@{node}!ImportBlocks@{ImportBlocks}}
\index{ImportBlocks@{ImportBlocks}!node@{node}}
\doxysubsubsection{ImportBlocks()}
{\footnotesize\ttfamily \label{namespacenode_a50030ce5206985e346250590dabd6d88} 
void Import\+Blocks (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{std\+::span$<$ const \textbf{ fs\+::path} $>$}]{import\+\_\+paths}{}\end{DoxyParamCaption})}

\index{node@{node}!InterruptWait@{InterruptWait}}
\index{InterruptWait@{InterruptWait}!node@{node}}
\doxysubsubsection{InterruptWait()}
{\footnotesize\ttfamily \label{namespacenode_ad9ddecf9590cc59582f576a1db0cc14c} 
void Interrupt\+Wait (\begin{DoxyParamCaption}\item[{\textbf{ Kernel\+Notifications} \&}]{kernel\+\_\+notifications}{, }\item[{bool \&}]{interrupt\+\_\+wait}{}\end{DoxyParamCaption})}

\index{node@{node}!LoadChainstate@{LoadChainstate}}
\index{LoadChainstate@{LoadChainstate}!node@{node}}
\doxysubsubsection{LoadChainstate()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacenode_a2d650cf978844ae65f6667c85fc53ede} 
\textbf{ Chainstate\+Load\+Result} Load\+Chainstate (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{const \textbf{ Cache\+Sizes} \&}]{cache\+\_\+sizes}{, }\item[{const \textbf{ Chainstate\+Load\+Options} \&}]{options}{}\end{DoxyParamCaption})}

\index{node@{node}!LoadChainstate@{LoadChainstate}}
\index{LoadChainstate@{LoadChainstate}!node@{node}}
\doxysubsubsection{LoadChainstate()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacenode_a2dbdeed288a3645a5ebb91335a1a86d6} 
\textbf{ Chainstate\+Load\+Result} Load\+Chainstate (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{const \textbf{ kernel\+::\+Cache\+Sizes} \&}]{cache\+\_\+sizes}{, }\item[{const \textbf{ Chainstate\+Load\+Options} \&}]{options}{}\end{DoxyParamCaption})}

This sequence can have 4 types of outcomes\+:


\begin{DoxyEnumerate}
\item Success
\item Shutdown requested
\begin{DoxyItemize}
\item nothing failed but a shutdown was triggered in the middle of the sequence
\end{DoxyItemize}
\item Soft failure
\begin{DoxyItemize}
\item a failure that might be recovered from with a reindex
\end{DoxyItemize}
\item Hard failure
\begin{DoxyItemize}
\item a failure that definitively cannot be recovered from with a reindex
\end{DoxyItemize}
\end{DoxyEnumerate}

Load\+Chainstate returns a (status code, error string) tuple. \index{node@{node}!LoadMempool@{LoadMempool}}
\index{LoadMempool@{LoadMempool}!node@{node}}
\doxysubsubsection{LoadMempool()}
{\footnotesize\ttfamily \label{namespacenode_ab2381316504e955ba03329e6eae581cc} 
bool Load\+Mempool (\begin{DoxyParamCaption}\item[{\textbf{ CTx\+Mem\+Pool} \&}]{pool}{, }\item[{const \textbf{ fs\+::path} \&}]{load\+\_\+path}{, }\item[{\textbf{ Chainstate} \&}]{active\+\_\+chainstate}{, }\item[{\textbf{ Import\+Mempool\+Options} \&\&}]{opts}{}\end{DoxyParamCaption})}

Import the file and attempt to add its contents to the mempool. \index{node@{node}!LogOversizedDbCache@{LogOversizedDbCache}}
\index{LogOversizedDbCache@{LogOversizedDbCache}!node@{node}}
\doxysubsubsection{LogOversizedDbCache()}
{\footnotesize\ttfamily \label{namespacenode_a0156a0d2c3be07b28980d8ad967263ee} 
void Log\+Oversized\+Db\+Cache (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{node@{node}!MakeMinisketch32@{MakeMinisketch32}}
\index{MakeMinisketch32@{MakeMinisketch32}!node@{node}}
\doxysubsubsection{MakeMinisketch32()}
{\footnotesize\ttfamily \label{namespacenode_a0e12a9612fd84893b7f88efc723b7554} 
Minisketch Make\+Minisketch32 (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{capacity}{}\end{DoxyParamCaption})}

\doxyref{Wrapper}{p.}{class_wrapper} around Minisketch\+::\+Minisketch(32, implementation, capacity). \index{node@{node}!MakeMinisketch32FP@{MakeMinisketch32FP}}
\index{MakeMinisketch32FP@{MakeMinisketch32FP}!node@{node}}
\doxysubsubsection{MakeMinisketch32FP()}
{\footnotesize\ttfamily \label{namespacenode_a5b13cfd20c2769b7f76441f731d7f617} 
Minisketch Make\+Minisketch32\+FP (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{max\+\_\+elements}{, }\item[{uint32\+\_\+t}]{fpbits}{}\end{DoxyParamCaption})}

\doxyref{Wrapper}{p.}{class_wrapper} around Minisketch\+::\+Create\+FP. \index{node@{node}!MakeTxOrphanage@{MakeTxOrphanage}}
\index{MakeTxOrphanage@{MakeTxOrphanage}!node@{node}}
\doxysubsubsection{MakeTxOrphanage()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacenode_aa4c7a71c1806142d5b1e084687b566c0} 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Orphanage} $>$ Make\+Tx\+Orphanage (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Create a new \doxyref{Tx\+Orphanage}{p.}{classnode_1_1_tx_orphanage} instance \index{node@{node}!MakeTxOrphanage@{MakeTxOrphanage}}
\index{MakeTxOrphanage@{MakeTxOrphanage}!node@{node}}
\doxysubsubsection{MakeTxOrphanage()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacenode_ad35287c945ebc4aa30c0f8dd52bb36e7} 
std\+::unique\+\_\+ptr$<$ \textbf{ Tx\+Orphanage} $>$ Make\+Tx\+Orphanage (\begin{DoxyParamCaption}\item[{\textbf{ Tx\+Orphanage\+::\+Count}}]{max\+\_\+global\+\_\+latency\+\_\+score}{, }\item[{\textbf{ Tx\+Orphanage\+::\+Usage}}]{reserved\+\_\+peer\+\_\+usage}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{node@{node}!MempoolPath@{MempoolPath}}
\index{MempoolPath@{MempoolPath}!node@{node}}
\doxysubsubsection{MempoolPath()}
{\footnotesize\ttfamily \label{namespacenode_a33310f5279d28a2f9fcc1b3a51cf53ff} 
\textbf{ fs\+::path} Mempool\+Path (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{argsman}{}\end{DoxyParamCaption})}

\index{node@{node}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!node@{node}}
\doxysubsubsection{operator$<$$<$()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacenode_a8c2935402f5ef3018e44e3af4b7e4ba1} 
std\+::ostream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{, }\item[{const \textbf{ Blockfile\+Cursor} \&}]{cursor}{}\end{DoxyParamCaption})}

\index{node@{node}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!node@{node}}
\doxysubsubsection{operator$<$$<$()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacenode_a3dad8e14e2d281a9ba7752916ddf22d3} 
std\+::ostream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{, }\item[{const \textbf{ Blockfile\+Type} \&}]{type}{}\end{DoxyParamCaption})}

\index{node@{node}!ReadCoinsViewArgs@{ReadCoinsViewArgs}}
\index{ReadCoinsViewArgs@{ReadCoinsViewArgs}!node@{node}}
\doxysubsubsection{ReadCoinsViewArgs()}
{\footnotesize\ttfamily \label{namespacenode_ab60165720176200b11a590d7f740dcaa} 
void Read\+Coins\+View\+Args (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{, }\item[{\textbf{ Coins\+View\+Options} \&}]{options}{}\end{DoxyParamCaption})}

\index{node@{node}!ReadDatabaseArgs@{ReadDatabaseArgs}}
\index{ReadDatabaseArgs@{ReadDatabaseArgs}!node@{node}}
\doxysubsubsection{ReadDatabaseArgs()}
{\footnotesize\ttfamily \label{namespacenode_a44ea8e2133a215e8a67a087fa4ab90e1} 
void Read\+Database\+Args (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{, }\item[{\textbf{ DBOptions} \&}]{options}{}\end{DoxyParamCaption})}

\index{node@{node}!ReadNotificationArgs@{ReadNotificationArgs}}
\index{ReadNotificationArgs@{ReadNotificationArgs}!node@{node}}
\doxysubsubsection{ReadNotificationArgs()}
{\footnotesize\ttfamily \label{namespacenode_acd82a235461d5587ce350b06c7fa3011} 
void Read\+Notification\+Args (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{args}{, }\item[{\textbf{ Kernel\+Notifications} \&}]{notifications}{}\end{DoxyParamCaption})}

\index{node@{node}!ReadSnapshotBaseBlockhash@{ReadSnapshotBaseBlockhash}}
\index{ReadSnapshotBaseBlockhash@{ReadSnapshotBaseBlockhash}!node@{node}}
\doxysubsubsection{ReadSnapshotBaseBlockhash()}
{\footnotesize\ttfamily \label{namespacenode_a4d2cd11f67bcd44c8e56621eeee89695} 
std\+::optional$<$ \textbf{ uint256} $>$ Read\+Snapshot\+Base\+Blockhash (\begin{DoxyParamCaption}\item[{\textbf{ fs\+::path}}]{chaindir}{}\end{DoxyParamCaption})}

\index{node@{node}!RegenerateCommitments@{RegenerateCommitments}}
\index{RegenerateCommitments@{RegenerateCommitments}!node@{node}}
\doxysubsubsection{RegenerateCommitments()}
{\footnotesize\ttfamily \label{namespacenode_ad7d81a8f20e10a0889027618f1ca7c96} 
void Regenerate\+Commitments (\begin{DoxyParamCaption}\item[{\textbf{ CBlock} \&}]{block}{, }\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{}\end{DoxyParamCaption})}

Update an old Generate\+Coinbase\+Commitment from Create\+New\+Block after the block txs have changed \index{node@{node}!ShouldPersistMempool@{ShouldPersistMempool}}
\index{ShouldPersistMempool@{ShouldPersistMempool}!node@{node}}
\doxysubsubsection{ShouldPersistMempool()}
{\footnotesize\ttfamily \label{namespacenode_a2ca33310929752f44f32a912fc1634ba} 
bool Should\+Persist\+Mempool (\begin{DoxyParamCaption}\item[{const \textbf{ Args\+Manager} \&}]{argsman}{}\end{DoxyParamCaption})}

\index{node@{node}!ShouldWarnOversizedDbCache@{ShouldWarnOversizedDbCache}}
\index{ShouldWarnOversizedDbCache@{ShouldWarnOversizedDbCache}!node@{node}}
\doxysubsubsection{ShouldWarnOversizedDbCache()}
{\footnotesize\ttfamily \label{namespacenode_a4c30a66b5de0d011291e6530ddb04375} 
bool Should\+Warn\+Oversized\+Db\+Cache (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{dbcache}{, }\item[{size\+\_\+t}]{total\+\_\+ram}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

\index{node@{node}!UpdateTime@{UpdateTime}}
\index{UpdateTime@{UpdateTime}!node@{node}}
\doxysubsubsection{UpdateTime()}
{\footnotesize\ttfamily \label{namespacenode_a9c09903c7d6401b5405db02af064179c} 
int64\+\_\+t Update\+Time (\begin{DoxyParamCaption}\item[{\textbf{ CBlock\+Header} $\ast$}]{pblock}{, }\item[{const \textbf{ Consensus\+::\+Params} \&}]{consensus\+Params}{, }\item[{const \textbf{ CBlock\+Index} $\ast$}]{pindex\+Prev}{}\end{DoxyParamCaption})}

\index{node@{node}!VerifyLoadedChainstate@{VerifyLoadedChainstate}}
\index{VerifyLoadedChainstate@{VerifyLoadedChainstate}!node@{node}}
\doxysubsubsection{VerifyLoadedChainstate()}
{\footnotesize\ttfamily \label{namespacenode_aa25a7902215e7a3de72f3b19a4372167} 
\textbf{ Chainstate\+Load\+Result} Verify\+Loaded\+Chainstate (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{const \textbf{ Chainstate\+Load\+Options} \&}]{options}{}\end{DoxyParamCaption})}

\index{node@{node}!WaitAndCreateNewBlock@{WaitAndCreateNewBlock}}
\index{WaitAndCreateNewBlock@{WaitAndCreateNewBlock}!node@{node}}
\doxysubsubsection{WaitAndCreateNewBlock()}
{\footnotesize\ttfamily \label{namespacenode_a278642046cc2f9ee283ed3e072585d69} 
std\+::unique\+\_\+ptr$<$ \textbf{ CBlock\+Template} $>$ Wait\+And\+Create\+New\+Block (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{\textbf{ Kernel\+Notifications} \&}]{kernel\+\_\+notifications}{, }\item[{\textbf{ CTx\+Mem\+Pool} $\ast$}]{mempool}{, }\item[{const std\+::unique\+\_\+ptr$<$ \textbf{ CBlock\+Template} $>$ \&}]{block\+\_\+template}{, }\item[{const \textbf{ Block\+Wait\+Options} \&}]{options}{, }\item[{const \textbf{ Block\+Assembler\+::\+Options} \&}]{assemble\+\_\+options}{, }\item[{bool \&}]{interrupt\+\_\+wait}{}\end{DoxyParamCaption})}

Return a new block template when fees rise to a certain threshold or after a new tip; return nullopt if timeout is reached. We determine if fees increased compared to the previous template by generating a fresh template. There may be more efficient ways to determine how much (approximate) fees for the next block increased, perhaps more so after Cluster Mempool.

We\textquotesingle{}ll also create a new template if the tip changed during this iteration.\index{node@{node}!WaitTipChanged@{WaitTipChanged}}
\index{WaitTipChanged@{WaitTipChanged}!node@{node}}
\doxysubsubsection{WaitTipChanged()}
{\footnotesize\ttfamily \label{namespacenode_abbc69ba8422e4a527f19e2b927c28fda} 
std\+::optional$<$ \textbf{ Block\+Ref} $>$ Wait\+Tip\+Changed (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate\+Manager} \&}]{chainman}{, }\item[{\textbf{ Kernel\+Notifications} \&}]{kernel\+\_\+notifications}{, }\item[{const \textbf{ uint256} \&}]{current\+\_\+tip}{, }\item[{\textbf{ Milliseconds\+Double} \&}]{timeout}{}\end{DoxyParamCaption})}

\index{node@{node}!WriteSnapshotBaseBlockhash@{WriteSnapshotBaseBlockhash}}
\index{WriteSnapshotBaseBlockhash@{WriteSnapshotBaseBlockhash}!node@{node}}
\doxysubsubsection{WriteSnapshotBaseBlockhash()}
{\footnotesize\ttfamily \label{namespacenode_aa28134e14a9f1ba865d7ca064e0486dd} 
bool Write\+Snapshot\+Base\+Blockhash (\begin{DoxyParamCaption}\item[{\textbf{ Chainstate} \&}]{snapshot\+\_\+chainstate}{}\end{DoxyParamCaption})}



\label{doc-var-members}
\doxysubsection{Variable Documentation}
\index{node@{node}!SNAPSHOT\_BLOCKHASH\_FILENAME@{SNAPSHOT\_BLOCKHASH\_FILENAME}}
\index{SNAPSHOT\_BLOCKHASH\_FILENAME@{SNAPSHOT\_BLOCKHASH\_FILENAME}!node@{node}}
\doxysubsubsection{SNAPSHOT\_BLOCKHASH\_FILENAME}
{\footnotesize\ttfamily \label{namespacenode_ae40260991115210bae924c07e683ac91} 
const \textbf{ fs\+::path} SNAPSHOT\+\_\+\+BLOCKHASH\+\_\+\+FILENAME \{"{}base\+\_\+blockhash"{}\}}

The file in the snapshot chainstate dir which stores the base blockhash. This is needed to reconstruct snapshot chainstates on init.

Because we only allow loading a single snapshot at a time, there will only be one chainstate directory with this filename present within it. \index{node@{node}!SNAPSHOT\_CHAINSTATE\_SUFFIX@{SNAPSHOT\_CHAINSTATE\_SUFFIX}}
\index{SNAPSHOT\_CHAINSTATE\_SUFFIX@{SNAPSHOT\_CHAINSTATE\_SUFFIX}!node@{node}}
\doxysubsubsection{SNAPSHOT\_CHAINSTATE\_SUFFIX}
{\footnotesize\ttfamily \label{namespacenode_afefb365ea639adf55cb1729e630c3f0f} 
bool \textbf{ Write\+Snapshot\+Base\+Blockhash} (\textbf{ Chainstate}\& snapshot\+\_\+chainstate) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( std\+::optional$<$\textbf{ uint256}$>$ \textbf{ Read\+Snapshot\+Base\+Blockhash} (\textbf{ fs\+::path} chaindir) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( constexpr std\+::string\+\_\+vie SNAPSHOT\+\_\+\+CHAINSTATE\+\_\+\+SUFFIX)  = "{}\+\_\+snapshot"{}\hspace{0.3cm}{\ttfamily [constexpr]}}

Write out the blockhash of the snapshot base block that was used to construct this chainstate. This value is read in during subsequent initializations and used to reconstruct snapshot-\/based chainstates.

Read the blockhash of the snapshot base block that was used to construct the chainstate.

Suffix appended to the chainstate (leveldb) dir when created based upon a snapshot. 