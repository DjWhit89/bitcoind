\doxysection{src/httpserver.cpp File Reference}
\label{httpserver_8cpp}\index{src/httpserver.cpp@{src/httpserver.cpp}}
{\ttfamily \#include $<$httpserver.\+h$>$}\newline
{\ttfamily \#include $<$chainparamsbase.\+h$>$}\newline
{\ttfamily \#include $<$common/args.\+h$>$}\newline
{\ttfamily \#include $<$common/messages.\+h$>$}\newline
{\ttfamily \#include $<$compat/compat.\+h$>$}\newline
{\ttfamily \#include $<$logging.\+h$>$}\newline
{\ttfamily \#include $<$netbase.\+h$>$}\newline
{\ttfamily \#include $<$node/interface\+\_\+ui.\+h$>$}\newline
{\ttfamily \#include $<$rpc/protocol.\+h$>$}\newline
{\ttfamily \#include $<$sync.\+h$>$}\newline
{\ttfamily \#include $<$util/check.\+h$>$}\newline
{\ttfamily \#include $<$util/signalinterrupt.\+h$>$}\newline
{\ttfamily \#include $<$util/strencodings.\+h$>$}\newline
{\ttfamily \#include $<$util/threadnames.\+h$>$}\newline
{\ttfamily \#include $<$util/translation.\+h$>$}\newline
{\ttfamily \#include $<$condition\+\_\+variable$>$}\newline
{\ttfamily \#include $<$cstdio$>$}\newline
{\ttfamily \#include $<$cstdlib$>$}\newline
{\ttfamily \#include $<$deque$>$}\newline
{\ttfamily \#include $<$memory$>$}\newline
{\ttfamily \#include $<$optional$>$}\newline
{\ttfamily \#include $<$span$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$thread$>$}\newline
{\ttfamily \#include $<$unordered\+\_\+map$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$sys/types.\+h$>$}\newline
{\ttfamily \#include $<$sys/stat.\+h$>$}\newline
{\ttfamily \#include $<$event2/buffer.\+h$>$}\newline
{\ttfamily \#include $<$event2/bufferevent.\+h$>$}\newline
{\ttfamily \#include $<$event2/http.\+h$>$}\newline
{\ttfamily \#include $<$event2/http\+\_\+struct.\+h$>$}\newline
{\ttfamily \#include $<$event2/keyvalq\+\_\+struct.\+h$>$}\newline
{\ttfamily \#include $<$event2/thread.\+h$>$}\newline
{\ttfamily \#include $<$event2/util.\+h$>$}\newline
{\ttfamily \#include $<$support/events.\+h$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ HTTPWork\+Item}
\item 
class \textbf{ Work\+Queue$<$ Work\+Item $>$}
\item 
struct \textbf{ HTTPPath\+Handler}
\item 
class \textbf{ HTTPRequest\+Tracker}
\begin{DoxyCompactList}\small\item\em Helps keep track of open {\ttfamily evhttp\+\_\+connection}s with active {\ttfamily evhttp\+\_\+requests}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ Request\+Method\+String} (\textbf{ HTTPRequest\+::\+Request\+Method} m)
\item 
bool \textbf{ Init\+HTTPServer} (const \textbf{ util\+::\+Signal\+Interrupt} \&interrupt)
\item 
void \textbf{ Update\+HTTPServer\+Logging} (bool enable)
\item 
void \textbf{ Start\+HTTPServer} ()
\item 
void \textbf{ Interrupt\+HTTPServer} ()
\item 
void \textbf{ Stop\+HTTPServer} ()
\item 
struct event\+\_\+base $\ast$ \textbf{ Event\+Base} ()
\item 
std\+::optional$<$ std\+::string $>$ \textbf{ Get\+Query\+Parameter\+From\+Uri} (const char $\ast$uri, const std\+::string \&key)
\item 
void \textbf{ Register\+HTTPHandler} (const std\+::string \&\textbf{ prefix}, bool exact\+Match, const \textbf{ HTTPRequest\+Handler} \&\textbf{ handler})
\item 
void \textbf{ Unregister\+HTTPHandler} (const std\+::string \&\textbf{ prefix}, bool exact\+Match)
\item 
\textbf{ bilingual\+\_\+str} \textbf{ Invalid\+Port\+Err\+Msg} (const std\+::string \&optname, const std\+::string \&invalid\+\_\+value)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{httpserver.cpp@{httpserver.cpp}!EventBase@{EventBase}}
\index{EventBase@{EventBase}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{EventBase()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a678938523347079b4dd5fabc47efdbbc} 
struct event\+\_\+base $\ast$ Event\+Base (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Return evhttp event base. This can be used by submodules to queue timers or custom events. \index{httpserver.cpp@{httpserver.cpp}!GetQueryParameterFromUri@{GetQueryParameterFromUri}}
\index{GetQueryParameterFromUri@{GetQueryParameterFromUri}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{GetQueryParameterFromUri()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a4b96025548083ad61a3b0847621c7a74} 
std\+::optional$<$ std\+::string $>$ Get\+Query\+Parameter\+From\+Uri (\begin{DoxyParamCaption}\item[{const char $\ast$}]{uri}{, }\item[{const std\+::string \&}]{key}{}\end{DoxyParamCaption})}

Get the query parameter value from request uri for a specified key, or std\+::nullopt if the key is not found.

If the query string contains duplicate keys, the first value is returned. Many web frameworks would instead parse this as an array of values, but this is not (yet) implemented as it is currently not needed in any of the endpoints.

Helper function for \doxyref{HTTPRequest\+::\+Get\+Query\+Parameter}{p.}{class_h_t_t_p_request_a4c8d3ca82089f916e360d1d06cf09dbf}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em uri} & is the entire request uri \\
\hline
\mbox{\texttt{in}}  & {\em key} & represents the query parameter of which the value is returned \\
\hline
\end{DoxyParams}
\index{httpserver.cpp@{httpserver.cpp}!InitHTTPServer@{InitHTTPServer}}
\index{InitHTTPServer@{InitHTTPServer}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{InitHTTPServer()}
{\footnotesize\ttfamily \label{httpserver_8cpp_aa5183260b12c1ce706dad5b454a44cec} 
bool Init\+HTTPServer (\begin{DoxyParamCaption}\item[{const \textbf{ util\+::\+Signal\+Interrupt} \&}]{interrupt}{}\end{DoxyParamCaption})}

Initialize HTTP server. Call this before Register\+HTTPHandler or \doxyref{Event\+Base()}{p.}{httpserver_8h_a678938523347079b4dd5fabc47efdbbc}. \index{httpserver.cpp@{httpserver.cpp}!InterruptHTTPServer@{InterruptHTTPServer}}
\index{InterruptHTTPServer@{InterruptHTTPServer}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{InterruptHTTPServer()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a0a02b6576090c9fde2eed21b9aa7dc0c} 
void Interrupt\+HTTPServer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Interrupt HTTP server threads \index{httpserver.cpp@{httpserver.cpp}!InvalidPortErrMsg@{InvalidPortErrMsg}}
\index{InvalidPortErrMsg@{InvalidPortErrMsg}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{InvalidPortErrMsg()}
{\footnotesize\ttfamily \label{httpserver_8cpp_aeb737684e2a2da0e1190fed1229d7990} 
\textbf{ bilingual\+\_\+str} Invalid\+Port\+Err\+Msg (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{optname}{, }\item[{const std\+::string \&}]{invalid\+\_\+value}{}\end{DoxyParamCaption})}

\index{httpserver.cpp@{httpserver.cpp}!RegisterHTTPHandler@{RegisterHTTPHandler}}
\index{RegisterHTTPHandler@{RegisterHTTPHandler}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{RegisterHTTPHandler()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a43a4c24762a6af819e364b55820323ed} 
void Register\+HTTPHandler (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{prefix}{, }\item[{bool}]{exact\+Match}{, }\item[{const \textbf{ HTTPRequest\+Handler} \&}]{handler}{}\end{DoxyParamCaption})}

Register handler for prefix. If multiple handlers match a prefix, the first-\/registered one will be invoked. \index{httpserver.cpp@{httpserver.cpp}!RequestMethodString@{RequestMethodString}}
\index{RequestMethodString@{RequestMethodString}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{RequestMethodString()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a75af2ef31b82c402e19abb5b24d1368a} 
std\+::string Request\+Method\+String (\begin{DoxyParamCaption}\item[{\textbf{ HTTPRequest\+::\+Request\+Method}}]{m}{}\end{DoxyParamCaption})}

HTTP request method as string -\/ use for logging only \index{httpserver.cpp@{httpserver.cpp}!StartHTTPServer@{StartHTTPServer}}
\index{StartHTTPServer@{StartHTTPServer}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{StartHTTPServer()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a4fd74612426e28d4678557f401066d96} 
void Start\+HTTPServer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Start HTTP server. This is separate from Init\+HTTPServer to give users race-\/condition-\/free time to register their handlers between Init\+HTTPServer and Start\+HTTPServer. \index{httpserver.cpp@{httpserver.cpp}!StopHTTPServer@{StopHTTPServer}}
\index{StopHTTPServer@{StopHTTPServer}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{StopHTTPServer()}
{\footnotesize\ttfamily \label{httpserver_8cpp_ad95d08d62c15b43d52fdba7b7ecaa0aa} 
void Stop\+HTTPServer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Stop HTTP server \index{httpserver.cpp@{httpserver.cpp}!UnregisterHTTPHandler@{UnregisterHTTPHandler}}
\index{UnregisterHTTPHandler@{UnregisterHTTPHandler}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{UnregisterHTTPHandler()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a42d2567faa003c410a310a9c4e36ebdc} 
void Unregister\+HTTPHandler (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{prefix}{, }\item[{bool}]{exact\+Match}{}\end{DoxyParamCaption})}

Unregister handler for prefix \index{httpserver.cpp@{httpserver.cpp}!UpdateHTTPServerLogging@{UpdateHTTPServerLogging}}
\index{UpdateHTTPServerLogging@{UpdateHTTPServerLogging}!httpserver.cpp@{httpserver.cpp}}
\doxysubsubsection{UpdateHTTPServerLogging()}
{\footnotesize\ttfamily \label{httpserver_8cpp_a5d061de02f52817cc3e5957046dbf766} 
void Update\+HTTPServer\+Logging (\begin{DoxyParamCaption}\item[{bool}]{enable}{}\end{DoxyParamCaption})}

Change logging level for libevent. 