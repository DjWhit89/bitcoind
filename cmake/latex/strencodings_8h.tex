\doxysection{src/util/strencodings.h File Reference}
\label{strencodings_8h}\index{src/util/strencodings.h@{src/util/strencodings.h}}
{\ttfamily \#include $<$crypto/hex\+\_\+base.\+h$>$}\newline
{\ttfamily \#include $<$span.\+h$>$}\newline
{\ttfamily \#include $<$util/string.\+h$>$}\newline
{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$bit$>$}\newline
{\ttfamily \#include $<$charconv$>$}\newline
{\ttfamily \#include $<$cstddef$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$limits$>$}\newline
{\ttfamily \#include $<$optional$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$string\+\_\+view$>$}\newline
{\ttfamily \#include $<$system\+\_\+error$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Hex$<$ N $>$}
\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ util}
\item 
namespace \textbf{ util\+::detail}
\item 
namespace \textbf{ util\+::hex\+\_\+literals}
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Safe\+Chars} \{ \textbf{ SAFE\+\_\+\+CHARS\+\_\+\+DEFAULT}
, \textbf{ SAFE\+\_\+\+CHARS\+\_\+\+UA\+\_\+\+COMMENT}
, \textbf{ SAFE\+\_\+\+CHARS\+\_\+\+FILENAME}
, \textbf{ SAFE\+\_\+\+CHARS\+\_\+\+URI}
 \}
\item 
enum class \textbf{ Byte\+Unit} \+: uint64\+\_\+t \{ \newline
\textbf{ NOOP} = 1ULL
, \textbf{ k} = 1000ULL
, \textbf{ K} = 1024ULL
, \textbf{ m} = 1\textquotesingle{}000\textquotesingle{}000ULL
, \newline
\textbf{ M} = 1ULL $<$$<$ 20
, \textbf{ g} = 1\textquotesingle{}000\textquotesingle{}000\textquotesingle{}000ULL
, \textbf{ G} = 1ULL $<$$<$ 30
, \textbf{ t} = 1\textquotesingle{}000\textquotesingle{}000\textquotesingle{}000\textquotesingle{}000ULL
, \newline
\textbf{ T} = 1ULL $<$$<$ 40
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ Sanitize\+String} (std\+::string\+\_\+view str, int rule=\textbf{ SAFE\+\_\+\+CHARS\+\_\+\+DEFAULT})
\item 
{\footnotesize template$<$typename Byte = std\+::byte$>$ }\\std\+::optional$<$ std\+::vector$<$ Byte $>$ $>$ \textbf{ Try\+Parse\+Hex} (std\+::string\+\_\+view str)
\item 
{\footnotesize template$<$typename Byte = uint8\+\_\+t$>$ }\\std\+::vector$<$ Byte $>$ \textbf{ Parse\+Hex} (std\+::string\+\_\+view hex\+\_\+str)
\item 
bool \textbf{ Is\+Hex} (std\+::string\+\_\+view str)
\item 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ \textbf{ Decode\+Base64} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Encode\+Base64} (std\+::span$<$ const unsigned char $>$ input)
\item 
std\+::string \textbf{ Encode\+Base64} (std\+::span$<$ const std\+::byte $>$ input)
\item 
std\+::string \textbf{ Encode\+Base64} (std\+::string\+\_\+view str)
\item 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ \textbf{ Decode\+Base32} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Encode\+Base32} (std\+::span$<$ const unsigned char $>$ input, bool pad=true)
\item 
std\+::string \textbf{ Encode\+Base32} (std\+::string\+\_\+view str, bool pad=true)
\item 
bool \textbf{ Split\+Host\+Port} (std\+::string\+\_\+view in, uint16\+\_\+t \&port\+Out, std\+::string \&host\+Out)
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ T} \textbf{ Locale\+Independent\+Atoi} (std\+::string\+\_\+view str)
\item 
constexpr bool \textbf{ Is\+Digit} (char c)
\item 
constexpr bool \textbf{ Is\+Space} (char c) noexcept
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\std\+::optional$<$ \textbf{ T} $>$ \textbf{ To\+Integral} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Format\+Paragraph} (std\+::string\+\_\+view in, size\+\_\+t width=79, size\+\_\+t indent=0)
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\bool \textbf{ Timing\+Resistant\+Equal} (const \textbf{ T} \&a, const \textbf{ T} \&b)
\item 
bool \textbf{ Parse\+Fixed\+Point} (std\+::string\+\_\+view, int decimals, int64\+\_\+t $\ast$amount\+\_\+out)
\item 
{\footnotesize template$<$int frombits, int tobits, bool pad, typename O, typename It, typename I = Int\+Identity$>$ }\\bool \textbf{ Convert\+Bits} (O outfn, It it, It end, I infn=\{\})
\item 
constexpr char \textbf{ To\+Lower} (char c)
\item 
std\+::string \textbf{ To\+Lower} (std\+::string\+\_\+view str)
\item 
constexpr char \textbf{ To\+Upper} (char c)
\item 
std\+::string \textbf{ To\+Upper} (std\+::string\+\_\+view str)
\item 
std\+::string \textbf{ Capitalize} (std\+::string str)
\item 
std\+::optional$<$ uint64\+\_\+t $>$ \textbf{ Parse\+Byte\+Units} (std\+::string\+\_\+view str, \textbf{ Byte\+Unit} default\+\_\+multiplier)
\item 
consteval uint8\+\_\+t \textbf{ Consteval\+Hex\+Digit} (const char c)
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\constexpr auto \textbf{ operator"{}"{}\+\_\+hex} ()
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\constexpr auto \textbf{ operator"{}"{}\+\_\+hex\+\_\+u8} ()
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\constexpr auto \textbf{ operator"{}"{}\+\_\+hex\+\_\+v} ()
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\auto \textbf{ operator"{}"{}\+\_\+hex\+\_\+v\+\_\+u8} ()
\end{DoxyCompactItemize}


\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{strencodings.h@{strencodings.h}!ByteUnit@{ByteUnit}}
\index{ByteUnit@{ByteUnit}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ByteUnit}
{\footnotesize\ttfamily \label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2c} 
enum class \textbf{ Byte\+Unit} \+: uint64\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}

Used by \doxyref{Parse\+Byte\+Units()}{p.}{strencodings_8h_ae89e79da81174d0900ca12cc82d04e04} Lowercase base 1000 Uppercase base 1024 \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{NOOP@{NOOP}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!NOOP@{NOOP}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2ca722d122e81cbbe543bd5520bb8678c0e} 
NOOP&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{k@{k}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!k@{k}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2ca8ce4b16b22b58894aa86c421e8759df3} 
k&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{K@{K}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!K@{K}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2caa5f3c6a11b03839d46af9fb43c97c188} 
K&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{m@{m}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!m@{m}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2ca6f8f57715090da2632453988d9a1501b} 
m&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{M@{M}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!M@{M}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2ca69691c7bdcc3ce6d5d8a1361f22d04ac} 
M&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{g@{g}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!g@{g}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2cab2f5ff47436671b6e533d8dc3614845d} 
g&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{G@{G}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!G@{G}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2cadfcf28d0734569a6a693bc8194de62bf} 
G&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{t@{t}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!t@{t}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2cae358efa489f58062f10dd7316b65649e} 
t&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T@{T}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!T@{T}}}\label{strencodings_8h_a7a8fe8e8ebe30d3329bb57478f49ae2cab9ece18c950afbfa6b0fdbfa4ff731d3} 
T&\\
\hline

\end{DoxyEnumFields}
\index{strencodings.h@{strencodings.h}!SafeChars@{SafeChars}}
\index{SafeChars@{SafeChars}!strencodings.h@{strencodings.h}}
\doxysubsubsection{SafeChars}
{\footnotesize\ttfamily \label{strencodings_8h_aecdd292e3acadfcc5ffe4fabe452cfef} 
enum \textbf{ Safe\+Chars}}

Utilities for converting data from/to strings. Used by \doxyref{Sanitize\+String()}{p.}{strencodings_8h_add3fe2ac4df68eac2f565746a4057901} \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{SAFE\_CHARS\_DEFAULT@{SAFE\_CHARS\_DEFAULT}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!SAFE\_CHARS\_DEFAULT@{SAFE\_CHARS\_DEFAULT}}}\label{strencodings_8h_aecdd292e3acadfcc5ffe4fabe452cfefa10a58df6bb2aa23a37d9dfb8b57bcb9e} 
SAFE\+\_\+\+CHARS\+\_\+\+DEFAULT&The full set of allowed chars. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SAFE\_CHARS\_UA\_COMMENT@{SAFE\_CHARS\_UA\_COMMENT}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!SAFE\_CHARS\_UA\_COMMENT@{SAFE\_CHARS\_UA\_COMMENT}}}\label{strencodings_8h_aecdd292e3acadfcc5ffe4fabe452cfefa2a2aa00945928521532f643f93a685b4} 
SAFE\+\_\+\+CHARS\+\_\+\+UA\+\_\+\+COMMENT&BIP-\/0014 subset. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SAFE\_CHARS\_FILENAME@{SAFE\_CHARS\_FILENAME}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!SAFE\_CHARS\_FILENAME@{SAFE\_CHARS\_FILENAME}}}\label{strencodings_8h_aecdd292e3acadfcc5ffe4fabe452cfefaaa5e649980dc5d849fa9977a683f33a3} 
SAFE\+\_\+\+CHARS\+\_\+\+FILENAME&Chars allowed in filenames. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SAFE\_CHARS\_URI@{SAFE\_CHARS\_URI}!strencodings.h@{strencodings.h}}\index{strencodings.h@{strencodings.h}!SAFE\_CHARS\_URI@{SAFE\_CHARS\_URI}}}\label{strencodings_8h_aecdd292e3acadfcc5ffe4fabe452cfefa6e52157fa0f63fa949b8a3d79048b40b} 
SAFE\+\_\+\+CHARS\+\_\+\+URI&Chars allowed in URIs (RFC 3986). \\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{strencodings.h@{strencodings.h}!Capitalize@{Capitalize}}
\index{Capitalize@{Capitalize}!strencodings.h@{strencodings.h}}
\doxysubsubsection{Capitalize()}
{\footnotesize\ttfamily \label{strencodings_8h_a07fea13e4dba45392e84b1205a3fa598} 
std\+::string Capitalize (\begin{DoxyParamCaption}\item[{std\+::string}]{str}{}\end{DoxyParamCaption})}

Capitalizes the first character of the given string. This function is locale independent. It only converts lowercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to capitalize. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string with the first letter capitalized. 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!ConvertBits@{ConvertBits}}
\index{ConvertBits@{ConvertBits}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ConvertBits()}
{\footnotesize\ttfamily \label{strencodings_8h_ad4f1e10357c43d940afc6a44ec9f054a} 
template$<$int frombits, int tobits, bool pad, typename O, typename It, typename I = Int\+Identity$>$ \\
bool Convert\+Bits (\begin{DoxyParamCaption}\item[{O}]{outfn}{, }\item[{It}]{it}{, }\item[{It}]{end}{, }\item[{I}]{infn}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})}

Convert from one power-\/of-\/2 number base to another. \index{strencodings.h@{strencodings.h}!DecodeBase32@{DecodeBase32}}
\index{DecodeBase32@{DecodeBase32}!strencodings.h@{strencodings.h}}
\doxysubsubsection{DecodeBase32()}
{\footnotesize\ttfamily \label{strencodings_8h_a640f09a4ac872c766bdc141c29c1a994} 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ Decode\+Base32 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.h@{strencodings.h}!DecodeBase64@{DecodeBase64}}
\index{DecodeBase64@{DecodeBase64}!strencodings.h@{strencodings.h}}
\doxysubsubsection{DecodeBase64()}
{\footnotesize\ttfamily \label{strencodings_8h_aca3b2791728bc2703381971e5a2d9582} 
std\+::optional$<$ std\+::vector$<$ unsigned char $>$ $>$ Decode\+Base64 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.h@{strencodings.h}!EncodeBase32@{EncodeBase32}}
\index{EncodeBase32@{EncodeBase32}!strencodings.h@{strencodings.h}}
\doxysubsubsection{EncodeBase32()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{strencodings_8h_a5e8b10b37d8fbf5dad596261540121f6} 
std\+::string Encode\+Base32 (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{input}{, }\item[{bool}]{pad}{ = {\ttfamily true}}\end{DoxyParamCaption})}

Base32 encode. If {\ttfamily pad} is true, then the output will be padded with \textquotesingle{}=\textquotesingle{} so that its length is a multiple of 8. \index{strencodings.h@{strencodings.h}!EncodeBase32@{EncodeBase32}}
\index{EncodeBase32@{EncodeBase32}!strencodings.h@{strencodings.h}}
\doxysubsubsection{EncodeBase32()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{strencodings_8h_ae350c861c56c26515d07816a53e2e172} 
std\+::string Encode\+Base32 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{bool}]{pad}{ = {\ttfamily true}}\end{DoxyParamCaption})}

Base32 encode. If {\ttfamily pad} is true, then the output will be padded with \textquotesingle{}=\textquotesingle{} so that its length is a multiple of 8. \index{strencodings.h@{strencodings.h}!EncodeBase64@{EncodeBase64}}
\index{EncodeBase64@{EncodeBase64}!strencodings.h@{strencodings.h}}
\doxysubsubsection{EncodeBase64()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{strencodings_8h_a7afbc36ed8d76a2316f7b621a9ee674d} 
std\+::string Encode\+Base64 (\begin{DoxyParamCaption}\item[{std\+::span$<$ const std\+::byte $>$}]{input}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{strencodings.h@{strencodings.h}!EncodeBase64@{EncodeBase64}}
\index{EncodeBase64@{EncodeBase64}!strencodings.h@{strencodings.h}}
\doxysubsubsection{EncodeBase64()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{strencodings_8h_ad8435069e57a90f332caa363d2b32a1c} 
std\+::string Encode\+Base64 (\begin{DoxyParamCaption}\item[{std\+::span$<$ const unsigned char $>$}]{input}{}\end{DoxyParamCaption})}

\index{strencodings.h@{strencodings.h}!EncodeBase64@{EncodeBase64}}
\index{EncodeBase64@{EncodeBase64}!strencodings.h@{strencodings.h}}
\doxysubsubsection{EncodeBase64()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{strencodings_8h_aaf24932ac8c17e8ca7bad82d6661ed24} 
std\+::string Encode\+Base64 (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{strencodings.h@{strencodings.h}!FormatParagraph@{FormatParagraph}}
\index{FormatParagraph@{FormatParagraph}!strencodings.h@{strencodings.h}}
\doxysubsubsection{FormatParagraph()}
{\footnotesize\ttfamily \label{strencodings_8h_ad953007d0aafb2d9b2a1e4bfc7ad89ad} 
std\+::string Format\+Paragraph (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{in}{, }\item[{size\+\_\+t}]{width}{ = {\ttfamily 79}, }\item[{size\+\_\+t}]{indent}{ = {\ttfamily 0}}\end{DoxyParamCaption})}

\doxyref{Format}{p.}{struct_format} a paragraph of text to a fixed width, adding spaces for indentation to any added line. \index{strencodings.h@{strencodings.h}!IsDigit@{IsDigit}}
\index{IsDigit@{IsDigit}!strencodings.h@{strencodings.h}}
\doxysubsubsection{IsDigit()}
{\footnotesize\ttfamily \label{strencodings_8h_a41d53846b822ba6e6df3e59760de114b} 
bool Is\+Digit (\begin{DoxyParamCaption}\item[{char}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}

Tests if the given character is a decimal digit. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em c} & character to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the argument is a decimal digit; otherwise false. 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!IsHex@{IsHex}}
\index{IsHex@{IsHex}!strencodings.h@{strencodings.h}}
\doxysubsubsection{IsHex()}
{\footnotesize\ttfamily \label{strencodings_8h_ab03ff4257acf4858602d1dc425848a19} 
bool Is\+Hex (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.h@{strencodings.h}!IsSpace@{IsSpace}}
\index{IsSpace@{IsSpace}!strencodings.h@{strencodings.h}}
\doxysubsubsection{IsSpace()}
{\footnotesize\ttfamily \label{strencodings_8h_aa30de1eac29287732050df7168cde03a} 
bool Is\+Space (\begin{DoxyParamCaption}\item[{char}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Tests if the given character is a whitespace character. The whitespace characters are\+: space, form-\/feed (\textquotesingle{}\textbackslash{}f\textquotesingle{}), newline (\textquotesingle{}~\newline
\textquotesingle{}), carriage return (\textquotesingle{}\textbackslash{}r\textquotesingle{}), horizontal tab (\textquotesingle{}\textbackslash{}t\textquotesingle{}), and vertical tab (\textquotesingle{}\textbackslash{}v\textquotesingle{}).

This function is locale independent. Under the C locale this function gives the same result as std\+::isspace.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em c} & character to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the argument is a whitespace character; otherwise false 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!LocaleIndependentAtoi@{LocaleIndependentAtoi}}
\index{LocaleIndependentAtoi@{LocaleIndependentAtoi}!strencodings.h@{strencodings.h}}
\doxysubsubsection{LocaleIndependentAtoi()}
{\footnotesize\ttfamily \label{strencodings_8h_a6aa7d0c9d0ff8c6d9da27ab3fbb83d5a} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ T} Locale\+Independent\+Atoi (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

\index{strencodings.h@{strencodings.h}!ParseByteUnits@{ParseByteUnits}}
\index{ParseByteUnits@{ParseByteUnits}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ParseByteUnits()}
{\footnotesize\ttfamily \label{strencodings_8h_ae89e79da81174d0900ca12cc82d04e04} 
std\+::optional$<$ uint64\+\_\+t $>$ Parse\+Byte\+Units (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{\textbf{ Byte\+Unit}}]{default\+\_\+multiplier}{}\end{DoxyParamCaption})}

Parse a string with suffix unit [k$\vert$\+K$\vert$m$\vert$\+M$\vert$g$\vert$\+G$\vert$t$\vert$T]. Must be a whole integer, fractions not allowed (0.\+5t), no whitespace or +-\/ Lowercase units are 1000 base. Uppercase units are 1024 base. Examples\+: 2m,27M,19g,41T


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to convert into bytes \\
\hline
\mbox{\texttt{in}}  & {\em default\+\_\+multiplier} & if no unit is found in str use this unit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
optional uint64\+\_\+t bytes from str or nullopt if To\+Integral is false, str is empty, trailing whitespace or overflow 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!ParseFixedPoint@{ParseFixedPoint}}
\index{ParseFixedPoint@{ParseFixedPoint}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ParseFixedPoint()}
{\footnotesize\ttfamily \label{strencodings_8h_a9362be43433efde8fa059ba1cef214f0} 
bool Parse\+Fixed\+Point (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{val}{, }\item[{int}]{decimals}{, }\item[{int64\+\_\+t $\ast$}]{amount\+\_\+out}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

Parse number as fixed point according to JSON number syntax. \begin{DoxyReturn}{Returns}
true on success, false on error. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The result must be in the range (-\/10$^\wedge$18,10$^\wedge$18), otherwise an overflow error will trigger. 
\end{DoxyNote}
\index{strencodings.h@{strencodings.h}!ParseHex@{ParseHex}}
\index{ParseHex@{ParseHex}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ParseHex()}
{\footnotesize\ttfamily \label{strencodings_8h_a882aa30dcd768538f02d7e710bf44dc9} 
template$<$typename Byte = uint8\+\_\+t$>$ \\
std\+::vector$<$ Byte $>$ Parse\+Hex (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{hex\+\_\+str}{}\end{DoxyParamCaption})}

Like Try\+Parse\+Hex, but returns an empty vector on invalid input. \index{strencodings.h@{strencodings.h}!SanitizeString@{SanitizeString}}
\index{SanitizeString@{SanitizeString}!strencodings.h@{strencodings.h}}
\doxysubsubsection{SanitizeString()}
{\footnotesize\ttfamily \label{strencodings_8h_add3fe2ac4df68eac2f565746a4057901} 
std\+::string Sanitize\+String (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{int}]{rule}{ = {\ttfamily \textbf{ SAFE\+\_\+\+CHARS\+\_\+\+DEFAULT}}}\end{DoxyParamCaption})}

Remove unsafe chars. Safe chars chosen to allow simple messages/\+URLs/email addresses, but avoid anything even possibly remotely dangerous like \& or $>$ 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & The string to sanitize \\
\hline
\mbox{\texttt{in}}  & {\em rule} & The set of safe chars to choose (default\+: least restrictive) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A new string without unsafe chars 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!SplitHostPort@{SplitHostPort}}
\index{SplitHostPort@{SplitHostPort}!strencodings.h@{strencodings.h}}
\doxysubsubsection{SplitHostPort()}
{\footnotesize\ttfamily \label{strencodings_8h_ad3dd865469a228a338af78c000859b4f} 
bool Split\+Host\+Port (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{in}{, }\item[{uint16\+\_\+t \&}]{port\+Out}{, }\item[{std\+::string \&}]{host\+Out}{}\end{DoxyParamCaption})}

Splits socket address string into host string and port value. Validates port value.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em in} & The socket address string to split. \\
\hline
\mbox{\texttt{out}}  & {\em port\+Out} & Port-\/portion of the input, if found and parsable. \\
\hline
\mbox{\texttt{out}}  & {\em host\+Out} & Host-\/portion of the input, if found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if port-\/portion is absent or within its allowed range, otherwise false 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!TimingResistantEqual@{TimingResistantEqual}}
\index{TimingResistantEqual@{TimingResistantEqual}!strencodings.h@{strencodings.h}}
\doxysubsubsection{TimingResistantEqual()}
{\footnotesize\ttfamily \label{strencodings_8h_a7ddc80f6840eae3277e324aec17c2568} 
template$<$typename \textbf{ T}$>$ \\
bool Timing\+Resistant\+Equal (\begin{DoxyParamCaption}\item[{const \textbf{ T} \&}]{a}{, }\item[{const \textbf{ T} \&}]{b}{}\end{DoxyParamCaption})}

Timing-\/attack-\/resistant comparison. Takes time proportional to length of first argument. \index{strencodings.h@{strencodings.h}!ToIntegral@{ToIntegral}}
\index{ToIntegral@{ToIntegral}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ToIntegral()}
{\footnotesize\ttfamily \label{strencodings_8h_acbe33538863b94521b0092988981198f} 
template$<$typename \textbf{ T}$>$ \\
std\+::optional$<$ \textbf{ T} $>$ To\+Integral (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Convert string to integral type T. Leading whitespace, a leading +, or any trailing character fail the parsing. The required format expressed as regex is {\ttfamily -\/?[0-\/9]+}. The minus sign is only permitted for signed integer types.

\begin{DoxyReturn}{Returns}
std\+::nullopt if the entire string could not be parsed, or if the parsed value is not in the range representable by the type T. 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!ToLower@{ToLower}}
\index{ToLower@{ToLower}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ToLower()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{strencodings_8h_a3556fcd948bc859caaa04f7355a71b16} 
char To\+Lower (\begin{DoxyParamCaption}\item[{char}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}

Converts the given character to its lowercase equivalent. This function is locale independent. It only converts uppercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em c} & the character to convert to lowercase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the lowercase equivalent of c; or the argument if no conversion is possible. 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!ToLower@{ToLower}}
\index{ToLower@{ToLower}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ToLower()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{strencodings_8h_aeb77a2481cc26fe4f5976c908e2378fb} 
std\+::string To\+Lower (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Returns the lowercase equivalent of the given string. This function is locale independent. It only converts uppercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to convert to lowercase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
lowercased equivalent of str 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!ToUpper@{ToUpper}}
\index{ToUpper@{ToUpper}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ToUpper()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{strencodings_8h_a5ab061d81af0af4cc5b84418bc5427b7} 
char To\+Upper (\begin{DoxyParamCaption}\item[{char}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}

Converts the given character to its uppercase equivalent. This function is locale independent. It only converts lowercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em c} & the character to convert to uppercase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the uppercase equivalent of c; or the argument if no conversion is possible. 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!ToUpper@{ToUpper}}
\index{ToUpper@{ToUpper}!strencodings.h@{strencodings.h}}
\doxysubsubsection{ToUpper()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{strencodings_8h_a43a1c84ec663c9f98c8799bfa6eab19f} 
std\+::string To\+Upper (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Returns the uppercase equivalent of the given string. This function is locale independent. It only converts lowercase characters in the standard 7-\/bit ASCII range. This is a feature, not a limitation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em str} & the string to convert to uppercase. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
UPPERCASED EQUIVALENT OF str 
\end{DoxyReturn}
\index{strencodings.h@{strencodings.h}!TryParseHex@{TryParseHex}}
\index{TryParseHex@{TryParseHex}!strencodings.h@{strencodings.h}}
\doxysubsubsection{TryParseHex()}
{\footnotesize\ttfamily \label{strencodings_8h_ae5abef1d5a3c59c300526b14b00003d8} 
template$<$typename Byte = std\+::byte$>$ \\
std\+::optional$<$ std\+::vector$<$ Byte $>$ $>$ Try\+Parse\+Hex (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})}

Parse the hex string into bytes (uint8\+\_\+t or std\+::byte). Ignores whitespace. Returns nullopt on invalid input. 