\doxysection{src/span.h File Reference}
\label{span_8h}\index{src/span.h@{src/span.h}}
{\ttfamily \#include $<$cassert$>$}\newline
{\ttfamily \#include $<$cstddef$>$}\newline
{\ttfamily \#include $<$span$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
\doxysubsubsection*{Concepts}
\begin{DoxyCompactItemize}
\item 
concept \textbf{ Basic\+Byte}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ T} \& \textbf{ Span\+Pop\+Back} (std\+::span$<$ \textbf{ T} $>$ \&span)
\item 
{\footnotesize template$<$typename V$>$ }\\auto \textbf{ Make\+Byte\+Span} (const V \&v) noexcept
\item 
{\footnotesize template$<$typename V$>$ }\\auto \textbf{ Make\+Writable\+Byte\+Span} (V \&\&v) noexcept
\item 
unsigned char $\ast$ \textbf{ UChar\+Cast} (char $\ast$c)
\item 
unsigned char $\ast$ \textbf{ UChar\+Cast} (unsigned char $\ast$c)
\item 
unsigned char $\ast$ \textbf{ UChar\+Cast} (signed char $\ast$c)
\item 
unsigned char $\ast$ \textbf{ UChar\+Cast} (std\+::byte $\ast$c)
\item 
const unsigned char $\ast$ \textbf{ UChar\+Cast} (const char $\ast$c)
\item 
const unsigned char $\ast$ \textbf{ UChar\+Cast} (const unsigned char $\ast$c)
\item 
const unsigned char $\ast$ \textbf{ UChar\+Cast} (const signed char $\ast$c)
\item 
const unsigned char $\ast$ \textbf{ UChar\+Cast} (const std\+::byte $\ast$c)
\item 
{\footnotesize template$<$typename \textbf{ T}, size\+\_\+t N$>$ }\\constexpr auto \textbf{ UChar\+Span\+Cast} (std\+::span$<$ \textbf{ T}, N $>$ s)
\item 
{\footnotesize template$<$typename V$>$ }\\constexpr auto \textbf{ Make\+UChar\+Span} (const V \&v) -\/$>$ decltype(\textbf{ UChar\+Span\+Cast}(std\+::span\{v\}))
\item 
{\footnotesize template$<$typename V$>$ }\\constexpr auto \textbf{ Make\+Writable\+UChar\+Span} (V \&\&v) -\/$>$ decltype(\textbf{ UChar\+Span\+Cast}(std\+::span\{std\+::forward$<$ V $>$(v)\}))
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{span.h@{span.h}!MakeByteSpan@{MakeByteSpan}}
\index{MakeByteSpan@{MakeByteSpan}!span.h@{span.h}}
\doxysubsubsection{MakeByteSpan()}
{\footnotesize\ttfamily \label{span_8h_a2b6abee2f5499e682e38f65b92b3b3c0} 
template$<$typename V$>$ \\
auto Make\+Byte\+Span (\begin{DoxyParamCaption}\item[{const V \&}]{v}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{span.h@{span.h}!MakeUCharSpan@{MakeUCharSpan}}
\index{MakeUCharSpan@{MakeUCharSpan}!span.h@{span.h}}
\doxysubsubsection{MakeUCharSpan()}
{\footnotesize\ttfamily \label{span_8h_a6575ec970cb7f80477e345de6c77129c} 
template$<$typename V$>$ \\
auto Make\+UChar\+Span (\begin{DoxyParamCaption}\item[{const V \&}]{v}{}\end{DoxyParamCaption})-\/$>$decltype(\textbf{ UChar\+Span\+Cast}(std\+::span\{v\}))\hspace{0.3cm}{\ttfamily [constexpr]}}

Like the std\+::span constructor, but for (const) unsigned char member types only. Only works for (un)signed char containers. \index{span.h@{span.h}!MakeWritableByteSpan@{MakeWritableByteSpan}}
\index{MakeWritableByteSpan@{MakeWritableByteSpan}!span.h@{span.h}}
\doxysubsubsection{MakeWritableByteSpan()}
{\footnotesize\ttfamily \label{span_8h_a91fa7e7fa45912295187d06529992ebc} 
template$<$typename V$>$ \\
auto Make\+Writable\+Byte\+Span (\begin{DoxyParamCaption}\item[{V \&\&}]{v}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{span.h@{span.h}!MakeWritableUCharSpan@{MakeWritableUCharSpan}}
\index{MakeWritableUCharSpan@{MakeWritableUCharSpan}!span.h@{span.h}}
\doxysubsubsection{MakeWritableUCharSpan()}
{\footnotesize\ttfamily \label{span_8h_a1d23cf6664031fe76b96428d109faf93} 
template$<$typename V$>$ \\
auto Make\+Writable\+UChar\+Span (\begin{DoxyParamCaption}\item[{V \&\&}]{v}{}\end{DoxyParamCaption})-\/$>$decltype(\textbf{ UChar\+Span\+Cast}(std\+::span\{std\+::forward$<$ V $>$(v)\}))\hspace{0.3cm}{\ttfamily [constexpr]}}

\index{span.h@{span.h}!SpanPopBack@{SpanPopBack}}
\index{SpanPopBack@{SpanPopBack}!span.h@{span.h}}
\doxysubsubsection{SpanPopBack()}
{\footnotesize\ttfamily \label{span_8h_a84b987a6009949297393f7ac0ba5771d} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ T} \& Span\+Pop\+Back (\begin{DoxyParamCaption}\item[{std\+::span$<$ \textbf{ T} $>$ \&}]{span}{}\end{DoxyParamCaption})}

A span is an object that can refer to a contiguous sequence of objects.

Things to be aware of when writing code that deals with spans\+:


\begin{DoxyItemize}
\item Similar to references themselves, spans are subject to reference lifetime issues. The user is responsible for making sure the objects pointed to by a span live as long as the span is used. For example\+: \begin{DoxyVerb}std::vector<int> vec{1,2,3,4};
std::span<int> sp(vec);
vec.push_back(5);
printf("%i\n", sp.front()); // UB!
\end{DoxyVerb}


may exhibit undefined behavior, as increasing the size of a vector may invalidate references.
\item One particular pitfall is that spans can be constructed from temporaries, but this is unsafe when the span is stored in a variable, outliving the temporary. For example, this will compile, but exhibits undefined behavior\+: \begin{DoxyVerb}std::span<const int> sp(std::vector<int>{1, 2, 3});
printf("%i\n", sp.front()); // UB!
\end{DoxyVerb}


The lifetime of the vector ends when the statement it is created in ends. Thus the span is left with a dangling reference, and using it is undefined.
\item Due to spans automatic creation from range-\/like objects (arrays, and data types that expose a data() and size() member function), functions that accept a span as input parameter can be called with any compatible range-\/like object. For example, this works\+: \begin{DoxyVerb}void Foo(std::span<const int> arg);

Foo(std::vector<int>{1, 2, 3}); // Works
\end{DoxyVerb}


This is very useful in cases where a function truly does not care about the container, and only about having exactly a range of elements. However it may also be surprising to see automatic conversions in this case.

When a function accepts a span with a mutable element type, it will not accept temporaries; only variables or other references. For example\+: \begin{DoxyVerb}void FooMut(std::span<int> arg);

FooMut(std::vector<int>{1, 2, 3}); // Does not compile
std::vector<int> baz{1, 2, 3};
FooMut(baz); // Works
\end{DoxyVerb}


This is similar to how functions that take (non-\/const) lvalue references as input cannot accept temporaries. This does not work either\+: \begin{DoxyVerb}void FooVec(std::vector<int>& arg);
FooVec(std::vector<int>{1, 2, 3}); // Does not compile
\end{DoxyVerb}


The idea is that if a function accepts a mutable reference, a meaningful result will be present in that variable after the call. Passing a temporary is useless in that context. Pop the last element off a span, and return a reference to that element. 
\end{DoxyItemize}\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily \label{span_8h_ad150fa0b59e38198809cfce8d0d5d11d} 
unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily \label{span_8h_ab91ff564b6f1ae0f087efe01710a727b} 
const unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{const char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily \label{span_8h_a06cd5329f20772f6ebbadb0e9ab70a76} 
const unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{const signed char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily \label{span_8h_a6b926ea2747af7f09779b5e78a9da113} 
const unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{const std\+::byte $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily \label{span_8h_af1e0184db6ab479fdf3dbf8ef7c70f4c} 
const unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{const unsigned char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily \label{span_8h_ac630686292763b9228fd50b8edf54041} 
unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{signed char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily \label{span_8h_a03a7667a37b37a937bbe1aebc0af0aef} 
unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{std\+::byte $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharCast@{UCharCast}}
\index{UCharCast@{UCharCast}!span.h@{span.h}}
\doxysubsubsection{UCharCast()\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily \label{span_8h_a83d8bdde5cbf74898e65e72c7bd67737} 
unsigned char $\ast$ UChar\+Cast (\begin{DoxyParamCaption}\item[{unsigned char $\ast$}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{span.h@{span.h}!UCharSpanCast@{UCharSpanCast}}
\index{UCharSpanCast@{UCharSpanCast}!span.h@{span.h}}
\doxysubsubsection{UCharSpanCast()}
{\footnotesize\ttfamily \label{span_8h_ac528b62560793fd3032db8188461a3da} 
template$<$typename \textbf{ T}, size\+\_\+t N$>$ \\
auto UChar\+Span\+Cast (\begin{DoxyParamCaption}\item[{std\+::span$<$ \textbf{ T}, N $>$}]{s}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}

