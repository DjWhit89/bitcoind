\doxysection{Block\+Manager Class Reference}
\label{class_block_manager}\index{BlockManager@{BlockManager}}


{\ttfamily \#include $<$blockstorage.\+h$>$}

Inheritance diagram for Block\+Manager\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_block_manager}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Options} = \textbf{ kernel\+::\+Block\+Manager\+Opts}
\item 
using \textbf{ Read\+Raw\+Block\+Result} = \textbf{ util\+::\+Expected}$<$std\+::vector$<$std\+::byte$>$, Read\+Raw\+Error$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Block\+Map} m\+\_\+block\+\_\+index \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+main})
\item 
std\+::unique\+\_\+ptr$<$ \textbf{ Block\+Tree\+DB} $>$ m\+\_\+block\+\_\+tree\+\_\+db \textbf{ GUARDED\+\_\+\+BY} (\textbf{ \+::cs\+\_\+main})
\item 
\textbf{ Block\+Manager} (const \textbf{ util\+::\+Signal\+Interrupt} \&interrupt, \textbf{ Options}\textbf{ Options} opts)
\item 
\textbf{ CBlock\+Index} $\ast$ \textbf{ Insert\+Block\+Index} (const \textbf{ uint256} \&hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
void \textbf{ Prune\+One\+Block\+File} (const int file\+Number) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\begin{DoxyCompactList}\small\item\em Mark one block file as pruned (modify associated database entries). \end{DoxyCompactList}\item 
\textbf{ CBlock\+Index} $\ast$ \textbf{ Lookup\+Block\+Index} (const \textbf{ uint256} \&hash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
const \textbf{ CBlock\+Index} $\ast$ \textbf{ Lookup\+Block\+Index} (const \textbf{ uint256} \&hash) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
\textbf{ CBlock\+File\+Info} $\ast$ \textbf{ Get\+Block\+File\+Info} (size\+\_\+t n)
\item 
void \textbf{ Update\+Block\+Info} (const \textbf{ CBlock} \&block, unsigned int \textbf{ n\+Height}, const \textbf{ Flat\+File\+Pos} \&pos)
\item 
bool \textbf{ Is\+Prune\+Mode} () const
\item 
uint64\+\_\+t \textbf{ Get\+Prune\+Target} () const
\item 
bool \textbf{ Loading\+Blocks} () const
\item 
uint64\+\_\+t \textbf{ Calculate\+Current\+Usage} ()
\item 
\textbf{ fs\+::path} \textbf{ Get\+Block\+Pos\+Filename} (const \textbf{ Flat\+File\+Pos} \&pos) const
\item 
void \textbf{ Unlink\+Pruned\+Files} (const std\+::set$<$ int $>$ \&set\+Files\+To\+Prune) const
\item 
bool \textbf{ Read\+Block} (\textbf{ CBlock} \&block, const \textbf{ Flat\+File\+Pos} \&pos, const std\+::optional$<$ \textbf{ uint256} $>$ \&expected\+\_\+hash) const
\item 
bool \textbf{ Read\+Block} (\textbf{ CBlock} \&block, const \textbf{ CBlock\+Index} \&index) const
\item 
\textbf{ Read\+Raw\+Block\+Result} \textbf{ Read\+Raw\+Block} (const \textbf{ Flat\+File\+Pos} \&pos, std\+::optional$<$ std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$ $>$ block\+\_\+part=std\+::nullopt) const
\item 
bool \textbf{ Read\+Block\+Undo} (\textbf{ CBlock\+Undo} \&blockundo, const \textbf{ CBlock\+Index} \&index) const
\item 
void \textbf{ Cleanup\+Block\+Rev\+Files} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
const \textbf{ util\+::\+Signal\+Interrupt} \& \textbf{ m\+\_\+interrupt}
\item 
std\+::atomic$<$ bool $>$ \textbf{ m\+\_\+importing} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ m\+\_\+blockfiles\+\_\+indexed} \{true\}
\item 
std\+::optional$<$ int $>$ \textbf{ m\+\_\+snapshot\+\_\+height}
\item 
std\+::vector$<$ \textbf{ CBlock\+Index} $\ast$ $>$ Get\+All\+Block\+Indices() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(std\+::multimap$<$ \textbf{ CBlock\+Index} $\ast$, \textbf{ CBlock\+Index} $\ast$ $>$ \textbf{ m\+\_\+blocks\+\_\+unlinked}
\item 
void Write\+Block\+Index\+DB() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(bool Load\+Block\+Index\+DB(const std\+::optional$<$ \textbf{ uint256} $>$ \&snapshot\+\_\+blockhash) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Scan\+And\+Unlink\+Already\+Pruned\+Files() \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ CBlock\+Index} \textbf{ Add\+To\+Block\+Index} )(const \textbf{ CBlock\+Header} \&block, \textbf{ CBlock\+Index} $\ast$\&best\+\_\+header) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+main})
\item 
bool Write\+Block\+Undo(const \textbf{ CBlock\+Undo} \&blockundo, \textbf{ Block\+Validation\+State} \&state, \textbf{ CBlock\+Index} \&block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(Flat\+File\+Po \textbf{ Write\+Block} )(const \textbf{ CBlock} \&block, int \textbf{ n\+Height})
\item 
bool \textbf{ Check\+Block\+Data\+Availability}(const \textbf{ CBlock\+Index} \&upper\+\_\+block, const \textbf{ CBlock\+Index} \&lower\+\_\+block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(const \textbf{ CBlock\+Index} \&Get\+First\+Block(const \textbf{ CBlock\+Index} \&upper\+\_\+block \textbf{ LIFETIMEBOUND}, uint32\+\_\+t status\+\_\+mask, const \textbf{ CBlock\+Index} $\ast$lower\+\_\+block \textbf{ LIFETIMEBOUND}=nullptr) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(boo \textbf{ m\+\_\+have\+\_\+pruned} ) = false
\begin{DoxyCompactList}\small\item\em Returns the earliest block with specified {\ttfamily status\+\_\+mask} flags set after the latest block {\itshape not} having those flags. \end{DoxyCompactList}\item 
bool Is\+Block\+Pruned(const \textbf{ CBlock\+Index} \&block) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(void Update\+Prune\+Lock(const std\+::string \&\textbf{ name}, const Prune\+Lock\+Info \&lock\+\_\+info) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(Auto\+Fil \textbf{ Open\+Block\+File} )(const \textbf{ Flat\+File\+Pos} \&pos, bool f\+Read\+Only) const
\begin{DoxyCompactList}\small\item\em Check whether the block associated with this index entry is pruned or not. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static constexpr auto \textbf{ PRUNE\+\_\+\+TARGET\+\_\+\+MANUAL} \{std\+::numeric\+\_\+limits$<$uint64\+\_\+t$>$\+::max()\}
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \textbf{ CBlock\+File\+Info} $>$ \textbf{ m\+\_\+blockfile\+\_\+info}
\item 
std\+::set$<$ \textbf{ CBlock\+Index} $\ast$ $>$ \textbf{ m\+\_\+dirty\+\_\+blockindex}
\item 
std\+::set$<$ int $>$ \textbf{ m\+\_\+dirty\+\_\+fileinfo}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Maintains a tree of blocks (stored in {\ttfamily m\+\_\+block\+\_\+index}) which is consulted to determine where the most-\/work tip is.

This data is used mostly in {\ttfamily \doxyref{Chainstate}{p.}{class_chainstate}} -\/ information about, e.\+g., candidate tips is not maintained here. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{BlockManager@{BlockManager}!Options@{Options}}
\index{Options@{Options}!BlockManager@{BlockManager}}
\doxysubsubsection{Options}
{\footnotesize\ttfamily \label{class_block_manager_a9d388cded97cd9f86c06358bb29abfad} 
using \textbf{ Options}\textbf{ Options} = \textbf{ kernel\+::\+Block\+Manager\+Opts}}

\index{BlockManager@{BlockManager}!ReadRawBlockResult@{ReadRawBlockResult}}
\index{ReadRawBlockResult@{ReadRawBlockResult}!BlockManager@{BlockManager}}
\doxysubsubsection{ReadRawBlockResult}
{\footnotesize\ttfamily \label{class_block_manager_ae44324a3c3aae8cdb9bdecd43260b98f} 
using \textbf{ Read\+Raw\+Block\+Result} = \textbf{ util\+::\+Expected}$<$std\+::vector$<$std\+::byte$>$, Read\+Raw\+Error$>$}



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{BlockManager@{BlockManager}!BlockManager@{BlockManager}}
\index{BlockManager@{BlockManager}!BlockManager@{BlockManager}}
\doxysubsubsection{BlockManager()}
{\footnotesize\ttfamily \label{class_block_manager_a5a7ab0002709da74f13f76921377c42c} 
\textbf{ Block\+Manager} (\begin{DoxyParamCaption}\item[{const \textbf{ util\+::\+Signal\+Interrupt} \&}]{interrupt}{, }\item[{\textbf{ Options}\textbf{ Options}}]{opts}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{BlockManager@{BlockManager}!CalculateCurrentUsage@{CalculateCurrentUsage}}
\index{CalculateCurrentUsage@{CalculateCurrentUsage}!BlockManager@{BlockManager}}
\doxysubsubsection{CalculateCurrentUsage()}
{\footnotesize\ttfamily \label{class_block_manager_a5d513fc954905589bc2a99da7d51e923} 
uint64\+\_\+t Calculate\+Current\+Usage (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Calculate the amount of disk space the block \& undo files currently use \index{BlockManager@{BlockManager}!CleanupBlockRevFiles@{CleanupBlockRevFiles}}
\index{CleanupBlockRevFiles@{CleanupBlockRevFiles}!BlockManager@{BlockManager}}
\doxysubsubsection{CleanupBlockRevFiles()}
{\footnotesize\ttfamily \label{class_block_manager_aabaa6172d403bb91657add7f42f3b371} 
void Cleanup\+Block\+Rev\+Files (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{BlockManager@{BlockManager}!GetBlockFileInfo@{GetBlockFileInfo}}
\index{GetBlockFileInfo@{GetBlockFileInfo}!BlockManager@{BlockManager}}
\doxysubsubsection{GetBlockFileInfo()}
{\footnotesize\ttfamily \label{class_block_manager_a524e9acdceb9fae201dbe36bd66c80e7} 
\textbf{ CBlock\+File\+Info} $\ast$ Get\+Block\+File\+Info (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n}{}\end{DoxyParamCaption})}

Get block file info entry for one block file \index{BlockManager@{BlockManager}!GetBlockPosFilename@{GetBlockPosFilename}}
\index{GetBlockPosFilename@{GetBlockPosFilename}!BlockManager@{BlockManager}}
\doxysubsubsection{GetBlockPosFilename()}
{\footnotesize\ttfamily \label{class_block_manager_a375f39dd7a25d0087c57ee6704eb7953} 
\textbf{ fs\+::path} Get\+Block\+Pos\+Filename (\begin{DoxyParamCaption}\item[{const \textbf{ Flat\+File\+Pos} \&}]{pos}{}\end{DoxyParamCaption}) const}

Translation to a filesystem path \index{BlockManager@{BlockManager}!GetPruneTarget@{GetPruneTarget}}
\index{GetPruneTarget@{GetPruneTarget}!BlockManager@{BlockManager}}
\doxysubsubsection{GetPruneTarget()}
{\footnotesize\ttfamily \label{class_block_manager_a95455271ec88dfcc93e411237b36a57c} 
uint64\+\_\+t Get\+Prune\+Target (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

Attempt to stay below this number of bytes of block files. \index{BlockManager@{BlockManager}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!BlockManager@{BlockManager}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_block_manager_ad06570b26658d12ac3ad08750e3b8f7c} 
std\+::unique\+\_\+ptr$<$ \textbf{ Block\+Tree\+DB} $>$ m\+\_\+block\+\_\+tree\+\_\+db GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ \+::cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

\index{BlockManager@{BlockManager}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!BlockManager@{BlockManager}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_block_manager_a3b953f400cc4e659ab9651c3dea79da5} 
\textbf{ Block\+Map} m\+\_\+block\+\_\+index GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+main}}]{}{}\end{DoxyParamCaption})}

\index{BlockManager@{BlockManager}!InsertBlockIndex@{InsertBlockIndex}}
\index{InsertBlockIndex@{InsertBlockIndex}!BlockManager@{BlockManager}}
\doxysubsubsection{InsertBlockIndex()}
{\footnotesize\ttfamily \label{class_block_manager_aa95eeae5f69857893eacc49700873255} 
\textbf{ CBlock\+Index} $\ast$ Insert\+Block\+Index (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{}\end{DoxyParamCaption})}

Create a new block index entry for a given block hash \index{BlockManager@{BlockManager}!IsPruneMode@{IsPruneMode}}
\index{IsPruneMode@{IsPruneMode}!BlockManager@{BlockManager}}
\doxysubsubsection{IsPruneMode()}
{\footnotesize\ttfamily \label{class_block_manager_ad03fd92fad95bb7f82ef78cc467cb12b} 
bool Is\+Prune\+Mode (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

Whether running in -\/prune mode. \index{BlockManager@{BlockManager}!LoadingBlocks@{LoadingBlocks}}
\index{LoadingBlocks@{LoadingBlocks}!BlockManager@{BlockManager}}
\doxysubsubsection{LoadingBlocks()}
{\footnotesize\ttfamily \label{class_block_manager_acef48b2a0b8aa252efa69928192b4d5a} 
bool Loading\+Blocks (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{BlockManager@{BlockManager}!LookupBlockIndex@{LookupBlockIndex}}
\index{LookupBlockIndex@{LookupBlockIndex}!BlockManager@{BlockManager}}
\doxysubsubsection{LookupBlockIndex()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_block_manager_afc9665be19b586880b275f0ccf17c8bb} 
const \textbf{ CBlock\+Index} $\ast$ Lookup\+Block\+Index (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{}\end{DoxyParamCaption}) const}

\index{BlockManager@{BlockManager}!LookupBlockIndex@{LookupBlockIndex}}
\index{LookupBlockIndex@{LookupBlockIndex}!BlockManager@{BlockManager}}
\doxysubsubsection{LookupBlockIndex()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_block_manager_a87eab19fb1a7e025715c13377ebfd356} 
\textbf{ CBlock\+Index} $\ast$ Lookup\+Block\+Index (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{}\end{DoxyParamCaption})}

\index{BlockManager@{BlockManager}!PruneOneBlockFile@{PruneOneBlockFile}}
\index{PruneOneBlockFile@{PruneOneBlockFile}!BlockManager@{BlockManager}}
\doxysubsubsection{PruneOneBlockFile()}
{\footnotesize\ttfamily \label{class_block_manager_a6ebc263091ba81ceaa3ec37d1000bf9b} 
void Prune\+One\+Block\+File (\begin{DoxyParamCaption}\item[{const int}]{file\+Number}{}\end{DoxyParamCaption})}



Mark one block file as pruned (modify associated database entries). 

\index{BlockManager@{BlockManager}!ReadBlock@{ReadBlock}}
\index{ReadBlock@{ReadBlock}!BlockManager@{BlockManager}}
\doxysubsubsection{ReadBlock()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_block_manager_a5637a4074380a9138c49742f8d0f39b8} 
bool Read\+Block (\begin{DoxyParamCaption}\item[{\textbf{ CBlock} \&}]{block}{, }\item[{const \textbf{ CBlock\+Index} \&}]{index}{}\end{DoxyParamCaption}) const}

\index{BlockManager@{BlockManager}!ReadBlock@{ReadBlock}}
\index{ReadBlock@{ReadBlock}!BlockManager@{BlockManager}}
\doxysubsubsection{ReadBlock()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_block_manager_ad59bbdccdaca9da495b6b6e80c481a1a} 
bool Read\+Block (\begin{DoxyParamCaption}\item[{\textbf{ CBlock} \&}]{block}{, }\item[{const \textbf{ Flat\+File\+Pos} \&}]{pos}{, }\item[{const std\+::optional$<$ \textbf{ uint256} $>$ \&}]{expected\+\_\+hash}{}\end{DoxyParamCaption}) const}

Functions for disk access for blocks \index{BlockManager@{BlockManager}!ReadBlockUndo@{ReadBlockUndo}}
\index{ReadBlockUndo@{ReadBlockUndo}!BlockManager@{BlockManager}}
\doxysubsubsection{ReadBlockUndo()}
{\footnotesize\ttfamily \label{class_block_manager_a054cbf50f4e5cb582fd744927f9ace7a} 
bool Read\+Block\+Undo (\begin{DoxyParamCaption}\item[{\textbf{ CBlock\+Undo} \&}]{blockundo}{, }\item[{const \textbf{ CBlock\+Index} \&}]{index}{}\end{DoxyParamCaption}) const}

\index{BlockManager@{BlockManager}!ReadRawBlock@{ReadRawBlock}}
\index{ReadRawBlock@{ReadRawBlock}!BlockManager@{BlockManager}}
\doxysubsubsection{ReadRawBlock()}
{\footnotesize\ttfamily \label{class_block_manager_a0bfb8d6c21eed2929e6a388578ceae4d} 
\textbf{ Block\+Manager\+::\+Read\+Raw\+Block\+Result} Read\+Raw\+Block (\begin{DoxyParamCaption}\item[{const \textbf{ Flat\+File\+Pos} \&}]{pos}{, }\item[{std\+::optional$<$ std\+::pair$<$ size\+\_\+t, size\+\_\+t $>$ $>$}]{block\+\_\+part}{ = {\ttfamily std\+:\+:nullopt}}\end{DoxyParamCaption}) const}

\index{BlockManager@{BlockManager}!UnlinkPrunedFiles@{UnlinkPrunedFiles}}
\index{UnlinkPrunedFiles@{UnlinkPrunedFiles}!BlockManager@{BlockManager}}
\doxysubsubsection{UnlinkPrunedFiles()}
{\footnotesize\ttfamily \label{class_block_manager_a0592de206bb3aa3070fb685e6c0b8923} 
void Unlink\+Pruned\+Files (\begin{DoxyParamCaption}\item[{const std\+::set$<$ int $>$ \&}]{set\+Files\+To\+Prune}{}\end{DoxyParamCaption}) const}

Actually unlink the specified files \index{BlockManager@{BlockManager}!UpdateBlockInfo@{UpdateBlockInfo}}
\index{UpdateBlockInfo@{UpdateBlockInfo}!BlockManager@{BlockManager}}
\doxysubsubsection{UpdateBlockInfo()}
{\footnotesize\ttfamily \label{class_block_manager_ac998253c8454e8f69d78c62fba7a5253} 
void Update\+Block\+Info (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock} \&}]{block}{, }\item[{unsigned int}]{n\+Height}{, }\item[{const \textbf{ Flat\+File\+Pos} \&}]{pos}{}\end{DoxyParamCaption})}

Update blockfile info while processing a block during reindex. The block must be available on disk.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em block} & the block being processed \\
\hline
\mbox{\texttt{in}}  & {\em n\+Height} & the height of the block \\
\hline
\mbox{\texttt{in}}  & {\em pos} & the position of the serialized \doxyref{CBlock}{p.}{class_c_block} on disk \\
\hline
\end{DoxyParams}


\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{BlockManager@{BlockManager}!AddToBlockIndex@{AddToBlockIndex}}
\index{AddToBlockIndex@{AddToBlockIndex}!BlockManager@{BlockManager}}
\doxysubsubsection{AddToBlockIndex}
{\footnotesize\ttfamily \label{class_block_manager_aa23f0a6c8540ce84e6526e2a7fe6aeec} 
\textbf{ CBlock\+Index} $\ast$ Add\+To\+Block\+Index}

Remove any pruned block \& undo files that are still on disk. This could happen on some systems if the file was still being read while unlinked, or if we crash before unlinking. \index{BlockManager@{BlockManager}!m\_blockfile\_info@{m\_blockfile\_info}}
\index{m\_blockfile\_info@{m\_blockfile\_info}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_blockfile\_info}
{\footnotesize\ttfamily \label{class_block_manager_afb9d51fced31a067a652b9b2f419de53} 
std\+::vector$<$\textbf{ CBlock\+File\+Info}$>$ m\+\_\+blockfile\+\_\+info\hspace{0.3cm}{\ttfamily [protected]}}

\index{BlockManager@{BlockManager}!m\_blockfiles\_indexed@{m\_blockfiles\_indexed}}
\index{m\_blockfiles\_indexed@{m\_blockfiles\_indexed}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_blockfiles\_indexed}
{\footnotesize\ttfamily \label{class_block_manager_a5627151c890af8526b512ff75f09eba1} 
std\+::atomic\+\_\+bool m\+\_\+blockfiles\+\_\+indexed \{true\}}

Whether all blockfiles have been added to the block tree database. Normally true, but set to false when a reindex is requested and the database is wiped. The value is persisted in the database across restarts and will be false until reindexing completes. \index{BlockManager@{BlockManager}!m\_blocks\_unlinked@{m\_blocks\_unlinked}}
\index{m\_blocks\_unlinked@{m\_blocks\_unlinked}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_blocks\_unlinked}
{\footnotesize\ttfamily \label{class_block_manager_a1a2028bdb52a8d052b7ccc0fae0888be} 
std\+::vector$<$\textbf{ CBlock\+Index}$\ast$$>$ Get\+All\+Block\+Indices () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( std\+::multimap$<$\textbf{ CBlock\+Index}$\ast$, \textbf{ CBlock\+Index}$\ast$$>$ m\+\_\+blocks\+\_\+unlinked}

All pairs A-\/$>$B, where A (or one of its ancestors) misses transactions, but B has transactions. Pruned nodes may have entries where B is missing data. \index{BlockManager@{BlockManager}!m\_dirty\_blockindex@{m\_dirty\_blockindex}}
\index{m\_dirty\_blockindex@{m\_dirty\_blockindex}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_dirty\_blockindex}
{\footnotesize\ttfamily \label{class_block_manager_a19dc9f19ce6715ed2227bdb3eabfa468} 
std\+::set$<$\textbf{ CBlock\+Index}$\ast$$>$ m\+\_\+dirty\+\_\+blockindex\hspace{0.3cm}{\ttfamily [protected]}}

Dirty block index entries. \index{BlockManager@{BlockManager}!m\_dirty\_fileinfo@{m\_dirty\_fileinfo}}
\index{m\_dirty\_fileinfo@{m\_dirty\_fileinfo}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_dirty\_fileinfo}
{\footnotesize\ttfamily \label{class_block_manager_a741acf23cdde1715d7589530c0bf2758} 
std\+::set$<$int$>$ m\+\_\+dirty\+\_\+fileinfo\hspace{0.3cm}{\ttfamily [protected]}}

Dirty block file entries. \index{BlockManager@{BlockManager}!m\_have\_pruned@{m\_have\_pruned}}
\index{m\_have\_pruned@{m\_have\_pruned}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_have\_pruned}
{\footnotesize\ttfamily \label{class_block_manager_abd422059799bb41da624c4b8c4878381} 
bool \textbf{ Check\+Block\+Data\+Availability} (const \textbf{ CBlock\+Index}\& upper\+\_\+block, const \textbf{ CBlock\+Index}\& lower\+\_\+block) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( const \textbf{ CBlock\+Index}\& Get\+First\+Block ( const \textbf{ CBlock\+Index}\& upper\+\_\+block \textbf{ LIFETIMEBOUND}, uint32\+\_\+t status\+\_\+mask, const \textbf{ CBlock\+Index}$\ast$ lower\+\_\+block \textbf{ LIFETIMEBOUND} = nullptr ) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}( boo m\+\_\+have\+\_\+pruned)  = false}



Returns the earliest block with specified {\ttfamily status\+\_\+mask} flags set after the latest block {\itshape not} having those flags. 

Check if all blocks in the [upper\+\_\+block, lower\+\_\+block] range have data available. The caller is responsible for ensuring that lower\+\_\+block is an ancestor of upper\+\_\+block (part of the same chain). 

This function starts from {\ttfamily upper\+\_\+block}, which must have all {\ttfamily status\+\_\+mask} flags set, and iterates backwards through its ancestors. It continues as long as each block has all {\ttfamily status\+\_\+mask} flags set, until reaching the oldest ancestor or {\ttfamily lower\+\_\+block}.

\begin{DoxyPrecond}{Precondition}
{\ttfamily upper\+\_\+block} must have all {\ttfamily status\+\_\+mask} flags set. 

{\ttfamily lower\+\_\+block} must be null or an ancestor of {\ttfamily upper\+\_\+block}
\end{DoxyPrecond}

\begin{DoxyParams}{Parameters}
{\em upper\+\_\+block} & The starting block for the search, which must have all {\ttfamily status\+\_\+mask} flags set. \\
\hline
{\em status\+\_\+mask} & Bitmask specifying required status flags. \\
\hline
{\em lower\+\_\+block} & The earliest possible block to return. If null, the search can extend to the genesis block.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A reference to the earliest block between {\ttfamily upper\+\_\+block} and {\ttfamily lower\+\_\+block}, inclusive, such that every block between the returned block and {\ttfamily upper\+\_\+block} has {\ttfamily status\+\_\+mask} flags set. True if any block files have ever been pruned. 
\end{DoxyReturn}
\index{BlockManager@{BlockManager}!m\_importing@{m\_importing}}
\index{m\_importing@{m\_importing}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_importing}
{\footnotesize\ttfamily \label{class_block_manager_a394b5b401d4fcd3c693dea7d6314ec7d} 
std\+::atomic$<$bool$>$ m\+\_\+importing \{false\}}

\index{BlockManager@{BlockManager}!m\_interrupt@{m\_interrupt}}
\index{m\_interrupt@{m\_interrupt}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_interrupt}
{\footnotesize\ttfamily \label{class_block_manager_a2163d8ef789c585b196a3ec7f468244b} 
const \textbf{ util\+::\+Signal\+Interrupt}\& m\+\_\+interrupt}

\index{BlockManager@{BlockManager}!m\_snapshot\_height@{m\_snapshot\_height}}
\index{m\_snapshot\_height@{m\_snapshot\_height}!BlockManager@{BlockManager}}
\doxysubsubsection{m\_snapshot\_height}
{\footnotesize\ttfamily \label{class_block_manager_a4768bb381991af0538ef921446f5ae92} 
std\+::optional$<$int$>$ m\+\_\+snapshot\+\_\+height}

The height of the base block of an assumeutxo snapshot, if one is in use.

This controls how blockfiles are segmented by chainstate type to avoid comingling different height regions of the chain when an assumedvalid chainstate is in use. If heights are drastically different in the same blockfile, pruning suffers.

This is set during Activate\+Snapshot() or upon Load\+Block\+Index() if a snapshot had been previously loaded. After the snapshot is validated, this is unset to restore normal Load\+Block\+Index behavior. \index{BlockManager@{BlockManager}!OpenBlockFile@{OpenBlockFile}}
\index{OpenBlockFile@{OpenBlockFile}!BlockManager@{BlockManager}}
\doxysubsubsection{OpenBlockFile}
{\footnotesize\ttfamily \label{class_block_manager_af94e2a1297df45c04d2802ab5b5813b2} 
\textbf{ Auto\+File} Open\+Block\+File}



Check whether the block associated with this index entry is pruned or not. 

Create or update a prune lock identified by its name Open a block file (blk?????.dat) \index{BlockManager@{BlockManager}!PRUNE\_TARGET\_MANUAL@{PRUNE\_TARGET\_MANUAL}}
\index{PRUNE\_TARGET\_MANUAL@{PRUNE\_TARGET\_MANUAL}!BlockManager@{BlockManager}}
\doxysubsubsection{PRUNE\_TARGET\_MANUAL}
{\footnotesize\ttfamily \label{class_block_manager_ad763c65be9451609b0f3d7ecd7bd4e3c} 
auto PRUNE\+\_\+\+TARGET\+\_\+\+MANUAL \{std\+::numeric\+\_\+limits$<$uint64\+\_\+t$>$\+::max()\}\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

\index{BlockManager@{BlockManager}!WriteBlock@{WriteBlock}}
\index{WriteBlock@{WriteBlock}!BlockManager@{BlockManager}}
\doxysubsubsection{WriteBlock}
{\footnotesize\ttfamily \label{class_block_manager_ae70b06aaf862d5ee0b31de6bab121136} 
\textbf{ Flat\+File\+Pos} Write\+Block}

Store block on disk and update block file statistics.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em block} & the block to be stored \\
\hline
\mbox{\texttt{in}}  & {\em n\+Height} & the height of the block\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
in case of success, the position to which the block was written to in case of an error, an empty \doxyref{Flat\+File\+Pos}{p.}{struct_flat_file_pos} 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/node/\textbf{ blockstorage.\+h}\item 
src/node/\textbf{ blockstorage.\+cpp}\end{DoxyCompactItemize}
