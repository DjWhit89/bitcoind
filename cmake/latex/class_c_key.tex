\doxysection{CKey Class Reference}
\label{class_c_key}\index{CKey@{CKey}}


{\ttfamily \#include $<$key.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CKey} () noexcept=default
\item 
\textbf{ CKey} (\textbf{ CKey} \&\&) noexcept=default
\item 
\textbf{ CKey} \& \textbf{ operator=} (\textbf{ CKey} \&\&) noexcept=default
\item 
\textbf{ CKey} \& \textbf{ operator=} (const \textbf{ CKey} \&other)
\item 
\textbf{ CKey} (const \textbf{ CKey} \&other)
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\void \textbf{ Set} (const \textbf{ T} pbegin, const \textbf{ T} pend, bool f\+Compressed\+In)
\begin{DoxyCompactList}\small\item\em Initialize using begin and end iterators to byte data. \end{DoxyCompactList}\item 
unsigned int \textbf{ size} () const
\begin{DoxyCompactList}\small\item\em Simple read-\/only vector-\/like interface. \end{DoxyCompactList}\item 
const std\+::byte $\ast$ \textbf{ data} () const
\item 
const std\+::byte $\ast$ \textbf{ begin} () const
\item 
const std\+::byte $\ast$ \textbf{ end} () const
\item 
bool \textbf{ Is\+Valid} () const
\begin{DoxyCompactList}\small\item\em Check whether this private key is valid. \end{DoxyCompactList}\item 
bool \textbf{ Is\+Compressed} () const
\begin{DoxyCompactList}\small\item\em Check whether the public key corresponding to this private key is (to be) compressed. \end{DoxyCompactList}\item 
void \textbf{ Make\+New\+Key} (bool f\+Compressed)
\begin{DoxyCompactList}\small\item\em Generate a new private key using a cryptographic PRNG. \end{DoxyCompactList}\item 
\textbf{ CPriv\+Key} \textbf{ Get\+Priv\+Key} () const
\item 
\textbf{ CPub\+Key} \textbf{ Get\+Pub\+Key} () const
\item 
bool \textbf{ Sign} (const \textbf{ uint256} \&hash, std\+::vector$<$ unsigned char $>$ \&vch\+Sig, bool grind=true, uint32\+\_\+t test\+\_\+case=0) const
\item 
bool \textbf{ Sign\+Compact} (const \textbf{ uint256} \&hash, std\+::vector$<$ unsigned char $>$ \&vch\+Sig) const
\item 
bool \textbf{ Sign\+Schnorr} (const \textbf{ uint256} \&hash, std\+::span$<$ unsigned char $>$ sig, const \textbf{ uint256} $\ast$merkle\+\_\+root, const \textbf{ uint256} \&aux) const
\item 
bool \textbf{ Derive} (\textbf{ CKey} \&key\+Child, \textbf{ Chain\+Code} \&cc\+Child, unsigned int n\+Child, const \textbf{ Chain\+Code} \&cc) const
\begin{DoxyCompactList}\small\item\em Derive BIP32 child key. \end{DoxyCompactList}\item 
bool \textbf{ Verify\+Pub\+Key} (const \textbf{ CPub\+Key} \&vch\+Pub\+Key) const
\item 
bool \textbf{ Load} (const \textbf{ CPriv\+Key} \&privkey, const \textbf{ CPub\+Key} \&vch\+Pub\+Key, bool f\+Skip\+Check)
\begin{DoxyCompactList}\small\item\em Load private key and check that public key matches. \end{DoxyCompactList}\item 
\textbf{ Ell\+Swift\+Pub\+Key} \textbf{ Ell\+Swift\+Create} (std\+::span$<$ const std\+::byte $>$ entropy) const
\item 
\textbf{ ECDHSecret} \textbf{ Compute\+BIP324\+ECDHSecret} (const \textbf{ Ell\+Swift\+Pub\+Key} \&their\+\_\+ellswift, const \textbf{ Ell\+Swift\+Pub\+Key} \&our\+\_\+ellswift, bool initiating) const
\item 
\textbf{ Key\+Pair} \textbf{ Compute\+Key\+Pair} (const \textbf{ uint256} $\ast$merkle\+\_\+root) const
\item 
std\+::vector$<$ uint8\+\_\+t $>$ \textbf{ Create\+Mu\+Sig2\+Nonce} (\textbf{ Mu\+Sig2\+Sec\+Nonce} \&secnonce, const \textbf{ uint256} \&sighash, const \textbf{ CPub\+Key} \&aggregate\+\_\+pubkey, const std\+::vector$<$ \textbf{ CPub\+Key} $>$ \&pubkeys)
\item 
std\+::optional$<$ \textbf{ uint256} $>$ \textbf{ Create\+Mu\+Sig2\+Partial\+Sig} (const \textbf{ uint256} \&hash, const \textbf{ CPub\+Key} \&aggregate\+\_\+pubkey, const std\+::vector$<$ \textbf{ CPub\+Key} $>$ \&pubkeys, const std\+::map$<$ \textbf{ CPub\+Key}, std\+::vector$<$ uint8\+\_\+t $>$ $>$ \&pubnonces, \textbf{ Mu\+Sig2\+Sec\+Nonce} \&secnonce, const std\+::vector$<$ std\+::pair$<$ \textbf{ uint256}, bool $>$ $>$ \&tweaks)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const unsigned int \textbf{ SIZE} = 279
\item 
static const unsigned int \textbf{ COMPRESSED\+\_\+\+SIZE} = 214
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
bool \textbf{ operator==} (const \textbf{ CKey} \&a, const \textbf{ CKey} \&b)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
An encapsulated private key. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CKey@{CKey}!CKey@{CKey}}
\index{CKey@{CKey}!CKey@{CKey}}
\doxysubsubsection{CKey()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{class_c_key_af074861bb4a23894e21a9874bd5bcfa5} 
\textbf{ CKey} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{CKey@{CKey}!CKey@{CKey}}
\index{CKey@{CKey}!CKey@{CKey}}
\doxysubsubsection{CKey()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{class_c_key_a720f3d637b1c8782714947794ed975ab} 
\textbf{ CKey} (\begin{DoxyParamCaption}\item[{\textbf{ CKey} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{CKey@{CKey}!CKey@{CKey}}
\index{CKey@{CKey}!CKey@{CKey}}
\doxysubsubsection{CKey()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{class_c_key_a2d40d2499c7ced8b152e1142d44b61d9} 
\textbf{ CKey} (\begin{DoxyParamCaption}\item[{const \textbf{ CKey} \&}]{other}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CKey@{CKey}!begin@{begin}}
\index{begin@{begin}!CKey@{CKey}}
\doxysubsubsection{begin()}
{\footnotesize\ttfamily \label{class_c_key_a3f0e783949c4bbf1122b67f8b3e0c6b8} 
const std\+::byte $\ast$ begin (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CKey@{CKey}!ComputeBIP324ECDHSecret@{ComputeBIP324ECDHSecret}}
\index{ComputeBIP324ECDHSecret@{ComputeBIP324ECDHSecret}!CKey@{CKey}}
\doxysubsubsection{ComputeBIP324ECDHSecret()}
{\footnotesize\ttfamily \label{class_c_key_a51daf36829a33c58aece705cb2f79cd8} 
\textbf{ ECDHSecret} Compute\+BIP324\+ECDHSecret (\begin{DoxyParamCaption}\item[{const \textbf{ Ell\+Swift\+Pub\+Key} \&}]{their\+\_\+ellswift}{, }\item[{const \textbf{ Ell\+Swift\+Pub\+Key} \&}]{our\+\_\+ellswift}{, }\item[{bool}]{initiating}{}\end{DoxyParamCaption}) const}

Compute a BIP324-\/style ECDH shared secret.


\begin{DoxyItemize}
\item their\+\_\+ellswift\+: \doxyref{Ell\+Swift\+Pub\+Key}{p.}{struct_ell_swift_pub_key} that was received from the other side.
\item our\+\_\+ellswift\+: \doxyref{Ell\+Swift\+Pub\+Key}{p.}{struct_ell_swift_pub_key} that was sent to the other side (must have been generated from $\ast$this using \doxyref{Ell\+Swift\+Create()}{p.}{class_c_key_aaa51951a1ed98ba1e5b575f70c17a0e6}).
\item initiating\+: whether we are the initiating party (true) or responding party (false). 
\end{DoxyItemize}\index{CKey@{CKey}!ComputeKeyPair@{ComputeKeyPair}}
\index{ComputeKeyPair@{ComputeKeyPair}!CKey@{CKey}}
\doxysubsubsection{ComputeKeyPair()}
{\footnotesize\ttfamily \label{class_c_key_a1989d2094d3ab2510b9f839a1ab05b34} 
\textbf{ Key\+Pair} Compute\+Key\+Pair (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} $\ast$}]{merkle\+\_\+root}{}\end{DoxyParamCaption}) const}

Compute a \doxyref{Key\+Pair}{p.}{class_key_pair}

Wraps a {\ttfamily \doxyref{secp256k1\+\_\+keypair}{p.}{structsecp256k1__keypair}} type.

{\ttfamily merkle\+\_\+root} is used to optionally perform tweaking of the internal key, as specified in BIP341\+:


\begin{DoxyItemize}
\item If merkle\+\_\+root == nullptr\+: no tweaking is done, use the internal key directly (this is used for signatures in BIP342 script).
\item If merkle\+\_\+root-\/$>$Is\+Null()\+: tweak the internal key with H\+\_\+\+Tap\+Tweak(pubkey) (this is used for key path spending when no scripts are present).
\item Otherwise\+: tweak the internal key with H\+\_\+\+Tap\+Tweak(pubkey $\vert$$\vert$ $\ast$merkle\+\_\+root) (this is used for key path spending with the Merkle root of the script tree). 
\end{DoxyItemize}\index{CKey@{CKey}!CreateMuSig2Nonce@{CreateMuSig2Nonce}}
\index{CreateMuSig2Nonce@{CreateMuSig2Nonce}!CKey@{CKey}}
\doxysubsubsection{CreateMuSig2Nonce()}
{\footnotesize\ttfamily \label{class_c_key_a9f8effa6c90983899312668a2268c99f} 
std\+::vector$<$ uint8\+\_\+t $>$ Create\+Mu\+Sig2\+Nonce (\begin{DoxyParamCaption}\item[{\textbf{ Mu\+Sig2\+Sec\+Nonce} \&}]{secnonce}{, }\item[{const \textbf{ uint256} \&}]{sighash}{, }\item[{const \textbf{ CPub\+Key} \&}]{aggregate\+\_\+pubkey}{, }\item[{const std\+::vector$<$ \textbf{ CPub\+Key} $>$ \&}]{pubkeys}{}\end{DoxyParamCaption})}

\index{CKey@{CKey}!CreateMuSig2PartialSig@{CreateMuSig2PartialSig}}
\index{CreateMuSig2PartialSig@{CreateMuSig2PartialSig}!CKey@{CKey}}
\doxysubsubsection{CreateMuSig2PartialSig()}
{\footnotesize\ttfamily \label{class_c_key_a88514aca46316a04e95dfce4ec209d68} 
std\+::optional$<$ \textbf{ uint256} $>$ Create\+Mu\+Sig2\+Partial\+Sig (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{, }\item[{const \textbf{ CPub\+Key} \&}]{aggregate\+\_\+pubkey}{, }\item[{const std\+::vector$<$ \textbf{ CPub\+Key} $>$ \&}]{pubkeys}{, }\item[{const std\+::map$<$ \textbf{ CPub\+Key}, std\+::vector$<$ uint8\+\_\+t $>$ $>$ \&}]{pubnonces}{, }\item[{\textbf{ Mu\+Sig2\+Sec\+Nonce} \&}]{secnonce}{, }\item[{const std\+::vector$<$ std\+::pair$<$ \textbf{ uint256}, bool $>$ $>$ \&}]{tweaks}{}\end{DoxyParamCaption})}

\index{CKey@{CKey}!data@{data}}
\index{data@{data}!CKey@{CKey}}
\doxysubsubsection{data()}
{\footnotesize\ttfamily \label{class_c_key_a79d691e4fa7d073b7c1809715933d8d1} 
const std\+::byte $\ast$ data (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CKey@{CKey}!Derive@{Derive}}
\index{Derive@{Derive}!CKey@{CKey}}
\doxysubsubsection{Derive()}
{\footnotesize\ttfamily \label{class_c_key_ac1e5f90d3ea728a29c0f29b5a85f3b87} 
bool Derive (\begin{DoxyParamCaption}\item[{\textbf{ CKey} \&}]{key\+Child}{, }\item[{\textbf{ Chain\+Code} \&}]{cc\+Child}{, }\item[{unsigned int}]{n\+Child}{, }\item[{const \textbf{ Chain\+Code} \&}]{cc}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}}



Derive BIP32 child key. 

\index{CKey@{CKey}!EllSwiftCreate@{EllSwiftCreate}}
\index{EllSwiftCreate@{EllSwiftCreate}!CKey@{CKey}}
\doxysubsubsection{EllSwiftCreate()}
{\footnotesize\ttfamily \label{class_c_key_aaa51951a1ed98ba1e5b575f70c17a0e6} 
\textbf{ Ell\+Swift\+Pub\+Key} Ell\+Swift\+Create (\begin{DoxyParamCaption}\item[{std\+::span$<$ const std\+::byte $>$}]{entropy}{}\end{DoxyParamCaption}) const}

Create an ellswift-\/encoded public key for this key, with specified entropy.

entropy must be a 32-\/byte span with additional entropy to use in the encoding. Every public key has $\sim$2$^\wedge$256 different encodings, and this function will deterministically pick one of them, based on entropy. Note that even without truly random entropy, the resulting encoding will be indistinguishable from uniform to any adversary who does not know the private key (because the private key itself is always used as entropy as well). \index{CKey@{CKey}!end@{end}}
\index{end@{end}!CKey@{CKey}}
\doxysubsubsection{end()}
{\footnotesize\ttfamily \label{class_c_key_aee13e112f1ea878b2e7f02e1f2fba3de} 
const std\+::byte $\ast$ end (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CKey@{CKey}!GetPrivKey@{GetPrivKey}}
\index{GetPrivKey@{GetPrivKey}!CKey@{CKey}}
\doxysubsubsection{GetPrivKey()}
{\footnotesize\ttfamily \label{class_c_key_a280157fca5685cc0894e582a3ef1d138} 
\textbf{ CPriv\+Key} Get\+Priv\+Key (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Convert the private key to a \doxyref{CPriv\+Key}{p.}{key_8h_a1da569b8b6e5b3fa1196cc1b877e7f54} (serialized Open\+SSL private key data). This is expensive. \index{CKey@{CKey}!GetPubKey@{GetPubKey}}
\index{GetPubKey@{GetPubKey}!CKey@{CKey}}
\doxysubsubsection{GetPubKey()}
{\footnotesize\ttfamily \label{class_c_key_a344311f57d0f0df0822c9fb04f66cf95} 
\textbf{ CPub\+Key} Get\+Pub\+Key (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Compute the public key from a private key. This is expensive. \index{CKey@{CKey}!IsCompressed@{IsCompressed}}
\index{IsCompressed@{IsCompressed}!CKey@{CKey}}
\doxysubsubsection{IsCompressed()}
{\footnotesize\ttfamily \label{class_c_key_a61c81b509c5f281f1afae76c7a3f3b4b} 
bool Is\+Compressed (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether the public key corresponding to this private key is (to be) compressed. 

\index{CKey@{CKey}!IsValid@{IsValid}}
\index{IsValid@{IsValid}!CKey@{CKey}}
\doxysubsubsection{IsValid()}
{\footnotesize\ttfamily \label{class_c_key_ac532c4b500b1a85ea22217f2c65a70ed} 
bool Is\+Valid (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Check whether this private key is valid. 

\index{CKey@{CKey}!Load@{Load}}
\index{Load@{Load}!CKey@{CKey}}
\doxysubsubsection{Load()}
{\footnotesize\ttfamily \label{class_c_key_ad226478fb14c47c32a6d75a2130114d8} 
bool Load (\begin{DoxyParamCaption}\item[{const \textbf{ CPriv\+Key} \&}]{privkey}{, }\item[{const \textbf{ CPub\+Key} \&}]{vch\+Pub\+Key}{, }\item[{bool}]{f\+Skip\+Check}{ = {\ttfamily false}}\end{DoxyParamCaption})}



Load private key and check that public key matches. 

\index{CKey@{CKey}!MakeNewKey@{MakeNewKey}}
\index{MakeNewKey@{MakeNewKey}!CKey@{CKey}}
\doxysubsubsection{MakeNewKey()}
{\footnotesize\ttfamily \label{class_c_key_a4c2b881159b01dacff86884fa2a7b7ff} 
void Make\+New\+Key (\begin{DoxyParamCaption}\item[{bool}]{f\+Compressed}{}\end{DoxyParamCaption})}



Generate a new private key using a cryptographic PRNG. 

\index{CKey@{CKey}!operator=@{operator=}}
\index{operator=@{operator=}!CKey@{CKey}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_key_a07c0c9668bdc0a71422654f9f86c6ccc} 
\textbf{ CKey} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ CKey} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

\index{CKey@{CKey}!operator=@{operator=}}
\index{operator=@{operator=}!CKey@{CKey}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_key_aefb746b689a0b9ecb59c41fddb51ef63} 
\textbf{ CKey} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ CKey} \&}]{other}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CKey@{CKey}!Set@{Set}}
\index{Set@{Set}!CKey@{CKey}}
\doxysubsubsection{Set()}
{\footnotesize\ttfamily \label{class_c_key_a187230fea4115615c6c65b39c9e18246} 
template$<$typename \textbf{ T}$>$ \\
void Set (\begin{DoxyParamCaption}\item[{const \textbf{ T}}]{pbegin}{, }\item[{const \textbf{ T}}]{pend}{, }\item[{bool}]{f\+Compressed\+In}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Initialize using begin and end iterators to byte data. 

\index{CKey@{CKey}!Sign@{Sign}}
\index{Sign@{Sign}!CKey@{CKey}}
\doxysubsubsection{Sign()}
{\footnotesize\ttfamily \label{class_c_key_a4143ab43733a1eef40d194163a2f69b0} 
bool Sign (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{, }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Sig}{, }\item[{bool}]{grind}{ = {\ttfamily true}, }\item[{uint32\+\_\+t}]{test\+\_\+case}{ = {\ttfamily 0}}\end{DoxyParamCaption}) const}

Create a DER-\/serialized signature. The test\+\_\+case parameter tweaks the deterministic nonce. \index{CKey@{CKey}!SignCompact@{SignCompact}}
\index{SignCompact@{SignCompact}!CKey@{CKey}}
\doxysubsubsection{SignCompact()}
{\footnotesize\ttfamily \label{class_c_key_ab813495ee5dd24d04ccd4abe59b6cf50} 
bool Sign\+Compact (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{, }\item[{std\+::vector$<$ unsigned char $>$ \&}]{vch\+Sig}{}\end{DoxyParamCaption}) const}

Create a compact signature (65 bytes), which allows reconstructing the used public key. The format is one header byte, followed by two times 32 bytes for the serialized r and s values. The header byte\+: 0x1B = first key with even y, 0x1C = first key with odd y, 0x1D = second key with even y, 0x1E = second key with odd y, add 0x04 for compressed keys. \index{CKey@{CKey}!SignSchnorr@{SignSchnorr}}
\index{SignSchnorr@{SignSchnorr}!CKey@{CKey}}
\doxysubsubsection{SignSchnorr()}
{\footnotesize\ttfamily \label{class_c_key_a0884ca8071e122315e1fb5dc8efda906} 
bool Sign\+Schnorr (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{hash}{, }\item[{std\+::span$<$ unsigned char $>$}]{sig}{, }\item[{const \textbf{ uint256} $\ast$}]{merkle\+\_\+root}{, }\item[{const \textbf{ uint256} \&}]{aux}{}\end{DoxyParamCaption}) const}

Create a BIP-\/340 Schnorr signature, for the xonly-\/pubkey corresponding to $\ast$this, optionally tweaked by $\ast$merkle\+\_\+root. Additional nonce entropy is provided through aux.

merkle\+\_\+root is used to optionally perform tweaking of the private key, as specified in BIP341\+:
\begin{DoxyItemize}
\item If merkle\+\_\+root == nullptr\+: no tweaking is done, sign with key directly (this is used for signatures in BIP342 script).
\item If merkle\+\_\+root-\/$>$Is\+Null()\+: sign with key + H\+\_\+\+Tap\+Tweak(pubkey) (this is used for key path spending when no scripts are present).
\item Otherwise\+: sign with key + H\+\_\+\+Tap\+Tweak(pubkey $\vert$$\vert$ $\ast$merkle\+\_\+root) (this is used for key path spending, with specific Merkle root of the script tree). 
\end{DoxyItemize}\index{CKey@{CKey}!size@{size}}
\index{size@{size}!CKey@{CKey}}
\doxysubsubsection{size()}
{\footnotesize\ttfamily \label{class_c_key_a69622a843a8c7f05bf706cf80fad6951} 
unsigned int size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Simple read-\/only vector-\/like interface. 

\index{CKey@{CKey}!VerifyPubKey@{VerifyPubKey}}
\index{VerifyPubKey@{VerifyPubKey}!CKey@{CKey}}
\doxysubsubsection{VerifyPubKey()}
{\footnotesize\ttfamily \label{class_c_key_ad7a34331f4b6972a38928b176038ef75} 
bool Verify\+Pub\+Key (\begin{DoxyParamCaption}\item[{const \textbf{ CPub\+Key} \&}]{vch\+Pub\+Key}{}\end{DoxyParamCaption}) const}

Verify thoroughly whether a private key and a public key match. This is done using a different mechanism than just regenerating it. 

\label{doc-related-members}
\doxysubsection{Friends And Related Symbol Documentation}
\index{CKey@{CKey}!operator==@{operator==}}
\index{operator==@{operator==}!CKey@{CKey}}
\doxysubsubsection{operator==}
{\footnotesize\ttfamily \label{class_c_key_a381efd9184dc467e73e690329c70371d} 
bool operator== (\begin{DoxyParamCaption}\item[{const \textbf{ CKey} \&}]{a}{, }\item[{const \textbf{ CKey} \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CKey@{CKey}!COMPRESSED\_SIZE@{COMPRESSED\_SIZE}}
\index{COMPRESSED\_SIZE@{COMPRESSED\_SIZE}!CKey@{CKey}}
\doxysubsubsection{COMPRESSED\_SIZE}
{\footnotesize\ttfamily \label{class_c_key_a474ebdb27a1c99c2b71f8ac40e2e68ac} 
const unsigned int COMPRESSED\+\_\+\+SIZE = 214\hspace{0.3cm}{\ttfamily [static]}}

\index{CKey@{CKey}!SIZE@{SIZE}}
\index{SIZE@{SIZE}!CKey@{CKey}}
\doxysubsubsection{SIZE}
{\footnotesize\ttfamily \label{class_c_key_a0760cd6fcc3f45a64b0402a4cc9b9ce3} 
const unsigned int SIZE = 279\hspace{0.3cm}{\ttfamily [static]}}

secp256k1\+: 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ key.\+h}\item 
src/\textbf{ key.\+cpp}\end{DoxyCompactItemize}
