\doxysection{src/minisketch/include/minisketch.h File Reference}
\label{minisketch_8h}\index{src/minisketch/include/minisketch.h@{src/minisketch/include/minisketch.h}}
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$unistd.\+h$>$}\newline
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ MINISKETCH\+\_\+\+API}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \textbf{ minisketch} \textbf{ minisketch}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ MINISKETCH\+\_\+\+API} int \textbf{ minisketch\+\_\+bits\+\_\+supported} (uint32\+\_\+t bits)
\item 
\textbf{ MINISKETCH\+\_\+\+API} uint32\+\_\+t \textbf{ minisketch\+\_\+implementation\+\_\+max} (void)
\item 
\textbf{ MINISKETCH\+\_\+\+API} int \textbf{ minisketch\+\_\+implementation\+\_\+supported} (uint32\+\_\+t bits, uint32\+\_\+t implementation)
\item 
\textbf{ MINISKETCH\+\_\+\+API} \textbf{ minisketch} $\ast$ \textbf{ minisketch\+\_\+create} (uint32\+\_\+t bits, uint32\+\_\+t implementation, size\+\_\+t capacity)
\item 
\textbf{ MINISKETCH\+\_\+\+API} uint32\+\_\+t \textbf{ minisketch\+\_\+bits} (const \textbf{ minisketch} $\ast$sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t \textbf{ minisketch\+\_\+capacity} (const \textbf{ minisketch} $\ast$sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} uint32\+\_\+t \textbf{ minisketch\+\_\+implementation} (const \textbf{ minisketch} $\ast$sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} void \textbf{ minisketch\+\_\+set\+\_\+seed} (\textbf{ minisketch} $\ast$sketch, uint64\+\_\+t seed)
\item 
\textbf{ MINISKETCH\+\_\+\+API} \textbf{ minisketch} $\ast$ \textbf{ minisketch\+\_\+clone} (const \textbf{ minisketch} $\ast$sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} void \textbf{ minisketch\+\_\+destroy} (\textbf{ minisketch} $\ast$sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t \textbf{ minisketch\+\_\+serialized\+\_\+size} (const \textbf{ minisketch} $\ast$sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} void \textbf{ minisketch\+\_\+serialize} (const \textbf{ minisketch} $\ast$sketch, unsigned char $\ast$output)
\item 
\textbf{ MINISKETCH\+\_\+\+API} void \textbf{ minisketch\+\_\+deserialize} (\textbf{ minisketch} $\ast$sketch, const unsigned char $\ast$input)
\item 
\textbf{ MINISKETCH\+\_\+\+API} void \textbf{ minisketch\+\_\+add\+\_\+uint64} (\textbf{ minisketch} $\ast$sketch, uint64\+\_\+t element)
\item 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t \textbf{ minisketch\+\_\+merge} (\textbf{ minisketch} $\ast$sketch, const \textbf{ minisketch} $\ast$other\+\_\+sketch)
\item 
\textbf{ MINISKETCH\+\_\+\+API} ssize\+\_\+t \textbf{ minisketch\+\_\+decode} (const \textbf{ minisketch} $\ast$sketch, size\+\_\+t max\+\_\+elements, uint64\+\_\+t $\ast$output)
\item 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t \textbf{ minisketch\+\_\+compute\+\_\+capacity} (uint32\+\_\+t bits, size\+\_\+t max\+\_\+elements, uint32\+\_\+t fpbits)
\item 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t \textbf{ minisketch\+\_\+compute\+\_\+max\+\_\+elements} (uint32\+\_\+t bits, size\+\_\+t capacity, uint32\+\_\+t fpbits)
\end{DoxyCompactItemize}


\label{doc-define-members}
\doxysubsection{Macro Definition Documentation}
\index{minisketch.h@{minisketch.h}!MINISKETCH\_API@{MINISKETCH\_API}}
\index{MINISKETCH\_API@{MINISKETCH\_API}!minisketch.h@{minisketch.h}}
\doxysubsubsection{MINISKETCH\_API}
{\footnotesize\ttfamily \label{minisketch_8h_a3aba271c6880fbb225d20ea2401b36e2} 
\#define MINISKETCH\+\_\+\+API}



\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{minisketch.h@{minisketch.h}!minisketch@{minisketch}}
\index{minisketch@{minisketch}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch}
{\footnotesize\ttfamily \label{minisketch_8h_adffb4f5b48fcdd25b57ae22f5b2147f4} 
typedef struct \textbf{ minisketch} \textbf{ minisketch}}

Opaque type for decoded sketches. 

\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{minisketch.h@{minisketch.h}!minisketch\_add\_uint64@{minisketch\_add\_uint64}}
\index{minisketch\_add\_uint64@{minisketch\_add\_uint64}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_add\_uint64()}
{\footnotesize\ttfamily \label{minisketch_8h_a6e0d272f72df96765d9041f859324880} 
\textbf{ MINISKETCH\+\_\+\+API} void minisketch\+\_\+add\+\_\+uint64 (\begin{DoxyParamCaption}\item[{\textbf{ minisketch} $\ast$}]{sketch}{, }\item[{uint64\+\_\+t}]{element}{}\end{DoxyParamCaption})}

Add an element to a sketch.

If the element to be added is too large for the sketch, the most significant bits of the element are dropped. More precisely, if the element size of {\ttfamily sketch} is b bits, then this function adds the unsigned integer represented by the b least significant bits of {\ttfamily element} to {\ttfamily sketch}.

If the element to be added is 0 (after potentially dropping the most significant bits), then this function is a no-\/op. Sketches cannot contain an element with the value 0.

Note that adding the same element a second time removes it again. \index{minisketch.h@{minisketch.h}!minisketch\_bits@{minisketch\_bits}}
\index{minisketch\_bits@{minisketch\_bits}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_bits()}
{\footnotesize\ttfamily \label{minisketch_8h_a9b51a3ccbee98114e71b0190b2f6a106} 
\textbf{ MINISKETCH\+\_\+\+API} uint32\+\_\+t minisketch\+\_\+bits (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{}\end{DoxyParamCaption})}

Get the element size of a sketch in bits. \index{minisketch.h@{minisketch.h}!minisketch\_bits\_supported@{minisketch\_bits\_supported}}
\index{minisketch\_bits\_supported@{minisketch\_bits\_supported}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_bits\_supported()}
{\footnotesize\ttfamily \label{minisketch_8h_a26c0c0816ad7a3391b5b99031e4c0afe} 
\textbf{ MINISKETCH\+\_\+\+API} int minisketch\+\_\+bits\+\_\+supported (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{bits}{}\end{DoxyParamCaption})}

Determine whether support for elements of {\ttfamily bits} bits was compiled in. \index{minisketch.h@{minisketch.h}!minisketch\_capacity@{minisketch\_capacity}}
\index{minisketch\_capacity@{minisketch\_capacity}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_capacity()}
{\footnotesize\ttfamily \label{minisketch_8h_a1335977c31b55fce5ccac936a9a7fc98} 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t minisketch\+\_\+capacity (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{}\end{DoxyParamCaption})}

Get the capacity of a sketch. \index{minisketch.h@{minisketch.h}!minisketch\_clone@{minisketch\_clone}}
\index{minisketch\_clone@{minisketch\_clone}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_clone()}
{\footnotesize\ttfamily \label{minisketch_8h_a85a63f2f6c0f6fc7346da4bf961ff557} 
\textbf{ MINISKETCH\+\_\+\+API} \textbf{ minisketch} $\ast$ minisketch\+\_\+clone (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{}\end{DoxyParamCaption})}

Clone a sketch.

The result must be destroyed using minisketch\+\_\+destroy. \index{minisketch.h@{minisketch.h}!minisketch\_compute\_capacity@{minisketch\_compute\_capacity}}
\index{minisketch\_compute\_capacity@{minisketch\_compute\_capacity}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_compute\_capacity()}
{\footnotesize\ttfamily \label{minisketch_8h_a1f58897ab5be5c6fd5bc5d64e9866ea3} 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t minisketch\+\_\+compute\+\_\+capacity (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{bits}{, }\item[{size\+\_\+t}]{max\+\_\+elements}{, }\item[{uint32\+\_\+t}]{fpbits}{}\end{DoxyParamCaption})}

Compute the capacity needed to achieve a certain rate of false positives.

A sketch with capacity c and no more than c elements can always be decoded correctly. However, if it has more than c elements, or contains just random bytes, it is possible that it will still decode, but the result will be nonsense. This can be counteracted by increasing the capacity slightly.

Given a field size bits, an intended number of elements that can be decoded max\+\_\+elements, and a false positive probability of 1 in 2$\ast$$\ast$fpbits, this function computes the necessary capacity. It is only guaranteed to be accurate up to fpbits=256. \index{minisketch.h@{minisketch.h}!minisketch\_compute\_max\_elements@{minisketch\_compute\_max\_elements}}
\index{minisketch\_compute\_max\_elements@{minisketch\_compute\_max\_elements}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_compute\_max\_elements()}
{\footnotesize\ttfamily \label{minisketch_8h_aa92ef4871e3bbcd0e1a740923e22c87b} 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t minisketch\+\_\+compute\+\_\+max\+\_\+elements (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{bits}{, }\item[{size\+\_\+t}]{capacity}{, }\item[{uint32\+\_\+t}]{fpbits}{}\end{DoxyParamCaption})}

Compute what max\+\_\+elements can be decoded for a certain rate of false positives.

This is the inverse operation of minisketch\+\_\+compute\+\_\+capacity. It determines, given a field size bits, a capacity of a sketch, and an acceptable false positive probability of 1 in 2$\ast$$\ast$fpbits, what the maximum allowed max\+\_\+elements value is. If no value of max\+\_\+elements would give the desired false positive probability, 0 is returned.

Note that this is not an exact inverse of minisketch\+\_\+compute\+\_\+capacity. For example, with bits=32, fpbits=16, and max\+\_\+elements=8, minisketch\+\_\+compute\+\_\+capacity will return 9, as capacity 8 would only have a false positive chance of 1 in 2$^\wedge$15.3. Increasing the capacity to 9 however decreases the fp chance to 1 in 2$^\wedge$47.3, enough for max\+\_\+elements=9 (with fp chance of 1 in 2$^\wedge$18.5). Therefore, minisketch\+\_\+compute\+\_\+max\+\_\+elements with capacity=9 will return 9. \index{minisketch.h@{minisketch.h}!minisketch\_create@{minisketch\_create}}
\index{minisketch\_create@{minisketch\_create}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_create()}
{\footnotesize\ttfamily \label{minisketch_8h_a4d39dce1593d829c3fde622807fda244} 
\textbf{ MINISKETCH\+\_\+\+API} \textbf{ minisketch} $\ast$ minisketch\+\_\+create (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{bits}{, }\item[{uint32\+\_\+t}]{implementation}{, }\item[{size\+\_\+t}]{capacity}{}\end{DoxyParamCaption})}

Construct a sketch for a given element size, implementation and capacity.

If the combination of {\ttfamily bits} and {\ttfamily implementation} is unavailable, or when OOM occurs, NULL is returned. If minisketch\+\_\+implementation\+\_\+supported returns 1 for the specified bits and implementation, this will always succeed (except when allocation fails).

If the result is not NULL, it must be destroyed using minisketch\+\_\+destroy. \index{minisketch.h@{minisketch.h}!minisketch\_decode@{minisketch\_decode}}
\index{minisketch\_decode@{minisketch\_decode}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_decode()}
{\footnotesize\ttfamily \label{minisketch_8h_a20adb9ea07329cdceb1f7254aee870b0} 
\textbf{ MINISKETCH\+\_\+\+API} ssize\+\_\+t minisketch\+\_\+decode (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{, }\item[{size\+\_\+t}]{max\+\_\+elements}{, }\item[{uint64\+\_\+t $\ast$}]{output}{}\end{DoxyParamCaption})}

Decode a sketch.

{\ttfamily output} is a pointer to an array of {\ttfamily max\+\_\+element} uint64\+\_\+t\textquotesingle{}s, which will be filled with the elements in this sketch.

The return value is the number of decoded elements, or -\/1 if decoding failed. \index{minisketch.h@{minisketch.h}!minisketch\_deserialize@{minisketch\_deserialize}}
\index{minisketch\_deserialize@{minisketch\_deserialize}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_deserialize()}
{\footnotesize\ttfamily \label{minisketch_8h_ad283ad30bb9ac697a42d81ca2796414b} 
\textbf{ MINISKETCH\+\_\+\+API} void minisketch\+\_\+deserialize (\begin{DoxyParamCaption}\item[{\textbf{ minisketch} $\ast$}]{sketch}{, }\item[{const unsigned char $\ast$}]{input}{}\end{DoxyParamCaption})}

Deserialize a sketch from bytes. \index{minisketch.h@{minisketch.h}!minisketch\_destroy@{minisketch\_destroy}}
\index{minisketch\_destroy@{minisketch\_destroy}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_destroy()}
{\footnotesize\ttfamily \label{minisketch_8h_ad603da5dcb6bfe0dd3bbe4b03895c73b} 
\textbf{ MINISKETCH\+\_\+\+API} void minisketch\+\_\+destroy (\begin{DoxyParamCaption}\item[{\textbf{ minisketch} $\ast$}]{sketch}{}\end{DoxyParamCaption})}

Destroy a sketch.

The pointer that was passed in may not be used anymore afterwards. \index{minisketch.h@{minisketch.h}!minisketch\_implementation@{minisketch\_implementation}}
\index{minisketch\_implementation@{minisketch\_implementation}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_implementation()}
{\footnotesize\ttfamily \label{minisketch_8h_a0bd6796b10a3b8d64877c6c16166e029} 
\textbf{ MINISKETCH\+\_\+\+API} uint32\+\_\+t minisketch\+\_\+implementation (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{}\end{DoxyParamCaption})}

Get the implementation of a sketch. \index{minisketch.h@{minisketch.h}!minisketch\_implementation\_max@{minisketch\_implementation\_max}}
\index{minisketch\_implementation\_max@{minisketch\_implementation\_max}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_implementation\_max()}
{\footnotesize\ttfamily \label{minisketch_8h_a5d058c77ef55e6b12400cedf1d386738} 
\textbf{ MINISKETCH\+\_\+\+API} uint32\+\_\+t minisketch\+\_\+implementation\+\_\+max (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption})}

Determine the maximum number of implementations available.

Multiple implementations may be available for a given element size, with different performance characteristics on different hardware.

Each implementation is identified by a number from 0 to the output of this function call, inclusive. Note that not every combination of implementation and element size may exist (see further). \index{minisketch.h@{minisketch.h}!minisketch\_implementation\_supported@{minisketch\_implementation\_supported}}
\index{minisketch\_implementation\_supported@{minisketch\_implementation\_supported}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_implementation\_supported()}
{\footnotesize\ttfamily \label{minisketch_8h_ae8a257aa605e2ac449cfdac20125063a} 
\textbf{ MINISKETCH\+\_\+\+API} int minisketch\+\_\+implementation\+\_\+supported (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{bits}{, }\item[{uint32\+\_\+t}]{implementation}{}\end{DoxyParamCaption})}

Determine if the a combination of bits and implementation number is available.

Returns 1 if it is, 0 otherwise. \index{minisketch.h@{minisketch.h}!minisketch\_merge@{minisketch\_merge}}
\index{minisketch\_merge@{minisketch\_merge}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_merge()}
{\footnotesize\ttfamily \label{minisketch_8h_a33e9c31b9b1ec357f85ba05c4d6724a2} 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t minisketch\+\_\+merge (\begin{DoxyParamCaption}\item[{\textbf{ minisketch} $\ast$}]{sketch}{, }\item[{const \textbf{ minisketch} $\ast$}]{other\+\_\+sketch}{}\end{DoxyParamCaption})}

Merge the elements of another sketch into this sketch.

After merging, {\ttfamily sketch} will contain every element that existed in one but not both of the input sketches. It can be seen as an exclusive or operation on the set elements. If the capacity of {\ttfamily other\+\_\+sketch} is lower than {\ttfamily sketch}\textquotesingle{}s, merging reduces the capacity of {\ttfamily sketch} to that of {\ttfamily other\+\_\+sketch}.

This function returns the capacity of {\ttfamily sketch} after merging has been performed (where this capacity is at least 1), or 0 to indicate that merging has failed because the two input sketches differ in their element size or implementation. If 0 is returned, {\ttfamily sketch} (and its capacity) have not been modified.

It is also possible to perform this operation directly on the serializations of two sketches with the same element size and capacity by performing a bitwise XOR of the serializations. \index{minisketch.h@{minisketch.h}!minisketch\_serialize@{minisketch\_serialize}}
\index{minisketch\_serialize@{minisketch\_serialize}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_serialize()}
{\footnotesize\ttfamily \label{minisketch_8h_a03a014a1f2885b473c14f6aa24de24f4} 
\textbf{ MINISKETCH\+\_\+\+API} void minisketch\+\_\+serialize (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{, }\item[{unsigned char $\ast$}]{output}{}\end{DoxyParamCaption})}

Serialize a sketch to bytes. \index{minisketch.h@{minisketch.h}!minisketch\_serialized\_size@{minisketch\_serialized\_size}}
\index{minisketch\_serialized\_size@{minisketch\_serialized\_size}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_serialized\_size()}
{\footnotesize\ttfamily \label{minisketch_8h_a3ab706ecc86c75ca06651ecc62024a23} 
\textbf{ MINISKETCH\+\_\+\+API} size\+\_\+t minisketch\+\_\+serialized\+\_\+size (\begin{DoxyParamCaption}\item[{const \textbf{ minisketch} $\ast$}]{sketch}{}\end{DoxyParamCaption})}

Compute the size in bytes for serializing a given sketch. \index{minisketch.h@{minisketch.h}!minisketch\_set\_seed@{minisketch\_set\_seed}}
\index{minisketch\_set\_seed@{minisketch\_set\_seed}!minisketch.h@{minisketch.h}}
\doxysubsubsection{minisketch\_set\_seed()}
{\footnotesize\ttfamily \label{minisketch_8h_a0a5456c8994b584c548128154c264637} 
\textbf{ MINISKETCH\+\_\+\+API} void minisketch\+\_\+set\+\_\+seed (\begin{DoxyParamCaption}\item[{\textbf{ minisketch} $\ast$}]{sketch}{, }\item[{uint64\+\_\+t}]{seed}{}\end{DoxyParamCaption})}

Set the seed for randomizing algorithm choices to a fixed value.

By default, sketches are initialized with a random seed. This is important to avoid scenarios where an attacker could force worst-\/case behavior.

This function initializes the seed to a user-\/provided value (any 64-\/bit integer is acceptable, regardless of field size).

When seed is -\/1, a fixed internal value with predictable behavior is used. It is only intended for testing. 