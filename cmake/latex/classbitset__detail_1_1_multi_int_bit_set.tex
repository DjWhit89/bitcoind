\doxysection{Multi\+Int\+Bit\+Set$<$ I, N $>$ Class Template Reference}
\label{classbitset__detail_1_1_multi_int_bit_set}\index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}


{\ttfamily \#include $<$bitset.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} () noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} (const Multi\+Int\+Bit\+Set \&) noexcept=default
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \& \textbf{ operator=} (const \textbf{ Multi\+Int\+Bit\+Set} \&) noexcept=default
\item 
void constexpr \textbf{ Set} (unsigned pos) noexcept
\item 
void constexpr \textbf{ Set} (unsigned pos, bool val) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} (std\+::initializer\+\_\+list$<$ unsigned $>$ ilist) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \& \textbf{ operator=} (std\+::initializer\+\_\+list$<$ unsigned $>$ ilist) noexcept
\item 
void constexpr \textbf{ Reset} (unsigned pos) noexcept
\item 
bool constexpr \textbf{ operator[$\,$]} (unsigned pos) const noexcept
\item 
unsigned constexpr \textbf{ Count} () const noexcept
\item 
bool constexpr \textbf{ None} () const noexcept
\item 
bool constexpr \textbf{ Any} () const noexcept
\item 
\textbf{ Iterator} constexpr \textbf{ begin} () const noexcept
\item 
Iterator\+End constexpr \textbf{ end} () const noexcept
\item 
unsigned constexpr \textbf{ First} () const noexcept
\item 
unsigned constexpr \textbf{ Last} () const noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \& \textbf{ operator$\vert$=} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \& \textbf{ operator\&=} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \& \textbf{ operator-\/=} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \& \textbf{ operator$^\wedge$=} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) noexcept
\item 
constexpr bool \textbf{ Overlaps} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) const noexcept
\item 
constexpr bool \textbf{ Is\+Superset\+Of} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) const noexcept
\item 
constexpr bool \textbf{ Is\+Subset\+Of} (const \textbf{ Multi\+Int\+Bit\+Set} \&a) const noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr \textbf{ Multi\+Int\+Bit\+Set} \textbf{ Singleton} (unsigned pos) noexcept
\item 
static constexpr \textbf{ Multi\+Int\+Bit\+Set} \textbf{ Fill} (unsigned count) noexcept
\item 
static constexpr unsigned \textbf{ Size} () noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \textbf{ operator\&} (const \textbf{ Multi\+Int\+Bit\+Set} \&a, const \textbf{ Multi\+Int\+Bit\+Set} \&b) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \textbf{ operator$\vert$} (const \textbf{ Multi\+Int\+Bit\+Set} \&a, const \textbf{ Multi\+Int\+Bit\+Set} \&b) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \textbf{ operator-\/} (const \textbf{ Multi\+Int\+Bit\+Set} \&a, const \textbf{ Multi\+Int\+Bit\+Set} \&b) noexcept
\item 
constexpr \textbf{ Multi\+Int\+Bit\+Set} \textbf{ operator$^\wedge$} (const \textbf{ Multi\+Int\+Bit\+Set} \&a, const \textbf{ Multi\+Int\+Bit\+Set} \&b) noexcept
\item 
constexpr bool \textbf{ operator==} (const \textbf{ Multi\+Int\+Bit\+Set} \&a, const \textbf{ Multi\+Int\+Bit\+Set} \&b) noexcept=default
\item 
constexpr void \textbf{ swap} (\textbf{ Multi\+Int\+Bit\+Set} \&a, \textbf{ Multi\+Int\+Bit\+Set} \&b) noexcept
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename I, unsigned N$>$\newline
class bitset\+\_\+detail\+::\+Multi\+Int\+Bit\+Set$<$ I, N $>$}
A bitset implementation backed by N integers of type I. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!MultiIntBitSet@{MultiIntBitSet}}
\index{MultiIntBitSet@{MultiIntBitSet}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{MultiIntBitSet()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a9c1f73bb2177f769cae9d9fa24a2537d} 
template$<$typename I, unsigned N$>$ \\
Multi\+Int\+Bit\+Set (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Construct an all-\/zero bitset. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!MultiIntBitSet@{MultiIntBitSet}}
\index{MultiIntBitSet@{MultiIntBitSet}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{MultiIntBitSet()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a79f8d23bedc88dcfb9ac0acb40d29523} 
template$<$typename I, unsigned N$>$ \\
Multi\+Int\+Bit\+Set (\begin{DoxyParamCaption}\item[{const Multi\+Int\+Bit\+Set$<$ I, N $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}, {\ttfamily [default]}, {\ttfamily [noexcept]}}

Copy construct a bitset. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!MultiIntBitSet@{MultiIntBitSet}}
\index{MultiIntBitSet@{MultiIntBitSet}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{MultiIntBitSet()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a029225c86a72d08cb4f4a7ae077324c7} 
template$<$typename I, unsigned N$>$ \\
Multi\+Int\+Bit\+Set (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ unsigned $>$}]{ilist}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Construct a bitset from a list of values. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Any@{Any}}
\index{Any@{Any}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Any()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_aa72a8e808016c1efce23813d9d79951c} 
template$<$typename I, unsigned N$>$ \\
bool constexpr Any (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Check if any bits are 1. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!begin@{begin}}
\index{begin@{begin}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{begin()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a34c7496828073d30eb3509b3cfadd770} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Iterator} constexpr begin (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Return an object that iterates over all 1 bits (++ and $\ast$ only allowed when != \doxyref{end()}{p.}{classbitset__detail_1_1_multi_int_bit_set_aad512209fff836e3a289eb43a00594f6}). \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Count@{Count}}
\index{Count@{Count}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Count()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a675b60c3fbfe1fa38c6a9411f10298ea} 
template$<$typename I, unsigned N$>$ \\
unsigned constexpr Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Compute the number of 1 bits in the bitset. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!end@{end}}
\index{end@{end}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{end()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_aad512209fff836e3a289eb43a00594f6} 
template$<$typename I, unsigned N$>$ \\
Iterator\+End constexpr end (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Return a dummy object to compare Iterators with. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Fill@{Fill}}
\index{Fill@{Fill}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Fill()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a781296adf7259411cee2de3fd5210b63} 
template$<$typename I, unsigned N$>$ \\
constexpr \textbf{ Multi\+Int\+Bit\+Set} Fill (\begin{DoxyParamCaption}\item[{unsigned}]{count}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Construct a bitset with bits 0..count-\/1 (inclusive) set to 1. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!First@{First}}
\index{First@{First}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{First()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_ab9b66745195941b5805455d7e858d688} 
template$<$typename I, unsigned N$>$ \\
unsigned constexpr First (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Find the first element (requires \doxyref{Any()}{p.}{classbitset__detail_1_1_multi_int_bit_set_aa72a8e808016c1efce23813d9d79951c}). \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!IsSubsetOf@{IsSubsetOf}}
\index{IsSubsetOf@{IsSubsetOf}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{IsSubsetOf()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a4f9bb850b5c8ef0dfd1f6502e005363d} 
template$<$typename I, unsigned N$>$ \\
bool Is\+Subset\+Of (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b). \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!IsSupersetOf@{IsSupersetOf}}
\index{IsSupersetOf@{IsSupersetOf}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{IsSupersetOf()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a0e201d58df788c3f41ea954a40bae532} 
template$<$typename I, unsigned N$>$ \\
bool Is\+Superset\+Of (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a). \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Last@{Last}}
\index{Last@{Last}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Last()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a69ec6d4d5182b5e978c58fffcda84206} 
template$<$typename I, unsigned N$>$ \\
unsigned constexpr Last (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Find the last element (requires \doxyref{Any()}{p.}{classbitset__detail_1_1_multi_int_bit_set_aa72a8e808016c1efce23813d9d79951c}). \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!None@{None}}
\index{None@{None}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{None()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a3aca2b4477492f9d50fb361aacabaf32} 
template$<$typename I, unsigned N$>$ \\
bool constexpr None (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Check if all bits are 0. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator\&=@{operator\&=}}
\index{operator\&=@{operator\&=}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator\&=()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_ab67be30d25fd068207ecb729de5e3473} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} \& operator\&= (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set this object\textquotesingle{}s bits to be the binary AND between respective bits from this and a. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator-\/=@{operator-\/=}}
\index{operator-\/=@{operator-\/=}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator-\/=()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a44018ca31572dd8285b7d4dac4880dda} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} \& operator-\/= (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set this object\textquotesingle{}s bits to be the binary AND NOT between respective bits from this and a. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator=@{operator=}}
\index{operator=@{operator=}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_abb85a7241f7175ecf104414de2c88494} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}, {\ttfamily [default]}, {\ttfamily [noexcept]}}

Copy assign a bitset. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator=@{operator=}}
\index{operator=@{operator=}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a77d0b6e93deacd8081642062778e1fe5} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} \& operator= (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ unsigned $>$}]{ilist}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set a bitset to a list of values. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator[]@{operator[]}}
\index{operator[]@{operator[]}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator[]()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a9d36fc86719f8030bdcd70592fc2de01} 
template$<$typename I, unsigned N$>$ \\
bool constexpr operator[$\,$] (\begin{DoxyParamCaption}\item[{unsigned}]{pos}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Retrieve a bit at the given position. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator$^\wedge$=@{operator$^\wedge$=}}
\index{operator$^\wedge$=@{operator$^\wedge$=}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator$^\wedge$=()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a3e68ebd228e2ae2d95081d512be236c1} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} \& operator$^\wedge$= (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set this object\textquotesingle{}s bits to be the binary XOR between respective bits from this and a. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator\texttt{"|}=@{operator\texttt{"|}=}}
\index{operator\texttt{"|}=@{operator\texttt{"|}=}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator\texttt{"|}=()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a3ce9a5c6f954e02a2df75533d30f832d} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} \& operator$\vert$= (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set this object\textquotesingle{}s bits to be the binary OR between respective bits from this and a. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Overlaps@{Overlaps}}
\index{Overlaps@{Overlaps}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Overlaps()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_aac3c63dd76bf8d635bfaa6243086bf1a} 
template$<$typename I, unsigned N$>$ \\
bool Overlaps (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Check whether the intersection between two sets is non-\/empty. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Reset@{Reset}}
\index{Reset@{Reset}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Reset()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a8a652faa6374c95be4042cb1fdebbf9e} 
template$<$typename I, unsigned N$>$ \\
void constexpr Reset (\begin{DoxyParamCaption}\item[{unsigned}]{pos}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set a bit to 0. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Set@{Set}}
\index{Set@{Set}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Set()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a3d64b03a33851e8568eb0571ade49109} 
template$<$typename I, unsigned N$>$ \\
void constexpr Set (\begin{DoxyParamCaption}\item[{unsigned}]{pos}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set a bit to 1. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Set@{Set}}
\index{Set@{Set}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Set()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a698b1edfde7aa165284214c92bcce886} 
template$<$typename I, unsigned N$>$ \\
void constexpr Set (\begin{DoxyParamCaption}\item[{unsigned}]{pos}{, }\item[{bool}]{val}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Set a bit to the specified value. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Singleton@{Singleton}}
\index{Singleton@{Singleton}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Singleton()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a9324fe6f535bd263f23b72af1c9b2205} 
template$<$typename I, unsigned N$>$ \\
constexpr \textbf{ Multi\+Int\+Bit\+Set} Singleton (\begin{DoxyParamCaption}\item[{unsigned}]{pos}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Construct a bitset with the singleton pos. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!Size@{Size}}
\index{Size@{Size}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{Size()}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_abdba65d1b901ff986b6896a1ca6d7c78} 
template$<$typename I, unsigned N$>$ \\
constexpr unsigned Size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}

Return the number of bits that this object holds. 

\label{doc-related-members}
\doxysubsection{Friends And Related Symbol Documentation}
\index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator\&}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_aa197a1a379137ab95553c143e48caf9f} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} operator\& (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{, }\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Return an object with the binary AND between respective bits from a and b. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator-\/}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_ad92d5f75af2a5ca733ee5f1804e9739d} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} operator-\/ (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{, }\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Return an object with the binary AND NOT between respective bits from a and b. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator==@{operator==}}
\index{operator==@{operator==}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator==}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_ace27ad67be2847395a527d64d28fc918} 
template$<$typename I, unsigned N$>$ \\
bool operator== (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{, }\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Check if bitset a and bitset b are identical. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator$^\wedge$}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_a8d62cdcdd4da06d73ed1b6de92ea40e3} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} operator$^\wedge$ (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{, }\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Return an object with the binary XOR between respective bits from a and b. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{operator\texttt{"|}}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_aa59ea72af892c4de1ba9d42cbb45ada3} 
template$<$typename I, unsigned N$>$ \\
\textbf{ Multi\+Int\+Bit\+Set} operator$\vert$ (\begin{DoxyParamCaption}\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{, }\item[{const \textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Return an object with the binary OR between respective bits from a and b. \index{MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}!swap@{swap}}
\index{swap@{swap}!MultiIntBitSet$<$ I, N $>$@{MultiIntBitSet$<$ I, N $>$}}
\doxysubsubsection{swap}
{\footnotesize\ttfamily \label{classbitset__detail_1_1_multi_int_bit_set_aa332304227ba47afa2711f48c5d7e7de} 
template$<$typename I, unsigned N$>$ \\
void swap (\begin{DoxyParamCaption}\item[{\textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{a}{, }\item[{\textbf{ Multi\+Int\+Bit\+Set}$<$ I, N $>$ \&}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [friend]}}

Swap two bitsets. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/util/\textbf{ bitset.\+h}\end{DoxyCompactItemize}
