\doxysection{CScheduler Class Reference}
\label{class_c_scheduler}\index{CScheduler@{CScheduler}}


{\ttfamily \#include $<$scheduler.\+h$>$}

\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef std\+::function$<$ void()$>$ \textbf{ Function}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ CScheduler} ()
\item 
\textbf{ $\sim$\+CScheduler} ()
\item 
void \textbf{ schedule} (\textbf{ Function} f, std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point t) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
void \textbf{ schedule\+From\+Now} (\textbf{ Function} f, std\+::chrono\+::milliseconds delta) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
void \textbf{ schedule\+Every} (\textbf{ Function} f, std\+::chrono\+::milliseconds delta) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
void \textbf{ Mock\+Forward} (std\+::chrono\+::seconds delta\+\_\+seconds) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
void \textbf{ service\+Queue} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
void \textbf{ stop} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
void \textbf{ Stop\+When\+Drained} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
size\+\_\+t \textbf{ get\+Queue\+Info} (std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point \&first, std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point \&last) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\item 
bool \textbf{ Are\+Threads\+Servicing\+Queue} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!new\+Task\+Mutex)
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
std\+::thread \textbf{ m\+\_\+service\+\_\+thread}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Simple class for background tasks that should be run periodically or once "{}after a while"{}

Usage\+:

CScheduler$\ast$ s = new \doxyref{CScheduler()}{p.}{class_c_scheduler_a8f1d5988a71a3242aae7ebbea1ba49ac}; s-\/$>$schedule\+From\+Now(do\+Something, std\+::chrono\+::milliseconds\{11\}); // Assuming a\+: void do\+Something() \{ \} s-\/$>$schedule\+From\+Now([=] \{ this-\/$>$func(argument); \}, std\+::chrono\+::milliseconds\{3\}); std\+::thread$\ast$ t = new std\+::thread([\&] \{ s-\/$>$\doxyref{service\+Queue()}{p.}{class_c_scheduler_a3c51a70f4b0106c4ee6f9dbad3f3da68}; \});

... then at program shutdown, make sure to call \doxyref{stop()}{p.}{class_c_scheduler_aded9b7a535edbef852c49e31f8ffa8a2} to clean up the thread(s) running service\+Queue\+: s-\/$>$\doxyref{stop()}{p.}{class_c_scheduler_aded9b7a535edbef852c49e31f8ffa8a2}; t-\/$>$join(); delete t; delete s; // Must be done after thread is interrupted/joined. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{CScheduler@{CScheduler}!Function@{Function}}
\index{Function@{Function}!CScheduler@{CScheduler}}
\doxysubsubsection{Function}
{\footnotesize\ttfamily \label{class_c_scheduler_a5969d318a59171fc0413b19f59434889} 
typedef std\+::function$<$void()$>$ \textbf{ Function}}



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CScheduler@{CScheduler}!CScheduler@{CScheduler}}
\index{CScheduler@{CScheduler}!CScheduler@{CScheduler}}
\doxysubsubsection{CScheduler()}
{\footnotesize\ttfamily \label{class_c_scheduler_a8f1d5988a71a3242aae7ebbea1ba49ac} 
\textbf{ CScheduler} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

\index{CScheduler@{CScheduler}!````~CScheduler@{$\sim$CScheduler}}
\index{````~CScheduler@{$\sim$CScheduler}!CScheduler@{CScheduler}}
\doxysubsubsection{$\sim$CScheduler()}
{\footnotesize\ttfamily \label{class_c_scheduler_a4d87ed7b38f60ca287b11ec69d8e2212} 
$\sim$\textbf{ CScheduler} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CScheduler@{CScheduler}!AreThreadsServicingQueue@{AreThreadsServicingQueue}}
\index{AreThreadsServicingQueue@{AreThreadsServicingQueue}!CScheduler@{CScheduler}}
\doxysubsubsection{AreThreadsServicingQueue()}
{\footnotesize\ttfamily \label{class_c_scheduler_a46b9b16b5ab91c682ebc937d3948775f} 
bool Are\+Threads\+Servicing\+Queue (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Returns true if there are threads actively running in \doxyref{service\+Queue()}{p.}{class_c_scheduler_a3c51a70f4b0106c4ee6f9dbad3f3da68} \index{CScheduler@{CScheduler}!getQueueInfo@{getQueueInfo}}
\index{getQueueInfo@{getQueueInfo}!CScheduler@{CScheduler}}
\doxysubsubsection{getQueueInfo()}
{\footnotesize\ttfamily \label{class_c_scheduler_aff14f7f321ef504ab44a28bb8d209ac2} 
size\+\_\+t get\+Queue\+Info (\begin{DoxyParamCaption}\item[{std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point \&}]{first}{, }\item[{std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point \&}]{last}{}\end{DoxyParamCaption}) const}

Returns number of tasks waiting to be serviced, and first and last task times \index{CScheduler@{CScheduler}!MockForward@{MockForward}}
\index{MockForward@{MockForward}!CScheduler@{CScheduler}}
\doxysubsubsection{MockForward()}
{\footnotesize\ttfamily \label{class_c_scheduler_a164bd31b14643a1063d6361c9f76da3f} 
void Mock\+Forward (\begin{DoxyParamCaption}\item[{std\+::chrono\+::seconds}]{delta\+\_\+seconds}{}\end{DoxyParamCaption})}

Mock the scheduler to fast forward in time. Iterates through items on task\+Queue and reschedules them to be delta\+\_\+seconds sooner. \index{CScheduler@{CScheduler}!schedule@{schedule}}
\index{schedule@{schedule}!CScheduler@{CScheduler}}
\doxysubsubsection{schedule()}
{\footnotesize\ttfamily \label{class_c_scheduler_a243fcdfb5446405a84dffc4da757d18b} 
void schedule (\begin{DoxyParamCaption}\item[{\textbf{ CScheduler\+::\+Function}}]{f}{, }\item[{std\+::chrono\+::steady\+\_\+clock\+::time\+\_\+point}]{t}{}\end{DoxyParamCaption})}

Call func at/after time t \index{CScheduler@{CScheduler}!scheduleEvery@{scheduleEvery}}
\index{scheduleEvery@{scheduleEvery}!CScheduler@{CScheduler}}
\doxysubsubsection{scheduleEvery()}
{\footnotesize\ttfamily \label{class_c_scheduler_afc967db034e89889059bca31574ec485} 
void schedule\+Every (\begin{DoxyParamCaption}\item[{\textbf{ CScheduler\+::\+Function}}]{f}{, }\item[{std\+::chrono\+::milliseconds}]{delta}{}\end{DoxyParamCaption})}

Repeat f until the scheduler is stopped. First run is after delta has passed once.

The timing is not exact\+: Every time f is finished, it is rescheduled to run again after delta. If you need more accurate scheduling, don\textquotesingle{}t use this method. \index{CScheduler@{CScheduler}!scheduleFromNow@{scheduleFromNow}}
\index{scheduleFromNow@{scheduleFromNow}!CScheduler@{CScheduler}}
\doxysubsubsection{scheduleFromNow()}
{\footnotesize\ttfamily \label{class_c_scheduler_afdb52271200f958fa88b14b94546bb20} 
void schedule\+From\+Now (\begin{DoxyParamCaption}\item[{\textbf{ Function}}]{f}{, }\item[{std\+::chrono\+::milliseconds}]{delta}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Call f once after the delta has passed \index{CScheduler@{CScheduler}!serviceQueue@{serviceQueue}}
\index{serviceQueue@{serviceQueue}!CScheduler@{CScheduler}}
\doxysubsubsection{serviceQueue()}
{\footnotesize\ttfamily \label{class_c_scheduler_a3c51a70f4b0106c4ee6f9dbad3f3da68} 
void service\+Queue (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Services the queue \textquotesingle{}forever\textquotesingle{}. Should be run in a thread. \index{CScheduler@{CScheduler}!stop@{stop}}
\index{stop@{stop}!CScheduler@{CScheduler}}
\doxysubsubsection{stop()}
{\footnotesize\ttfamily \label{class_c_scheduler_aded9b7a535edbef852c49e31f8ffa8a2} 
void stop (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Tell any threads running service\+Queue to stop as soon as the current task is done \index{CScheduler@{CScheduler}!StopWhenDrained@{StopWhenDrained}}
\index{StopWhenDrained@{StopWhenDrained}!CScheduler@{CScheduler}}
\doxysubsubsection{StopWhenDrained()}
{\footnotesize\ttfamily \label{class_c_scheduler_a351504618ec55e33093a42e14f67e842} 
void Stop\+When\+Drained (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Tell any threads running service\+Queue to stop when there is no work left to be done 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CScheduler@{CScheduler}!m\_service\_thread@{m\_service\_thread}}
\index{m\_service\_thread@{m\_service\_thread}!CScheduler@{CScheduler}}
\doxysubsubsection{m\_service\_thread}
{\footnotesize\ttfamily \label{class_c_scheduler_a6d839daab9225235d84cf6997c3f0ba2} 
std\+::thread m\+\_\+service\+\_\+thread}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ scheduler.\+h}\item 
src/\textbf{ scheduler.\+cpp}\end{DoxyCompactItemize}
