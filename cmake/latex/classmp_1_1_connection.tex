\doxysection{Connection Class Reference}
\label{classmp_1_1_connection}\index{Connection@{Connection}}


{\ttfamily \#include $<$proxy-\/io.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Connection} (\textbf{ Event\+Loop} \&loop, kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \&\&stream\+\_\+)
\item 
\textbf{ Connection} (\textbf{ Event\+Loop} \&loop, kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \&\&stream\+\_\+, const std\+::function$<$\+::capnp\+::\+Capability\+::\+Client(Connection \&)$>$ \&make\+\_\+client)
\item 
\textbf{ $\sim$\+Connection} ()
\item 
\textbf{ Cleanup\+It} \textbf{ add\+Sync\+Cleanup} (std\+::function$<$ void()$>$ fn)
\item 
void \textbf{ remove\+Sync\+Cleanup} (\textbf{ Cleanup\+It} it)
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ on\+Disconnect} (F \&\&f)
\begin{DoxyCompactList}\small\item\em Add disconnect handler. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
\textbf{ Event\+Loop\+Ref} \textbf{ m\+\_\+loop}
\item 
kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \textbf{ m\+\_\+stream}
\item 
\textbf{ Logging\+Error\+Handler} \textbf{ m\+\_\+error\+\_\+handler} \{$\ast$\textbf{ m\+\_\+loop}\}
\item 
kj\+::\+Task\+Set \textbf{ m\+\_\+on\+\_\+disconnect} \{\textbf{ m\+\_\+error\+\_\+handler}\}
\item 
\+::capnp\+::\+Two\+Party\+Vat\+Network \textbf{ m\+\_\+network}
\item 
std\+::optional$<$\+::capnp\+::\+Rpc\+System$<$\+::capnp\+::rpc\+::twoparty\+::\+Vat\+Id $>$ $>$ \textbf{ m\+\_\+rpc\+\_\+system}
\item 
Thread\+Map\+::\+Client \textbf{ m\+\_\+thread\+\_\+map} \{nullptr\}
\item 
\+::capnp\+::\+Capability\+Server\+Set$<$ Thread $>$ \textbf{ m\+\_\+threads}
\item 
\textbf{ Cleanup\+List} \textbf{ m\+\_\+sync\+\_\+cleanup\+\_\+fns}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Object holding network \& rpc state associated with either an incoming server connection, or an outgoing client connection. It must be created and destroyed on the event loop thread. In addition to Cap\textquotesingle{}n Proto state, it also holds lists of callbacks to run when the connection is closed. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Connection@{Connection}!Connection@{Connection}}
\index{Connection@{Connection}!Connection@{Connection}}
\doxysubsubsection{Connection()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classmp_1_1_connection_af29bbec879064beec9441a1078bddec3} 
Connection (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \&\&}]{stream\+\_\+}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Connection@{Connection}!Connection@{Connection}}
\index{Connection@{Connection}!Connection@{Connection}}
\doxysubsubsection{Connection()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a5f5fe74aee9f84ce7c92450be96dc090} 
Connection (\begin{DoxyParamCaption}\item[{\textbf{ Event\+Loop} \&}]{loop}{, }\item[{kj\+::\+Own$<$ kj\+::\+Async\+Io\+Stream $>$ \&\&}]{stream\+\_\+}{, }\item[{const std\+::function$<$\+::capnp\+::\+Capability\+::\+Client(Connection \&)$>$ \&}]{make\+\_\+client}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{Connection@{Connection}!````~Connection@{$\sim$Connection}}
\index{````~Connection@{$\sim$Connection}!Connection@{Connection}}
\doxysubsubsection{$\sim$Connection()}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a7a3e1a734e64796b393be72275bcb246} 
$\sim$\textbf{ Connection} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Run cleanup functions. Must be called from the event loop thread. First calls synchronous cleanup functions while blocked (to free capnp Capability\+::\+Client handles owned by \doxyref{Proxy\+Client}{p.}{structmp_1_1_proxy_client} objects), then schedules asynchronous cleanup functions to run in a worker thread (to run destructors of m\+\_\+impl instances owned by \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} objects). 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Connection@{Connection}!addSyncCleanup@{addSyncCleanup}}
\index{addSyncCleanup@{addSyncCleanup}!Connection@{Connection}}
\doxysubsubsection{addSyncCleanup()}
{\footnotesize\ttfamily \label{classmp_1_1_connection_ae675a54e813b980ddd62a73db7eb39c4} 
\textbf{ Cleanup\+It} add\+Sync\+Cleanup (\begin{DoxyParamCaption}\item[{std\+::function$<$ void()$>$}]{fn}{}\end{DoxyParamCaption})}

Register synchronous cleanup function to run on event loop thread (with access to capnp thread local variables) when disconnect() is called. any new i/o. \index{Connection@{Connection}!onDisconnect@{onDisconnect}}
\index{onDisconnect@{onDisconnect}!Connection@{Connection}}
\doxysubsubsection{onDisconnect()}
{\footnotesize\ttfamily \label{classmp_1_1_connection_ad80dba71352898ebf4e8f88028ddc7e1} 
template$<$typename F$>$ \\
void on\+Disconnect (\begin{DoxyParamCaption}\item[{F \&\&}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Add disconnect handler. 

\index{Connection@{Connection}!removeSyncCleanup@{removeSyncCleanup}}
\index{removeSyncCleanup@{removeSyncCleanup}!Connection@{Connection}}
\doxysubsubsection{removeSyncCleanup()}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a66043c6fa3b03740d87ba143a21fd683} 
void remove\+Sync\+Cleanup (\begin{DoxyParamCaption}\item[{\textbf{ Cleanup\+It}}]{it}{}\end{DoxyParamCaption})}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{Connection@{Connection}!m\_error\_handler@{m\_error\_handler}}
\index{m\_error\_handler@{m\_error\_handler}!Connection@{Connection}}
\doxysubsubsection{m\_error\_handler}
{\footnotesize\ttfamily \label{classmp_1_1_connection_aa3a0b29328e0fc0ec8b26132feb0fcc5} 
\textbf{ Logging\+Error\+Handler} m\+\_\+error\+\_\+handler \{$\ast$\textbf{ m\+\_\+loop}\}}

\index{Connection@{Connection}!m\_loop@{m\_loop}}
\index{m\_loop@{m\_loop}!Connection@{Connection}}
\doxysubsubsection{m\_loop}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a37b5b5040fdf06491742db64e929dbeb} 
\textbf{ Event\+Loop\+Ref} m\+\_\+loop}

\index{Connection@{Connection}!m\_network@{m\_network}}
\index{m\_network@{m\_network}!Connection@{Connection}}
\doxysubsubsection{m\_network}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a54d27701ff67ea0db8ae9e852c274d30} 
\+::capnp\+::\+Two\+Party\+Vat\+Network m\+\_\+network}

\index{Connection@{Connection}!m\_on\_disconnect@{m\_on\_disconnect}}
\index{m\_on\_disconnect@{m\_on\_disconnect}!Connection@{Connection}}
\doxysubsubsection{m\_on\_disconnect}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a20da0cbcf16fc5a09b87c061496cb1b1} 
kj\+::\+Task\+Set m\+\_\+on\+\_\+disconnect \{\textbf{ m\+\_\+error\+\_\+handler}\}}

\index{Connection@{Connection}!m\_rpc\_system@{m\_rpc\_system}}
\index{m\_rpc\_system@{m\_rpc\_system}!Connection@{Connection}}
\doxysubsubsection{m\_rpc\_system}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a67cb43da9e4f67dbc9d6a74a3c301a0e} 
std\+::optional$<$\+::capnp\+::\+Rpc\+System$<$\+::capnp\+::rpc\+::twoparty\+::\+Vat\+Id$>$ $>$ m\+\_\+rpc\+\_\+system}

\index{Connection@{Connection}!m\_stream@{m\_stream}}
\index{m\_stream@{m\_stream}!Connection@{Connection}}
\doxysubsubsection{m\_stream}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a826fdcefcc3eae8215a8b1d8628892bc} 
kj\+::\+Own$<$kj\+::\+Async\+Io\+Stream$>$ m\+\_\+stream}

\index{Connection@{Connection}!m\_sync\_cleanup\_fns@{m\_sync\_cleanup\_fns}}
\index{m\_sync\_cleanup\_fns@{m\_sync\_cleanup\_fns}!Connection@{Connection}}
\doxysubsubsection{m\_sync\_cleanup\_fns}
{\footnotesize\ttfamily \label{classmp_1_1_connection_ae364219e4df65bbd818bcfada34e4311} 
\textbf{ Cleanup\+List} m\+\_\+sync\+\_\+cleanup\+\_\+fns}

Cleanup functions to run if connection is broken unexpectedly. List will be empty if all \doxyref{Proxy\+Client}{p.}{structmp_1_1_proxy_client} are destroyed cleanly before the connection is destroyed. \index{Connection@{Connection}!m\_thread\_map@{m\_thread\_map}}
\index{m\_thread\_map@{m\_thread\_map}!Connection@{Connection}}
\doxysubsubsection{m\_thread\_map}
{\footnotesize\ttfamily \label{classmp_1_1_connection_aa8499cb4f42a4f1fb12b46a450bfc951} 
Thread\+Map\+::\+Client m\+\_\+thread\+\_\+map \{nullptr\}}

\index{Connection@{Connection}!m\_threads@{m\_threads}}
\index{m\_threads@{m\_threads}!Connection@{Connection}}
\doxysubsubsection{m\_threads}
{\footnotesize\ttfamily \label{classmp_1_1_connection_a1008c41395d28e937364a9806754856c} 
\+::capnp\+::\+Capability\+Server\+Set$<$Thread$>$ m\+\_\+threads}

Collection of server-\/side IPC worker threads (\doxyref{Proxy\+Server$<$\+Thread$>$}{p.}{structmp_1_1_proxy_server_3_01_thread_01_4} objects previously returned by Thread\+Map.\+make\+Thread) used to service requests to clients. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/ipc/libmultiprocess/include/mp/\textbf{ proxy-\/io.\+h}\item 
src/ipc/libmultiprocess/src/mp/\textbf{ proxy.\+cpp}\end{DoxyCompactItemize}
