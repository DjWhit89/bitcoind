\doxysection{src/minisketch/src/sketch\+\_\+impl.h File Reference}
\label{sketch__impl_8h}\index{src/minisketch/src/sketch\_impl.h@{src/minisketch/src/sketch\_impl.h}}
{\ttfamily \#include $<$random$>$}\newline
{\ttfamily \#include "{}util.\+h"{}}\newline
{\ttfamily \#include "{}sketch.\+h"{}}\newline
{\ttfamily \#include "{}int\+\_\+utils.\+h"{}}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Sketch\+Impl$<$ F $>$}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ Poly\+Mod} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&mod, std\+::vector$<$ typename F\+::\+Elem $>$ \&val, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ Div\+Mod} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&mod, std\+::vector$<$ typename F\+::\+Elem $>$ \&val, std\+::vector$<$ typename F\+::\+Elem $>$ \&div, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\F\+::\+Elem \textbf{ Make\+Monic} (std\+::vector$<$ typename F\+::\+Elem $>$ \&a, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ GCD} (std\+::vector$<$ typename F\+::\+Elem $>$ \&a, std\+::vector$<$ typename F\+::\+Elem $>$ \&b, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ Sqr} (std\+::vector$<$ typename F\+::\+Elem $>$ \&poly, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ Trace\+Mod} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&mod, std\+::vector$<$ typename F\+::\+Elem $>$ \&out, const typename F\+::\+Elem \&param, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\bool \textbf{ Rec\+Find\+Roots} (std\+::vector$<$ std\+::vector$<$ typename F\+::\+Elem $>$ $>$ \&stack, size\+\_\+t pos, std\+::vector$<$ typename F\+::\+Elem $>$ \&roots, bool fully\+\_\+factorizable, int depth, typename F\+::\+Elem randv, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\std\+::vector$<$ typename F\+::\+Elem $>$ \textbf{ Find\+Roots} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&poly, typename F\+::\+Elem basis, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\std\+::vector$<$ typename F\+::\+Elem $>$ \textbf{ Berlekamp\+Massey} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&syndromes, size\+\_\+t max\+\_\+degree, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\std\+::vector$<$ typename F\+::\+Elem $>$ \textbf{ Reconstruct\+All\+Syndromes} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&odd\+\_\+syndromes, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\void \textbf{ Add\+To\+Odd\+Syndromes} (std\+::vector$<$ typename F\+::\+Elem $>$ \&osyndromes, typename F\+::\+Elem data, const F \&field)
\item 
{\footnotesize template$<$typename F$>$ }\\std\+::vector$<$ typename F\+::\+Elem $>$ \textbf{ Full\+Decode} (const std\+::vector$<$ typename F\+::\+Elem $>$ \&osyndromes, const F \&field)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{sketch\_impl.h@{sketch\_impl.h}!AddToOddSyndromes@{AddToOddSyndromes}}
\index{AddToOddSyndromes@{AddToOddSyndromes}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{AddToOddSyndromes()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a27a3b7f393ce8a65e7a0b3c53fc98351} 
template$<$typename F$>$ \\
void Add\+To\+Odd\+Syndromes (\begin{DoxyParamCaption}\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{osyndromes}{, }\item[{typename F\+::\+Elem}]{data}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

\index{sketch\_impl.h@{sketch\_impl.h}!BerlekampMassey@{BerlekampMassey}}
\index{BerlekampMassey@{BerlekampMassey}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{BerlekampMassey()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a84321ada8783a7739ab1951f93be51f7} 
template$<$typename F$>$ \\
std\+::vector$<$ typename F\+::\+Elem $>$ Berlekamp\+Massey (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{syndromes}{, }\item[{size\+\_\+t}]{max\+\_\+degree}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

\index{sketch\_impl.h@{sketch\_impl.h}!DivMod@{DivMod}}
\index{DivMod@{DivMod}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{DivMod()}
{\footnotesize\ttfamily \label{sketch__impl_8h_ab763a1ca30922377876b154fc8b6fc0b} 
template$<$typename F$>$ \\
void Div\+Mod (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{mod}{, }\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{val}{, }\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{div}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Compute the quotient of a polynomial division of val by mod, putting the quotient in div and the remainder in val. \index{sketch\_impl.h@{sketch\_impl.h}!FindRoots@{FindRoots}}
\index{FindRoots@{FindRoots}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{FindRoots()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a993634c0879d106caf86b23371285d0f} 
template$<$typename F$>$ \\
std\+::vector$<$ typename F\+::\+Elem $>$ Find\+Roots (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{poly}{, }\item[{typename F\+::\+Elem}]{basis}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Returns the roots of a fully factorizable polynomial

This function assumes that the input polynomial is square-\/free and not the zero polynomial (represented by an empty vector).

In case the square-\/free polynomial is not fully factorizable, i.\+e., it has fewer roots than its degree, the empty vector is returned. \index{sketch\_impl.h@{sketch\_impl.h}!FullDecode@{FullDecode}}
\index{FullDecode@{FullDecode}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{FullDecode()}
{\footnotesize\ttfamily \label{sketch__impl_8h_ad026b20e6f1a643d5e520531ba74c42e} 
template$<$typename F$>$ \\
std\+::vector$<$ typename F\+::\+Elem $>$ Full\+Decode (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{osyndromes}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

\index{sketch\_impl.h@{sketch\_impl.h}!GCD@{GCD}}
\index{GCD@{GCD}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{GCD()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a6655f2456a87dafa6366b8507a437e72} 
template$<$typename F$>$ \\
void GCD (\begin{DoxyParamCaption}\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{a}{, }\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{b}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Compute the GCD of two polynomials, putting the result in a. b will be cleared. \index{sketch\_impl.h@{sketch\_impl.h}!MakeMonic@{MakeMonic}}
\index{MakeMonic@{MakeMonic}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{MakeMonic()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a912efbc4f33bd2ce5d3e1e2007a4b756} 
template$<$typename F$>$ \\
F\+::\+Elem Make\+Monic (\begin{DoxyParamCaption}\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{a}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Make a polynomial monic. \index{sketch\_impl.h@{sketch\_impl.h}!PolyMod@{PolyMod}}
\index{PolyMod@{PolyMod}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{PolyMod()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a4f7b3f9a0c2bb6fc79c680fb2313008b} 
template$<$typename F$>$ \\
void Poly\+Mod (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{mod}{, }\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{val}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Compute the remainder of a polynomial division of val by mod, putting the result in mod. \index{sketch\_impl.h@{sketch\_impl.h}!RecFindRoots@{RecFindRoots}}
\index{RecFindRoots@{RecFindRoots}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{RecFindRoots()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a2ec3bcfdba89a36bd384e48ecb40616d} 
template$<$typename F$>$ \\
bool Rec\+Find\+Roots (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ typename F\+::\+Elem $>$ $>$ \&}]{stack}{, }\item[{size\+\_\+t}]{pos}{, }\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{roots}{, }\item[{bool}]{fully\+\_\+factorizable}{, }\item[{int}]{depth}{, }\item[{typename F\+::\+Elem}]{randv}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

One step of the root finding algorithm; finds roots of stack[pos] and adds them to roots. Stack elements $>$= pos are destroyed.

It operates on a stack of polynomials. The polynomial operated on is {\ttfamily stack[pos]}, where elements of {\ttfamily stack} with index higher than {\ttfamily pos} are used as scratch space.

{\ttfamily stack[pos]} is assumed to be square-\/free polynomial. If {\ttfamily fully\+\_\+factorizable} is true, it is also assumed to have no irreducible factors of degree higher than 1.

This implements the Berlekamp trace algorithm, plus an efficient test to fail fast in case the polynomial cannot be fully factored. \index{sketch\_impl.h@{sketch\_impl.h}!ReconstructAllSyndromes@{ReconstructAllSyndromes}}
\index{ReconstructAllSyndromes@{ReconstructAllSyndromes}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{ReconstructAllSyndromes()}
{\footnotesize\ttfamily \label{sketch__impl_8h_afcd8c0d2739f7f2c2ae576cdcb21069b} 
template$<$typename F$>$ \\
std\+::vector$<$ typename F\+::\+Elem $>$ Reconstruct\+All\+Syndromes (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{odd\+\_\+syndromes}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

\index{sketch\_impl.h@{sketch\_impl.h}!Sqr@{Sqr}}
\index{Sqr@{Sqr}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{Sqr()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a999f039ffacc96127c9bbe28cdeada0d} 
template$<$typename F$>$ \\
void Sqr (\begin{DoxyParamCaption}\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{poly}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Square a polynomial. \index{sketch\_impl.h@{sketch\_impl.h}!TraceMod@{TraceMod}}
\index{TraceMod@{TraceMod}!sketch\_impl.h@{sketch\_impl.h}}
\doxysubsubsection{TraceMod()}
{\footnotesize\ttfamily \label{sketch__impl_8h_a2f4c5cbdc39635790a1525ee8091c24e} 
template$<$typename F$>$ \\
void Trace\+Mod (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{mod}{, }\item[{std\+::vector$<$ typename F\+::\+Elem $>$ \&}]{out}{, }\item[{const typename F\+::\+Elem \&}]{param}{, }\item[{const F \&}]{field}{}\end{DoxyParamCaption})}

Compute the trace map of (param$\ast$x) modulo mod, putting the result in out. 