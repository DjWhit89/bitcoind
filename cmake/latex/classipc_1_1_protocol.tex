\doxysection{Protocol Class Reference}
\label{classipc_1_1_protocol}\index{Protocol@{Protocol}}


{\ttfamily \#include $<$protocol.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+Protocol} ()=default
\item 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ interfaces\+::\+Init} $>$ \textbf{ connect} (int fd, const char $\ast$exe\+\_\+name)=0
\item 
virtual void \textbf{ listen} (int listen\+\_\+fd, const char $\ast$exe\+\_\+name, \textbf{ interfaces\+::\+Init} \&\textbf{ init})=0
\item 
virtual void \textbf{ serve} (int fd, const char $\ast$exe\+\_\+name, \textbf{ interfaces\+::\+Init} \&\textbf{ init}, const std\+::function$<$ void()$>$ \&ready\+\_\+fn=\{\})=0
\item 
virtual void \textbf{ disconnect\+Incoming} ()=0
\begin{DoxyCompactList}\small\item\em Disconnect any incoming connections that are still connected. \end{DoxyCompactList}\item 
virtual void \textbf{ add\+Cleanup} (std\+::type\+\_\+index type, void $\ast$iface, std\+::function$<$ void()$>$ cleanup)=0
\item 
virtual \textbf{ Context} \& \textbf{ context} ()=0
\begin{DoxyCompactList}\small\item\em \doxyref{Context}{p.}{structipc_1_1_context} accessor. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
IPC protocol interface for calling IPC methods over sockets.

There may be different implementations of this interface for different IPC protocols (e.\+g. Cap\textquotesingle{}n Proto, g\+RPC, JSON-\/\+RPC, or custom protocols). 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Protocol@{Protocol}!````~Protocol@{$\sim$Protocol}}
\index{````~Protocol@{$\sim$Protocol}!Protocol@{Protocol}}
\doxysubsubsection{$\sim$Protocol()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_ae8dff142c91e726e5e1ca3abff872adf} 
virtual $\sim$\textbf{ Protocol} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Protocol@{Protocol}!addCleanup@{addCleanup}}
\index{addCleanup@{addCleanup}!Protocol@{Protocol}}
\doxysubsubsection{addCleanup()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_ab752d262895c2173617749fea06bcba1} 
virtual void add\+Cleanup (\begin{DoxyParamCaption}\item[{std\+::type\+\_\+index}]{type}{, }\item[{void $\ast$}]{iface}{, }\item[{std\+::function$<$ void()$>$}]{cleanup}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Add cleanup callback to interface that will run when the interface is deleted. \index{Protocol@{Protocol}!connect@{connect}}
\index{connect@{connect}!Protocol@{Protocol}}
\doxysubsubsection{connect()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_a098584fc42adacc9ecfd5dc910fea66f} 
virtual std\+::unique\+\_\+ptr$<$ \textbf{ interfaces\+::\+Init} $>$ connect (\begin{DoxyParamCaption}\item[{int}]{fd}{, }\item[{const char $\ast$}]{exe\+\_\+name}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Return \doxyref{Init}{p.}{class_init} interface that forwards requests over given socket descriptor. Socket communication is handled on a background thread.

\begin{DoxyNote}{Note}
It could be potentially useful in the future to add std\+::function$<$void()$>$ on\+\_\+disconnect callback argument here. But there isn\textquotesingle{}t an immediate need, because the protocol implementation can clean up its own state (calling Proxy\+Server destructors, etc) on disconnect, and any client calls will just throw \doxyref{ipc\+::\+Exception}{p.}{classipc_1_1_exception} errors after a disconnect. 
\end{DoxyNote}
\index{Protocol@{Protocol}!context@{context}}
\index{context@{context}!Protocol@{Protocol}}
\doxysubsubsection{context()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_a4b2af83137ac1ea8dd7afb875940b3cb} 
virtual \textbf{ Context} \& context (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



\doxyref{Context}{p.}{structipc_1_1_context} accessor. 

\index{Protocol@{Protocol}!disconnectIncoming@{disconnectIncoming}}
\index{disconnectIncoming@{disconnectIncoming}!Protocol@{Protocol}}
\doxysubsubsection{disconnectIncoming()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_a45306c63b743375d0db4f613d2de7300} 
virtual void disconnect\+Incoming (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Disconnect any incoming connections that are still connected. 

\index{Protocol@{Protocol}!listen@{listen}}
\index{listen@{listen}!Protocol@{Protocol}}
\doxysubsubsection{listen()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_aefda533b5b61d4d7c1e4aa513ee94aa9} 
virtual void listen (\begin{DoxyParamCaption}\item[{int}]{listen\+\_\+fd}{, }\item[{const char $\ast$}]{exe\+\_\+name}{, }\item[{\textbf{ interfaces\+::\+Init} \&}]{init}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Listen for connections on provided socket descriptor, accept them, and handle requests on accepted connections. This method doesn\textquotesingle{}t block, and performs I/O on a background thread. \index{Protocol@{Protocol}!serve@{serve}}
\index{serve@{serve}!Protocol@{Protocol}}
\doxysubsubsection{serve()}
{\footnotesize\ttfamily \label{classipc_1_1_protocol_a5249513dbbca3afe53c192be98ac7504} 
virtual void serve (\begin{DoxyParamCaption}\item[{int}]{fd}{, }\item[{const char $\ast$}]{exe\+\_\+name}{, }\item[{\textbf{ interfaces\+::\+Init} \&}]{init}{, }\item[{const std\+::function$<$ void()$>$ \&}]{ready\+\_\+fn}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Handle requests on provided socket descriptor, forwarding them to the provided \doxyref{Init}{p.}{class_init} interface. Socket communication is handled on the current thread, and this call blocks until the socket is closed.

\begin{DoxyNote}{Note}
\+: If this method is called, it needs be called before \doxyref{connect()}{p.}{classipc_1_1_protocol_a098584fc42adacc9ecfd5dc910fea66f} or \doxyref{listen()}{p.}{classipc_1_1_protocol_aefda533b5b61d4d7c1e4aa513ee94aa9} methods, because for ease of implementation it\textquotesingle{}s inflexible and always runs the event loop in the foreground thread. It can share its event loop with the other methods but can\textquotesingle{}t share an event loop that was created by them. This isn\textquotesingle{}t really a problem because \doxyref{serve()}{p.}{classipc_1_1_protocol_a5249513dbbca3afe53c192be98ac7504} is only called by spawned child processes that call it immediately to communicate back with parent processes.
\end{DoxyNote}
The optional {\ttfamily ready\+\_\+fn} callback will be called after the event loop is created but before it is started. This can be useful in tests to trigger client connections from another thread as soon as the event loop is available, but should not be necessary in normal code which starts clients and servers independently. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/ipc/\textbf{ protocol.\+h}\end{DoxyCompactItemize}
