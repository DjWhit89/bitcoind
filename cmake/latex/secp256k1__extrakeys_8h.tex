\doxysection{src/secp256k1/include/secp256k1\+\_\+extrakeys.h File Reference}
\label{secp256k1__extrakeys_8h}\index{src/secp256k1/include/secp256k1\_extrakeys.h@{src/secp256k1/include/secp256k1\_extrakeys.h}}
{\ttfamily \#include "{}secp256k1.\+h"{}}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey}
\item 
struct \textbf{ secp256k1\+\_\+keypair}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct secp256k1\+\_\+xonly\+\_\+pubkey \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey}
\item 
typedef struct secp256k1\+\_\+keypair \textbf{ secp256k1\+\_\+keypair}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+parse} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey, const unsigned char $\ast$input32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+serialize} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$output32, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+cmp} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pk1, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pk2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$xonly\+\_\+pubkey, int $\ast$pk\+\_\+parity, const \textbf{ secp256k1\+\_\+pubkey} $\ast$pubkey) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$output\+\_\+pubkey, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$internal\+\_\+pubkey, const unsigned char $\ast$tweak32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add\+\_\+check} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, const unsigned char $\ast$tweaked\+\_\+pubkey32, int tweaked\+\_\+pk\+\_\+parity, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$internal\+\_\+pubkey, const unsigned char $\ast$tweak32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(5)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+keypair\+\_\+create} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, const unsigned char $\ast$seckey) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+keypair\+\_\+sec} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$seckey, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+keypair\+\_\+pub} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$pubkey, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+keypair\+\_\+xonly\+\_\+pub} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey, int $\ast$pk\+\_\+parity, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+keypair\+\_\+xonly\+\_\+tweak\+\_\+add} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, const unsigned char $\ast$tweak32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_keypair@{secp256k1\_keypair}}
\index{secp256k1\_keypair@{secp256k1\_keypair}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_keypair}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_ad8d14ec4a23d43f16eb45e216c414a9b} 
typedef struct secp256k1\+\_\+keypair secp256k1\+\_\+keypair}

Opaque data structure that holds a keypair consisting of a secret and a public key.

The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions. It is however guaranteed to be 96 bytes in size, and can be safely copied/moved. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey@{secp256k1\_xonly\_pubkey}}
\index{secp256k1\_xonly\_pubkey@{secp256k1\_xonly\_pubkey}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a0868e774c9b0692ede20b4ce2a7d2a85} 
typedef struct secp256k1\+\_\+xonly\+\_\+pubkey secp256k1\+\_\+xonly\+\_\+pubkey}

Opaque data structure that holds a parsed and valid "{}x-\/only"{} public key. An x-\/only pubkey encodes a point whose Y coordinate is even. It is serialized using only its X coordinate (32 bytes). See BIP-\/340 for more information about x-\/only pubkeys.

The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions. It is however guaranteed to be 64 bytes in size, and can be safely copied/moved. If you need to convert to a format suitable for storage, transmission, use use secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+serialize and secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+parse. To compare keys, use secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+cmp. 

\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_keypair\_create@{secp256k1\_keypair\_create}}
\index{secp256k1\_keypair\_create@{secp256k1\_keypair\_create}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_keypair\_create()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a61b1362ada2435ab10240e52ff738476} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+keypair\+\_\+create (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{const unsigned char $\ast$}]{seckey}{}\end{DoxyParamCaption})}

Compute the keypair for a valid secret key.

See the documentation of {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify}{p.}{secp256k1_8h_a366f922fc0c787351e82ff8e3a95f652}} for more information about the validity of secret keys.

Returns\+: 1\+: secret key is valid 0\+: secret key is invalid Args\+: ctx\+: pointer to a context object (not secp256k1\+\_\+context\+\_\+static). Out\+: keypair\+: pointer to the created keypair. In\+: seckey\+: pointer to a 32-\/byte secret key. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_keypair\_pub@{secp256k1\_keypair\_pub}}
\index{secp256k1\_keypair\_pub@{secp256k1\_keypair\_pub}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_keypair\_pub()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_af9c115df738fabe6b04574d4880495bc} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+keypair\+\_\+pub (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{}\end{DoxyParamCaption})}

Get the public key from a keypair.

Returns\+: 1 always. Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to a pubkey object, set to the keypair public key. In\+: keypair\+: pointer to a keypair. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_keypair\_sec@{secp256k1\_keypair\_sec}}
\index{secp256k1\_keypair\_sec@{secp256k1\_keypair\_sec}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_keypair\_sec()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_aff2e05c76e2eeac729a1eec6796778b8} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+keypair\+\_\+sec (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{seckey}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{}\end{DoxyParamCaption})}

Get the secret key from a keypair.

Returns\+: 1 always. Args\+: ctx\+: pointer to a context object. Out\+: seckey\+: pointer to a 32-\/byte buffer for the secret key. In\+: keypair\+: pointer to a keypair. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_keypair\_xonly\_pub@{secp256k1\_keypair\_xonly\_pub}}
\index{secp256k1\_keypair\_xonly\_pub@{secp256k1\_keypair\_xonly\_pub}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_keypair\_xonly\_pub()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a96800411deb08bb3b6b0876fea6f6eb4} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+keypair\+\_\+xonly\+\_\+pub (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{int $\ast$}]{pk\+\_\+parity}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{}\end{DoxyParamCaption})}

Get the x-\/only public key from a keypair.

This is the same as calling secp256k1\+\_\+keypair\+\_\+pub and then secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey.

Returns\+: 1 always. Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to an xonly\+\_\+pubkey object, set to the keypair public key after converting it to an xonly\+\_\+pubkey. pk\+\_\+parity\+: Ignored if NULL. Otherwise, pointer to an integer that will be set to the pk\+\_\+parity argument of secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey. In\+: keypair\+: pointer to a keypair. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_keypair\_xonly\_tweak\_add@{secp256k1\_keypair\_xonly\_tweak\_add}}
\index{secp256k1\_keypair\_xonly\_tweak\_add@{secp256k1\_keypair\_xonly\_tweak\_add}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_keypair\_xonly\_tweak\_add()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_aa99a68bfe473704d08eac556915883b6} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+keypair\+\_\+xonly\+\_\+tweak\+\_\+add (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Tweak a keypair by adding tweak32 to the secret key and updating the public key accordingly.

Calling this function and then secp256k1\+\_\+keypair\+\_\+pub results in the same public key as calling secp256k1\+\_\+keypair\+\_\+xonly\+\_\+pub and then secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add.

Returns\+: 0 if the arguments are invalid or the resulting keypair would be invalid (only when the tweak is the negation of the keypair\textquotesingle{}s secret key). 1 otherwise.

Args\+: ctx\+: pointer to a context object. In/\+Out\+: keypair\+: pointer to a keypair to apply the tweak to. Will be set to an invalid value if this function returns 0. In\+: tweak32\+: pointer to a 32-\/byte tweak, which must be valid according to secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify or 32 zero bytes. For uniformly random 32-\/byte tweaks, the chance of being invalid is negligible (around 1 in 2$^\wedge$128). \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey\_cmp@{secp256k1\_xonly\_pubkey\_cmp}}
\index{secp256k1\_xonly\_pubkey\_cmp@{secp256k1\_xonly\_pubkey\_cmp}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_cmp()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a06f07f2cde819fd612ff4cc13e785aa9} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+cmp (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pk1}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pk2}{}\end{DoxyParamCaption})}

Compare two x-\/only public keys using lexicographic order

Returns\+: $<$0 if the first public key is less than the second $>$0 if the first public key is greater than the second 0 if the two public keys are equal Args\+: ctx\+: pointer to a context object. In\+: pubkey1\+: first public key to compare pubkey2\+: second public key to compare \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey\_from\_pubkey@{secp256k1\_xonly\_pubkey\_from\_pubkey}}
\index{secp256k1\_xonly\_pubkey\_from\_pubkey@{secp256k1\_xonly\_pubkey\_from\_pubkey}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_from\_pubkey()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a38e6de43d8ee12d83e5cc85c47fcdc98} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+from\+\_\+pubkey (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{xonly\+\_\+pubkey}{, }\item[{int $\ast$}]{pk\+\_\+parity}{, }\item[{const \textbf{ secp256k1\+\_\+pubkey} $\ast$}]{pubkey}{}\end{DoxyParamCaption})}

Converts a \doxyref{secp256k1\+\_\+pubkey}{p.}{structsecp256k1__pubkey} into a \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey}.

Returns\+: 1 always.

Args\+: ctx\+: pointer to a context object. Out\+: xonly\+\_\+pubkey\+: pointer to an x-\/only public key object for placing the converted public key. pk\+\_\+parity\+: Ignored if NULL. Otherwise, pointer to an integer that will be set to 1 if the point encoded by xonly\+\_\+pubkey is the negation of the pubkey and set to 0 otherwise. In\+: pubkey\+: pointer to a public key that is converted. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey\_parse@{secp256k1\_xonly\_pubkey\_parse}}
\index{secp256k1\_xonly\_pubkey\_parse@{secp256k1\_xonly\_pubkey\_parse}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_parse()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_ad9e5f1dae6a1e3e03d0093aa17e6c21c} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+parse (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{const unsigned char $\ast$}]{input32}{}\end{DoxyParamCaption})}

Parse a 32-\/byte sequence into a xonly\+\_\+pubkey object.

Returns\+: 1 if the public key was fully valid. 0 if the public key could not be parsed or is invalid.

Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to a pubkey object. If 1 is returned, it is set to a parsed version of input. If not, it\textquotesingle{}s set to an invalid value. In\+: input32\+: pointer to a serialized xonly\+\_\+pubkey. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey\_serialize@{secp256k1\_xonly\_pubkey\_serialize}}
\index{secp256k1\_xonly\_pubkey\_serialize@{secp256k1\_xonly\_pubkey\_serialize}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_serialize()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a455e86be0f18f4313ba8ea73e34a25a6} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+serialize (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{output32}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{}\end{DoxyParamCaption})}

Serialize an xonly\+\_\+pubkey object into a 32-\/byte sequence.

Returns\+: 1 always.

Args\+: ctx\+: pointer to a context object. Out\+: output32\+: pointer to a 32-\/byte array to place the serialized key in. In\+: pubkey\+: pointer to a \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey} containing an initialized public key. \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey\_tweak\_add@{secp256k1\_xonly\_pubkey\_tweak\_add}}
\index{secp256k1\_xonly\_pubkey\_tweak\_add@{secp256k1\_xonly\_pubkey\_tweak\_add}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_tweak\_add()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_aaf832fa110c2610d69dee6ca74c856e8} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{output\+\_\+pubkey}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{internal\+\_\+pubkey}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Tweak an x-\/only public key by adding the generator multiplied with tweak32 to it.

Note that the resulting point can not in general be represented by an x-\/only pubkey because it may have an odd Y coordinate. Instead, the output\+\_\+pubkey is a normal \doxyref{secp256k1\+\_\+pubkey}{p.}{structsecp256k1__pubkey}.

Returns\+: 0 if the arguments are invalid or the resulting public key would be invalid (only when the tweak is the negation of the corresponding secret key). 1 otherwise.

Args\+: ctx\+: pointer to a context object. Out\+: output\+\_\+pubkey\+: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. In\+: internal\+\_\+pubkey\+: pointer to an x-\/only pubkey to apply the tweak to. tweak32\+: pointer to a 32-\/byte tweak, which must be valid according to secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify or 32 zero bytes. For uniformly random 32-\/byte tweaks, the chance of being invalid is negligible (around 1 in 2$^\wedge$128). \index{secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}!secp256k1\_xonly\_pubkey\_tweak\_add\_check@{secp256k1\_xonly\_pubkey\_tweak\_add\_check}}
\index{secp256k1\_xonly\_pubkey\_tweak\_add\_check@{secp256k1\_xonly\_pubkey\_tweak\_add\_check}!secp256k1\_extrakeys.h@{secp256k1\_extrakeys.h}}
\doxysubsubsection{secp256k1\_xonly\_pubkey\_tweak\_add\_check()}
{\footnotesize\ttfamily \label{secp256k1__extrakeys_8h_a466fe5b6ca122c33e51f7a3e70ff3590} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add\+\_\+check (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{const unsigned char $\ast$}]{tweaked\+\_\+pubkey32}{, }\item[{int}]{tweaked\+\_\+pk\+\_\+parity}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{internal\+\_\+pubkey}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Checks that a tweaked pubkey is the result of calling secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add with internal\+\_\+pubkey and tweak32.

The tweaked pubkey is represented by its 32-\/byte x-\/only serialization and its pk\+\_\+parity, which can both be obtained by converting the result of tweak\+\_\+add to a \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey}.

Note that this alone does {\itshape not} verify that the tweaked pubkey is a commitment. If the tweak is not chosen in a specific way, the tweaked pubkey can easily be the result of a different internal\+\_\+pubkey and tweak.

Returns\+: 0 if the arguments are invalid or the tweaked pubkey is not the result of tweaking the internal\+\_\+pubkey with tweak32. 1 otherwise. Args\+: ctx\+: pointer to a context object. In\+: tweaked\+\_\+pubkey32\+: pointer to a serialized xonly\+\_\+pubkey. tweaked\+\_\+pk\+\_\+parity\+: the parity of the tweaked pubkey (whose serialization is passed in as tweaked\+\_\+pubkey32). This must match the pk\+\_\+parity value that is returned when calling \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey}{p.}{structsecp256k1__xonly__pubkey} with the tweaked pubkey, or this function will fail. internal\+\_\+pubkey\+: pointer to an x-\/only public key object to apply the tweak to. tweak32\+: pointer to a 32-\/byte tweak. 