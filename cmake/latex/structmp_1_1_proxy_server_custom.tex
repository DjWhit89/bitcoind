\doxysection{Proxy\+Server\+Custom$<$ Interface, Impl $>$ Struct Template Reference}
\label{structmp_1_1_proxy_server_custom}\index{ProxyServerCustom$<$ Interface, Impl $>$@{ProxyServerCustom$<$ Interface, Impl $>$}}


{\ttfamily \#include $<$proxy.\+h$>$}

Inheritance diagram for Proxy\+Server\+Custom$<$ Interface, Impl $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{structmp_1_1_proxy_server_custom}
\end{center}
\end{figure}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Proxy\+Server\+Base$<$ Interface, Impl $>$}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Interface}
\item 
using \textbf{ Impl}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Proxy\+Server\+Base$<$ Interface, Impl $>$}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Proxy\+Server\+Base} (std\+::shared\+\_\+ptr$<$ \textbf{ Impl} $>$ impl, \textbf{ Connection} \&connection)
\item 
virtual \textbf{ $\sim$\+Proxy\+Server\+Base} ()
\item 
void \textbf{ invoke\+Destroy} ()
\end{DoxyCompactItemize}
\doxysubsection*{Data Fields inherited from \textbf{ Proxy\+Server\+Base$<$ Interface, Impl $>$}}
\begin{DoxyCompactItemize}
\item 
std\+::shared\+\_\+ptr$<$ \textbf{ Impl} $>$ \textbf{ m\+\_\+impl}
\item 
\textbf{ Proxy\+Context} \textbf{ m\+\_\+context}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename \textbf{ Interface}, typename \textbf{ Impl}$>$\newline
struct mp\+::\+Proxy\+Server\+Custom$<$ Interface, Impl $>$}
Customizable (through template specialization) base class which \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} classes produced by generated code will inherit from. The default specialization of this class just inherits from \doxyref{Proxy\+Server\+Base}{p.}{structmp_1_1_proxy_server_base}, but custom specializations can be defined to control \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} behavior.

Specifically, it can be useful to specialize this class to add additional state to \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} classes, for example to cache state between IPC calls. If this is done, however, care should be taken to ensure that the extra state can be destroyed without blocking, because \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} destructors are called from the \doxyref{Event\+Loop}{p.}{classmp_1_1_event_loop} thread, and if they block, it could deadlock the program. One way to do avoid blocking is to clean up the state by pushing cleanup callbacks to the m\+\_\+context.\+cleanup\+\_\+fns list, which run after the server m\+\_\+impl object is destroyed on the same thread destroying it (which will either be an IPC worker thread if the \doxyref{Proxy\+Server}{p.}{structmp_1_1_proxy_server} is being explicitly destroyed by a client calling a destroy() method with a Context argument and Context.\+thread value set, or the temporary \doxyref{Event\+Loop\+::m\+\_\+async\+\_\+thread}{p.}{classmp_1_1_event_loop_a7ff706a17a3571c9b28db11e81dc7585} used to run destructors without blocking the event loop when no-\/longer used server objects are garbage collected by Cap\textquotesingle{}n Proto.) Alternately, if cleanup needs to run before m\+\_\+impl is destroyed, the specialization can override invoke\+Destroy and destructor methods to do that. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/ipc/libmultiprocess/include/mp/\textbf{ proxy.\+h}\end{DoxyCompactItemize}
