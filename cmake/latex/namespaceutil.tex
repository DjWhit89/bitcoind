\doxysection{util Namespace Reference}
\label{namespaceutil}\index{util@{util}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ detail}
\item 
namespace \textbf{ hex\+\_\+literals}
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Consteval\+Format\+String}
\begin{DoxyCompactList}\small\item\em A wrapper for a compile-\/time partially validated format string. \end{DoxyCompactList}\item 
class \textbf{ Unexpected}
\item 
class \textbf{ Expected}
\item 
struct \textbf{ Overloaded}
\item 
struct \textbf{ Error}
\item 
class \textbf{ Result}
\item 
class \textbf{ Signal\+Interrupt}
\item 
class \textbf{ Task\+Runner\+Interface}
\item 
class \textbf{ Immediate\+Task\+Runner}
\item 
struct \textbf{ Translated\+Literal}
\begin{DoxyCompactList}\small\item\em Compile-\/time literal string that can be translated with an optional translation function. \end{DoxyCompactList}\item 
struct \textbf{ Bilingual\+Fmt}
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Lock\+Result} \{ \textbf{ Success}
, \textbf{ Error\+Write}
, \textbf{ Error\+Lock}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ T} $\ast$ \textbf{ Any\+Ptr} (const std\+::any \&any) noexcept
\item 
int \textbf{ Exec\+Vp} (const char $\ast$file, char $\ast$const argv[$\,$])
\item 
\textbf{ fs\+::path} \textbf{ Get\+Exe\+Path} (std\+::string\+\_\+view argv0)
\item 
\textbf{ Lock\+Result} \textbf{ Lock\+Directory} (const \textbf{ fs\+::path} \&directory, const \textbf{ fs\+::path} \&lockfile\+\_\+name, bool probe\+\_\+only)
\item 
{\footnotesize template$<$typename Tdst, typename Tsrc$>$ }\\void \textbf{ insert} (Tdst \&dst, const Tsrc \&src)
\begin{DoxyCompactList}\small\item\em Simplification of std insertion. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TsetT, typename Tsrc$>$ }\\void \textbf{ insert} (std\+::set$<$ TsetT $>$ \&dst, const Tsrc \&src)
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ bilingual\+\_\+str} \textbf{ Error\+String} (const \textbf{ Result}$<$ \textbf{ T} $>$ \&result)
\item 
consteval uint8\+\_\+t \textbf{ Consteval\+Hex\+Digit} (const char c)
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\constexpr auto \textbf{ operator"{}"{}\+\_\+hex} ()
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\constexpr auto \textbf{ operator"{}"{}\+\_\+hex\+\_\+u8} ()
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\constexpr auto \textbf{ operator"{}"{}\+\_\+hex\+\_\+v} ()
\item 
{\footnotesize template$<$\textbf{ util\+::detail\+::\+Hex} str$>$ }\\auto \textbf{ operator"{}"{}\+\_\+hex\+\_\+v\+\_\+u8} ()
\item 
void \textbf{ Replace\+All} (std\+::string \&in\+\_\+out, const std\+::string \&search, const std\+::string \&substitute)
\item 
{\footnotesize template$<$typename \textbf{ T} = std\+::span$<$const char$>$$>$ }\\std\+::vector$<$ \textbf{ T} $>$ \textbf{ Split} (const std\+::span$<$ const char $>$ \&sp, std\+::string\+\_\+view separators, bool include\+\_\+sep=false)
\item 
{\footnotesize template$<$typename \textbf{ T} = std\+::span$<$const char$>$$>$ }\\std\+::vector$<$ \textbf{ T} $>$ \textbf{ Split} (const std\+::span$<$ const char $>$ \&sp, char sep, bool include\+\_\+sep=false)
\item 
std\+::vector$<$ std\+::string $>$ \textbf{ Split\+String} (std\+::string\+\_\+view str, char sep)
\item 
std\+::vector$<$ std\+::string $>$ \textbf{ Split\+String} (std\+::string\+\_\+view str, std\+::string\+\_\+view separators)
\item 
std\+::string\+\_\+view \textbf{ Trim\+String\+View} (std\+::string\+\_\+view str, std\+::string\+\_\+view pattern="{} \textbackslash{}f\textbackslash{}n\textbackslash{}r\textbackslash{}t\textbackslash{}v"{})
\item 
std\+::string \textbf{ Trim\+String} (std\+::string\+\_\+view str, std\+::string\+\_\+view pattern="{} \textbackslash{}f\textbackslash{}n\textbackslash{}r\textbackslash{}t\textbackslash{}v"{})
\item 
std\+::string\+\_\+view \textbf{ Remove\+Suffix\+View} (std\+::string\+\_\+view str, std\+::string\+\_\+view suffix)
\item 
std\+::string\+\_\+view \textbf{ Remove\+Prefix\+View} (std\+::string\+\_\+view str, std\+::string\+\_\+view \textbf{ prefix})
\item 
std\+::string \textbf{ Remove\+Prefix} (std\+::string\+\_\+view str, std\+::string\+\_\+view \textbf{ prefix})
\item 
{\footnotesize template$<$typename C, typename \textbf{ S}, typename Unary\+Op$>$ }\\auto \textbf{ Join} (const C \&container, const \textbf{ S} \&separator, Unary\+Op unary\+\_\+op)
\item 
{\footnotesize template$<$typename C, typename \textbf{ S}$>$ }\\auto \textbf{ Join} (const C \&container, const \textbf{ S} \&separator)
\item 
std\+::string \textbf{ Make\+Unordered\+List} (const std\+::vector$<$ std\+::string $>$ \&items)
\item 
bool \textbf{ Contains\+No\+NUL} (std\+::string\+\_\+view str) noexcept
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\std\+::string \textbf{ To\+String} (const \textbf{ T} \&t)
\item 
{\footnotesize template$<$typename T1, size\+\_\+t PREFIX\+\_\+\+LEN$>$ }\\bool \textbf{ Has\+Prefix} (const T1 \&obj, const std\+::array$<$ uint8\+\_\+t, PREFIX\+\_\+\+LEN $>$ \&\textbf{ prefix})
\item 
void \textbf{ Trace\+Thread} (std\+::string\+\_\+view thread\+\_\+name, std\+::function$<$ void()$>$ thread\+\_\+func)
\item 
void \textbf{ Thread\+Rename} (const std\+::string \&)
\item 
void \textbf{ Thread\+Set\+Internal\+Name} (const std\+::string \&)
\begin{DoxyCompactList}\small\item\em Set the internal (in-\/memory) name of the current thread only. \end{DoxyCompactList}\item 
std\+::string \textbf{ Thread\+Get\+Internal\+Name} ()
\item 
std\+::ostream \& \textbf{ operator$<$$<$} (std\+::ostream \&os, const \textbf{ Translated\+Literal} \&lit)
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ T} \textbf{ operator+} (const \textbf{ T} \&lhs, const \textbf{ Translated\+Literal} \&rhs)
\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ T} \textbf{ operator+} (const \textbf{ Translated\+Literal} \&lhs, const \textbf{ T} \&rhs)
\end{DoxyCompactItemize}


\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{util@{util}!LockResult@{LockResult}}
\index{LockResult@{LockResult}!util@{util}}
\doxysubsubsection{LockResult}
{\footnotesize\ttfamily \label{namespaceutil_a3520a91e926bf45bc7230610c2e893f3} 
enum class \textbf{ Lock\+Result}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Success@{Success}!util@{util}}\index{util@{util}!Success@{Success}}}\label{namespaceutil_a3520a91e926bf45bc7230610c2e893f3a505a83f220c02df2f85c3810cd9ceb38} 
Success&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ErrorWrite@{ErrorWrite}!util@{util}}\index{util@{util}!ErrorWrite@{ErrorWrite}}}\label{namespaceutil_a3520a91e926bf45bc7230610c2e893f3a05f9fd8b78a01625a2df427c3413488d} 
Error\+Write&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ErrorLock@{ErrorLock}!util@{util}}\index{util@{util}!ErrorLock@{ErrorLock}}}\label{namespaceutil_a3520a91e926bf45bc7230610c2e893f3a6dc3e93d1a7110731aaec2df1cfc93b8} 
Error\+Lock&\\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{util@{util}!AnyPtr@{AnyPtr}}
\index{AnyPtr@{AnyPtr}!util@{util}}
\doxysubsubsection{AnyPtr()}
{\footnotesize\ttfamily \label{namespaceutil_aafe01afb1c2f2a3b862837747c5bf2ee} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ T} $\ast$ Any\+Ptr (\begin{DoxyParamCaption}\item[{const std\+::any \&}]{any}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Helper function to access the contained object of a std\+::any instance. Returns a pointer to the object if passed instance has a value and the type matches, nullptr otherwise. \index{util@{util}!ConstevalHexDigit@{ConstevalHexDigit}}
\index{ConstevalHexDigit@{ConstevalHexDigit}!util@{util}}
\doxysubsubsection{ConstevalHexDigit()}
{\footnotesize\ttfamily \label{namespaceutil_a471a384919e7b099185ccc3c0ea00f3b} 
uint8\+\_\+t Consteval\+Hex\+Digit (\begin{DoxyParamCaption}\item[{const char}]{c}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [consteval]}}

consteval version of \doxyref{Hex\+Digit()}{p.}{hex__base_8cpp_aa59e8a8c5a39cb5041f93bb95dd02119} without the lookup table. \index{util@{util}!ContainsNoNUL@{ContainsNoNUL}}
\index{ContainsNoNUL@{ContainsNoNUL}!util@{util}}
\doxysubsubsection{ContainsNoNUL()}
{\footnotesize\ttfamily \label{namespaceutil_ae88ae9c1bf5ad674e847402ac896b434} 
bool Contains\+No\+NUL (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}, {\ttfamily [noexcept]}}

Check if a string does not contain any embedded NUL (\textbackslash{}0) characters \index{util@{util}!ErrorString@{ErrorString}}
\index{ErrorString@{ErrorString}!util@{util}}
\doxysubsubsection{ErrorString()}
{\footnotesize\ttfamily \label{namespaceutil_adbcebd9741ba34de94c8384025e54825} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ bilingual\+\_\+str} Error\+String (\begin{DoxyParamCaption}\item[{const \textbf{ Result}$<$ \textbf{ T} $>$ \&}]{result}{}\end{DoxyParamCaption})}

\index{util@{util}!ExecVp@{ExecVp}}
\index{ExecVp@{ExecVp}!util@{util}}
\doxysubsubsection{ExecVp()}
{\footnotesize\ttfamily \label{namespaceutil_a8045d2653fbff4bf08a8a8e35e4703a5} 
int Exec\+Vp (\begin{DoxyParamCaption}\item[{const char $\ast$}]{file}{, }\item[{char $\ast$const}]{argv}{[$\,$]}\end{DoxyParamCaption})}

Cross-\/platform wrapper for POSIX execvp function. Arguments and return value are the same as for POSIX execvp, and the argv array should consist of null terminated strings and be null terminated itself, like the POSIX function. \index{util@{util}!GetExePath@{GetExePath}}
\index{GetExePath@{GetExePath}!util@{util}}
\doxysubsubsection{GetExePath()}
{\footnotesize\ttfamily \label{namespaceutil_ae0344be74400ec5880c0883b4a808828} 
\textbf{ fs\+::path} Get\+Exe\+Path (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{argv0}{}\end{DoxyParamCaption})}

Return path to current executable assuming it was invoked with argv0. If path could not be determined, returns an empty path. \index{util@{util}!HasPrefix@{HasPrefix}}
\index{HasPrefix@{HasPrefix}!util@{util}}
\doxysubsubsection{HasPrefix()}
{\footnotesize\ttfamily \label{namespaceutil_af23d4553c526fce640a92f491182057a} 
template$<$typename T1, size\+\_\+t PREFIX\+\_\+\+LEN$>$ \\
bool Has\+Prefix (\begin{DoxyParamCaption}\item[{const T1 \&}]{obj}{, }\item[{const std\+::array$<$ uint8\+\_\+t, PREFIX\+\_\+\+LEN $>$ \&}]{prefix}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

Check whether a container begins with the given prefix. \index{util@{util}!insert@{insert}}
\index{insert@{insert}!util@{util}}
\doxysubsubsection{insert()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespaceutil_ac304052e8917553cd22cf1cf6f107980} 
template$<$typename TsetT, typename Tsrc$>$ \\
void insert (\begin{DoxyParamCaption}\item[{std\+::set$<$ TsetT $>$ \&}]{dst}{, }\item[{const Tsrc \&}]{src}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{util@{util}!insert@{insert}}
\index{insert@{insert}!util@{util}}
\doxysubsubsection{insert()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespaceutil_a3a6bda27d7c6b3ea44dc144186595ef9} 
template$<$typename Tdst, typename Tsrc$>$ \\
void insert (\begin{DoxyParamCaption}\item[{Tdst \&}]{dst}{, }\item[{const Tsrc \&}]{src}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Simplification of std insertion. 

\index{util@{util}!Join@{Join}}
\index{Join@{Join}!util@{util}}
\doxysubsubsection{Join()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespaceutil_a753788c39fa4b19d9a93ff9f797b480f} 
template$<$typename C, typename \textbf{ S}$>$ \\
auto Join (\begin{DoxyParamCaption}\item[{const C \&}]{container}{, }\item[{const \textbf{ S} \&}]{separator}{}\end{DoxyParamCaption})}

\index{util@{util}!Join@{Join}}
\index{Join@{Join}!util@{util}}
\doxysubsubsection{Join()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespaceutil_aff2a33f4c8a8ebd77cf6e0630bd1dbe3} 
template$<$typename C, typename \textbf{ S}, typename Unary\+Op$>$ \\
auto Join (\begin{DoxyParamCaption}\item[{const C \&}]{container}{, }\item[{const \textbf{ S} \&}]{separator}{, }\item[{Unary\+Op}]{unary\+\_\+op}{}\end{DoxyParamCaption})}

Join all container items. Typically used to concatenate strings but accepts containers with elements of any type.


\begin{DoxyParams}{Parameters}
{\em container} & The items to join \\
\hline
{\em separator} & The separator \\
\hline
{\em unary\+\_\+op} & Apply this operator to each item \\
\hline
\end{DoxyParams}
\index{util@{util}!LockDirectory@{LockDirectory}}
\index{LockDirectory@{LockDirectory}!util@{util}}
\doxysubsubsection{LockDirectory()}
{\footnotesize\ttfamily \label{namespaceutil_a4e0b24c45776b5599a02005ef0a189dd} 
\textbf{ Lock\+Result} Lock\+Directory (\begin{DoxyParamCaption}\item[{const \textbf{ fs\+::path} \&}]{directory}{, }\item[{const \textbf{ fs\+::path} \&}]{lockfile\+\_\+name}{, }\item[{bool}]{probe\+\_\+only}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [nodiscard]}}

\index{util@{util}!MakeUnorderedList@{MakeUnorderedList}}
\index{MakeUnorderedList@{MakeUnorderedList}!util@{util}}
\doxysubsubsection{MakeUnorderedList()}
{\footnotesize\ttfamily \label{namespaceutil_aabc06ac4086eb3c70c66f11de29782f2} 
std\+::string Make\+Unordered\+List (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::string $>$ \&}]{items}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Create an unordered multi-\/line list of items. \index{util@{util}!operator+@{operator+}}
\index{operator+@{operator+}!util@{util}}
\doxysubsubsection{operator+()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespaceutil_a8da3df812bcd8b110b1960ffe26036f8} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ T} operator+ (\begin{DoxyParamCaption}\item[{const \textbf{ T} \&}]{lhs}{, }\item[{const \textbf{ Translated\+Literal} \&}]{rhs}{}\end{DoxyParamCaption})}

\index{util@{util}!operator+@{operator+}}
\index{operator+@{operator+}!util@{util}}
\doxysubsubsection{operator+()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespaceutil_ab487aa659a2e7ce9c2d834ab1373d3df} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ T} operator+ (\begin{DoxyParamCaption}\item[{const \textbf{ Translated\+Literal} \&}]{lhs}{, }\item[{const \textbf{ T} \&}]{rhs}{}\end{DoxyParamCaption})}

\index{util@{util}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!util@{util}}
\doxysubsubsection{operator$<$$<$()}
{\footnotesize\ttfamily \label{namespaceutil_a1f872f873fa814ec9365768579cfac1a} 
std\+::ostream \& operator$<$$<$ (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{, }\item[{const \textbf{ Translated\+Literal} \&}]{lit}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{util@{util}!RemovePrefix@{RemovePrefix}}
\index{RemovePrefix@{RemovePrefix}!util@{util}}
\doxysubsubsection{RemovePrefix()}
{\footnotesize\ttfamily \label{namespaceutil_a8ff0177025a6486b4b9c9d13c187d0b0} 
std\+::string Remove\+Prefix (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{std\+::string\+\_\+view}]{prefix}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{util@{util}!RemovePrefixView@{RemovePrefixView}}
\index{RemovePrefixView@{RemovePrefixView}!util@{util}}
\doxysubsubsection{RemovePrefixView()}
{\footnotesize\ttfamily \label{namespaceutil_ac90ebbde671e4b19c1a25c6a2b308b10} 
std\+::string\+\_\+view Remove\+Prefix\+View (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{std\+::string\+\_\+view}]{prefix}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{util@{util}!RemoveSuffixView@{RemoveSuffixView}}
\index{RemoveSuffixView@{RemoveSuffixView}!util@{util}}
\doxysubsubsection{RemoveSuffixView()}
{\footnotesize\ttfamily \label{namespaceutil_a0e97be4ceed96178dde80391017e9c1c} 
std\+::string\+\_\+view Remove\+Suffix\+View (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{std\+::string\+\_\+view}]{suffix}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{util@{util}!ReplaceAll@{ReplaceAll}}
\index{ReplaceAll@{ReplaceAll}!util@{util}}
\doxysubsubsection{ReplaceAll()}
{\footnotesize\ttfamily \label{namespaceutil_ac3615d6e25683cb921a19c421c2f558b} 
void Replace\+All (\begin{DoxyParamCaption}\item[{std\+::string \&}]{in\+\_\+out}{, }\item[{const std\+::string \&}]{search}{, }\item[{const std\+::string \&}]{substitute}{}\end{DoxyParamCaption})}

\index{util@{util}!Split@{Split}}
\index{Split@{Split}!util@{util}}
\doxysubsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespaceutil_afa5278a9f578e910fa9877630a9056a3} 
template$<$typename \textbf{ T} = std\+::span$<$const char$>$$>$ \\
std\+::vector$<$ \textbf{ T} $>$ Split (\begin{DoxyParamCaption}\item[{const std\+::span$<$ const char $>$ \&}]{sp}{, }\item[{char}]{sep}{, }\item[{bool}]{include\+\_\+sep}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Split a string on every instance of sep, returning a vector.

If sep does not occur in sp, a singleton with the entirety of sp is returned.

Note that this function does not care about braces, so splitting "{}foo(bar(1),2),3) on \textquotesingle{},\textquotesingle{} will return \{"{}foo(bar(1)"{}, "{}2)"{}, "{}3)"{}\}. \index{util@{util}!Split@{Split}}
\index{Split@{Split}!util@{util}}
\doxysubsubsection{Split()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespaceutil_a8146320153c3d148df2965a46199a03c} 
template$<$typename \textbf{ T} = std\+::span$<$const char$>$$>$ \\
std\+::vector$<$ \textbf{ T} $>$ Split (\begin{DoxyParamCaption}\item[{const std\+::span$<$ const char $>$ \&}]{sp}{, }\item[{std\+::string\+\_\+view}]{separators}{, }\item[{bool}]{include\+\_\+sep}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Split a string on any char found in separators, returning a vector.

If sep does not occur in sp, a singleton with the entirety of sp is returned.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em include\+\_\+sep} & Whether to include the separator at the end of the left side of the splits.\\
\hline
\end{DoxyParams}
Note that this function does not care about braces, so splitting "{}foo(bar(1),2),3) on \textquotesingle{},\textquotesingle{} will return \{"{}foo(bar(1)"{}, "{}2)"{}, "{}3)"{}\}.  \+If include\+\_\+sep == true, splitting "{}foo(bar(1),2),3) on \textquotesingle{},\textquotesingle{} will return\+:
\begin{DoxyItemize}
\item foo(bar(1),
\item 2),
\item 3) 
\end{DoxyItemize}\index{util@{util}!SplitString@{SplitString}}
\index{SplitString@{SplitString}!util@{util}}
\doxysubsubsection{SplitString()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespaceutil_aa8c971a6e91a687b968e737c9d22de2c} 
std\+::vector$<$ std\+::string $>$ Split\+String (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{char}]{sep}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{util@{util}!SplitString@{SplitString}}
\index{SplitString@{SplitString}!util@{util}}
\doxysubsubsection{SplitString()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespaceutil_af8ff854c95b61590d7993f9007d874b6} 
std\+::vector$<$ std\+::string $>$ Split\+String (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{std\+::string\+\_\+view}]{separators}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{util@{util}!ThreadGetInternalName@{ThreadGetInternalName}}
\index{ThreadGetInternalName@{ThreadGetInternalName}!util@{util}}
\doxysubsubsection{ThreadGetInternalName()}
{\footnotesize\ttfamily \label{namespaceutil_a40af0863399929342ec6d28be5dace8f} 
std\+::string Thread\+Get\+Internal\+Name (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Get the thread\textquotesingle{}s internal (in-\/memory) name; used e.\+g. for identification in logging. \index{util@{util}!ThreadRename@{ThreadRename}}
\index{ThreadRename@{ThreadRename}!util@{util}}
\doxysubsubsection{ThreadRename()}
{\footnotesize\ttfamily \label{namespaceutil_a0b501a2cc08ebe4c0d9073938a5a0731} 
void Thread\+Rename (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name}{}\end{DoxyParamCaption})}

Rename a thread both in terms of an internal (in-\/memory) name as well as its system thread name. \begin{DoxyNote}{Note}
Do not call this for the main thread, as this will interfere with UNIX utilities such as top and killall. Use Thread\+Set\+Internal\+Name instead. 
\end{DoxyNote}
\index{util@{util}!ThreadSetInternalName@{ThreadSetInternalName}}
\index{ThreadSetInternalName@{ThreadSetInternalName}!util@{util}}
\doxysubsubsection{ThreadSetInternalName()}
{\footnotesize\ttfamily \label{namespaceutil_a03e481ad687cf2b6c2956282fd1281e5} 
void Thread\+Set\+Internal\+Name (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name}{}\end{DoxyParamCaption})}



Set the internal (in-\/memory) name of the current thread only. 

\index{util@{util}!ToString@{ToString}}
\index{ToString@{ToString}!util@{util}}
\doxysubsubsection{ToString()}
{\footnotesize\ttfamily \label{namespaceutil_aec2c30b1707eac00ff7e4fb5b3f7a92d} 
template$<$typename \textbf{ T}$>$ \\
std\+::string To\+String (\begin{DoxyParamCaption}\item[{const \textbf{ T} \&}]{t}{}\end{DoxyParamCaption})}

Locale-\/independent version of std\+::to\+\_\+string \index{util@{util}!TraceThread@{TraceThread}}
\index{TraceThread@{TraceThread}!util@{util}}
\doxysubsubsection{TraceThread()}
{\footnotesize\ttfamily \label{namespaceutil_ad983ac5f9865491ceb166699d95b0599} 
void Trace\+Thread (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{thread\+\_\+name}{, }\item[{std\+::function$<$ void()$>$}]{thread\+\_\+func}{}\end{DoxyParamCaption})}

A wrapper for do-\/something-\/once thread functions. \index{util@{util}!TrimString@{TrimString}}
\index{TrimString@{TrimString}!util@{util}}
\doxysubsubsection{TrimString()}
{\footnotesize\ttfamily \label{namespaceutil_a5bd066c28e2e73c88348b7acb43c0ceb} 
std\+::string Trim\+String (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{std\+::string\+\_\+view}]{pattern}{ = {\ttfamily "{}~\textbackslash{}f\textbackslash{}n\textbackslash{}r\textbackslash{}t\textbackslash{}v"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

\index{util@{util}!TrimStringView@{TrimStringView}}
\index{TrimStringView@{TrimStringView}!util@{util}}
\doxysubsubsection{TrimStringView()}
{\footnotesize\ttfamily \label{namespaceutil_af05e99aff654d45492e4a99b234c434c} 
std\+::string\+\_\+view Trim\+String\+View (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{str}{, }\item[{std\+::string\+\_\+view}]{pattern}{ = {\ttfamily "{}~\textbackslash{}f\textbackslash{}n\textbackslash{}r\textbackslash{}t\textbackslash{}v"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}}

