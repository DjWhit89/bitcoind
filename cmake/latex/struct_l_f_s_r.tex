\doxysection{LFSR$<$ F, MOD $>$ Struct Template Reference}
\label{struct_l_f_s_r}\index{LFSR$<$ F, MOD $>$@{LFSR$<$ F, MOD $>$}}


{\ttfamily \#include $<$int\+\_\+utils.\+h$>$}

\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef F\+::\+Repr \textbf{ I}
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr \textbf{ I} \textbf{ Call} (const \textbf{ I} \&a)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename F, uint32\+\_\+t MOD$>$\newline
struct LFSR$<$ F, MOD $>$}
Class which implements a stateless \doxyref{LFSR}{p.}{struct_l_f_s_r} for generic moduli. 

\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{LFSR$<$ F, MOD $>$@{LFSR$<$ F, MOD $>$}!I@{I}}
\index{I@{I}!LFSR$<$ F, MOD $>$@{LFSR$<$ F, MOD $>$}}
\doxysubsubsection{I}
{\footnotesize\ttfamily \label{struct_l_f_s_r_a8baf7430cc924f6ccf99108d780ba60b} 
template$<$typename F, uint32\+\_\+t MOD$>$ \\
typedef F\+::\+Repr \textbf{ I}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{LFSR$<$ F, MOD $>$@{LFSR$<$ F, MOD $>$}!Call@{Call}}
\index{Call@{Call}!LFSR$<$ F, MOD $>$@{LFSR$<$ F, MOD $>$}}
\doxysubsubsection{Call()}
{\footnotesize\ttfamily \label{struct_l_f_s_r_a69594dc00918b3d47b6c1dbcf6448a34} 
template$<$typename F, uint32\+\_\+t MOD$>$ \\
constexpr \textbf{ I} Call (\begin{DoxyParamCaption}\item[{const \textbf{ I} \&}]{a}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}

Shift a value {\ttfamily a} up once, treating it as an {\ttfamily N}-\/bit \doxyref{LFSR}{p.}{struct_l_f_s_r}, with pattern {\ttfamily MOD}. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/minisketch/src/\textbf{ int\+\_\+utils.\+h}\end{DoxyCompactItemize}
