\doxysection{HTTPRequest Class Reference}
\label{class_h_t_t_p_request}\index{HTTPRequest@{HTTPRequest}}


{\ttfamily \#include $<$httpserver.\+h$>$}

\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Request\+Method} \{ \newline
\textbf{ UNKNOWN}
, \textbf{ GET}
, \textbf{ POST}
, \textbf{ HEAD}
, \newline
\textbf{ PUT}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ HTTPRequest} (struct evhttp\+\_\+request $\ast$req, const \textbf{ util\+::\+Signal\+Interrupt} \&interrupt, bool reply\+Sent=false)
\item 
\textbf{ $\sim$\+HTTPRequest} ()
\item 
std\+::string \textbf{ Get\+URI} () const
\item 
\textbf{ CService} \textbf{ Get\+Peer} () const
\item 
\textbf{ Request\+Method} \textbf{ Get\+Request\+Method} () const
\item 
std\+::optional$<$ std\+::string $>$ \textbf{ Get\+Query\+Parameter} (const std\+::string \&key) const
\item 
std\+::pair$<$ bool, std\+::string $>$ \textbf{ Get\+Header} (const std\+::string \&hdr) const
\item 
std\+::string \textbf{ Read\+Body} ()
\item 
void \textbf{ Write\+Header} (const std\+::string \&hdr, const std\+::string \&value)
\item 
void \textbf{ Write\+Reply} (int n\+Status, std\+::string\+\_\+view reply="{}"{})
\item 
void \textbf{ Write\+Reply} (int n\+Status, std\+::span$<$ const std\+::byte $>$ reply)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
In-\/flight HTTP request. Thin C++ wrapper around evhttp\+\_\+request. 

\label{doc-enum-members}
\doxysubsection{Member Enumeration Documentation}
\index{HTTPRequest@{HTTPRequest}!RequestMethod@{RequestMethod}}
\index{RequestMethod@{RequestMethod}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{RequestMethod}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a667255974fbff6d39bc2e840d46f47e1} 
enum \textbf{ Request\+Method}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{UNKNOWN@{UNKNOWN}!HTTPRequest@{HTTPRequest}}\index{HTTPRequest@{HTTPRequest}!UNKNOWN@{UNKNOWN}}}\label{class_h_t_t_p_request_a667255974fbff6d39bc2e840d46f47e1a6ce26a62afab55d7606ad4e92428b30c} 
UNKNOWN&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{GET@{GET}!HTTPRequest@{HTTPRequest}}\index{HTTPRequest@{HTTPRequest}!GET@{GET}}}\label{class_h_t_t_p_request_a667255974fbff6d39bc2e840d46f47e1a12a8dcf59c16b5aadfda3a08ba67d529} 
GET&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{POST@{POST}!HTTPRequest@{HTTPRequest}}\index{HTTPRequest@{HTTPRequest}!POST@{POST}}}\label{class_h_t_t_p_request_a667255974fbff6d39bc2e840d46f47e1a368c5bc07109370b819193871352b926} 
POST&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{HEAD@{HEAD}!HTTPRequest@{HTTPRequest}}\index{HTTPRequest@{HTTPRequest}!HEAD@{HEAD}}}\label{class_h_t_t_p_request_a667255974fbff6d39bc2e840d46f47e1a0b0955668575b21eb0ab2272aef49f76} 
HEAD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PUT@{PUT}!HTTPRequest@{HTTPRequest}}\index{HTTPRequest@{HTTPRequest}!PUT@{PUT}}}\label{class_h_t_t_p_request_a667255974fbff6d39bc2e840d46f47e1afec39d40e8bc9e12afa614df5ddb9fa9} 
PUT&\\
\hline

\end{DoxyEnumFields}


\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{HTTPRequest@{HTTPRequest}!HTTPRequest@{HTTPRequest}}
\index{HTTPRequest@{HTTPRequest}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{HTTPRequest()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a695d4e0bd48770aed385799a1d3a43b0} 
\textbf{ HTTPRequest} (\begin{DoxyParamCaption}\item[{struct evhttp\+\_\+request $\ast$}]{req}{, }\item[{const \textbf{ util\+::\+Signal\+Interrupt} \&}]{interrupt}{, }\item[{bool}]{reply\+Sent}{ = {\ttfamily false}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

\index{HTTPRequest@{HTTPRequest}!````~HTTPRequest@{$\sim$HTTPRequest}}
\index{````~HTTPRequest@{$\sim$HTTPRequest}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{$\sim$HTTPRequest()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a2267d5cb0d2d7249ec706fab1039f515} 
$\sim$\textbf{ HTTPRequest} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{HTTPRequest@{HTTPRequest}!GetHeader@{GetHeader}}
\index{GetHeader@{GetHeader}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{GetHeader()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a9e1943c284613b342fb3e95d8f6358f9} 
std\+::pair$<$ bool, std\+::string $>$ Get\+Header (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{hdr}{}\end{DoxyParamCaption}) const}

Get the request header specified by hdr, or an empty string. Return a pair (is\+Present,string). \index{HTTPRequest@{HTTPRequest}!GetPeer@{GetPeer}}
\index{GetPeer@{GetPeer}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{GetPeer()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a53e93f86754005bcf0b38aab4705cf33} 
\textbf{ CService} Get\+Peer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Get \doxyref{CService}{p.}{class_c_service} (address\+:ip) for the origin of the http request. \index{HTTPRequest@{HTTPRequest}!GetQueryParameter@{GetQueryParameter}}
\index{GetQueryParameter@{GetQueryParameter}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{GetQueryParameter()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a4c8d3ca82089f916e360d1d06cf09dbf} 
std\+::optional$<$ std\+::string $>$ Get\+Query\+Parameter (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{key}{}\end{DoxyParamCaption}) const}

Get the query parameter value from request uri for a specified key, or std\+::nullopt if the key is not found.

If the query string contains duplicate keys, the first value is returned. Many web frameworks would instead parse this as an array of values, but this is not (yet) implemented as it is currently not needed in any of the endpoints.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em key} & represents the query parameter of which the value is returned \\
\hline
\end{DoxyParams}
\index{HTTPRequest@{HTTPRequest}!GetRequestMethod@{GetRequestMethod}}
\index{GetRequestMethod@{GetRequestMethod}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{GetRequestMethod()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a4fd1a07ea7c4b01bf9f36ff4fef3a013} 
\textbf{ HTTPRequest\+::\+Request\+Method} Get\+Request\+Method (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Get request method. \index{HTTPRequest@{HTTPRequest}!GetURI@{GetURI}}
\index{GetURI@{GetURI}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{GetURI()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a0e9ec0f515c6ada8362483c99ffccc50} 
std\+::string Get\+URI (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Get requested URI. \index{HTTPRequest@{HTTPRequest}!ReadBody@{ReadBody}}
\index{ReadBody@{ReadBody}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{ReadBody()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a9af24083ca63a8466df045fef1450fd4} 
std\+::string Read\+Body (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Read request body.

\begin{DoxyNote}{Note}
As this consumes the underlying buffer, call this only once. Repeated calls will return an empty string. 
\end{DoxyNote}
Trivial implementation\+: if this is ever a performance bottleneck, internal copying can be avoided in multi-\/segment buffers by using evbuffer\+\_\+peek and an awkward loop. Though in that case, it\textquotesingle{}d be even better to not copy into an intermediate string but use a stream abstraction to consume the evbuffer on the fly in the parsing algorithm.\index{HTTPRequest@{HTTPRequest}!WriteHeader@{WriteHeader}}
\index{WriteHeader@{WriteHeader}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{WriteHeader()}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a5b0ce9b581c5594a105dc778d7e0d12e} 
void Write\+Header (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{hdr}{, }\item[{const std\+::string \&}]{value}{}\end{DoxyParamCaption})}

Write output header.

\begin{DoxyNote}{Note}
call this before calling Write\+Error\+Reply or Reply. 
\end{DoxyNote}
\index{HTTPRequest@{HTTPRequest}!WriteReply@{WriteReply}}
\index{WriteReply@{WriteReply}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{WriteReply()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_aabcaac8e6d5b9da3d0ba39532ebd4f0e} 
void Write\+Reply (\begin{DoxyParamCaption}\item[{int}]{n\+Status}{, }\item[{std\+::span$<$ const std\+::byte $>$}]{reply}{}\end{DoxyParamCaption})}

Closure sent to main thread to request a reply to be sent to a HTTP request. Replies must be sent in the main loop in the main http thread, this cannot be done from worker threads. \index{HTTPRequest@{HTTPRequest}!WriteReply@{WriteReply}}
\index{WriteReply@{WriteReply}!HTTPRequest@{HTTPRequest}}
\doxysubsubsection{WriteReply()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_h_t_t_p_request_a4f1b66cf11060b823e7a3efa913ea89c} 
void Write\+Reply (\begin{DoxyParamCaption}\item[{int}]{n\+Status}{, }\item[{std\+::string\+\_\+view}]{reply}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Write HTTP reply. n\+Status is the HTTP status code to send. reply is the body of the reply. Keep it empty to send a standard message.

\begin{DoxyNote}{Note}
Can be called only once. As this will give the request back to the main thread, do not call any other \doxyref{HTTPRequest}{p.}{class_h_t_t_p_request} methods after calling this. 
\end{DoxyNote}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ httpserver.\+h}\item 
src/\textbf{ httpserver.\+cpp}\end{DoxyCompactItemize}
