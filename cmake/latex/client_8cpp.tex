\doxysection{src/rpc/client.cpp File Reference}
\label{client_8cpp}\index{src/rpc/client.cpp@{src/rpc/client.cpp}}
{\ttfamily \#include $<$common/args.\+h$>$}\newline
{\ttfamily \#include $<$rpc/client.\+h$>$}\newline
{\ttfamily \#include $<$tinyformat.\+h$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$set$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$string\+\_\+view$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ CRPCConvert\+Param}
\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ rpc\+\_\+convert}
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Param\+Format} \{ \textbf{ JSON}
, \textbf{ STRING}
, \textbf{ JSON\+\_\+\+OR\+\_\+\+STRING}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
const \textbf{ CRPCConvert\+Param} $\ast$ \textbf{ From\+Position} (std\+::string\+\_\+view method, size\+\_\+t pos)
\item 
const \textbf{ CRPCConvert\+Param} $\ast$ \textbf{ From\+Name} (std\+::string\+\_\+view method, std\+::string\+\_\+view \textbf{ name})
\item 
\textbf{ Uni\+Value} \textbf{ RPCConvert\+Values} (const std\+::string \&str\+Method, const std\+::vector$<$ std\+::string $>$ \&str\+Params)
\item 
\textbf{ Uni\+Value} \textbf{ RPCConvert\+Named\+Values} (const std\+::string \&str\+Method, const std\+::vector$<$ std\+::string $>$ \&str\+Params)
\end{DoxyCompactItemize}


\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{client.cpp@{client.cpp}!ParamFormat@{ParamFormat}}
\index{ParamFormat@{ParamFormat}!client.cpp@{client.cpp}}
\doxysubsubsection{ParamFormat}
{\footnotesize\ttfamily \label{client_8cpp_aaedac74f66fe7dea34ec3ba3333e00ae} 
enum \textbf{ Param\+Format}}

Specify whether parameter should be parsed by bitcoin-\/cli as a JSON value, or passed unchanged as a string, or a combination of both. \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{JSON@{JSON}!client.cpp@{client.cpp}}\index{client.cpp@{client.cpp}!JSON@{JSON}}}\label{client_8cpp_aaedac74f66fe7dea34ec3ba3333e00aeaa5210511e3859748f136ab50c313ef05} 
JSON&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{STRING@{STRING}!client.cpp@{client.cpp}}\index{client.cpp@{client.cpp}!STRING@{STRING}}}\label{client_8cpp_aaedac74f66fe7dea34ec3ba3333e00aeaee847e634a4297b274316de8a8ca9921} 
STRING&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{JSON\_OR\_STRING@{JSON\_OR\_STRING}!client.cpp@{client.cpp}}\index{client.cpp@{client.cpp}!JSON\_OR\_STRING@{JSON\_OR\_STRING}}}\label{client_8cpp_aaedac74f66fe7dea34ec3ba3333e00aea6934c29904a9d9cf113994c67baf4bbb} 
JSON\+\_\+\+OR\+\_\+\+STRING&\\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{client.cpp@{client.cpp}!RPCConvertNamedValues@{RPCConvertNamedValues}}
\index{RPCConvertNamedValues@{RPCConvertNamedValues}!client.cpp@{client.cpp}}
\doxysubsubsection{RPCConvertNamedValues()}
{\footnotesize\ttfamily \label{client_8cpp_a38eaa6a1c0fafe2387d1cfdaf11bc360} 
\textbf{ Uni\+Value} RPCConvert\+Named\+Values (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str\+Method}{, }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{str\+Params}{}\end{DoxyParamCaption})}

Convert command line arguments to params object when -\/named is enabled.

The -\/named syntax accepts named arguments in NAME=VALUE format, as well as positional arguments without names. The syntax is inherently ambiguous if names are omitted and values contain \textquotesingle{}=\textquotesingle{}, so a heuristic is used to disambiguate\+:


\begin{DoxyItemize}
\item Arguments that do not contain \textquotesingle{}=\textquotesingle{} are treated as positional parameters.
\item Arguments that do contain \textquotesingle{}=\textquotesingle{} are assumed to be named parameters in NAME=VALUE format except for two special cases\+:
\begin{DoxyEnumerate}
\item The case where NAME is not a known parameter name, and the next positional parameter requires a JSON value, and the argument parses as JSON. E.\+g. ["{}list"{}, "{}with"{}, "{}="{}].
\item The case where NAME is not a known parameter name and the next positional parameter requires a string value. E.\+g. "{}my=wallet"{}.
\end{DoxyEnumerate}
\end{DoxyItemize}

For example, the command {\ttfamily bitcoin-\/cli -\/named createwallet "{}my=\doxyref{wallet}{p.}{namespacewallet}"{}}, the parser initially sees "{}my=wallet"{} and attempts to process it as a parameter named "{}my"{}. When it finds that "{}my"{} is not a valid named parameter parameter for this method, it falls back to checking the rule for the next available positional parameter (index 0). Because it finds the rule that this parameter is a Param\+Format\+::\+STRING, it correctly treats the entire "{}my=wallet"{} as a single positional string, successfully creating a wallet with that literal name. \index{client.cpp@{client.cpp}!RPCConvertValues@{RPCConvertValues}}
\index{RPCConvertValues@{RPCConvertValues}!client.cpp@{client.cpp}}
\doxysubsubsection{RPCConvertValues()}
{\footnotesize\ttfamily \label{client_8cpp_a1ea35c5db48e1175cdd55e4feb0ca6c8} 
\textbf{ Uni\+Value} RPCConvert\+Values (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str\+Method}{, }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{str\+Params}{}\end{DoxyParamCaption})}

Convert command lines arguments to params object when -\/named is disabled. 