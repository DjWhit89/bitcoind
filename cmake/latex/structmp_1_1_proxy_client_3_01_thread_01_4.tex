\doxysection{Proxy\+Client$<$ Thread $>$ Struct Reference}
\label{structmp_1_1_proxy_client_3_01_thread_01_4}\index{ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}}


{\ttfamily \#include $<$proxy-\/io.\+h$>$}

Inheritance diagram for Proxy\+Client$<$ Thread $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{structmp_1_1_proxy_client_3_01_thread_01_4}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Proxy\+Client} (const Proxy\+Client \&)=delete
\item 
\textbf{ $\sim$\+Proxy\+Client} ()
\item 
\textbf{ Proxy\+Client\+Base} (typename Interface\+::\+Client client, \textbf{ Connection} $\ast$connection, bool destroy\+\_\+connection)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Proxy\+Client\+Base$<$ Thread, \+::capnp\+::\+Void $>$}}
\begin{DoxyCompactItemize}
\item 
\textbf{ Proxy\+Client\+Base} (typename Interface\+::\+Client client, \textbf{ Connection} $\ast$connection, bool destroy\+\_\+connection)
\item 
\textbf{ $\sim$\+Proxy\+Client\+Base} () noexcept
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
std\+::optional$<$ \textbf{ Cleanup\+It} $>$ \textbf{ m\+\_\+disconnect\+\_\+cb}
\end{DoxyCompactItemize}
\doxysubsection*{Data Fields inherited from \textbf{ Proxy\+Client\+Base$<$ Thread, \+::capnp\+::\+Void $>$}}
\begin{DoxyCompactItemize}
\item 
Interface\+::\+Client \textbf{ m\+\_\+client}
\item 
\textbf{ Proxy\+Context} \textbf{ m\+\_\+context}
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Proxy\+Client\+Base$<$ Thread, \+::capnp\+::\+Void $>$}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Interface}
\item 
using \textbf{ Impl}
\item 
using \textbf{ Sub}
\item 
using \textbf{ Super}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions inherited from \textbf{ Proxy\+Client\+Base$<$ Thread, \+::capnp\+::\+Void $>$}}
\begin{DoxyCompactItemize}
\item 
static void \textbf{ construct} (\textbf{ Super} \&)
\item 
static void \textbf{ destroy} (\textbf{ Super} \&)
\end{DoxyCompactItemize}


\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}!ProxyClient@{ProxyClient}}
\index{ProxyClient@{ProxyClient}!ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}}
\doxysubsubsection{ProxyClient()}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_client_3_01_thread_01_4_acdc11ed333f47511007a0554f529e05b} 
Proxy\+Client (\begin{DoxyParamCaption}\item[{const Proxy\+Client$<$ Thread $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}!````~ProxyClient@{$\sim$ProxyClient}}
\index{````~ProxyClient@{$\sim$ProxyClient}!ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}}
\doxysubsubsection{$\sim$ProxyClient()}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_client_3_01_thread_01_4_a20e57d0d84ee9d0282a79764462d5568} 
$\sim$\textbf{ Proxy\+Client} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}!ProxyClientBase@{ProxyClientBase}}
\index{ProxyClientBase@{ProxyClientBase}!ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}}
\doxysubsubsection{ProxyClientBase()}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_client_3_01_thread_01_4_a32f6c2ed2bf7fd1668e2d5c3e5256682} 
Proxy\+Client\+Base (\begin{DoxyParamCaption}\item[{typename Interface\+::\+Client}]{client}{, }\item[{\textbf{ Connection} $\ast$}]{connection}{, }\item[{bool}]{destroy\+\_\+connection}{}\end{DoxyParamCaption})}

Construct libmultiprocess client object wrapping Cap\textquotesingle{}n Proto client object with a reference to the associated \doxyref{mp\+::\+Connection}{p.}{classmp_1_1_connection} object.

The destroy\+\_\+connection option determines whether destroying this client object closes the connection. It is set to true for the Proxy\+Client$<$\+Init\+Interface$>$ object returned by Connect\+Stream, to let IPC clients close the connection by freeing the object. It is false for other client objects so they can be destroyed without affecting the connection. 

\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}!m\_disconnect\_cb@{m\_disconnect\_cb}}
\index{m\_disconnect\_cb@{m\_disconnect\_cb}!ProxyClient$<$ Thread $>$@{ProxyClient$<$ Thread $>$}}
\doxysubsubsection{m\_disconnect\_cb}
{\footnotesize\ttfamily \label{structmp_1_1_proxy_client_3_01_thread_01_4_a36bc04dbcc8122bc405076c2bd588f7a} 
std\+::optional$<$\textbf{ Cleanup\+It}$>$ m\+\_\+disconnect\+\_\+cb}

Reference to callback function that is run if there is a sudden disconnect and the \doxyref{Connection}{p.}{classmp_1_1_connection} object is destroyed before this \doxyref{Proxy\+Client$<$\+Thread$>$}{p.}{structmp_1_1_proxy_client_3_01_thread_01_4} object. The callback will destroy this object and remove its entry from the thread\textquotesingle{}s request\+\_\+threads or callback\+\_\+threads map. It will also reset m\+\_\+disconnect\+\_\+cb so the destructor does not access it. In the normal case where there is no sudden disconnect, the destructor will unregister m\+\_\+disconnect\+\_\+cb so the callback is never run. Since this variable is accessed from multiple threads, accesses should be guarded with the associated \doxyref{Waiter\+::m\+\_\+mutex}{p.}{structmp_1_1_waiter_a71aaf23d91d7b7a5611738c4f06e3577}. 

The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/ipc/libmultiprocess/include/mp/\textbf{ proxy-\/io.\+h}\item 
src/ipc/libmultiprocess/src/mp/\textbf{ proxy.\+cpp}\end{DoxyCompactItemize}
