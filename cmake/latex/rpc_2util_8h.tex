\doxysection{src/rpc/util.h File Reference}
\label{rpc_2util_8h}\index{src/rpc/util.h@{src/rpc/util.h}}
{\ttfamily \#include $<$addresstype.\+h$>$}\newline
{\ttfamily \#include $<$consensus/amount.\+h$>$}\newline
{\ttfamily \#include $<$node/transaction.\+h$>$}\newline
{\ttfamily \#include $<$outputtype.\+h$>$}\newline
{\ttfamily \#include $<$pubkey.\+h$>$}\newline
{\ttfamily \#include $<$rpc/protocol.\+h$>$}\newline
{\ttfamily \#include $<$rpc/request.\+h$>$}\newline
{\ttfamily \#include $<$script/script.\+h$>$}\newline
{\ttfamily \#include $<$script/sign.\+h$>$}\newline
{\ttfamily \#include $<$uint256.\+h$>$}\newline
{\ttfamily \#include $<$univalue.\+h$>$}\newline
{\ttfamily \#include $<$util/check.\+h$>$}\newline
{\ttfamily \#include $<$cstddef$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$functional$>$}\newline
{\ttfamily \#include $<$initializer\+\_\+list$>$}\newline
{\ttfamily \#include $<$map$>$}\newline
{\ttfamily \#include $<$optional$>$}\newline
{\ttfamily \#include $<$string$>$}\newline
{\ttfamily \#include $<$string\+\_\+view$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$variant$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Help\+Result}
\item 
struct \textbf{ Uni\+Value\+Type}
\item 
struct \textbf{ RPCArg\+Options}
\item 
struct \textbf{ RPCArg}
\item 
struct \textbf{ RPCResult}
\item 
struct \textbf{ RPCResults}
\item 
struct \textbf{ RPCExamples}
\item 
class \textbf{ RPCHelp\+Man}
\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ common}
\item 
namespace \textbf{ node}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \textbf{ RPCArg\+List} = std\+::vector$<$std\+::pair$<$std\+::string, \textbf{ Uni\+Value}$>$$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Outer\+Type} \{ \textbf{ ARR}
, \textbf{ OBJ}
, \textbf{ NONE}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ Get\+All\+Output\+Types} ()
\item 
void \textbf{ RPCType\+Check\+Obj} (const \textbf{ Uni\+Value} \&o, const std\+::map$<$ std\+::string, \textbf{ Uni\+Value\+Type} $>$ \&types\+Expected, bool f\+Allow\+Null=false, bool f\+Strict=false)
\item 
\textbf{ uint256} \textbf{ Parse\+HashV} (const \textbf{ Uni\+Value} \&v, std\+::string\+\_\+view \textbf{ name})
\item 
\textbf{ uint256} \textbf{ Parse\+HashO} (const \textbf{ Uni\+Value} \&o, std\+::string\+\_\+view str\+Key)
\item 
std\+::vector$<$ unsigned char $>$ \textbf{ Parse\+HexV} (const \textbf{ Uni\+Value} \&v, std\+::string\+\_\+view \textbf{ name})
\item 
std\+::vector$<$ unsigned char $>$ \textbf{ Parse\+HexO} (const \textbf{ Uni\+Value} \&o, std\+::string\+\_\+view str\+Key)
\item 
int \textbf{ Parse\+Verbosity} (const \textbf{ Uni\+Value} \&arg, int default\+\_\+verbosity, bool allow\+\_\+bool)
\item 
\textbf{ CAmount} \textbf{ Amount\+From\+Value} (const \textbf{ Uni\+Value} \&value, int decimals=8)
\item 
\textbf{ CFee\+Rate} \textbf{ Parse\+Fee\+Rate} (const \textbf{ Uni\+Value} \&json)
\item 
std\+::string \textbf{ Help\+Example\+Cli} (const std\+::string \&methodname, const std\+::string \&\textbf{ args})
\item 
std\+::string \textbf{ Help\+Example\+Cli\+Named} (const std\+::string \&methodname, const \textbf{ RPCArg\+List} \&\textbf{ args})
\item 
std\+::string \textbf{ Help\+Example\+Rpc} (const std\+::string \&methodname, const std\+::string \&\textbf{ args})
\item 
std\+::string \textbf{ Help\+Example\+Rpc\+Named} (const std\+::string \&methodname, const \textbf{ RPCArg\+List} \&\textbf{ args})
\item 
\textbf{ CPub\+Key} \textbf{ Hex\+To\+Pub\+Key} (const std\+::string \&hex\+\_\+in)
\item 
\textbf{ CTx\+Destination} \textbf{ Add\+And\+Get\+Multisig\+Destination} (const int required, const std\+::vector$<$ \textbf{ CPub\+Key} $>$ \&pubkeys, \textbf{ Output\+Type} type, \textbf{ Flat\+Signing\+Provider} \&keystore, \textbf{ CScript} \&script\+\_\+out)
\item 
\textbf{ Uni\+Value} \textbf{ Describe\+Address} (const \textbf{ CTx\+Destination} \&dest)
\item 
std\+::optional$<$ int $>$ \textbf{ Parse\+Sighash\+String} (const \textbf{ Uni\+Value} \&sighash)
\item 
unsigned int \textbf{ Parse\+Confirm\+Target} (const \textbf{ Uni\+Value} \&value, unsigned int max\+\_\+target)
\begin{DoxyCompactList}\small\item\em Parse a confirm target option and raise an RPC error if it is invalid. \end{DoxyCompactList}\item 
\textbf{ RPCError\+Code} \textbf{ RPCError\+From\+Transaction\+Error} (\textbf{ node\+::\+Transaction\+Error} terr)
\item 
\textbf{ Uni\+Value} \textbf{ JSONRPCPSBTError} (\textbf{ common\+::\+PSBTError} err)
\item 
\textbf{ Uni\+Value} \textbf{ JSONRPCTransaction\+Error} (\textbf{ node\+::\+Transaction\+Error} terr, const std\+::string \&err\+\_\+string="{}"{})
\item 
std\+::pair$<$ int64\+\_\+t, int64\+\_\+t $>$ \textbf{ Parse\+Descriptor\+Range} (const \textbf{ Uni\+Value} \&value)
\begin{DoxyCompactList}\small\item\em Parse a JSON range specified as int64, or [int64, int64]. \end{DoxyCompactList}\item 
std\+::vector$<$ \textbf{ CScript} $>$ \textbf{ Eval\+Descriptor\+String\+Or\+Object} (const \textbf{ Uni\+Value} \&scanobject, \textbf{ Flat\+Signing\+Provider} \&provider, const bool expand\+\_\+priv=false)
\item 
void \textbf{ Push\+Warnings} (const \textbf{ Uni\+Value} \&warnings, \textbf{ Uni\+Value} \&obj)
\item 
void \textbf{ Push\+Warnings} (const std\+::vector$<$ \textbf{ bilingual\+\_\+str} $>$ \&warnings, \textbf{ Uni\+Value} \&obj)
\item 
std\+::vector$<$ \textbf{ RPCResult} $>$ \textbf{ Script\+Pub\+Key\+Doc} ()
\item 
\textbf{ uint256} \textbf{ Get\+Target} (const \textbf{ CBlock\+Index} \&blockindex, const \textbf{ uint256} pow\+\_\+limit)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const std\+::string \textbf{ UNIX\+\_\+\+EPOCH\+\_\+\+TIME}
\item 
const std\+::string \textbf{ EXAMPLE\+\_\+\+ADDRESS} [2]
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{util.h@{util.h}!RPCArgList@{RPCArgList}}
\index{RPCArgList@{RPCArgList}!util.h@{util.h}}
\doxysubsubsection{RPCArgList}
{\footnotesize\ttfamily \label{rpc_2util_8h_ab693959629bd7d0ec0f81468e190f1f4} 
using \textbf{ RPCArg\+List} = std\+::vector$<$std\+::pair$<$std\+::string, \textbf{ Uni\+Value}$>$$>$}



\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{util.h@{util.h}!OuterType@{OuterType}}
\index{OuterType@{OuterType}!util.h@{util.h}}
\doxysubsubsection{OuterType}
{\footnotesize\ttfamily \label{rpc_2util_8h_a8b1c0fde2e2c40e3059c7a924cab76de} 
enum class \textbf{ Outer\+Type}\hspace{0.3cm}{\ttfamily [strong]}}

Serializing JSON objects depends on the outer type. Only arrays and dictionaries can be nested in json. The top-\/level outer type is "{}\+NONE"{}. \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{ARR@{ARR}!util.h@{util.h}}\index{util.h@{util.h}!ARR@{ARR}}}\label{rpc_2util_8h_a8b1c0fde2e2c40e3059c7a924cab76deac703eb65f968f2a9c9145fd07132f72b} 
ARR&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{OBJ@{OBJ}!util.h@{util.h}}\index{util.h@{util.h}!OBJ@{OBJ}}}\label{rpc_2util_8h_a8b1c0fde2e2c40e3059c7a924cab76deaf34d534adfb78a9e6432be4621a93eec} 
OBJ&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NONE@{NONE}!util.h@{util.h}}\index{util.h@{util.h}!NONE@{NONE}}}\label{rpc_2util_8h_a8b1c0fde2e2c40e3059c7a924cab76deab50339a10e1de285ac99d4c3990b8693} 
NONE&\\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{util.h@{util.h}!AddAndGetMultisigDestination@{AddAndGetMultisigDestination}}
\index{AddAndGetMultisigDestination@{AddAndGetMultisigDestination}!util.h@{util.h}}
\doxysubsubsection{AddAndGetMultisigDestination()}
{\footnotesize\ttfamily \label{rpc_2util_8h_add5432950866445c7ae5584c7573c9a6} 
\textbf{ CTx\+Destination} Add\+And\+Get\+Multisig\+Destination (\begin{DoxyParamCaption}\item[{const int}]{required}{, }\item[{const std\+::vector$<$ \textbf{ CPub\+Key} $>$ \&}]{pubkeys}{, }\item[{\textbf{ Output\+Type}}]{type}{, }\item[{\textbf{ Flat\+Signing\+Provider} \&}]{keystore}{, }\item[{\textbf{ CScript} \&}]{script\+\_\+out}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!AmountFromValue@{AmountFromValue}}
\index{AmountFromValue@{AmountFromValue}!util.h@{util.h}}
\doxysubsubsection{AmountFromValue()}
{\footnotesize\ttfamily \label{rpc_2util_8h_aa3db7248650452a9b17808a42e33a8a7} 
\textbf{ CAmount} Amount\+From\+Value (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{value}{, }\item[{int}]{decimals}{ = {\ttfamily 8}}\end{DoxyParamCaption})}

Validate and return a \doxyref{CAmount}{p.}{amount_8h_a4eaf3a5239714d8c45b851527f7cb564} from a \doxyref{Uni\+Value}{p.}{class_uni_value} number or string.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em value} & \doxyref{Uni\+Value}{p.}{class_uni_value} number or string to parse. \\
\hline
\mbox{\texttt{in}}  & {\em decimals} & Number of significant digits (default\+: 8). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \doxyref{CAmount}{p.}{amount_8h_a4eaf3a5239714d8c45b851527f7cb564} if the various checks pass. 
\end{DoxyReturn}
\index{util.h@{util.h}!DescribeAddress@{DescribeAddress}}
\index{DescribeAddress@{DescribeAddress}!util.h@{util.h}}
\doxysubsubsection{DescribeAddress()}
{\footnotesize\ttfamily \label{rpc_2util_8h_af91efe7877ce4e77064e04d13888ae4f} 
\textbf{ Uni\+Value} Describe\+Address (\begin{DoxyParamCaption}\item[{const \textbf{ CTx\+Destination} \&}]{dest}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!EvalDescriptorStringOrObject@{EvalDescriptorStringOrObject}}
\index{EvalDescriptorStringOrObject@{EvalDescriptorStringOrObject}!util.h@{util.h}}
\doxysubsubsection{EvalDescriptorStringOrObject()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a0486cc588687ca96ecae010803be29a2} 
std\+::vector$<$ \textbf{ CScript} $>$ Eval\+Descriptor\+String\+Or\+Object (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{scanobject}{, }\item[{\textbf{ Flat\+Signing\+Provider} \&}]{provider}{, }\item[{const bool}]{expand\+\_\+priv}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Evaluate a descriptor given as a string, or as a \{"{}desc"{}\+:...,"{}range"{}\+:...\} object, with default range of 1000. \index{util.h@{util.h}!GetAllOutputTypes@{GetAllOutputTypes}}
\index{GetAllOutputTypes@{GetAllOutputTypes}!util.h@{util.h}}
\doxysubsubsection{GetAllOutputTypes()}
{\footnotesize\ttfamily \label{rpc_2util_8h_ab80177724d583c7709f7d0aa6dc7cb29} 
std\+::string Get\+All\+Output\+Types (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Gets all existing output types formatted for RPC help sections.

\begin{DoxyReturn}{Returns}
Comma separated string representing output type names. 
\end{DoxyReturn}
\index{util.h@{util.h}!GetTarget@{GetTarget}}
\index{GetTarget@{GetTarget}!util.h@{util.h}}
\doxysubsubsection{GetTarget()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a76268fe0c09309e309553810f65c3ee1} 
\textbf{ uint256} Get\+Target (\begin{DoxyParamCaption}\item[{const \textbf{ CBlock\+Index} \&}]{blockindex}{, }\item[{const \textbf{ uint256}}]{pow\+\_\+limit}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!HelpExampleCli@{HelpExampleCli}}
\index{HelpExampleCli@{HelpExampleCli}!util.h@{util.h}}
\doxysubsubsection{HelpExampleCli()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a26bafe3d526ee8cbc84b3c0b0dc3a43b} 
std\+::string Help\+Example\+Cli (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{methodname}{, }\item[{const std\+::string \&}]{args}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!HelpExampleCliNamed@{HelpExampleCliNamed}}
\index{HelpExampleCliNamed@{HelpExampleCliNamed}!util.h@{util.h}}
\doxysubsubsection{HelpExampleCliNamed()}
{\footnotesize\ttfamily \label{rpc_2util_8h_aef68e5e578187453853ef0db399ee5f9} 
std\+::string Help\+Example\+Cli\+Named (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{methodname}{, }\item[{const \textbf{ RPCArg\+List} \&}]{args}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!HelpExampleRpc@{HelpExampleRpc}}
\index{HelpExampleRpc@{HelpExampleRpc}!util.h@{util.h}}
\doxysubsubsection{HelpExampleRpc()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a9ef4f8fb114508ceb861a0e8c3e0d26e} 
std\+::string Help\+Example\+Rpc (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{methodname}{, }\item[{const std\+::string \&}]{args}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!HelpExampleRpcNamed@{HelpExampleRpcNamed}}
\index{HelpExampleRpcNamed@{HelpExampleRpcNamed}!util.h@{util.h}}
\doxysubsubsection{HelpExampleRpcNamed()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a33f1f1f1de6d60ce9bb6c96da2fe0314} 
std\+::string Help\+Example\+Rpc\+Named (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{methodname}{, }\item[{const \textbf{ RPCArg\+List} \&}]{args}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!HexToPubKey@{HexToPubKey}}
\index{HexToPubKey@{HexToPubKey}!util.h@{util.h}}
\doxysubsubsection{HexToPubKey()}
{\footnotesize\ttfamily \label{rpc_2util_8h_ac18ea86a874bf7841b716eca2b467746} 
\textbf{ CPub\+Key} Hex\+To\+Pub\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{hex\+\_\+in}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!JSONRPCPSBTError@{JSONRPCPSBTError}}
\index{JSONRPCPSBTError@{JSONRPCPSBTError}!util.h@{util.h}}
\doxysubsubsection{JSONRPCPSBTError()}
{\footnotesize\ttfamily \label{rpc_2util_8h_abdfa6f97708cda0f4dcde07802187fc7} 
\textbf{ Uni\+Value} JSONRPCPSBTError (\begin{DoxyParamCaption}\item[{\textbf{ common\+::\+PSBTError}}]{err}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!JSONRPCTransactionError@{JSONRPCTransactionError}}
\index{JSONRPCTransactionError@{JSONRPCTransactionError}!util.h@{util.h}}
\doxysubsubsection{JSONRPCTransactionError()}
{\footnotesize\ttfamily \label{rpc_2util_8h_aba075011bec6c15d363fc1f6e0af1c44} 
\textbf{ Uni\+Value} JSONRPCTransaction\+Error (\begin{DoxyParamCaption}\item[{\textbf{ node\+::\+Transaction\+Error}}]{terr}{, }\item[{const std\+::string \&}]{err\+\_\+string}{ = {\ttfamily "{}"{}}}\end{DoxyParamCaption})}

\index{util.h@{util.h}!ParseConfirmTarget@{ParseConfirmTarget}}
\index{ParseConfirmTarget@{ParseConfirmTarget}!util.h@{util.h}}
\doxysubsubsection{ParseConfirmTarget()}
{\footnotesize\ttfamily \label{rpc_2util_8h_ae928fea7d8ddf182a6ccc24e2156b065} 
unsigned int Parse\+Confirm\+Target (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{value}{, }\item[{unsigned int}]{max\+\_\+target}{}\end{DoxyParamCaption})}



Parse a confirm target option and raise an RPC error if it is invalid. 

\index{util.h@{util.h}!ParseDescriptorRange@{ParseDescriptorRange}}
\index{ParseDescriptorRange@{ParseDescriptorRange}!util.h@{util.h}}
\doxysubsubsection{ParseDescriptorRange()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a1f77552bf8ab978f0d9feaee2c9c96c7} 
std\+::pair$<$ int64\+\_\+t, int64\+\_\+t $>$ Parse\+Descriptor\+Range (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{value}{}\end{DoxyParamCaption})}



Parse a JSON range specified as int64, or [int64, int64]. 

\index{util.h@{util.h}!ParseFeeRate@{ParseFeeRate}}
\index{ParseFeeRate@{ParseFeeRate}!util.h@{util.h}}
\doxysubsubsection{ParseFeeRate()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a86ad0583c6e2ec8636a98943a1f7df1d} 
\textbf{ CFee\+Rate} Parse\+Fee\+Rate (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{json}{}\end{DoxyParamCaption})}

Parse a json number or string, denoting BTC/kvB, into a \doxyref{CFee\+Rate}{p.}{class_c_fee_rate} (sat/kvB). Reject negative values or rates larger than 1BTC/kvB. \index{util.h@{util.h}!ParseHashO@{ParseHashO}}
\index{ParseHashO@{ParseHashO}!util.h@{util.h}}
\doxysubsubsection{ParseHashO()}
{\footnotesize\ttfamily \label{rpc_2util_8h_ae8c631504cb78f78f6d8486df8d3a367} 
\textbf{ uint256} Parse\+HashO (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{o}{, }\item[{std\+::string\+\_\+view}]{str\+Key}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!ParseHashV@{ParseHashV}}
\index{ParseHashV@{ParseHashV}!util.h@{util.h}}
\doxysubsubsection{ParseHashV()}
{\footnotesize\ttfamily \label{rpc_2util_8h_af3015e129d8128c9a63782d20bd938a8} 
\textbf{ uint256} Parse\+HashV (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{v}{, }\item[{std\+::string\+\_\+view}]{name}{}\end{DoxyParamCaption})}

Utilities\+: convert hex-\/encoded Values (throws error if not hex). \index{util.h@{util.h}!ParseHexO@{ParseHexO}}
\index{ParseHexO@{ParseHexO}!util.h@{util.h}}
\doxysubsubsection{ParseHexO()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a73c0ee86b761a7bfd3d32019e048fadb} 
std\+::vector$<$ unsigned char $>$ Parse\+HexO (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{o}{, }\item[{std\+::string\+\_\+view}]{str\+Key}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!ParseHexV@{ParseHexV}}
\index{ParseHexV@{ParseHexV}!util.h@{util.h}}
\doxysubsubsection{ParseHexV()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a48967efeadd670a8c428e7d96b363a07} 
std\+::vector$<$ unsigned char $>$ Parse\+HexV (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{v}{, }\item[{std\+::string\+\_\+view}]{name}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!ParseSighashString@{ParseSighashString}}
\index{ParseSighashString@{ParseSighashString}!util.h@{util.h}}
\doxysubsubsection{ParseSighashString()}
{\footnotesize\ttfamily \label{rpc_2util_8h_ada9f55d73614722cd8f644539574860f} 
std\+::optional$<$ int $>$ Parse\+Sighash\+String (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{sighash}{}\end{DoxyParamCaption})}

Parse a sighash string representation and raise an RPC error if it is invalid.

Returns a sighash value corresponding to the passed in argument.

\begin{DoxyPrecond}{Precondition}
The sighash argument should be string or null. 
\end{DoxyPrecond}
\index{util.h@{util.h}!ParseVerbosity@{ParseVerbosity}}
\index{ParseVerbosity@{ParseVerbosity}!util.h@{util.h}}
\doxysubsubsection{ParseVerbosity()}
{\footnotesize\ttfamily \label{rpc_2util_8h_aba9a721416437d74615d14cb3727db14} 
int Parse\+Verbosity (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{arg}{, }\item[{int}]{default\+\_\+verbosity}{, }\item[{bool}]{allow\+\_\+bool}{}\end{DoxyParamCaption})}

Parses verbosity from provided \doxyref{Uni\+Value}{p.}{class_uni_value}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em arg} & The verbosity argument as an int (0, 1, 2,...) or bool if allow\+\_\+bool is set to true \\
\hline
\mbox{\texttt{in}}  & {\em default\+\_\+verbosity} & The value to return if verbosity argument is null \\
\hline
\mbox{\texttt{in}}  & {\em allow\+\_\+bool} & If true, allows arg to be a bool and parses it \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An integer describing the verbosity level (e.\+g. 0, 1, 2, etc.) 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em JSONRPCError} & if allow\+\_\+bool is false but arg provided is boolean \\
\hline
\end{DoxyExceptions}
\index{util.h@{util.h}!PushWarnings@{PushWarnings}}
\index{PushWarnings@{PushWarnings}!util.h@{util.h}}
\doxysubsubsection{PushWarnings()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{rpc_2util_8h_acdc94b40081909405691e3950cbae69e} 
void Push\+Warnings (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \textbf{ bilingual\+\_\+str} $>$ \&}]{warnings}{, }\item[{\textbf{ Uni\+Value} \&}]{obj}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!PushWarnings@{PushWarnings}}
\index{PushWarnings@{PushWarnings}!util.h@{util.h}}
\doxysubsubsection{PushWarnings()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{rpc_2util_8h_a538b11e78440f82d49a51465b9eef3fd} 
void Push\+Warnings (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{warnings}{, }\item[{\textbf{ Uni\+Value} \&}]{obj}{}\end{DoxyParamCaption})}

Push warning messages to an RPC "{}warnings"{} field as a JSON array of strings.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em warnings} & Warning messages to push. \\
\hline
\mbox{\texttt{out}}  & {\em obj} & \doxyref{Uni\+Value}{p.}{class_uni_value} object to push the warnings array object to. \\
\hline
\end{DoxyParams}
\index{util.h@{util.h}!RPCErrorFromTransactionError@{RPCErrorFromTransactionError}}
\index{RPCErrorFromTransactionError@{RPCErrorFromTransactionError}!util.h@{util.h}}
\doxysubsubsection{RPCErrorFromTransactionError()}
{\footnotesize\ttfamily \label{rpc_2util_8h_a18189d468a09ef31a3e0390c051be791} 
\textbf{ RPCError\+Code} RPCError\+From\+Transaction\+Error (\begin{DoxyParamCaption}\item[{\textbf{ node\+::\+Transaction\+Error}}]{terr}{}\end{DoxyParamCaption})}

\index{util.h@{util.h}!RPCTypeCheckObj@{RPCTypeCheckObj}}
\index{RPCTypeCheckObj@{RPCTypeCheckObj}!util.h@{util.h}}
\doxysubsubsection{RPCTypeCheckObj()}
{\footnotesize\ttfamily \label{rpc_2util_8h_ab6e621702aaefd12b164609463e81150} 
void RPCType\+Check\+Obj (\begin{DoxyParamCaption}\item[{const \textbf{ Uni\+Value} \&}]{o}{, }\item[{const std\+::map$<$ std\+::string, \textbf{ Uni\+Value\+Type} $>$ \&}]{types\+Expected}{, }\item[{bool}]{f\+Allow\+Null}{ = {\ttfamily false}, }\item[{bool}]{f\+Strict}{ = {\ttfamily false}}\end{DoxyParamCaption})}

\index{util.h@{util.h}!ScriptPubKeyDoc@{ScriptPubKeyDoc}}
\index{ScriptPubKeyDoc@{ScriptPubKeyDoc}!util.h@{util.h}}
\doxysubsubsection{ScriptPubKeyDoc()}
{\footnotesize\ttfamily \label{rpc_2util_8h_afd27d784ca049d2a67129232d42a6db1} 
std\+::vector$<$ \textbf{ RPCResult} $>$ Script\+Pub\+Key\+Doc (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-var-members}
\doxysubsection{Variable Documentation}
\index{util.h@{util.h}!EXAMPLE\_ADDRESS@{EXAMPLE\_ADDRESS}}
\index{EXAMPLE\_ADDRESS@{EXAMPLE\_ADDRESS}!util.h@{util.h}}
\doxysubsubsection{EXAMPLE\_ADDRESS}
{\footnotesize\ttfamily \label{rpc_2util_8h_adbb21c6828f59f3df79b3d25c0821635} 
const std\+::string EXAMPLE\+\_\+\+ADDRESS[2]\hspace{0.3cm}{\ttfamily [extern]}}

Example \doxyref{bech32}{p.}{namespacebech32} addresses for the \doxyref{RPCExamples}{p.}{struct_r_p_c_examples} help documentation. They are intentionally invalid to prevent accidental transactions by users. \index{util.h@{util.h}!UNIX\_EPOCH\_TIME@{UNIX\_EPOCH\_TIME}}
\index{UNIX\_EPOCH\_TIME@{UNIX\_EPOCH\_TIME}!util.h@{util.h}}
\doxysubsubsection{UNIX\_EPOCH\_TIME}
{\footnotesize\ttfamily \label{rpc_2util_8h_aad676cc5fc482fffa78911b8d7d9d32d} 
const std\+::string UNIX\+\_\+\+EPOCH\+\_\+\+TIME\hspace{0.3cm}{\ttfamily [extern]}}

String used to describe UNIX epoch time in documentation, factored out to a constant for consistency. 