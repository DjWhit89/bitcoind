\doxysection{src/script/miniscript.h File Reference}
\label{miniscript_8h}\index{src/script/miniscript.h@{src/script/miniscript.h}}
{\ttfamily \#include $<$algorithm$>$}\newline
{\ttfamily \#include $<$compare$>$}\newline
{\ttfamily \#include $<$cstdint$>$}\newline
{\ttfamily \#include $<$cstdlib$>$}\newline
{\ttfamily \#include $<$iterator$>$}\newline
{\ttfamily \#include $<$memory$>$}\newline
{\ttfamily \#include $<$optional$>$}\newline
{\ttfamily \#include $<$set$>$}\newline
{\ttfamily \#include $<$stdexcept$>$}\newline
{\ttfamily \#include $<$tuple$>$}\newline
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include $<$consensus/consensus.\+h$>$}\newline
{\ttfamily \#include $<$policy/policy.\+h$>$}\newline
{\ttfamily \#include $<$script/interpreter.\+h$>$}\newline
{\ttfamily \#include $<$script/parsing.\+h$>$}\newline
{\ttfamily \#include $<$script/script.\+h$>$}\newline
{\ttfamily \#include $<$serialize.\+h$>$}\newline
{\ttfamily \#include $<$span.\+h$>$}\newline
{\ttfamily \#include $<$util/check.\+h$>$}\newline
{\ttfamily \#include $<$util/strencodings.\+h$>$}\newline
{\ttfamily \#include $<$util/string.\+h$>$}\newline
{\ttfamily \#include $<$util/vector.\+h$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Type}
\item 
struct \textbf{ Input\+Stack}
\begin{DoxyCompactList}\small\item\em An object representing a sequence of witness stack elements. \end{DoxyCompactList}\item 
struct \textbf{ Input\+Result}
\begin{DoxyCompactList}\small\item\em A pair of a satisfaction and a dissatisfaction \doxyref{Input\+Stack}{p.}{structminiscript_1_1internal_1_1_input_stack}. \end{DoxyCompactList}\item 
struct \textbf{ Max\+Int$<$ I $>$}
\begin{DoxyCompactList}\small\item\em Class whose objects represent the maximum of a list of integers. \end{DoxyCompactList}\item 
struct \textbf{ Ops}
\item 
struct \textbf{ Sat\+Info}
\item 
struct \textbf{ Stack\+Size}
\item 
struct \textbf{ Witness\+Size}
\item 
struct \textbf{ No\+Dup\+Check}
\item 
struct \textbf{ Node$<$ Key $>$}
\begin{DoxyCompactList}\small\item\em A node in a miniscript expression. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \textbf{ miniscript}
\item 
namespace \textbf{ miniscript\+::internal}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Opcode} = std\+::pair$<$\textbf{ opcodetype}, std\+::vector$<$unsigned char$>$$>$
\item 
{\footnotesize template$<$typename Key$>$ }\\using \textbf{ Node\+Ref} = std\+::unique\+\_\+ptr$<$const \textbf{ Node}$<$Key$>$$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Fragment} \{ \newline
\textbf{ JUST\+\_\+0}
, \textbf{ JUST\+\_\+1}
, \textbf{ PK\+\_\+K}
, \textbf{ PK\+\_\+H}
, \newline
\textbf{ OLDER}
, \textbf{ AFTER}
, \textbf{ SHA256}
, \textbf{ HASH256}
, \newline
\textbf{ RIPEMD160}
, \textbf{ HASH160}
, \textbf{ WRAP\+\_\+A}
, \textbf{ WRAP\+\_\+S}
, \newline
\textbf{ WRAP\+\_\+C}
, \textbf{ WRAP\+\_\+D}
, \textbf{ WRAP\+\_\+V}
, \textbf{ WRAP\+\_\+J}
, \newline
\textbf{ WRAP\+\_\+N}
, \textbf{ AND\+\_\+V}
, \textbf{ AND\+\_\+B}
, \textbf{ OR\+\_\+B}
, \newline
\textbf{ OR\+\_\+C}
, \textbf{ OR\+\_\+D}
, \textbf{ OR\+\_\+I}
, \textbf{ ANDOR}
, \newline
\textbf{ THRESH}
, \textbf{ MULTI}
, \textbf{ MULTI\+\_\+A}
 \}
\begin{DoxyCompactList}\small\item\em The different node types in miniscript. \end{DoxyCompactList}\item 
enum class \textbf{ Availability} \{ \textbf{ NO}
, \textbf{ YES}
, \textbf{ MAYBE}
 \}
\item 
enum class \textbf{ Miniscript\+Context} \{ \textbf{ P2\+WSH}
, \textbf{ TAPSCRIPT}
 \}
\item 
enum class \textbf{ Parse\+Context} \{ \newline
\textbf{ WRAPPED\+\_\+\+EXPR}
, \textbf{ EXPR}
, \textbf{ SWAP}
, \textbf{ ALT}
, \newline
\textbf{ CHECK}
, \textbf{ DUP\+\_\+\+IF}
, \textbf{ VERIFY}
, \textbf{ NON\+\_\+\+ZERO}
, \newline
\textbf{ ZERO\+\_\+\+NOTEQUAL}
, \textbf{ WRAP\+\_\+U}
, \textbf{ WRAP\+\_\+T}
, \textbf{ AND\+\_\+N}
, \newline
\textbf{ AND\+\_\+V}
, \textbf{ AND\+\_\+B}
, \textbf{ ANDOR}
, \textbf{ OR\+\_\+B}
, \newline
\textbf{ OR\+\_\+C}
, \textbf{ OR\+\_\+D}
, \textbf{ OR\+\_\+I}
, \textbf{ THRESH}
, \newline
\textbf{ COMMA}
, \textbf{ CLOSE\+\_\+\+BRACKET}
 \}
\item 
enum class \textbf{ Decode\+Context} \{ \newline
\textbf{ SINGLE\+\_\+\+BKV\+\_\+\+EXPR}
, \textbf{ BKV\+\_\+\+EXPR}
, \textbf{ W\+\_\+\+EXPR}
, \textbf{ SWAP}
, \newline
\textbf{ ALT}
, \textbf{ CHECK}
, \textbf{ DUP\+\_\+\+IF}
, \textbf{ VERIFY}
, \newline
\textbf{ NON\+\_\+\+ZERO}
, \textbf{ ZERO\+\_\+\+NOTEQUAL}
, \textbf{ MAYBE\+\_\+\+AND\+\_\+V}
, \textbf{ AND\+\_\+V}
, \newline
\textbf{ AND\+\_\+B}
, \textbf{ ANDOR}
, \textbf{ OR\+\_\+B}
, \textbf{ OR\+\_\+C}
, \newline
\textbf{ OR\+\_\+D}
, \textbf{ THRESH\+\_\+W}
, \textbf{ THRESH\+\_\+E}
, \textbf{ ENDIF}
, \newline
\textbf{ ENDIF\+\_\+\+NOTIF}
, \textbf{ ENDIF\+\_\+\+ELSE}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
consteval \textbf{ Type} \textbf{ operator"{}"{}\+\_\+mst} (const char $\ast$c, size\+\_\+t l)
\begin{DoxyCompactList}\small\item\em Literal operator to construct \doxyref{Type}{p.}{classminiscript_1_1_type} objects. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Key, typename... Args$>$ }\\\textbf{ Node\+Ref}$<$ Key $>$ \textbf{ Make\+Node\+Ref} (Args \&\&... \textbf{ args})
\begin{DoxyCompactList}\small\item\em Construct a miniscript node as a unique\+\_\+ptr. \end{DoxyCompactList}\item 
constexpr bool \textbf{ Is\+Tapscript} (\textbf{ Miniscript\+Context} ms\+\_\+ctx)
\item 
constexpr uint32\+\_\+t \textbf{ Max\+Script\+Size} (\textbf{ Miniscript\+Context} ms\+\_\+ctx)
\item 
\textbf{ Type} \textbf{ Compute\+Type} (\textbf{ Fragment} fragment, \textbf{ Type} x, \textbf{ Type} y, \textbf{ Type} z, const std\+::vector$<$ \textbf{ Type} $>$ \&sub\+\_\+types, uint32\+\_\+t k, size\+\_\+t data\+\_\+size, size\+\_\+t n\+\_\+subs, size\+\_\+t n\+\_\+keys, \textbf{ Miniscript\+Context} ms\+\_\+ctx)
\begin{DoxyCompactList}\small\item\em Helper function for Node\+::\+Calc\+Type. \end{DoxyCompactList}\item 
size\+\_\+t \textbf{ Compute\+Script\+Len} (\textbf{ Fragment} fragment, \textbf{ Type} sub0typ, size\+\_\+t subsize, uint32\+\_\+t k, size\+\_\+t n\+\_\+subs, size\+\_\+t n\+\_\+keys, \textbf{ Miniscript\+Context} ms\+\_\+ctx)
\begin{DoxyCompactList}\small\item\em Helper function for Node\+::\+Calc\+Script\+Len. \end{DoxyCompactList}\item 
\textbf{ Type} \textbf{ Sanitize\+Type} (\textbf{ Type} x)
\begin{DoxyCompactList}\small\item\em A helper sanitizer/checker for the output of Calc\+Type. \end{DoxyCompactList}\item 
int \textbf{ Find\+Next\+Char} (std\+::span$<$ const char $>$ sp, const char m)
\item 
{\footnotesize template$<$typename Key, typename Ctx$>$ }\\std\+::optional$<$ std\+::pair$<$ Key, int $>$ $>$ \textbf{ Parse\+Key\+End} (std\+::span$<$ const char $>$ in, const Ctx \&ctx)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\std\+::optional$<$ std\+::pair$<$ std\+::vector$<$ unsigned char $>$, int $>$ $>$ \textbf{ Parse\+Hex\+Str\+End} (std\+::span$<$ const char $>$ in, const size\+\_\+t expected\+\_\+size, const Ctx \&ctx)
\item 
{\footnotesize template$<$typename Key$>$ }\\void \textbf{ Build\+Back} (const \textbf{ Miniscript\+Context} script\+\_\+ctx, \textbf{ Fragment} nt, std\+::vector$<$ \textbf{ Node\+Ref}$<$ Key $>$ $>$ \&constructed, const bool reverse=false)
\item 
{\footnotesize template$<$typename Key, typename Ctx$>$ }\\\textbf{ Node\+Ref}$<$ Key $>$ \textbf{ Parse} (std\+::span$<$ const char $>$ in, const Ctx \&ctx)
\item 
std\+::optional$<$ std\+::vector$<$ \textbf{ Opcode} $>$ $>$ \textbf{ Decompose\+Script} (const \textbf{ CScript} \&\textbf{ script})
\item 
std\+::optional$<$ int64\+\_\+t $>$ \textbf{ Parse\+Script\+Number} (const \textbf{ Opcode} \&in)
\item 
{\footnotesize template$<$typename Key, typename Ctx, typename I$>$ }\\\textbf{ Node\+Ref}$<$ Key $>$ \textbf{ Decode\+Script} (I \&in, I last, const Ctx \&ctx)
\begin{DoxyCompactList}\small\item\em Parse a miniscript from a bitcoin script. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node\+Ref}$<$ typename Ctx\+::\+Key $>$ \textbf{ From\+String} (const std\+::string \&str, const Ctx \&ctx)
\item 
{\footnotesize template$<$typename Ctx$>$ }\\\textbf{ Node\+Ref}$<$ typename Ctx\+::\+Key $>$ \textbf{ From\+Script} (const \textbf{ CScript} \&\textbf{ script}, const Ctx \&ctx)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr uint32\+\_\+t \textbf{ TX\+\_\+\+OVERHEAD} \{4 + 4\}
\begin{DoxyCompactList}\small\item\em version + n\+Lock\+Time \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ TXIN\+\_\+\+BYTES\+\_\+\+NO\+\_\+\+WITNESS} \{36 + 4 + 1\}
\begin{DoxyCompactList}\small\item\em prevout + n\+Sequence + script\+Sig \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ P2\+WSH\+\_\+\+TXOUT\+\_\+\+BYTES} \{8 + 1 + 1 + 33\}
\begin{DoxyCompactList}\small\item\em n\+Value + script len + OP\+\_\+0 + pushdata 32. \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ TX\+\_\+\+BODY\+\_\+\+LEEWAY\+\_\+\+WEIGHT} \{(\textbf{ TX\+\_\+\+OVERHEAD} + \textbf{ Get\+Size\+Of\+Compact\+Size}(1) + \textbf{ TXIN\+\_\+\+BYTES\+\_\+\+NO\+\_\+\+WITNESS} + \textbf{ Get\+Size\+Of\+Compact\+Size}(1) + \textbf{ P2\+WSH\+\_\+\+TXOUT\+\_\+\+BYTES}) $\ast$ WITNESS\+\_\+\+SCALE\+\_\+\+FACTOR + 2\}
\begin{DoxyCompactList}\small\item\em Data other than the witness in a transaction. Overhead + vin count + one vin + vout count + one vout + segwit marker. \end{DoxyCompactList}\item 
constexpr uint32\+\_\+t \textbf{ MAX\+\_\+\+TAPSCRIPT\+\_\+\+SAT\+\_\+\+SIZE} \{\textbf{ Get\+Size\+Of\+Compact\+Size}(MAX\+\_\+\+STACK\+\_\+\+SIZE) + (\textbf{ Get\+Size\+Of\+Compact\+Size}(MAX\+\_\+\+TAPMINISCRIPT\+\_\+\+STACK\+\_\+\+ELEM\+\_\+\+SIZE) + MAX\+\_\+\+TAPMINISCRIPT\+\_\+\+STACK\+\_\+\+ELEM\+\_\+\+SIZE) $\ast$ MAX\+\_\+\+STACK\+\_\+\+SIZE + \textbf{ Get\+Size\+Of\+Compact\+Size}(TAPROOT\+\_\+\+CONTROL\+\_\+\+MAX\+\_\+\+SIZE) + TAPROOT\+\_\+\+CONTROL\+\_\+\+MAX\+\_\+\+SIZE\}
\begin{DoxyCompactList}\small\item\em Maximum possible stack size to spend a Taproot output (excluding the script itself). \end{DoxyCompactList}\end{DoxyCompactItemize}
