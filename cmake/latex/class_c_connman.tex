\doxysection{CConnman Class Reference}
\label{class_c_connman}\index{CConnman@{CConnman}}


{\ttfamily \#include $<$net.\+h$>$}

Inheritance diagram for CConnman\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_c_connman}
\end{center}
\end{figure}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Options}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Node\+Fn} = std\+::function$<$void(\textbf{ CNode}$\ast$)$>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Init} (const \textbf{ Options} \&conn\+Options) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex
\item 
const bool \textbf{ use\+\_\+v2transport} (\textbf{ Get\+Local\+Services}() \&\textbf{ NODE\+\_\+\+P2\+P\+\_\+\+V2})
\item 
\textbf{ for} (const std\+::string \&added\+\_\+node \+:conn\+Options.\+m\+\_\+added\+\_\+nodes)
\item 
void \textbf{ Set\+Capture\+Messages} (bool cap)
\item 
\textbf{ CConnman} (uint64\+\_\+t seed0, uint64\+\_\+t seed1, \textbf{ Addr\+Man} \&addrman, const \textbf{ Net\+Group\+Manager} \&netgroupman, const \textbf{ CChain\+Params} \&params, bool network\+\_\+active=true, std\+::shared\+\_\+ptr$<$ \textbf{ CThread\+Interrupt} $>$ interrupt\+\_\+net=std\+::make\+\_\+shared$<$ \textbf{ CThread\+Interrupt} $>$())
\item 
\textbf{ $\sim$\+CConnman} ()
\item 
bool \textbf{ Start} (\textbf{ CScheduler} \&scheduler, const \textbf{ Options} \&options) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex
\item 
void \textbf{ Stop\+Threads} ()
\item 
void \textbf{ Stop\+Nodes} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+reconnections\+\_\+mutex)
\item 
void \textbf{ Stop} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+reconnections\+\_\+mutex)
\item 
void \textbf{ Interrupt} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!mutex\+Msg\+Proc)
\item 
bool \textbf{ Get\+Network\+Active} () const
\item 
bool \textbf{ Get\+Use\+Addrman\+Outgoing} () const
\item 
void \textbf{ Set\+Network\+Active} (bool active)
\item 
bool \textbf{ Open\+Network\+Connection} (const \textbf{ CAddress} \&addr\+Connect, bool f\+Count\+Failure, \textbf{ Counting\+Semaphore\+Grant}$<$$>$ \&\&grant\+\_\+outbound, const char $\ast$psz\+Dest, \textbf{ Connection\+Type} conn\+\_\+type, bool \textbf{ use\+\_\+v2transport}, const std\+::optional$<$ \textbf{ Proxy} $>$ \&proxy\+\_\+override=std\+::nullopt) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+unused\+\_\+i2p\+\_\+sessions\+\_\+mutex)
\item 
bool \textbf{ Check\+Incoming\+Nonce} (uint64\+\_\+t \textbf{ nonce})
\item 
void \textbf{ ASMap\+Health\+Check} ()
\item 
\textbf{ Recursive\+Mutex} \& \textbf{ Get\+Nodes\+Mutex} () const \textbf{ LOCK\+\_\+\+RETURNED}(m\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ For\+Node} (\textbf{ Node\+Id} id, std\+::function$<$ bool(\textbf{ CNode} $\ast$pnode)$>$ func)
\item 
void \textbf{ Push\+Message} (\textbf{ CNode} $\ast$pnode, \textbf{ CSerialized\+Net\+Msg} \&\&msg) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
void \textbf{ For\+Each\+Node} (const \textbf{ Node\+Fn} \&func)
\item 
void \textbf{ For\+Each\+Node} (const \textbf{ Node\+Fn} \&func) const
\item 
std\+::vector$<$ \textbf{ CAddress} $>$ \textbf{ Get\+Addresses\+Unsafe} (size\+\_\+t max\+\_\+addresses, size\+\_\+t max\+\_\+pct, std\+::optional$<$ \textbf{ Network} $>$ network, const bool filtered=true) const
\item 
std\+::vector$<$ \textbf{ CAddress} $>$ \textbf{ Get\+Addresses} (\textbf{ CNode} \&requestor, size\+\_\+t max\+\_\+addresses, size\+\_\+t max\+\_\+pct)
\item 
void \textbf{ Set\+Try\+New\+Outbound\+Peer} (bool flag)
\item 
bool \textbf{ Get\+Try\+New\+Outbound\+Peer} () const
\item 
void \textbf{ Start\+Extra\+Block\+Relay\+Peers} ()
\item 
int \textbf{ Get\+Full\+Outbound\+Conn\+Count} () const
\item 
int \textbf{ Get\+Extra\+Full\+Outbound\+Count} () const
\item 
int \textbf{ Get\+Extra\+Block\+Relay\+Count} () const
\item 
bool \textbf{ Add\+Node} (const \textbf{ Added\+Node\+Params} \&add) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ Remove\+Added\+Node} (std\+::string\+\_\+view \textbf{ node}) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ Added\+Nodes\+Contain} (const \textbf{ CAddress} \&addr) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
std\+::vector$<$ \textbf{ Added\+Node\+Info} $>$ \textbf{ Get\+Added\+Node\+Info} (bool include\+\_\+connected) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+added\+\_\+nodes\+\_\+mutex)
\item 
bool \textbf{ Add\+Connection} (const std\+::string \&address, \textbf{ Connection\+Type} conn\+\_\+type, bool \textbf{ use\+\_\+v2transport}) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+unused\+\_\+i2p\+\_\+sessions\+\_\+mutex)
\item 
size\+\_\+t \textbf{ Get\+Node\+Count} (\textbf{ Connection\+Direction}) const
\item 
std\+::map$<$ \textbf{ CNet\+Addr}, \textbf{ Local\+Service\+Info} $>$ \textbf{ get\+Net\+Local\+Addresses} () const
\item 
uint32\+\_\+t \textbf{ Get\+Mapped\+AS} (const \textbf{ CNet\+Addr} \&addr) const
\item 
void \textbf{ Get\+Node\+Stats} (std\+::vector$<$ \textbf{ CNode\+Stats} $>$ \&vstats) const
\item 
bool \textbf{ Disconnect\+Node} (std\+::string\+\_\+view \textbf{ node})
\item 
bool \textbf{ Disconnect\+Node} (const \textbf{ CSub\+Net} \&subnet)
\item 
bool \textbf{ Disconnect\+Node} (const \textbf{ CNet\+Addr} \&addr)
\item 
bool \textbf{ Disconnect\+Node} (\textbf{ Node\+Id} id)
\item 
\textbf{ Service\+Flags} \textbf{ Get\+Local\+Services} () const
\item 
void \textbf{ Add\+Local\+Services} (\textbf{ Service\+Flags} services)
\item 
void \textbf{ Remove\+Local\+Services} (\textbf{ Service\+Flags} services)
\item 
uint64\+\_\+t \textbf{ Get\+Max\+Outbound\+Target} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
std\+::chrono\+::seconds \textbf{ Get\+Max\+Outbound\+Timeframe} () const
\item 
bool \textbf{ Outbound\+Target\+Reached} (bool historical\+Block\+Serving\+Limit) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
uint64\+\_\+t \textbf{ Get\+Outbound\+Target\+Bytes\+Left} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
std\+::chrono\+::seconds \textbf{ Get\+Max\+Outbound\+Time\+Left\+In\+Cycle} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
uint64\+\_\+t \textbf{ Get\+Total\+Bytes\+Recv} () const
\item 
uint64\+\_\+t \textbf{ Get\+Total\+Bytes\+Sent} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex)
\item 
\textbf{ CSip\+Hasher} \textbf{ Get\+Deterministic\+Randomizer} (uint64\+\_\+t id) const
\item 
void \textbf{ Wake\+Message\+Handler} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!mutex\+Msg\+Proc)
\item 
bool \textbf{ Should\+Run\+Inactivity\+Checks} (const \textbf{ CNode} \&\textbf{ node}, std\+::chrono\+::microseconds now) const
\item 
bool \textbf{ Multiple\+Manual\+Or\+Full\+Outbound\+Conns} (\textbf{ Network} net) const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(m\+\_\+nodes\+\_\+mutex)
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
void \textbf{ !m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex}
\item 
\textbf{ m\+\_\+local\+\_\+services} = conn\+Options.\+m\+\_\+local\+\_\+services
\item 
\textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} = conn\+Options.\+m\+\_\+max\+\_\+automatic\+\_\+connections
\item 
\textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay} = std\+::min(MAX\+\_\+\+OUTBOUND\+\_\+\+FULL\+\_\+\+RELAY\+\_\+\+CONNECTIONS, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections})
\item 
\textbf{ m\+\_\+max\+\_\+outbound\+\_\+block\+\_\+relay} = std\+::min(MAX\+\_\+\+BLOCK\+\_\+\+RELAY\+\_\+\+ONLY\+\_\+\+CONNECTIONS, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} -\/ \textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay})
\item 
\textbf{ m\+\_\+max\+\_\+automatic\+\_\+outbound} = \textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay} + \textbf{ m\+\_\+max\+\_\+outbound\+\_\+block\+\_\+relay} + m\+\_\+max\+\_\+feeler
\item 
\textbf{ m\+\_\+max\+\_\+inbound} = std\+::max(0, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} -\/ \textbf{ m\+\_\+max\+\_\+automatic\+\_\+outbound})
\item 
\textbf{ m\+\_\+use\+\_\+addrman\+\_\+outgoing} = conn\+Options.\+m\+\_\+use\+\_\+addrman\+\_\+outgoing
\item 
\textbf{ m\+\_\+client\+\_\+interface} = conn\+Options.\+ui\+Interface
\item 
\textbf{ m\+\_\+banman} = conn\+Options.\+m\+\_\+banman
\item 
\textbf{ m\+\_\+msgproc} = conn\+Options.\+m\+\_\+msgproc
\item 
\textbf{ n\+Send\+Buffer\+Max\+Size} = conn\+Options.\+n\+Send\+Buffer\+Max\+Size
\item 
\textbf{ n\+Receive\+Flood\+Size} = conn\+Options.\+n\+Receive\+Flood\+Size
\item 
\textbf{ m\+\_\+peer\+\_\+connect\+\_\+timeout} = std\+::chrono\+::seconds\{conn\+Options.\+m\+\_\+peer\+\_\+connect\+\_\+timeout\}
\item 
\textbf{ n\+Max\+Outbound\+Limit} = conn\+Options.\+n\+Max\+Outbound\+Limit
\item 
\textbf{ v\+Whitelisted\+Range\+Incoming} = conn\+Options.\+v\+Whitelisted\+Range\+Incoming
\item 
\textbf{ v\+Whitelisted\+Range\+Outgoing} = conn\+Options.\+v\+Whitelisted\+Range\+Outgoing
\item 
\textbf{ m\+\_\+onion\+\_\+binds} = conn\+Options.\+onion\+\_\+binds
\item 
\textbf{ whitelist\+\_\+forcerelay} = conn\+Options.\+whitelist\+\_\+forcerelay
\item 
\textbf{ whitelist\+\_\+relay} = conn\+Options.\+whitelist\+\_\+relay
\item 
\textbf{ m\+\_\+capture\+\_\+messages} = conn\+Options.\+m\+\_\+capture\+\_\+messages
\item 
bool \textbf{ !m\+\_\+added\+\_\+nodes\+\_\+mutex}
\item 
bool \textbf{ !m\+\_\+addr\+\_\+fetches\+\_\+mutex}
\item 
bool \textbf{ !mutex\+Msg\+Proc}
\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Connman\+Test\+Msg}
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Member Typedef Documentation}
\index{CConnman@{CConnman}!NodeFn@{NodeFn}}
\index{NodeFn@{NodeFn}!CConnman@{CConnman}}
\doxysubsubsection{NodeFn}
{\footnotesize\ttfamily \label{class_c_connman_a70eb4bb313029ea2691178ee6a1fdada} 
using \textbf{ Node\+Fn} = std\+::function$<$void(\textbf{ CNode}$\ast$)$>$}



\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CConnman@{CConnman}!CConnman@{CConnman}}
\index{CConnman@{CConnman}!CConnman@{CConnman}}
\doxysubsubsection{CConnman()}
{\footnotesize\ttfamily \label{class_c_connman_a66c9578e34dbcf52608e3674b50007fb} 
\textbf{ CConnman} (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{seed0}{, }\item[{uint64\+\_\+t}]{seed1}{, }\item[{\textbf{ Addr\+Man} \&}]{addrman}{, }\item[{const \textbf{ Net\+Group\+Manager} \&}]{netgroupman}{, }\item[{const \textbf{ CChain\+Params} \&}]{params}{, }\item[{bool}]{network\+\_\+active}{ = {\ttfamily true}, }\item[{std\+::shared\+\_\+ptr$<$ \textbf{ CThread\+Interrupt} $>$}]{interrupt\+\_\+net}{ = {\ttfamily std\+:\+:make\+\_\+shared$<$\textbf{ CThread\+Interrupt}$>$()}}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!````~CConnman@{$\sim$CConnman}}
\index{````~CConnman@{$\sim$CConnman}!CConnman@{CConnman}}
\doxysubsubsection{$\sim$CConnman()}
{\footnotesize\ttfamily \label{class_c_connman_abb2b862ff6af18b463ec2937b566890b} 
$\sim$\textbf{ CConnman} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CConnman@{CConnman}!AddConnection@{AddConnection}}
\index{AddConnection@{AddConnection}!CConnman@{CConnman}}
\doxysubsubsection{AddConnection()}
{\footnotesize\ttfamily \label{class_c_connman_a25bb019bf1e493d525fac6f85ec4f25d} 
bool Add\+Connection (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{address}{, }\item[{\textbf{ Connection\+Type}}]{conn\+\_\+type}{, }\item[{bool}]{use\+\_\+v2transport}{ = {\ttfamily false}}\end{DoxyParamCaption})}

Attempts to open a connection. Currently only used from tests.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em address} & Address of node to try connecting to \\
\hline
\mbox{\texttt{in}}  & {\em conn\+\_\+type} & Connection\+Type\+::\+OUTBOUND, \doxyref{Connection\+Type\+::\+BLOCK\+\_\+\+RELAY}{p.}{connection__types_8h_aa1f0e2efd52935fd01bfece0fbead81fa29803eb3861591f3b074fabfcc1eaa7e}, \doxyref{Connection\+Type\+::\+ADDR\+\_\+\+FETCH}{p.}{connection__types_8h_aa1f0e2efd52935fd01bfece0fbead81faed461b2576cd30c51b94944c78c53dc5} or \doxyref{Connection\+Type\+::\+FEELER}{p.}{connection__types_8h_aa1f0e2efd52935fd01bfece0fbead81fab8acc77a8fa0722a6efb0c395deed9dc} \\
\hline
\mbox{\texttt{in}}  & {\em use\+\_\+v2transport} & Set to true if node attempts to connect using BIP 324 v2 transport protocol. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool Returns false if there are no available slots for this connection\+:
\begin{DoxyItemize}
\item conn\+\_\+type not a supported \doxyref{Connection\+Type}{p.}{connection__types_8h_aa1f0e2efd52935fd01bfece0fbead81f}
\item Max total outbound connection capacity filled
\item Max connection capacity for type is filled 
\end{DoxyItemize}
\end{DoxyReturn}
\index{CConnman@{CConnman}!AddedNodesContain@{AddedNodesContain}}
\index{AddedNodesContain@{AddedNodesContain}!CConnman@{CConnman}}
\doxysubsubsection{AddedNodesContain()}
{\footnotesize\ttfamily \label{class_c_connman_ab6ff875759abc20ec0e609e44e759bf3} 
bool Added\+Nodes\+Contain (\begin{DoxyParamCaption}\item[{const \textbf{ CAddress} \&}]{addr}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!AddLocalServices@{AddLocalServices}}
\index{AddLocalServices@{AddLocalServices}!CConnman@{CConnman}}
\doxysubsubsection{AddLocalServices()}
{\footnotesize\ttfamily \label{class_c_connman_a430c74fc63ae962353dbe2d7bd54d859} 
void Add\+Local\+Services (\begin{DoxyParamCaption}\item[{\textbf{ Service\+Flags}}]{services}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Updates the local services that this node advertises to other peers during connection handshake. \index{CConnman@{CConnman}!AddNode@{AddNode}}
\index{AddNode@{AddNode}!CConnman@{CConnman}}
\doxysubsubsection{AddNode()}
{\footnotesize\ttfamily \label{class_c_connman_a486d9fb12a98ac67c1c4e99bdd4acf51} 
bool Add\+Node (\begin{DoxyParamCaption}\item[{const \textbf{ Added\+Node\+Params} \&}]{add}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!ASMapHealthCheck@{ASMapHealthCheck}}
\index{ASMapHealthCheck@{ASMapHealthCheck}!CConnman@{CConnman}}
\doxysubsubsection{ASMapHealthCheck()}
{\footnotesize\ttfamily \label{class_c_connman_a56ff3cf02a059d7578a4c7797031f3ae} 
void ASMap\+Health\+Check (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!CheckIncomingNonce@{CheckIncomingNonce}}
\index{CheckIncomingNonce@{CheckIncomingNonce}!CConnman@{CConnman}}
\doxysubsubsection{CheckIncomingNonce()}
{\footnotesize\ttfamily \label{class_c_connman_a3d661c95f879db66d23304643d0d2814} 
bool Check\+Incoming\+Nonce (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{nonce}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!DisconnectNode@{DisconnectNode}}
\index{DisconnectNode@{DisconnectNode}!CConnman@{CConnman}}
\doxysubsubsection{DisconnectNode()\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{class_c_connman_ab0e7c2bf62bf32c79daeb1785799deab} 
bool Disconnect\+Node (\begin{DoxyParamCaption}\item[{const \textbf{ CNet\+Addr} \&}]{addr}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!DisconnectNode@{DisconnectNode}}
\index{DisconnectNode@{DisconnectNode}!CConnman@{CConnman}}
\doxysubsubsection{DisconnectNode()\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{class_c_connman_a4264a2d44ed5b316e1699744060a3aae} 
bool Disconnect\+Node (\begin{DoxyParamCaption}\item[{const \textbf{ CSub\+Net} \&}]{subnet}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!DisconnectNode@{DisconnectNode}}
\index{DisconnectNode@{DisconnectNode}!CConnman@{CConnman}}
\doxysubsubsection{DisconnectNode()\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{class_c_connman_a9fc19f75feb9ff374a276ccae2720bb9} 
bool Disconnect\+Node (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{id}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!DisconnectNode@{DisconnectNode}}
\index{DisconnectNode@{DisconnectNode}!CConnman@{CConnman}}
\doxysubsubsection{DisconnectNode()\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{class_c_connman_ade63741a2d84f56c6986320e25169d8d} 
bool Disconnect\+Node (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{node}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!for@{for}}
\index{for@{for}!CConnman@{CConnman}}
\doxysubsubsection{for()}
{\footnotesize\ttfamily \label{class_c_connman_a7fa41cdc4308d0cdb1c0a94560ca595d} 
for (\begin{DoxyParamCaption}\item[{const std\+::string \&added\+\_\+node \+:conn\+Options.}]{m\+\_\+added\+\_\+nodes}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!ForEachNode@{ForEachNode}}
\index{ForEachNode@{ForEachNode}!CConnman@{CConnman}}
\doxysubsubsection{ForEachNode()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_connman_a94ba073a4116729f3850622392d86168} 
void For\+Each\+Node (\begin{DoxyParamCaption}\item[{const \textbf{ Node\+Fn} \&}]{func}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!ForEachNode@{ForEachNode}}
\index{ForEachNode@{ForEachNode}!CConnman@{CConnman}}
\doxysubsubsection{ForEachNode()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_connman_a073aec59f4dad59efe943d5fb35c3257} 
void For\+Each\+Node (\begin{DoxyParamCaption}\item[{const \textbf{ Node\+Fn} \&}]{func}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!ForNode@{ForNode}}
\index{ForNode@{ForNode}!CConnman@{CConnman}}
\doxysubsubsection{ForNode()}
{\footnotesize\ttfamily \label{class_c_connman_a0df360faf6c653e1ebea6b5b7eee301b} 
bool For\+Node (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{id}{, }\item[{std\+::function$<$ bool(\textbf{ CNode} $\ast$pnode)$>$}]{func}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!GetAddedNodeInfo@{GetAddedNodeInfo}}
\index{GetAddedNodeInfo@{GetAddedNodeInfo}!CConnman@{CConnman}}
\doxysubsubsection{GetAddedNodeInfo()}
{\footnotesize\ttfamily \label{class_c_connman_a9226c4b41bf0ec1c95bccf87a1c8d713} 
std\+::vector$<$ \textbf{ Added\+Node\+Info} $>$ Get\+Added\+Node\+Info (\begin{DoxyParamCaption}\item[{bool}]{include\+\_\+connected}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetAddresses@{GetAddresses}}
\index{GetAddresses@{GetAddresses}!CConnman@{CConnman}}
\doxysubsubsection{GetAddresses()}
{\footnotesize\ttfamily \label{class_c_connman_a29251a88172193512f78a8a1ecd89dd9} 
std\+::vector$<$ \textbf{ CAddress} $>$ Get\+Addresses (\begin{DoxyParamCaption}\item[{\textbf{ CNode} \&}]{requestor}{, }\item[{size\+\_\+t}]{max\+\_\+addresses}{, }\item[{size\+\_\+t}]{max\+\_\+pct}{}\end{DoxyParamCaption})}

Return addresses from the per-\/requestor cache. If no cache entry exists, it is populated with randomly selected addresses. This function can be used in untrusted contexts.

A trusted caller (e.\+g. from RPC or a peer with addr permission) can use \doxyref{Get\+Addresses\+Unsafe}{p.}{class_c_connman_a072825b7032342ea0b37b0b656cc13a2} to avoid using the cache.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em requestor} & The requesting peer. Used to key the cache to prevent privacy leaks. \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+addresses} & Maximum number of addresses to return (0 = all). Ignored when cache already contains an entry for requestor. \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+pct} & Maximum percentage of addresses to return (0 = all). Value must be from 0 to 100. Ignored when cache already contains an entry for requestor. \\
\hline
\end{DoxyParams}
\index{CConnman@{CConnman}!GetAddressesUnsafe@{GetAddressesUnsafe}}
\index{GetAddressesUnsafe@{GetAddressesUnsafe}!CConnman@{CConnman}}
\doxysubsubsection{GetAddressesUnsafe()}
{\footnotesize\ttfamily \label{class_c_connman_a072825b7032342ea0b37b0b656cc13a2} 
std\+::vector$<$ \textbf{ CAddress} $>$ Get\+Addresses\+Unsafe (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{max\+\_\+addresses}{, }\item[{size\+\_\+t}]{max\+\_\+pct}{, }\item[{std\+::optional$<$ \textbf{ Network} $>$}]{network}{, }\item[{const bool}]{filtered}{ = {\ttfamily true}}\end{DoxyParamCaption}) const}

Return randomly selected addresses. This function does not use the address response cache and should only be used in trusted contexts.

An untrusted caller (e.\+g. from p2p) should instead use \doxyref{Get\+Addresses}{p.}{class_c_connman_a29251a88172193512f78a8a1ecd89dd9} to use the cache.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em max\+\_\+addresses} & Maximum number of addresses to return (0 = all). \\
\hline
\mbox{\texttt{in}}  & {\em max\+\_\+pct} & Maximum percentage of addresses to return (0 = all). Value must be from 0 to 100. \\
\hline
\mbox{\texttt{in}}  & {\em network} & Select only addresses of this network (nullopt = all). \\
\hline
\mbox{\texttt{in}}  & {\em filtered} & Select only addresses that are considered high quality (false = all). \\
\hline
\end{DoxyParams}
\index{CConnman@{CConnman}!GetDeterministicRandomizer@{GetDeterministicRandomizer}}
\index{GetDeterministicRandomizer@{GetDeterministicRandomizer}!CConnman@{CConnman}}
\doxysubsubsection{GetDeterministicRandomizer()}
{\footnotesize\ttfamily \label{class_c_connman_a62d984d9362bdd151e2f845bd153f331} 
\textbf{ CSip\+Hasher} Get\+Deterministic\+Randomizer (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{id}{}\end{DoxyParamCaption}) const}

Get a unique deterministic randomizer. \index{CConnman@{CConnman}!GetExtraBlockRelayCount@{GetExtraBlockRelayCount}}
\index{GetExtraBlockRelayCount@{GetExtraBlockRelayCount}!CConnman@{CConnman}}
\doxysubsubsection{GetExtraBlockRelayCount()}
{\footnotesize\ttfamily \label{class_c_connman_a1d11e3e2f35e758ad83e563ec480aef9} 
int Get\+Extra\+Block\+Relay\+Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetExtraFullOutboundCount@{GetExtraFullOutboundCount}}
\index{GetExtraFullOutboundCount@{GetExtraFullOutboundCount}!CConnman@{CConnman}}
\doxysubsubsection{GetExtraFullOutboundCount()}
{\footnotesize\ttfamily \label{class_c_connman_ab0caa20b590484f9eeae5de7dda6ea8e} 
int Get\+Extra\+Full\+Outbound\+Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetFullOutboundConnCount@{GetFullOutboundConnCount}}
\index{GetFullOutboundConnCount@{GetFullOutboundConnCount}!CConnman@{CConnman}}
\doxysubsubsection{GetFullOutboundConnCount()}
{\footnotesize\ttfamily \label{class_c_connman_aa3a9cd5e5ab81852d8399abd49cdcedd} 
int Get\+Full\+Outbound\+Conn\+Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetLocalServices@{GetLocalServices}}
\index{GetLocalServices@{GetLocalServices}!CConnman@{CConnman}}
\doxysubsubsection{GetLocalServices()}
{\footnotesize\ttfamily \label{class_c_connman_a27ba7cb479821996a82a5183a585ca20} 
\textbf{ Service\+Flags} Get\+Local\+Services (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Used to convey which local services we are offering peers during node connection.

The data returned by this is used in \doxyref{CNode}{p.}{class_c_node} construction, which is used to advertise which services we are offering that peer during {\ttfamily \doxyref{net\+\_\+processing.\+cpp}{p.}{net__processing_8cpp}\+:Push\+Node\+Version()}. \index{CConnman@{CConnman}!GetMappedAS@{GetMappedAS}}
\index{GetMappedAS@{GetMappedAS}!CConnman@{CConnman}}
\doxysubsubsection{GetMappedAS()}
{\footnotesize\ttfamily \label{class_c_connman_a2f77334dc8df2c960c3c0c650d3fa9d3} 
uint32\+\_\+t Get\+Mapped\+AS (\begin{DoxyParamCaption}\item[{const \textbf{ CNet\+Addr} \&}]{addr}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetMaxOutboundTarget@{GetMaxOutboundTarget}}
\index{GetMaxOutboundTarget@{GetMaxOutboundTarget}!CConnman@{CConnman}}
\doxysubsubsection{GetMaxOutboundTarget()}
{\footnotesize\ttfamily \label{class_c_connman_aa2634e3f67f38dab1da3de849112e528} 
uint64\+\_\+t Get\+Max\+Outbound\+Target (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetMaxOutboundTimeframe@{GetMaxOutboundTimeframe}}
\index{GetMaxOutboundTimeframe@{GetMaxOutboundTimeframe}!CConnman@{CConnman}}
\doxysubsubsection{GetMaxOutboundTimeframe()}
{\footnotesize\ttfamily \label{class_c_connman_aa95a5a49331b68f49933e041908c7d06} 
std\+::chrono\+::seconds Get\+Max\+Outbound\+Timeframe (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetMaxOutboundTimeLeftInCycle@{GetMaxOutboundTimeLeftInCycle}}
\index{GetMaxOutboundTimeLeftInCycle@{GetMaxOutboundTimeLeftInCycle}!CConnman@{CConnman}}
\doxysubsubsection{GetMaxOutboundTimeLeftInCycle()}
{\footnotesize\ttfamily \label{class_c_connman_a6208310c6a7dbc090d161aeeaf7872c7} 
std\+::chrono\+::seconds Get\+Max\+Outbound\+Time\+Left\+In\+Cycle (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!getNetLocalAddresses@{getNetLocalAddresses}}
\index{getNetLocalAddresses@{getNetLocalAddresses}!CConnman@{CConnman}}
\doxysubsubsection{getNetLocalAddresses()}
{\footnotesize\ttfamily \label{class_c_connman_a0ea563d9a5f5ef74822e3cc67987ad0b} 
std\+::map$<$ \textbf{ CNet\+Addr}, \textbf{ Local\+Service\+Info} $>$ get\+Net\+Local\+Addresses (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetNetworkActive@{GetNetworkActive}}
\index{GetNetworkActive@{GetNetworkActive}!CConnman@{CConnman}}
\doxysubsubsection{GetNetworkActive()}
{\footnotesize\ttfamily \label{class_c_connman_abb77ca85329f0052489c70f4fc313944} 
bool Get\+Network\+Active (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!GetNodeCount@{GetNodeCount}}
\index{GetNodeCount@{GetNodeCount}!CConnman@{CConnman}}
\doxysubsubsection{GetNodeCount()}
{\footnotesize\ttfamily \label{class_c_connman_a9e065a9249c30e574b92341c10f35a45} 
size\+\_\+t Get\+Node\+Count (\begin{DoxyParamCaption}\item[{\textbf{ Connection\+Direction}}]{flags}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetNodesMutex@{GetNodesMutex}}
\index{GetNodesMutex@{GetNodesMutex}!CConnman@{CConnman}}
\doxysubsubsection{GetNodesMutex()}
{\footnotesize\ttfamily \label{class_c_connman_a8e44ba362501acfe9cd6f249b9c8f750} 
\textbf{ Recursive\+Mutex} \& Get\+Nodes\+Mutex (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetNodeStats@{GetNodeStats}}
\index{GetNodeStats@{GetNodeStats}!CConnman@{CConnman}}
\doxysubsubsection{GetNodeStats()}
{\footnotesize\ttfamily \label{class_c_connman_a3c38c43f5cadaee28e18c0816aea338d} 
void Get\+Node\+Stats (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \textbf{ CNode\+Stats} $>$ \&}]{vstats}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetOutboundTargetBytesLeft@{GetOutboundTargetBytesLeft}}
\index{GetOutboundTargetBytesLeft@{GetOutboundTargetBytesLeft}!CConnman@{CConnman}}
\doxysubsubsection{GetOutboundTargetBytesLeft()}
{\footnotesize\ttfamily \label{class_c_connman_ad48344e6865f2e60b9790b113b41195f} 
uint64\+\_\+t Get\+Outbound\+Target\+Bytes\+Left (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

response the bytes left in the current max outbound cycle in case of no limit, it will always response 0 \index{CConnman@{CConnman}!GetTotalBytesRecv@{GetTotalBytesRecv}}
\index{GetTotalBytesRecv@{GetTotalBytesRecv}!CConnman@{CConnman}}
\doxysubsubsection{GetTotalBytesRecv()}
{\footnotesize\ttfamily \label{class_c_connman_aacc0933e9638502ec159dbc9263b2ac5} 
uint64\+\_\+t Get\+Total\+Bytes\+Recv (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetTotalBytesSent@{GetTotalBytesSent}}
\index{GetTotalBytesSent@{GetTotalBytesSent}!CConnman@{CConnman}}
\doxysubsubsection{GetTotalBytesSent()}
{\footnotesize\ttfamily \label{class_c_connman_ab648513c4974533fbd7285f8e8d72b7f} 
uint64\+\_\+t Get\+Total\+Bytes\+Sent (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetTryNewOutboundPeer@{GetTryNewOutboundPeer}}
\index{GetTryNewOutboundPeer@{GetTryNewOutboundPeer}!CConnman@{CConnman}}
\doxysubsubsection{GetTryNewOutboundPeer()}
{\footnotesize\ttfamily \label{class_c_connman_abc34b82d1c414d1a7baf4bfef5210179} 
bool Get\+Try\+New\+Outbound\+Peer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!GetUseAddrmanOutgoing@{GetUseAddrmanOutgoing}}
\index{GetUseAddrmanOutgoing@{GetUseAddrmanOutgoing}!CConnman@{CConnman}}
\doxysubsubsection{GetUseAddrmanOutgoing()}
{\footnotesize\ttfamily \label{class_c_connman_a33a4e1919bc0d75c050cc66a2cabed3a} 
bool Get\+Use\+Addrman\+Outgoing (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!Init@{Init}}
\index{Init@{Init}!CConnman@{CConnman}}
\doxysubsubsection{Init()}
{\footnotesize\ttfamily \label{class_c_connman_a9edd467c2ca194771048ffa2fd5167db} 
void \textbf{ Init} (\begin{DoxyParamCaption}\item[{const \textbf{ Options} \&}]{conn\+Options}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!Interrupt@{Interrupt}}
\index{Interrupt@{Interrupt}!CConnman@{CConnman}}
\doxysubsubsection{Interrupt()}
{\footnotesize\ttfamily \label{class_c_connman_af89b6d8fcb5878f5ad748d4278c2bca2} 
void Interrupt (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!MultipleManualOrFullOutboundConns@{MultipleManualOrFullOutboundConns}}
\index{MultipleManualOrFullOutboundConns@{MultipleManualOrFullOutboundConns}!CConnman@{CConnman}}
\doxysubsubsection{MultipleManualOrFullOutboundConns()}
{\footnotesize\ttfamily \label{class_c_connman_ad7a979f5e739a889318d914efb511d6d} 
bool Multiple\+Manual\+Or\+Full\+Outbound\+Conns (\begin{DoxyParamCaption}\item[{\textbf{ Network}}]{net}{}\end{DoxyParamCaption}) const}

\index{CConnman@{CConnman}!OpenNetworkConnection@{OpenNetworkConnection}}
\index{OpenNetworkConnection@{OpenNetworkConnection}!CConnman@{CConnman}}
\doxysubsubsection{OpenNetworkConnection()}
{\footnotesize\ttfamily \label{class_c_connman_abd372a8be841d9efbdc5ffcd47373498} 
bool Open\+Network\+Connection (\begin{DoxyParamCaption}\item[{const \textbf{ CAddress} \&}]{addr\+Connect}{, }\item[{bool}]{f\+Count\+Failure}{, }\item[{\textbf{ Counting\+Semaphore\+Grant}$<$$>$ \&\&}]{grant\+\_\+outbound}{, }\item[{const char $\ast$}]{psz\+Dest}{, }\item[{\textbf{ Connection\+Type}}]{conn\+\_\+type}{, }\item[{bool}]{use\+\_\+v2transport}{, }\item[{const std\+::optional$<$ \textbf{ Proxy} $>$ \&}]{proxy\+\_\+override}{ = {\ttfamily std\+:\+:nullopt}}\end{DoxyParamCaption})}

Open a new P2P connection and initialize it with the \doxyref{Peer\+Manager}{p.}{class_peer_manager} at {\ttfamily \doxyref{m\+\_\+msgproc}{p.}{class_c_connman_aaca1a8b0b2a79d349528f7d235d8c999}}. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em addr\+Connect} & Address to connect to, if {\ttfamily psz\+Dest} is {\ttfamily nullptr}. \\
\hline
\mbox{\texttt{in}}  & {\em f\+Count\+Failure} & Increment the number of connection attempts to this address in Addrman. \\
\hline
\mbox{\texttt{in}}  & {\em grant\+\_\+outbound} & Take ownership of this grant, to be released later when the connection is closed. \\
\hline
\mbox{\texttt{in}}  & {\em psz\+Dest} & Address to resolve and connect to. \\
\hline
\mbox{\texttt{in}}  & {\em conn\+\_\+type} & Type of the connection to open, must not be {\ttfamily \doxyref{Connection\+Type\+::\+INBOUND}{p.}{connection__types_8h_aa1f0e2efd52935fd01bfece0fbead81fadf8068ff1ff686a6956977a30ed264b1}}. \\
\hline
\mbox{\texttt{in}}  & {\em use\+\_\+v2transport} & Use P2P encryption, (aka V2 transport, BIP324). \\
\hline
\mbox{\texttt{in}}  & {\em proxy\+\_\+override} & Optional proxy to use and override normal proxy selection. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em true} & The connection was opened successfully. \\
\hline
{\em false} & The connection attempt failed. \\
\hline
\end{DoxyRetVals}
\index{CConnman@{CConnman}!OutboundTargetReached@{OutboundTargetReached}}
\index{OutboundTargetReached@{OutboundTargetReached}!CConnman@{CConnman}}
\doxysubsubsection{OutboundTargetReached()}
{\footnotesize\ttfamily \label{class_c_connman_ab1c8de1b6e3a4a49afb85c3ad5daa528} 
bool Outbound\+Target\+Reached (\begin{DoxyParamCaption}\item[{bool}]{historical\+Block\+Serving\+Limit}{}\end{DoxyParamCaption}) const}

check if the outbound target is reached if param historical\+Block\+Serving\+Limit is set true, the function will response true if the limit for serving historical blocks has been reached \index{CConnman@{CConnman}!PushMessage@{PushMessage}}
\index{PushMessage@{PushMessage}!CConnman@{CConnman}}
\doxysubsubsection{PushMessage()}
{\footnotesize\ttfamily \label{class_c_connman_a1413a132873288365525338b0a869dc5} 
void Push\+Message (\begin{DoxyParamCaption}\item[{\textbf{ CNode} $\ast$}]{pnode}{, }\item[{\textbf{ CSerialized\+Net\+Msg} \&\&}]{msg}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!RemoveAddedNode@{RemoveAddedNode}}
\index{RemoveAddedNode@{RemoveAddedNode}!CConnman@{CConnman}}
\doxysubsubsection{RemoveAddedNode()}
{\footnotesize\ttfamily \label{class_c_connman_a2fa8093fd01430f3c88067bf69fc41d8} 
bool Remove\+Added\+Node (\begin{DoxyParamCaption}\item[{std\+::string\+\_\+view}]{node}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!RemoveLocalServices@{RemoveLocalServices}}
\index{RemoveLocalServices@{RemoveLocalServices}!CConnman@{CConnman}}
\doxysubsubsection{RemoveLocalServices()}
{\footnotesize\ttfamily \label{class_c_connman_a3da81d5ee6cc7849fb463691f4ee92ce} 
void Remove\+Local\+Services (\begin{DoxyParamCaption}\item[{\textbf{ Service\+Flags}}]{services}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!SetCaptureMessages@{SetCaptureMessages}}
\index{SetCaptureMessages@{SetCaptureMessages}!CConnman@{CConnman}}
\doxysubsubsection{SetCaptureMessages()}
{\footnotesize\ttfamily \label{class_c_connman_a713434047183da09bd2fce7c42bac2c0} 
void Set\+Capture\+Messages (\begin{DoxyParamCaption}\item[{bool}]{cap}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!SetNetworkActive@{SetNetworkActive}}
\index{SetNetworkActive@{SetNetworkActive}!CConnman@{CConnman}}
\doxysubsubsection{SetNetworkActive()}
{\footnotesize\ttfamily \label{class_c_connman_a732a885879b0f4f630184a941d403d09} 
void Set\+Network\+Active (\begin{DoxyParamCaption}\item[{bool}]{active}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!SetTryNewOutboundPeer@{SetTryNewOutboundPeer}}
\index{SetTryNewOutboundPeer@{SetTryNewOutboundPeer}!CConnman@{CConnman}}
\doxysubsubsection{SetTryNewOutboundPeer()}
{\footnotesize\ttfamily \label{class_c_connman_ad9b56d7738cb2cc935f98fd5a4f2e606} 
void Set\+Try\+New\+Outbound\+Peer (\begin{DoxyParamCaption}\item[{bool}]{flag}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!ShouldRunInactivityChecks@{ShouldRunInactivityChecks}}
\index{ShouldRunInactivityChecks@{ShouldRunInactivityChecks}!CConnman@{CConnman}}
\doxysubsubsection{ShouldRunInactivityChecks()}
{\footnotesize\ttfamily \label{class_c_connman_a7c65a78b1f97c25fbcd0ef7b8a131aad} 
bool Should\+Run\+Inactivity\+Checks (\begin{DoxyParamCaption}\item[{const \textbf{ CNode} \&}]{node}{, }\item[{std\+::chrono\+::microseconds}]{now}{}\end{DoxyParamCaption}) const}

Return true if we should disconnect the peer for failing an inactivity check. \index{CConnman@{CConnman}!Start@{Start}}
\index{Start@{Start}!CConnman@{CConnman}}
\doxysubsubsection{Start()}
{\footnotesize\ttfamily \label{class_c_connman_a5bc1f94b1358878f02575f71cc03ad52} 
bool Start (\begin{DoxyParamCaption}\item[{\textbf{ CScheduler} \&}]{scheduler}{, }\item[{const \textbf{ Options} \&}]{options}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!StartExtraBlockRelayPeers@{StartExtraBlockRelayPeers}}
\index{StartExtraBlockRelayPeers@{StartExtraBlockRelayPeers}!CConnman@{CConnman}}
\doxysubsubsection{StartExtraBlockRelayPeers()}
{\footnotesize\ttfamily \label{class_c_connman_ad5345042d09d385f8c8076d79ee2bedf} 
void Start\+Extra\+Block\+Relay\+Peers (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!Stop@{Stop}}
\index{Stop@{Stop}!CConnman@{CConnman}}
\doxysubsubsection{Stop()}
{\footnotesize\ttfamily \label{class_c_connman_a77a70d790dbf92c90e3ca5cdf4008e65} 
void Stop (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CConnman@{CConnman}!StopNodes@{StopNodes}}
\index{StopNodes@{StopNodes}!CConnman@{CConnman}}
\doxysubsubsection{StopNodes()}
{\footnotesize\ttfamily \label{class_c_connman_a521dcadeb057870e46600e99d9348154} 
void Stop\+Nodes (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!StopThreads@{StopThreads}}
\index{StopThreads@{StopThreads}!CConnman@{CConnman}}
\doxysubsubsection{StopThreads()}
{\footnotesize\ttfamily \label{class_c_connman_a11043145184a078c8476171d3c1e229b} 
void Stop\+Threads (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!use\_v2transport@{use\_v2transport}}
\index{use\_v2transport@{use\_v2transport}!CConnman@{CConnman}}
\doxysubsubsection{use\_v2transport()}
{\footnotesize\ttfamily \label{class_c_connman_a7b9fcdda156d414b3348d4551203160f} 
const bool use\+\_\+v2transport (\begin{DoxyParamCaption}\item[{\textbf{ Get\+Local\+Services}() \&}]{NODE\+\_\+\+P2\+P\+\_\+\+V2}{}\end{DoxyParamCaption})}

\index{CConnman@{CConnman}!WakeMessageHandler@{WakeMessageHandler}}
\index{WakeMessageHandler@{WakeMessageHandler}!CConnman@{CConnman}}
\doxysubsubsection{WakeMessageHandler()}
{\footnotesize\ttfamily \label{class_c_connman_aca877d27e58f6c965c68af7440bc9e0d} 
void Wake\+Message\+Handler (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



\label{doc-related-members}
\doxysubsection{Friends And Related Symbol Documentation}
\index{CConnman@{CConnman}!ConnmanTestMsg@{ConnmanTestMsg}}
\index{ConnmanTestMsg@{ConnmanTestMsg}!CConnman@{CConnman}}
\doxysubsubsection{ConnmanTestMsg}
{\footnotesize\ttfamily \label{class_c_connman_a5f6e451dab5f76b24ea10e1ac61230e1} 
friend struct \textbf{ Connman\+Test\+Msg}\hspace{0.3cm}{\ttfamily [friend]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CConnman@{CConnman}!"!m\_added\_nodes\_mutex@{"!m\_added\_nodes\_mutex}}
\index{"!m\_added\_nodes\_mutex@{"!m\_added\_nodes\_mutex}!CConnman@{CConnman}}
\doxysubsubsection{"!m\_added\_nodes\_mutex}
{\footnotesize\ttfamily \label{class_c_connman_a233719b3951df98369f199ce5b4dd898} 
bool !m\+\_\+added\+\_\+nodes\+\_\+mutex}

\index{CConnman@{CConnman}!"!m\_addr\_fetches\_mutex@{"!m\_addr\_fetches\_mutex}}
\index{"!m\_addr\_fetches\_mutex@{"!m\_addr\_fetches\_mutex}!CConnman@{CConnman}}
\doxysubsubsection{"!m\_addr\_fetches\_mutex}
{\footnotesize\ttfamily \label{class_c_connman_aa576fcf4d4195e9955e822f342317082} 
bool !m\+\_\+addr\+\_\+fetches\+\_\+mutex}

\index{CConnman@{CConnman}!"!m\_total\_bytes\_sent\_mutex@{"!m\_total\_bytes\_sent\_mutex}}
\index{"!m\_total\_bytes\_sent\_mutex@{"!m\_total\_bytes\_sent\_mutex}!CConnman@{CConnman}}
\doxysubsubsection{"!m\_total\_bytes\_sent\_mutex}
{\footnotesize\ttfamily \label{class_c_connman_ab2eadad14af89ded754a33547918a619} 
void !m\+\_\+total\+\_\+bytes\+\_\+sent\+\_\+mutex}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ AssertLockNotHeld(m\_total\_bytes\_sent\_mutex)}

\end{DoxyCode}
\index{CConnman@{CConnman}!"!mutexMsgProc@{"!mutexMsgProc}}
\index{"!mutexMsgProc@{"!mutexMsgProc}!CConnman@{CConnman}}
\doxysubsubsection{"!mutexMsgProc}
{\footnotesize\ttfamily \label{class_c_connman_adb5bceb8aefce8b493b60ee2829785f6} 
void !mutex\+Msg\+Proc}

\index{CConnman@{CConnman}!m\_banman@{m\_banman}}
\index{m\_banman@{m\_banman}!CConnman@{CConnman}}
\doxysubsubsection{m\_banman}
{\footnotesize\ttfamily \label{class_c_connman_a8b29f3f3edd46bc6d59feb1193a09956} 
m\+\_\+banman = conn\+Options.\+m\+\_\+banman}

\index{CConnman@{CConnman}!m\_capture\_messages@{m\_capture\_messages}}
\index{m\_capture\_messages@{m\_capture\_messages}!CConnman@{CConnman}}
\doxysubsubsection{m\_capture\_messages}
{\footnotesize\ttfamily \label{class_c_connman_a17e1e916af58250f01238655743966f1} 
m\+\_\+capture\+\_\+messages = conn\+Options.\+m\+\_\+capture\+\_\+messages}

\index{CConnman@{CConnman}!m\_client\_interface@{m\_client\_interface}}
\index{m\_client\_interface@{m\_client\_interface}!CConnman@{CConnman}}
\doxysubsubsection{m\_client\_interface}
{\footnotesize\ttfamily \label{class_c_connman_acf14085ac945e746e6a955980662c089} 
m\+\_\+client\+\_\+interface = conn\+Options.\+ui\+Interface}

\index{CConnman@{CConnman}!m\_local\_services@{m\_local\_services}}
\index{m\_local\_services@{m\_local\_services}!CConnman@{CConnman}}
\doxysubsubsection{m\_local\_services}
{\footnotesize\ttfamily \label{class_c_connman_a9078c52f57bd8e0372cf001fcb6eedc8} 
m\+\_\+local\+\_\+services = conn\+Options.\+m\+\_\+local\+\_\+services}

\index{CConnman@{CConnman}!m\_max\_automatic\_connections@{m\_max\_automatic\_connections}}
\index{m\_max\_automatic\_connections@{m\_max\_automatic\_connections}!CConnman@{CConnman}}
\doxysubsubsection{m\_max\_automatic\_connections}
{\footnotesize\ttfamily \label{class_c_connman_a684da20c0ac0b8aa254c0beed8a00e8a} 
m\+\_\+max\+\_\+automatic\+\_\+connections = conn\+Options.\+m\+\_\+max\+\_\+automatic\+\_\+connections}

\index{CConnman@{CConnman}!m\_max\_automatic\_outbound@{m\_max\_automatic\_outbound}}
\index{m\_max\_automatic\_outbound@{m\_max\_automatic\_outbound}!CConnman@{CConnman}}
\doxysubsubsection{m\_max\_automatic\_outbound}
{\footnotesize\ttfamily \label{class_c_connman_a14310c17788645b557acd3f171b42145} 
m\+\_\+max\+\_\+automatic\+\_\+outbound = \textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay} + \textbf{ m\+\_\+max\+\_\+outbound\+\_\+block\+\_\+relay} + m\+\_\+max\+\_\+feeler}

\index{CConnman@{CConnman}!m\_max\_inbound@{m\_max\_inbound}}
\index{m\_max\_inbound@{m\_max\_inbound}!CConnman@{CConnman}}
\doxysubsubsection{m\_max\_inbound}
{\footnotesize\ttfamily \label{class_c_connman_aceee251d0f3fbc6bf911ac16b9dc7194} 
m\+\_\+max\+\_\+inbound = std\+::max(0, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} -\/ \textbf{ m\+\_\+max\+\_\+automatic\+\_\+outbound})}

\index{CConnman@{CConnman}!m\_max\_outbound\_block\_relay@{m\_max\_outbound\_block\_relay}}
\index{m\_max\_outbound\_block\_relay@{m\_max\_outbound\_block\_relay}!CConnman@{CConnman}}
\doxysubsubsection{m\_max\_outbound\_block\_relay}
{\footnotesize\ttfamily \label{class_c_connman_a9b2ea1f10306ded1c53d4a2c12bcdc01} 
m\+\_\+max\+\_\+outbound\+\_\+block\+\_\+relay = std\+::min(MAX\+\_\+\+BLOCK\+\_\+\+RELAY\+\_\+\+ONLY\+\_\+\+CONNECTIONS, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections} -\/ \textbf{ m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay})}

\index{CConnman@{CConnman}!m\_max\_outbound\_full\_relay@{m\_max\_outbound\_full\_relay}}
\index{m\_max\_outbound\_full\_relay@{m\_max\_outbound\_full\_relay}!CConnman@{CConnman}}
\doxysubsubsection{m\_max\_outbound\_full\_relay}
{\footnotesize\ttfamily \label{class_c_connman_a1680661c0d66d3b2f1a6dbc87942c772} 
m\+\_\+max\+\_\+outbound\+\_\+full\+\_\+relay = std\+::min(MAX\+\_\+\+OUTBOUND\+\_\+\+FULL\+\_\+\+RELAY\+\_\+\+CONNECTIONS, \textbf{ m\+\_\+max\+\_\+automatic\+\_\+connections})}

\index{CConnman@{CConnman}!m\_msgproc@{m\_msgproc}}
\index{m\_msgproc@{m\_msgproc}!CConnman@{CConnman}}
\doxysubsubsection{m\_msgproc}
{\footnotesize\ttfamily \label{class_c_connman_aaca1a8b0b2a79d349528f7d235d8c999} 
m\+\_\+msgproc = conn\+Options.\+m\+\_\+msgproc}

\index{CConnman@{CConnman}!m\_onion\_binds@{m\_onion\_binds}}
\index{m\_onion\_binds@{m\_onion\_binds}!CConnman@{CConnman}}
\doxysubsubsection{m\_onion\_binds}
{\footnotesize\ttfamily \label{class_c_connman_a0e7899320735002c043556323dc8a126} 
m\+\_\+onion\+\_\+binds = conn\+Options.\+onion\+\_\+binds}

\index{CConnman@{CConnman}!m\_peer\_connect\_timeout@{m\_peer\_connect\_timeout}}
\index{m\_peer\_connect\_timeout@{m\_peer\_connect\_timeout}!CConnman@{CConnman}}
\doxysubsubsection{m\_peer\_connect\_timeout}
{\footnotesize\ttfamily \label{class_c_connman_ac796a2675a1e27d9d71dff76c76d6c64} 
m\+\_\+peer\+\_\+connect\+\_\+timeout = std\+::chrono\+::seconds\{conn\+Options.\+m\+\_\+peer\+\_\+connect\+\_\+timeout\}}

\index{CConnman@{CConnman}!m\_use\_addrman\_outgoing@{m\_use\_addrman\_outgoing}}
\index{m\_use\_addrman\_outgoing@{m\_use\_addrman\_outgoing}!CConnman@{CConnman}}
\doxysubsubsection{m\_use\_addrman\_outgoing}
{\footnotesize\ttfamily \label{class_c_connman_a588c941aebcfcc4bc2176976d7ba497b} 
m\+\_\+use\+\_\+addrman\+\_\+outgoing = conn\+Options.\+m\+\_\+use\+\_\+addrman\+\_\+outgoing}

\index{CConnman@{CConnman}!nMaxOutboundLimit@{nMaxOutboundLimit}}
\index{nMaxOutboundLimit@{nMaxOutboundLimit}!CConnman@{CConnman}}
\doxysubsubsection{nMaxOutboundLimit}
{\footnotesize\ttfamily \label{class_c_connman_a620f26a62de8d2cc18c7fec5a72fda77} 
n\+Max\+Outbound\+Limit = conn\+Options.\+n\+Max\+Outbound\+Limit}

\index{CConnman@{CConnman}!nReceiveFloodSize@{nReceiveFloodSize}}
\index{nReceiveFloodSize@{nReceiveFloodSize}!CConnman@{CConnman}}
\doxysubsubsection{nReceiveFloodSize}
{\footnotesize\ttfamily \label{class_c_connman_ad8d26cd14fff2b883fc44e900f16d1aa} 
n\+Receive\+Flood\+Size = conn\+Options.\+n\+Receive\+Flood\+Size}

\index{CConnman@{CConnman}!nSendBufferMaxSize@{nSendBufferMaxSize}}
\index{nSendBufferMaxSize@{nSendBufferMaxSize}!CConnman@{CConnman}}
\doxysubsubsection{nSendBufferMaxSize}
{\footnotesize\ttfamily \label{class_c_connman_adbd5f7a1339773716f18f4b48a5a6ff9} 
n\+Send\+Buffer\+Max\+Size = conn\+Options.\+n\+Send\+Buffer\+Max\+Size}

\index{CConnman@{CConnman}!vWhitelistedRangeIncoming@{vWhitelistedRangeIncoming}}
\index{vWhitelistedRangeIncoming@{vWhitelistedRangeIncoming}!CConnman@{CConnman}}
\doxysubsubsection{vWhitelistedRangeIncoming}
{\footnotesize\ttfamily \label{class_c_connman_af96caef06bbdce6b2c815238b9c1947f} 
v\+Whitelisted\+Range\+Incoming = conn\+Options.\+v\+Whitelisted\+Range\+Incoming}

\index{CConnman@{CConnman}!vWhitelistedRangeOutgoing@{vWhitelistedRangeOutgoing}}
\index{vWhitelistedRangeOutgoing@{vWhitelistedRangeOutgoing}!CConnman@{CConnman}}
\doxysubsubsection{vWhitelistedRangeOutgoing}
{\footnotesize\ttfamily \label{class_c_connman_a6382ecd94d0f436e1fc8388213cdc37c} 
v\+Whitelisted\+Range\+Outgoing = conn\+Options.\+v\+Whitelisted\+Range\+Outgoing}

\index{CConnman@{CConnman}!whitelist\_forcerelay@{whitelist\_forcerelay}}
\index{whitelist\_forcerelay@{whitelist\_forcerelay}!CConnman@{CConnman}}
\doxysubsubsection{whitelist\_forcerelay}
{\footnotesize\ttfamily \label{class_c_connman_a907e024d36b78bc481b120bb17c104b4} 
whitelist\+\_\+forcerelay = conn\+Options.\+whitelist\+\_\+forcerelay}

\index{CConnman@{CConnman}!whitelist\_relay@{whitelist\_relay}}
\index{whitelist\_relay@{whitelist\_relay}!CConnman@{CConnman}}
\doxysubsubsection{whitelist\_relay}
{\footnotesize\ttfamily \label{class_c_connman_a1454d0de5dadb2cb7ba43ed233d9e764} 
whitelist\+\_\+relay = conn\+Options.\+whitelist\+\_\+relay}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ net.\+h}\item 
src/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
