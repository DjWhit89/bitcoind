\doxysection{src/secp256k1/include/secp256k1\+\_\+schnorrsig.h File Reference}
\label{secp256k1__schnorrsig_8h}\index{src/secp256k1/include/secp256k1\_schnorrsig.h@{src/secp256k1/include/secp256k1\_schnorrsig.h}}
{\ttfamily \#include "{}secp256k1.\+h"{}}\newline
{\ttfamily \#include "{}secp256k1\+\_\+extrakeys.\+h"{}}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ secp256k1\+\_\+schnorrsig\+\_\+extraparams}
\end{DoxyCompactItemize}
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ SECP256\+K1\+\_\+\+SCHNORRSIG\+\_\+\+EXTRAPARAMS\+\_\+\+MAGIC}~\{ 0xda, 0x6f, 0xb3, 0x8c \}
\item 
\#define \textbf{ SECP256\+K1\+\_\+\+SCHNORRSIG\+\_\+\+EXTRAPARAMS\+\_\+\+INIT}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef int($\ast$ \textbf{ secp256k1\+\_\+nonce\+\_\+function\+\_\+hardened}) (unsigned char $\ast$nonce32, const unsigned char $\ast$msg, size\+\_\+t msglen, const unsigned char $\ast$key32, const unsigned char $\ast$xonly\+\_\+pk32, const unsigned char $\ast$algo, size\+\_\+t algolen, void $\ast$data)
\item 
typedef struct secp256k1\+\_\+schnorrsig\+\_\+extraparams \textbf{ secp256k1\+\_\+schnorrsig\+\_\+extraparams}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+schnorrsig\+\_\+sign32} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$sig64, const unsigned char $\ast$msg32, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, const unsigned char $\ast$aux\+\_\+rand32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+schnorrsig\+\_\+sign} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$sig64, const unsigned char $\ast$msg32, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, const unsigned char $\ast$aux\+\_\+rand32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4) \textbf{ SECP256\+K1\+\_\+\+DEPRECATED}("{}Use \textbf{ secp256k1\+\_\+schnorrsig\+\_\+sign32} instead"{})
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+schnorrsig\+\_\+sign\+\_\+custom} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$sig64, const unsigned char $\ast$msg, size\+\_\+t msglen, const \textbf{ secp256k1\+\_\+keypair} $\ast$keypair, \textbf{ secp256k1\+\_\+schnorrsig\+\_\+extraparams} $\ast$extraparams) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(5)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+schnorrsig\+\_\+verify} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, const unsigned char $\ast$sig64, const unsigned char $\ast$msg, size\+\_\+t msglen, const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$pubkey) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(5)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\textbf{ SECP256\+K1\+\_\+\+API} const \textbf{ secp256k1\+\_\+nonce\+\_\+function\+\_\+hardened} \textbf{ secp256k1\+\_\+nonce\+\_\+function\+\_\+bip340}
\end{DoxyCompactItemize}


\label{doc-define-members}
\doxysubsection{Macro Definition Documentation}
\index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_INIT@{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_INIT}}
\index{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_INIT@{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_INIT}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_INIT}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_abe427fe49f26db3beb199b82d6102452} 
\#define SECP256\+K1\+\_\+\+SCHNORRSIG\+\_\+\+EXTRAPARAMS\+\_\+\+INIT}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ \ \ \ \{\(\backslash\)}
\DoxyCodeLine{\ \ \ \ SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_MAGIC,\(\backslash\)}
\DoxyCodeLine{\ \ \ \ NULL,\(\backslash\)}
\DoxyCodeLine{\ \ \ \ NULL\(\backslash\)}
\DoxyCodeLine{\}}

\end{DoxyCode}
\index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_MAGIC@{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_MAGIC}}
\index{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_MAGIC@{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_MAGIC}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_MAGIC}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_a05a2d9736aa71ae95bfc59f58d962e1d} 
\#define SECP256\+K1\+\_\+\+SCHNORRSIG\+\_\+\+EXTRAPARAMS\+\_\+\+MAGIC~\{ 0xda, 0x6f, 0xb3, 0x8c \}}



\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_nonce\_function\_hardened@{secp256k1\_nonce\_function\_hardened}}
\index{secp256k1\_nonce\_function\_hardened@{secp256k1\_nonce\_function\_hardened}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_nonce\_function\_hardened}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_a134d980bb4432c6d70e3298979c8f5ec} 
typedef int($\ast$ secp256k1\+\_\+nonce\+\_\+function\+\_\+hardened) (unsigned char $\ast$nonce32, const unsigned char $\ast$msg, size\+\_\+t msglen, const unsigned char $\ast$key32, const unsigned char $\ast$xonly\+\_\+pk32, const unsigned char $\ast$algo, size\+\_\+t algolen, void $\ast$data)}

This module implements a variant of Schnorr signatures compliant with Bitcoin Improvement Proposal 340 "{}\+Schnorr Signatures for secp256k1"{} ({\texttt{https\+://github.\+com/bitcoin/bips/blob/master/bip-\/0340.\+mediawiki}}). A pointer to a function to deterministically generate a nonce.

Same as secp256k1\+\_\+nonce function with the exception of accepting an additional pubkey argument and not requiring an attempt argument. The pubkey argument can protect signature schemes with key-\/prefixed challenge hash inputs against reusing the nonce when signing with the wrong precomputed pubkey.

Returns\+: 1 if a nonce was successfully generated. 0 will cause signing to return an error. Out\+: nonce32\+: pointer to a 32-\/byte array to be filled by the function In\+: msg\+: the message being verified. Is NULL if and only if msglen is 0. msglen\+: the length of the message key32\+: pointer to a 32-\/byte secret key (will not be NULL) xonly\+\_\+pk32\+: the 32-\/byte serialized xonly pubkey corresponding to key32 (will not be NULL) algo\+: pointer to an array describing the signature algorithm (will not be NULL) algolen\+: the length of the algo array data\+: arbitrary data pointer that is passed through

Except for test cases, this function should compute some cryptographic hash of the message, the key, the pubkey, the algorithm description, and data. \index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_schnorrsig\_extraparams@{secp256k1\_schnorrsig\_extraparams}}
\index{secp256k1\_schnorrsig\_extraparams@{secp256k1\_schnorrsig\_extraparams}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_schnorrsig\_extraparams}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_a7a863be54eea009e520bdf773fc75f26} 
typedef struct secp256k1\+\_\+schnorrsig\+\_\+extraparams secp256k1\+\_\+schnorrsig\+\_\+extraparams}

Data structure that contains additional arguments for schnorrsig\+\_\+sign\+\_\+custom.

A schnorrsig\+\_\+extraparams structure object can be initialized correctly by setting it to SECP256\+K1\+\_\+\+SCHNORRSIG\+\_\+\+EXTRAPARAMS\+\_\+\+INIT.

Members\+: magic\+: set to SECP256\+K1\+\_\+\+SCHNORRSIG\+\_\+\+EXTRAPARAMS\+\_\+\+MAGIC at initialization and has no other function than making sure the object is initialized. noncefp\+: pointer to a nonce generation function. If NULL, secp256k1\+\_\+nonce\+\_\+function\+\_\+bip340 is used ndata\+: pointer to arbitrary data used by the nonce generation function (can be NULL). If it is non-\/\+NULL and secp256k1\+\_\+nonce\+\_\+function\+\_\+bip340 is used, then ndata must be a pointer to 32-\/byte auxiliary randomness as per BIP-\/340. 

\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_schnorrsig\_sign@{secp256k1\_schnorrsig\_sign}}
\index{secp256k1\_schnorrsig\_sign@{secp256k1\_schnorrsig\_sign}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_schnorrsig\_sign()}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_ac7e67a4654137be5adecdcb3d5fd5d41} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+schnorrsig\+\_\+sign (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{sig64}{, }\item[{const unsigned char $\ast$}]{msg32}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{const unsigned char $\ast$}]{aux\+\_\+rand32}{}\end{DoxyParamCaption})}

Same as secp256k1\+\_\+schnorrsig\+\_\+sign32, but DEPRECATED. Will be removed in future versions. \index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_schnorrsig\_sign32@{secp256k1\_schnorrsig\_sign32}}
\index{secp256k1\_schnorrsig\_sign32@{secp256k1\_schnorrsig\_sign32}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_schnorrsig\_sign32()}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_a562fe7745d3c285d64ef8b88ab70d7e1} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+schnorrsig\+\_\+sign32 (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{sig64}{, }\item[{const unsigned char $\ast$}]{msg32}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{const unsigned char $\ast$}]{aux\+\_\+rand32}{}\end{DoxyParamCaption})}

Create a Schnorr signature.

Does {\itshape not} strictly follow BIP-\/340 because it does not verify the resulting signature. Instead, you can manually use secp256k1\+\_\+schnorrsig\+\_\+verify and abort if it fails.

This function only signs 32-\/byte messages. If you have messages of a different size (or the same size but without a context-\/specific tag prefix), it is recommended to create a 32-\/byte message hash with secp256k1\+\_\+tagged\+\_\+sha256 and then sign the hash. Tagged hashing allows providing an context-\/specific tag for domain separation. This prevents signatures from being valid in multiple contexts by accident.

Returns 1 on success, 0 on failure. Args\+: ctx\+: pointer to a context object (not secp256k1\+\_\+context\+\_\+static). Out\+: sig64\+: pointer to a 64-\/byte array to store the serialized signature. In\+: msg32\+: the 32-\/byte message being signed. keypair\+: pointer to an initialized keypair. aux\+\_\+rand32\+: 32 bytes of fresh randomness. While recommended to provide this, it is only supplemental to security and can be NULL. A NULL argument is treated the same as an all-\/zero one. See BIP-\/340 "{}\+Default Signing"{} for a full explanation of this argument and for guidance if randomness is expensive. \index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_schnorrsig\_sign\_custom@{secp256k1\_schnorrsig\_sign\_custom}}
\index{secp256k1\_schnorrsig\_sign\_custom@{secp256k1\_schnorrsig\_sign\_custom}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_schnorrsig\_sign\_custom()}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_ad76edec4d42f65e4bc85ce445f1672fd} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+schnorrsig\+\_\+sign\+\_\+custom (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{sig64}{, }\item[{const unsigned char $\ast$}]{msg}{, }\item[{size\+\_\+t}]{msglen}{, }\item[{const \textbf{ secp256k1\+\_\+keypair} $\ast$}]{keypair}{, }\item[{\textbf{ secp256k1\+\_\+schnorrsig\+\_\+extraparams} $\ast$}]{extraparams}{}\end{DoxyParamCaption})}

Create a Schnorr signature with a more flexible API.

Same arguments as secp256k1\+\_\+schnorrsig\+\_\+sign except that it allows signing variable length messages and accepts a pointer to an extraparams object that allows customizing signing by passing additional arguments.

Equivalent to secp256k1\+\_\+schnorrsig\+\_\+sign32(..., aux\+\_\+rand32) if msglen is 32 and extraparams is initialized as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{secp256k1\_schnorrsig\_extraparams\ extraparams\ =\ SECP256K1\_SCHNORRSIG\_EXTRAPARAMS\_INIT;}
\DoxyCodeLine{extraparams.ndata\ =\ (\textcolor{keywordtype}{unsigned}\ \textcolor{keywordtype}{char}*)aux\_rand32;}

\end{DoxyCode}


Returns 1 on success, 0 on failure. Args\+: ctx\+: pointer to a context object (not secp256k1\+\_\+context\+\_\+static). Out\+: sig64\+: pointer to a 64-\/byte array to store the serialized signature. In\+: msg\+: the message being signed. Can only be NULL if msglen is 0. msglen\+: length of the message. keypair\+: pointer to an initialized keypair. extraparams\+: pointer to an extraparams object (can be NULL). \index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_schnorrsig\_verify@{secp256k1\_schnorrsig\_verify}}
\index{secp256k1\_schnorrsig\_verify@{secp256k1\_schnorrsig\_verify}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_schnorrsig\_verify()}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_ad8c9ecde1b1b561bb0a864ef307a48cb} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+schnorrsig\+\_\+verify (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{const unsigned char $\ast$}]{sig64}{, }\item[{const unsigned char $\ast$}]{msg}{, }\item[{size\+\_\+t}]{msglen}{, }\item[{const \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{pubkey}{}\end{DoxyParamCaption})}

Verify a Schnorr signature.

Returns\+: 1\+: correct signature 0\+: incorrect signature Args\+: ctx\+: pointer to a context object. In\+: sig64\+: pointer to the 64-\/byte signature to verify. msg\+: the message being verified. Can only be NULL if msglen is 0. msglen\+: length of the message pubkey\+: pointer to an x-\/only public key to verify with 

\label{doc-var-members}
\doxysubsection{Variable Documentation}
\index{secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}!secp256k1\_nonce\_function\_bip340@{secp256k1\_nonce\_function\_bip340}}
\index{secp256k1\_nonce\_function\_bip340@{secp256k1\_nonce\_function\_bip340}!secp256k1\_schnorrsig.h@{secp256k1\_schnorrsig.h}}
\doxysubsubsection{secp256k1\_nonce\_function\_bip340}
{\footnotesize\ttfamily \label{secp256k1__schnorrsig_8h_ad1e236e6927bda6c59bb45ece01dab3a} 
\textbf{ SECP256\+K1\+\_\+\+API} const \textbf{ secp256k1\+\_\+nonce\+\_\+function\+\_\+hardened} secp256k1\+\_\+nonce\+\_\+function\+\_\+bip340}

An implementation of the nonce generation function as defined in Bitcoin Improvement Proposal 340 "{}\+Schnorr Signatures for secp256k1"{} ({\texttt{https\+://github.\+com/bitcoin/bips/blob/master/bip-\/0340.\+mediawiki}}).

If a data pointer is passed, it is assumed to be a pointer to 32 bytes of auxiliary random data as defined in BIP-\/340. If the data pointer is NULL, the nonce derivation procedure follows BIP-\/340 by setting the auxiliary random data to zero. The algo argument must be non-\/\+NULL, otherwise the function will fail and return 0. The hash will be tagged with algo. Therefore, to create BIP-\/340 compliant signatures, algo must be set to "{}\+BIP0340/nonce"{} and algolen to 13. 