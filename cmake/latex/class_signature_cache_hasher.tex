\doxysection{Signature\+Cache\+Hasher Class Reference}
\label{class_signature_cache_hasher}\index{SignatureCacheHasher@{SignatureCacheHasher}}


{\ttfamily \#include $<$hasher.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$uint8\+\_\+t hash\+\_\+select$>$ }\\uint32\+\_\+t \textbf{ operator()} (const \textbf{ uint256} \&key) const
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
We\textquotesingle{}re hashing a nonce into the entries themselves, so we don\textquotesingle{}t need extra blinding in the set hash computation.

This may exhibit platform endian dependent behavior but because these are nonced hashes (random) and this state is only ever used locally it is safe. All that matters is local consistency. 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{SignatureCacheHasher@{SignatureCacheHasher}!operator()@{operator()}}
\index{operator()@{operator()}!SignatureCacheHasher@{SignatureCacheHasher}}
\doxysubsubsection{operator()()}
{\footnotesize\ttfamily \label{class_signature_cache_hasher_a2bf316b62b7a7e5f3138788d89fb8469} 
template$<$uint8\+\_\+t hash\+\_\+select$>$ \\
uint32\+\_\+t operator() (\begin{DoxyParamCaption}\item[{const \textbf{ uint256} \&}]{key}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/util/\textbf{ hasher.\+h}\end{DoxyCompactItemize}
