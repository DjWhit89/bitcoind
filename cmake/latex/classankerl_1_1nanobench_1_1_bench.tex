\doxysection{Bench Class Reference}
\label{classankerl_1_1nanobench_1_1_bench}\index{Bench@{Bench}}


Main entry point to nanobench\textquotesingle{}s benchmarking facility.  




{\ttfamily \#include $<$nanobench.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Bench} ()
\begin{DoxyCompactList}\small\item\em Creates a new benchmark for configuration and running of benchmarks. \end{DoxyCompactList}\item 
\textbf{ Bench} (Bench \&\&other) noexcept
\item 
\textbf{ Bench} \& \textbf{ operator=} (\textbf{ Bench} \&\&other) noexcept(\textbf{ ANKERL\+\_\+\+NANOBENCH}(NOEXCEPT\+\_\+\+STRING\+\_\+\+MOVE))
\item 
\textbf{ Bench} (Bench const \&other)
\item 
\textbf{ Bench} \& \textbf{ operator=} (\textbf{ Bench} const \&other)
\item 
\textbf{ $\sim$\+Bench} () noexcept
\item 
{\footnotesize template$<$typename Op$>$ }\\\textbf{ Bench} \& \textbf{ run} (char const $\ast$benchmark\+Name, Op \&\&op)
\begin{DoxyCompactList}\small\item\em Repeatedly calls {\ttfamily op()} based on the configuration, and performs measurements. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Op$>$ }\\\textbf{ Bench} \& \textbf{ run} (std\+::string const \&benchmark\+Name, Op \&\&op)
\item 
{\footnotesize template$<$typename Op$>$ }\\\textbf{ Bench} \& \textbf{ run} (Op \&\&op)
\begin{DoxyCompactList}\small\item\em Same as run(char const$\ast$ benchmark\+Name, Op op), but instead uses the previously set name. \end{DoxyCompactList}\item 
\textbf{ Bench} \& \textbf{ title} (char const $\ast$benchmark\+Title)
\begin{DoxyCompactList}\small\item\em Title of the benchmark, will be shown in the table header. Changing the title will start a new markdown table. \end{DoxyCompactList}\item 
\textbf{ Bench} \& \textbf{ title} (std\+::string const \&benchmark\+Title)
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ name} (char const $\ast$benchmark\+Name)
\begin{DoxyCompactList}\small\item\em Gets the title of the benchmark. \end{DoxyCompactList}\item 
\textbf{ Bench} \& \textbf{ name} (std\+::string const \&benchmark\+Name)
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ context} (char const $\ast$variable\+Name, char const $\ast$variable\+Value)
\begin{DoxyCompactList}\small\item\em Set context information. \end{DoxyCompactList}\item 
\textbf{ Bench} \& \textbf{ context} (std\+::string const \&variable\+Name, std\+::string const \&variable\+Value)
\item 
\textbf{ Bench} \& \textbf{ clear\+Context} ()
\begin{DoxyCompactList}\small\item\em Reset context information. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ Bench} \& \textbf{ batch} (\textbf{ T} b) noexcept
\begin{DoxyCompactList}\small\item\em Sets the batch size. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) double \textbf{ batch}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ unit} (char const $\ast$unit)
\begin{DoxyCompactList}\small\item\em Sets the operation unit. \end{DoxyCompactList}\item 
\textbf{ Bench} \& \textbf{ unit} (std\+::string const \&unit)
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ time\+Unit} (std\+::chrono\+::duration$<$ double $>$ const \&tu, std\+::string const \&tu\+Name)
\begin{DoxyCompactList}\small\item\em Sets the time unit to be used for the default output. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ output} (std\+::ostream $\ast$outstream) noexcept
\begin{DoxyCompactList}\small\item\em Set the output stream where the resulting markdown table will be printed to. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ clock\+Resolution\+Multiple} (size\+\_\+t multiple) noexcept
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) size\+\_\+t \textbf{ clock\+Resolution\+Multiple}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ epochs} (size\+\_\+t num\+Epochs) noexcept
\begin{DoxyCompactList}\small\item\em Controls number of epochs, the number of measurements to perform. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) size\+\_\+t \textbf{ epochs}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ max\+Epoch\+Time} (std\+::chrono\+::nanoseconds t) noexcept
\begin{DoxyCompactList}\small\item\em Upper limit for the runtime of each epoch. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ min\+Epoch\+Time} (std\+::chrono\+::nanoseconds t) noexcept
\begin{DoxyCompactList}\small\item\em Minimum time each epoch should take. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ min\+Epoch\+Iterations} (uint64\+\_\+t num\+Iters) noexcept
\begin{DoxyCompactList}\small\item\em Sets the minimum number of iterations each epoch should take. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) uint64\+\_\+t \textbf{ min\+Epoch\+Iterations}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ epoch\+Iterations} (uint64\+\_\+t num\+Iters) noexcept
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) uint64\+\_\+t \textbf{ epoch\+Iterations}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ warmup} (uint64\+\_\+t num\+Warmup\+Iters) noexcept
\begin{DoxyCompactList}\small\item\em Sets a number of iterations that are initially performed without any measurements. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) uint64\+\_\+t \textbf{ warmup}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ relative} (bool is\+Relative\+Enabled) noexcept
\begin{DoxyCompactList}\small\item\em Marks the next run as the baseline. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) bool \textbf{ relative}() const noexcept
\item 
\textbf{ Bench} \& \textbf{ performance\+Counters} (bool show\+Performance\+Counters) noexcept
\begin{DoxyCompactList}\small\item\em Enables/disables performance counters. \end{DoxyCompactList}\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) bool \textbf{ performance\+Counters}() const noexcept
\item 
{\footnotesize template$<$typename Arg$>$ }\\\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& \textbf{ do\+Not\+Optimize\+Away} (Arg \&\&arg)
\begin{DoxyCompactList}\small\item\em Retrieves all benchmark results collected by the bench object so far. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \textbf{ T}$>$ }\\\textbf{ Bench} \& \textbf{ complexityN} (\textbf{ T} n) noexcept
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) double \textbf{ complexityN}() const noexcept
\item 
std\+::vector$<$ \textbf{ BigO} $>$ \textbf{ complexity\+BigO} () const
\item 
{\footnotesize template$<$typename Op$>$ }\\\textbf{ BigO} \textbf{ complexity\+BigO} (char const $\ast$\textbf{ name}, Op op) const
\begin{DoxyCompactList}\small\item\em Calculates bigO for a custom function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Op$>$ }\\\textbf{ BigO} \textbf{ complexity\+BigO} (std\+::string const \&\textbf{ name}, Op op) const
\item 
\textbf{ Bench} \& \textbf{ render} (char const $\ast$template\+Content, std\+::ostream \&os)
\item 
\textbf{ Bench} \& \textbf{ render} (std\+::string const \&template\+Content, std\+::ostream \&os)
\item 
\textbf{ Bench} \& \textbf{ config} (\textbf{ Config} const \&benchmark\+Config)
\item 
\textbf{ ANKERL\+\_\+\+NANOBENCH} (NODISCARD) \textbf{ Config} const \&\textbf{ config}() const noexcept
\item 
{\footnotesize template$<$typename Arg$>$ }\\\textbf{ Bench} \& \textbf{ do\+Not\+Optimize\+Away} (Arg \&\&arg)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Main entry point to nanobench\textquotesingle{}s benchmarking facility. 

It holds configuration and results from one or more benchmark runs. Usually it is used in a single line, where the object is constructed, configured, and then a benchmark is run. E.\+g. like this\+: \begin{DoxyVerb}ankerl::nanobench::Bench().unit("byte").batch(1000).run("random fluctuations", [&] {
    // here be the benchmark code
});
\end{DoxyVerb}


In that example \doxyref{Bench()}{p.}{classankerl_1_1nanobench_1_1_bench_a0369c631cdbbd4e61b4cdcecda634cca} constructs the benchmark, it is then configured with \doxyref{unit()}{p.}{classankerl_1_1nanobench_1_1_bench_a7fada6f805f9af86b8508e8ef028d936} and \doxyref{batch()}{p.}{classankerl_1_1nanobench_1_1_bench_a37d376bc0b00680fc13656e4761f8168}, and after configuration a benchmark is executed with \doxyref{run()}{p.}{classankerl_1_1nanobench_1_1_bench_ae0f1d3ec977f3733d457b759b1f08e9e}. Once \doxyref{run()}{p.}{classankerl_1_1nanobench_1_1_bench_ae0f1d3ec977f3733d457b759b1f08e9e} has finished, it prints the result to {\ttfamily std\+::cout}. It would also store the results in the \doxyref{Bench}{p.}{classankerl_1_1nanobench_1_1_bench} instance, but in this case the object is immediately destroyed so it\textquotesingle{}s not available any more. 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{Bench@{Bench}!Bench@{Bench}}
\index{Bench@{Bench}!Bench@{Bench}}
\doxysubsubsection{Bench()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a0369c631cdbbd4e61b4cdcecda634cca} 
Bench (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Creates a new benchmark for configuration and running of benchmarks. 

\index{Bench@{Bench}!Bench@{Bench}}
\index{Bench@{Bench}!Bench@{Bench}}
\doxysubsubsection{Bench()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a3bf6b595796ee74d22f40c2d0afd99ac} 
Bench (\begin{DoxyParamCaption}\item[{Bench \&\&}]{other}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!Bench@{Bench}}
\index{Bench@{Bench}!Bench@{Bench}}
\doxysubsubsection{Bench()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a2d0881f6e6c3c139ad4956f11038b70a} 
Bench (\begin{DoxyParamCaption}\item[{Bench const \&}]{other}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!````~Bench@{$\sim$Bench}}
\index{````~Bench@{$\sim$Bench}!Bench@{Bench}}
\doxysubsubsection{$\sim$Bench()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a86dbc9b2f51365303f8bac1bfffe9651} 
$\sim$\textbf{ Bench} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [1/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a0acd95544ac4925ff0a60740a6c08f5a} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [2/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_aacb57abf02ea943a9c084e0b4574570a} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [3/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a10067e3ac091394f09b839847b5b471c} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [4/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a63d315ebd863801fd87b91c6d00fb722} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [5/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a81b78b56e2d1eecadec93dfaeb6a95f1} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [6/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_ac445176a2c888e2110ea39da86c55b06} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [7/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a3059fb8ac12342e1989ee7ed3c88e19a} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [8/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a01c68da61eb2e2309afe3750afa9204d} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [9/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a9e977966aac653eeb88812eb2c8cd896} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}}
\index{ANKERL\_NANOBENCH@{ANKERL\_NANOBENCH}!Bench@{Bench}}
\doxysubsubsection{ANKERL\_NANOBENCH()\hspace{0.1cm}{\footnotesize\ttfamily [10/10]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a8d7ff1a0e17181d42be2ff23373e3fd5} 
ANKERL\+\_\+\+NANOBENCH (\begin{DoxyParamCaption}\item[{NODISCARD}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!batch@{batch}}
\index{batch@{batch}!Bench@{Bench}}
\doxysubsubsection{batch()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a37d376bc0b00680fc13656e4761f8168} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ Bench} \& batch (\begin{DoxyParamCaption}\item[{\textbf{ T}}]{b}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Sets the batch size. 

E.\+g. number of processed byte, or some other metric for the size of the processed data in each iteration. If you benchmark hashing of a 1000 byte long string and want byte/sec as a result, you can specify 1000 as the batch size.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Any input type is internally cast to {\ttfamily double}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em b} & batch size \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!clearContext@{clearContext}}
\index{clearContext@{clearContext}!Bench@{Bench}}
\doxysubsubsection{clearContext()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a44b3f8a1e4c325215a84ffbf4da7fe89} 
\textbf{ Bench} \& clear\+Context (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Reset context information. 

This may improve efficiency when using many context entries, or improve robustness by removing spurious context entries.

\begin{DoxySeeAlso}{See also}
\doxyref{context}{p.}{classankerl_1_1nanobench_1_1_bench_a6c5c13becb6edb48ef7d02cc8caab1bb} 
\end{DoxySeeAlso}
\index{Bench@{Bench}!clockResolutionMultiple@{clockResolutionMultiple}}
\index{clockResolutionMultiple@{clockResolutionMultiple}!Bench@{Bench}}
\doxysubsubsection{clockResolutionMultiple()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a92b3a1e3050c61c1e24e42a116b92a87} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& clock\+Resolution\+Multiple (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{multiple}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds. This is the main trick nanobech to be so fast\+: we find out how accurate the clock is, then run the benchmark only so often that the clock\textquotesingle{}s accuracy is good enough for accurate measurements.

The default is to run one epoch for 1000 times the clock resolution. So for 20ns resolution and 11 epochs, this gives a total runtime of

\[20ns * 1000 * 11 \approx 0.2ms
\]

To be precise, nanobench adds a 0-\/20\% random noise to each evaluation. This is to prevent any aliasing effects, and further improves accuracy.

Total runtime will be higher though\+: Some initial time is needed to find out the target number of iterations for each epoch, and there is some overhead involved to start \& stop timers and calculate resulting statistics and writing the output.


\begin{DoxyParams}{Parameters}
{\em multiple} & Target number of times of clock resolution. Usually 1000 is a good compromise between runtime and accuracy. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!complexityBigO@{complexityBigO}}
\index{complexityBigO@{complexityBigO}!Bench@{Bench}}
\doxysubsubsection{complexityBigO()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_ad7708f807ad0566c2a2046a21dad077c} 
std\+::vector$<$ \textbf{ BigO} $>$ complexity\+BigO (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Calculates {\texttt{Big O}} of the results with all preconfigured complexity functions. Currently these complexity functions are fitted into the benchmark results\+:

$ \mathcal{O}(1) $, $ \mathcal{O}(n) $, $ \mathcal{O}(\log{}n) $, $ \mathcal{O}(n\log{}n) $, $ \mathcal{O}(n^2) $, $ \mathcal{O}(n^3) $.

If we e.\+g. evaluate the complexity of {\ttfamily std\+::sort}, this is the result of {\ttfamily std\+::cout $<$$<$ bench.\+complexity\+Big\+O()}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{|\ \ \ coefficient\ |\ \ \ err\%\ |\ complexity}
\DoxyCodeLine{|-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/:|-\/-\/-\/-\/-\/-\/-\/:|-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{|\ \ \ 5.08935e-\/09\ |\ \ \ 2.6\%\ |\ O(n\ log\ n)}
\DoxyCodeLine{|\ \ \ 6.10608e-\/08\ |\ \ \ 8.0\%\ |\ O(n)}
\DoxyCodeLine{|\ \ \ 1.29307e-\/11\ |\ \ 47.2\%\ |\ O(n\string^2)}
\DoxyCodeLine{|\ \ \ 2.48677e-\/15\ |\ \ 69.6\%\ |\ O(n\string^3)}
\DoxyCodeLine{|\ \ \ 9.88133e-\/06\ |\ 132.3\%\ |\ O(log\ n)}
\DoxyCodeLine{|\ \ \ 5.98793e-\/05\ |\ 162.5\%\ |\ O(1)}

\end{DoxyCode}


So in this case $ \mathcal{O}(n\log{}n) $ provides the best approximation.

\begin{DoxyVerb}embed:rst
See the tutorial :ref:`asymptotic-complexity` for details.
\end{DoxyVerb}
 \begin{DoxyReturn}{Returns}
Evaluation results, which can be printed or otherwise inspected. 
\end{DoxyReturn}
\index{Bench@{Bench}!complexityBigO@{complexityBigO}}
\index{complexityBigO@{complexityBigO}!Bench@{Bench}}
\doxysubsubsection{complexityBigO()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a7af356797ebb904408474596f37f8dd1} 
template$<$typename Op$>$ \\
\textbf{ BigO} complexity\+BigO (\begin{DoxyParamCaption}\item[{char const $\ast$}]{name}{, }\item[{Op}]{op}{}\end{DoxyParamCaption}) const}



Calculates bigO for a custom function. 

E.\+g. to calculate the mean squared error for $ \mathcal{O}(\log{}\log{}n) $, which is not part of the default set of \doxyref{complexity\+Big\+O()}{p.}{classankerl_1_1nanobench_1_1_bench_ad7708f807ad0566c2a2046a21dad077c}, you can do this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ logLogN\ =\ bench.complexityBigO(\textcolor{stringliteral}{"{}O(log\ log\ n)"{}},\ [](\textcolor{keywordtype}{double}\ n)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::log2(std::log2(n));}
\DoxyCodeLine{\});}

\end{DoxyCode}


The resulting mean squared error can be printed with {\ttfamily std\+::cout $<$$<$ log\+LogN}. E.\+g. it prints something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{2.46985e-\/05\ *\ O(log\ log\ n),\ rms=1.48121}

\end{DoxyCode}



\begin{DoxyTemplParams}{Template Parameters}
{\em Op} & Type of mapping operation. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em name} & Name for the function, e.\+g. "{}\+O(log log n)"{} \\
\hline
{\em op} & Op\textquotesingle{}s operator() maps a {\ttfamily double} with the desired complexity function, e.\+g. {\ttfamily log2(log2(n))}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxyref{BigO}{p.}{classankerl_1_1nanobench_1_1_big_o} Error calculation, which is streamable to std\+::cout. 
\end{DoxyReturn}
\index{Bench@{Bench}!complexityBigO@{complexityBigO}}
\index{complexityBigO@{complexityBigO}!Bench@{Bench}}
\doxysubsubsection{complexityBigO()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a49a469941b5daecfd6b38d962a9aea10} 
template$<$typename Op$>$ \\
\textbf{ BigO} complexity\+BigO (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{name}{, }\item[{Op}]{op}{}\end{DoxyParamCaption}) const}

\index{Bench@{Bench}!complexityN@{complexityN}}
\index{complexityN@{complexityN}!Bench@{Bench}}
\doxysubsubsection{complexityN()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a4c2fa1375c3a79a88cfb8532b4017f69} 
template$<$typename \textbf{ T}$>$ \\
\textbf{ Bench} \& complexityN (\begin{DoxyParamCaption}\item[{\textbf{ T}}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\begin{DoxyVerb}embed:rst

Sets N for asymptotic complexity calculation, so it becomes possible to calculate `Big O
<https://en.wikipedia.org/wiki/Big_O_notation>`_ from multiple benchmark evaluations.

Use :cpp:func:`ankerl::nanobench::Bench::complexityBigO` when the evaluation has finished. See the tutorial
:ref:`asymptotic-complexity` for details.
\end{DoxyVerb}



\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Any type is cast to {\ttfamily double}. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em n} & Length of N for the next benchmark run, so it is possible to calculate {\ttfamily bigO}. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!config@{config}}
\index{config@{config}!Bench@{Bench}}
\doxysubsubsection{config()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a625fd2139bfb23bc2f985ee305968e7e} 
\textbf{ Bench} \& config (\begin{DoxyParamCaption}\item[{\textbf{ Config} const \&}]{benchmark\+Config}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!context@{context}}
\index{context@{context}!Bench@{Bench}}
\doxysubsubsection{context()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a6c5c13becb6edb48ef7d02cc8caab1bb} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& context (\begin{DoxyParamCaption}\item[{char const $\ast$}]{variable\+Name}{, }\item[{char const $\ast$}]{variable\+Value}{}\end{DoxyParamCaption})}



Set context information. 

The information can be accessed using custom render templates via {\ttfamily \{\{context(variable\+Name)\}\}}. Trying to render a variable that hasn\textquotesingle{}t been set before raises an exception. Not included in (default) markdown table.

\begin{DoxySeeAlso}{See also}
\doxyref{clear\+Context}{p.}{classankerl_1_1nanobench_1_1_bench_a44b3f8a1e4c325215a84ffbf4da7fe89}, \doxyref{render}{p.}{classankerl_1_1nanobench_1_1_bench_a249fd9ff213cf963f4ed78262d15fc6f}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em variable\+Name} & The name of the context variable. \\
\hline
{\em variable\+Value} & The value of the context variable. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!context@{context}}
\index{context@{context}!Bench@{Bench}}
\doxysubsubsection{context()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a69b97096c16fe745cedaf3adf25244e5} 
\textbf{ Bench} \& context (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{variable\+Name}{, }\item[{std\+::string const \&}]{variable\+Value}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!doNotOptimizeAway@{doNotOptimizeAway}}
\index{doNotOptimizeAway@{doNotOptimizeAway}!Bench@{Bench}}
\doxysubsubsection{doNotOptimizeAway()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a31c3c4cae99db0c3efe0c180e9c0a9a9} 
template$<$typename Arg$>$ \\
\textbf{ Bench} \& do\+Not\+Optimize\+Away (\begin{DoxyParamCaption}\item[{Arg \&\&}]{arg}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!doNotOptimizeAway@{doNotOptimizeAway}}
\index{doNotOptimizeAway@{doNotOptimizeAway}!Bench@{Bench}}
\doxysubsubsection{doNotOptimizeAway()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a27f4d44a6c8051915296db99fe3749e3} 
template$<$typename Arg$>$ \\
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& do\+Not\+Optimize\+Away (\begin{DoxyParamCaption}\item[{Arg \&\&}]{arg}{}\end{DoxyParamCaption})}



Retrieves all benchmark results collected by the bench object so far. 

Each call to \doxyref{run()}{p.}{classankerl_1_1nanobench_1_1_bench_ae0f1d3ec977f3733d457b759b1f08e9e} generates a \doxyref{Result}{p.}{classankerl_1_1nanobench_1_1_result} that is stored within the \doxyref{Bench}{p.}{classankerl_1_1nanobench_1_1_bench} instance. This is mostly for advanced users who want to see all the nitty gritty details.

\begin{DoxyReturn}{Returns}
All results collected so far.
\end{DoxyReturn}
\begin{DoxyVerb}embed:rst

Convenience shortcut to :cpp:func:`ankerl::nanobench::doNotOptimizeAway`.
\end{DoxyVerb}
 \index{Bench@{Bench}!epochIterations@{epochIterations}}
\index{epochIterations@{epochIterations}!Bench@{Bench}}
\doxysubsubsection{epochIterations()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_ae084f501a2a3c61c1d128a519d4a38ae} 
\textbf{ Bench} \& epoch\+Iterations (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{num\+Iters}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Sets exactly the number of iterations for each epoch. Ignores all other epoch limits. This forces nanobench to use exactly the given number of iterations for each epoch, not more and not less. Default is 0 (disabled).


\begin{DoxyParams}{Parameters}
{\em num\+Iters} & Exact number of iterations to use. Set to 0 to disable. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!epochs@{epochs}}
\index{epochs@{epochs}!Bench@{Bench}}
\doxysubsubsection{epochs()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a2aace9b04e1962c6490d7b2bbcbf0269} 
\textbf{ Bench} \& epochs (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num\+Epochs}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Controls number of epochs, the number of measurements to perform. 

The reported result will be the median of evaluation of each epoch. The higher you choose this, the more deterministic the result be and outliers will be more easily removed. Also the {\ttfamily err\%} will be more accurate the higher this number is. Note that the {\ttfamily err\%} will not necessarily decrease when number of epochs is increased. But it will be a more accurate representation of the benchmarked code\textquotesingle{}s runtime stability.

Choose the value wisely. In practice, 11 has been shown to be a reasonable choice between runtime performance and accuracy. This setting goes hand in hand with \doxyref{min\+Epoch\+Iterations()}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034} (or \doxyref{min\+Epoch\+Time()}{p.}{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf}). If you are more interested in {\itshape median} runtime, you might want to increase \doxyref{epochs()}{p.}{classankerl_1_1nanobench_1_1_bench_a2aace9b04e1962c6490d7b2bbcbf0269}. If you are more interested in {\itshape mean} runtime, you might want to increase \doxyref{min\+Epoch\+Iterations()}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034} instead.


\begin{DoxyParams}{Parameters}
{\em num\+Epochs} & Number of epochs. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!maxEpochTime@{maxEpochTime}}
\index{maxEpochTime@{maxEpochTime}!Bench@{Bench}}
\doxysubsubsection{maxEpochTime()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_abb7e4067323a8d7569e9867b03a35b39} 
\textbf{ Bench} \& max\+Epoch\+Time (\begin{DoxyParamCaption}\item[{std\+::chrono\+::nanoseconds}]{t}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Upper limit for the runtime of each epoch. 

As a safety precaution if the clock is not very accurate, we can set an upper limit for the maximum evaluation time per epoch. Default is 100ms. At least a single evaluation of the benchmark is performed.

\begin{DoxySeeAlso}{See also}
\doxyref{min\+Epoch\+Time}{p.}{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf}, \doxyref{min\+Epoch\+Iterations}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em t} & Maximum target runtime for a single epoch. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!minEpochIterations@{minEpochIterations}}
\index{minEpochIterations@{minEpochIterations}!Bench@{Bench}}
\doxysubsubsection{minEpochIterations()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& min\+Epoch\+Iterations (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{num\+Iters}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Sets the minimum number of iterations each epoch should take. 

Default is 1, and we rely on \doxyref{clock\+Resolution\+Multiple()}{p.}{classankerl_1_1nanobench_1_1_bench_a92b3a1e3050c61c1e24e42a116b92a87}. If the {\ttfamily err\%} is high and you want a more smooth result, you might want to increase the minimum number of iterations, or increase the \doxyref{min\+Epoch\+Time()}{p.}{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf}.

\begin{DoxySeeAlso}{See also}
\doxyref{min\+Epoch\+Time}{p.}{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf}, \doxyref{max\+Epoch\+Time}{p.}{classankerl_1_1nanobench_1_1_bench_abb7e4067323a8d7569e9867b03a35b39}, \doxyref{min\+Epoch\+Iterations}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em num\+Iters} & Minimum number of iterations per epoch. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!minEpochTime@{minEpochTime}}
\index{minEpochTime@{minEpochTime}!Bench@{Bench}}
\doxysubsubsection{minEpochTime()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& min\+Epoch\+Time (\begin{DoxyParamCaption}\item[{std\+::chrono\+::nanoseconds}]{t}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Minimum time each epoch should take. 

Default is zero, so we are fully relying on \doxyref{clock\+Resolution\+Multiple()}{p.}{classankerl_1_1nanobench_1_1_bench_a92b3a1e3050c61c1e24e42a116b92a87}. In most cases this is exactly what you want. If you see that the evaluation is unreliable with a high {\ttfamily err\%}, you can increase either \doxyref{min\+Epoch\+Time()}{p.}{classankerl_1_1nanobench_1_1_bench_aa6b15573e7e0c48f1290e1842fd21edf} or \doxyref{min\+Epoch\+Iterations()}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034}.

\begin{DoxySeeAlso}{See also}
\doxyref{max\+Epoch\+Time}{p.}{classankerl_1_1nanobench_1_1_bench_abb7e4067323a8d7569e9867b03a35b39}, \doxyref{min\+Epoch\+Iterations}{p.}{classankerl_1_1nanobench_1_1_bench_aab73759486903f243d9664e3c3208034}
\end{DoxySeeAlso}

\begin{DoxyParams}{Parameters}
{\em t} & Minimum time each epoch should take. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!name@{name}}
\index{name@{name}!Bench@{Bench}}
\doxysubsubsection{name()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a8a87b6c0978c4d69179ee249beb86c0c} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& name (\begin{DoxyParamCaption}\item[{char const $\ast$}]{benchmark\+Name}{}\end{DoxyParamCaption})}



Gets the title of the benchmark. 

Name of the benchmark, will be shown in the table row. \index{Bench@{Bench}!name@{name}}
\index{name@{name}!Bench@{Bench}}
\doxysubsubsection{name()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a915d9b1dfd2b915540b31cdedcef09bf} 
\textbf{ Bench} \& name (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{benchmark\+Name}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!operator=@{operator=}}
\index{operator=@{operator=}!Bench@{Bench}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a8e386768d4be4f31f9f6dda9bfcc9034} 
\textbf{ Bench} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ Bench} \&\&}]{other}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

\index{Bench@{Bench}!operator=@{operator=}}
\index{operator=@{operator=}!Bench@{Bench}}
\doxysubsubsection{operator=()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a8b9dc241748631d4a8aaaa9b491895ba} 
\textbf{ Bench} \& operator= (\begin{DoxyParamCaption}\item[{\textbf{ Bench} const \&}]{other}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!output@{output}}
\index{output@{output}!Bench@{Bench}}
\doxysubsubsection{output()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a10436f841dad877a2c165f8d00e21fc6} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& output (\begin{DoxyParamCaption}\item[{std\+::ostream $\ast$}]{outstream}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Set the output stream where the resulting markdown table will be printed to. 

The default is {\ttfamily \&std\+::cout}. You can disable all output by setting {\ttfamily nullptr}.


\begin{DoxyParams}{Parameters}
{\em outstream} & Pointer to output stream, can be {\ttfamily nullptr}. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!performanceCounters@{performanceCounters}}
\index{performanceCounters@{performanceCounters}!Bench@{Bench}}
\doxysubsubsection{performanceCounters()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a631a9cd991845ac75991564a9ed80f89} 
\textbf{ Bench} \& performance\+Counters (\begin{DoxyParamCaption}\item[{bool}]{show\+Performance\+Counters}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Enables/disables performance counters. 

On Linux nanobench has a powerful feature to use performance counters. This enables counting of retired instructions, count number of branches, missed branches, etc. On default this is enabled, but you can disable it if you don\textquotesingle{}t need that feature.


\begin{DoxyParams}{Parameters}
{\em show\+Performance\+Counters} & True to enable, false to disable. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!relative@{relative}}
\index{relative@{relative}!Bench@{Bench}}
\doxysubsubsection{relative()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a2b35462c62dcf9e55bf31618dd8008e0} 
\textbf{ Bench} \& relative (\begin{DoxyParamCaption}\item[{bool}]{is\+Relative\+Enabled}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Marks the next run as the baseline. 

Call {\ttfamily relative(true)} to mark the run as the baseline. Successive runs will be compared to this run. It is calculated by

\[100\% * \frac{baseline}{runtime}
\]


\begin{DoxyItemize}
\item 100\% means it is exactly as fast as the baseline
\item $>$100\% means it is faster than the baseline. E.\+g. 200\% means the current run is twice as fast as the baseline.
\item $<$100\% means it is slower than the baseline. E.\+g. 50\% means it is twice as slow as the baseline.
\end{DoxyItemize}

See the tutorial section "{}\+Comparing Results"{} for example usage.


\begin{DoxyParams}{Parameters}
{\em is\+Relative\+Enabled} & True to enable processing \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!render@{render}}
\index{render@{render}!Bench@{Bench}}
\doxysubsubsection{render()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a249fd9ff213cf963f4ed78262d15fc6f} 
\textbf{ Bench} \& render (\begin{DoxyParamCaption}\item[{char const $\ast$}]{template\+Content}{, }\item[{std\+::ostream \&}]{os}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}embed:rst

Convenience shortcut to :cpp:func:`ankerl::nanobench::render`.
\end{DoxyVerb}
 \index{Bench@{Bench}!render@{render}}
\index{render@{render}!Bench@{Bench}}
\doxysubsubsection{render()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a0c983f26db77b68f2f9821ae153244bc} 
\textbf{ Bench} \& render (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{template\+Content}{, }\item[{std\+::ostream \&}]{os}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!run@{run}}
\index{run@{run}!Bench@{Bench}}
\doxysubsubsection{run()\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_ae0f1d3ec977f3733d457b759b1f08e9e} 
template$<$typename Op$>$ \\
\textbf{ Bench} \& run (\begin{DoxyParamCaption}\item[{char const $\ast$}]{benchmark\+Name}{, }\item[{Op \&\&}]{op}{}\end{DoxyParamCaption})}



Repeatedly calls {\ttfamily op()} based on the configuration, and performs measurements. 

This call is marked with {\ttfamily noinline} to prevent the compiler to optimize beyond different benchmarks. This can have quite a big effect on benchmark accuracy.

\begin{DoxyVerb}embed:rst
.. note::

  Each call to your lambda must have a side effect that the compiler can't possibly optimize it away. E.g. add a result to an
  externally defined number (like `x` in the above example), and finally call `doNotOptimizeAway` on the variables the compiler
  must not remove. You can also use :cpp:func:`ankerl::nanobench::doNotOptimizeAway` directly in the lambda, but be aware that
  this has a small overhead.
\end{DoxyVerb}



\begin{DoxyTemplParams}{Template Parameters}
{\em Op} & The code to benchmark. \\
\hline
\end{DoxyTemplParams}
\index{Bench@{Bench}!run@{run}}
\index{run@{run}!Bench@{Bench}}
\doxysubsubsection{run()\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a5ed0f9c7a612dc2b0e88fb73dc3840b2} 
template$<$typename Op$>$ \\
\textbf{ Bench} \& run (\begin{DoxyParamCaption}\item[{Op \&\&}]{op}{}\end{DoxyParamCaption})}



Same as run(char const$\ast$ benchmark\+Name, Op op), but instead uses the previously set name. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Op} & The code to benchmark. \\
\hline
\end{DoxyTemplParams}
\index{Bench@{Bench}!run@{run}}
\index{run@{run}!Bench@{Bench}}
\doxysubsubsection{run()\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a0c763a995ba8b2715ddef0a845207cac} 
template$<$typename Op$>$ \\
\textbf{ Bench} \& run (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{benchmark\+Name}{, }\item[{Op \&\&}]{op}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!timeUnit@{timeUnit}}
\index{timeUnit@{timeUnit}!Bench@{Bench}}
\doxysubsubsection{timeUnit()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a13e3eaf7b5e9c0cf77da4673571c8e89} 
\textbf{ ANKERL\+\_\+\+NANOBENCH}(NODISCARD) \textbf{ std} \textbf{ Bench} \& time\+Unit (\begin{DoxyParamCaption}\item[{std\+::chrono\+::duration$<$ double $>$ const \&}]{tu}{, }\item[{std\+::string const \&}]{tu\+Name}{}\end{DoxyParamCaption})}



Sets the time unit to be used for the default output. 

Nanobench defaults to using ns (nanoseconds) as output in the markdown. For some benchmarks this is too coarse, so it is possible to configure this. E.\+g. use {\ttfamily \doxyref{time\+Unit}{p.}{classankerl_1_1nanobench_1_1_bench_a13e3eaf7b5e9c0cf77da4673571c8e89}(1ms, "{}ms"{})} to show {\ttfamily ms/op} instead of {\ttfamily ns/op}.


\begin{DoxyParams}{Parameters}
{\em tu} & Time unit to display the results in, default is 1ns. \\
\hline
{\em tu\+Name} & Name for the time unit, default is "{}ns"{} \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!title@{title}}
\index{title@{title}!Bench@{Bench}}
\doxysubsubsection{title()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a4e7209cd88a09e1e2278f0d506dd3aa3} 
\textbf{ Bench} \& title (\begin{DoxyParamCaption}\item[{char const $\ast$}]{benchmark\+Title}{}\end{DoxyParamCaption})}



Title of the benchmark, will be shown in the table header. Changing the title will start a new markdown table. 


\begin{DoxyParams}{Parameters}
{\em benchmark\+Title} & The title of the benchmark. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!title@{title}}
\index{title@{title}!Bench@{Bench}}
\doxysubsubsection{title()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a23306c0c89ae888d98683c58c7e2bec9} 
\textbf{ Bench} \& title (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{benchmark\+Title}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!unit@{unit}}
\index{unit@{unit}!Bench@{Bench}}
\doxysubsubsection{unit()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a7fada6f805f9af86b8508e8ef028d936} 
\textbf{ Bench} \& unit (\begin{DoxyParamCaption}\item[{char const $\ast$}]{unit}{}\end{DoxyParamCaption})}



Sets the operation unit. 

Defaults to "{}op"{}. Could be e.\+g. "{}byte"{} for string processing. This is used for the table header, e.\+g. to show {\ttfamily ns/byte}. Use singular ({\itshape byte}, not {\itshape bytes}). A change clears the currently collected results.


\begin{DoxyParams}{Parameters}
{\em unit} & The unit name. \\
\hline
\end{DoxyParams}
\index{Bench@{Bench}!unit@{unit}}
\index{unit@{unit}!Bench@{Bench}}
\doxysubsubsection{unit()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_a44bc96023aa24d13b3d96f956478b304} 
\textbf{ Bench} \& unit (\begin{DoxyParamCaption}\item[{std\+::string const \&}]{unit}{}\end{DoxyParamCaption})}

\index{Bench@{Bench}!warmup@{warmup}}
\index{warmup@{warmup}!Bench@{Bench}}
\doxysubsubsection{warmup()}
{\footnotesize\ttfamily \label{classankerl_1_1nanobench_1_1_bench_ae48156567cac1e76706ac0ce076894b7} 
\textbf{ Bench} \& warmup (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{num\+Warmup\+Iters}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}



Sets a number of iterations that are initially performed without any measurements. 

Some benchmarks need a few evaluations to warm up caches / database / whatever access. Normally this should not be needed, since we show the median result so initial outliers will be filtered away automatically. If the warmup effect is large though, you might want to set it. Default is 0.


\begin{DoxyParams}{Parameters}
{\em num\+Warmup\+Iters} & Number of warmup iterations. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/bench/\textbf{ nanobench.\+h}\end{DoxyCompactItemize}
