\doxysection{src/secp256k1/src/modules/musig/keyagg\+\_\+impl.h File Reference}
\label{keyagg__impl_8h}\index{src/secp256k1/src/modules/musig/keyagg\_impl.h@{src/secp256k1/src/modules/musig/keyagg\_impl.h}}
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include "{}keyagg.\+h"{}}\newline
{\ttfamily \#include "{}../../eckey.\+h"{}}\newline
{\ttfamily \#include "{}../../ecmult.\+h"{}}\newline
{\ttfamily \#include "{}../../field.\+h"{}}\newline
{\ttfamily \#include "{}../../group.\+h"{}}\newline
{\ttfamily \#include "{}../../hash.\+h"{}}\newline
{\ttfamily \#include "{}../../util.\+h"{}}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ secp256k1\+\_\+musig\+\_\+pubkey\+\_\+agg\+\_\+ecmult\+\_\+data}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ secp256k1\+\_\+musig\+\_\+pubkey\+\_\+agg} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$agg\+\_\+pk, \textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$keyagg\+\_\+cache, const \textbf{ secp256k1\+\_\+pubkey} $\ast$const $\ast$pubkeys, size\+\_\+t n\+\_\+pubkeys)
\item 
int \textbf{ secp256k1\+\_\+musig\+\_\+pubkey\+\_\+get} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$agg\+\_\+pk, const \textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$keyagg\+\_\+cache)
\item 
int \textbf{ secp256k1\+\_\+musig\+\_\+pubkey\+\_\+ec\+\_\+tweak\+\_\+add} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$output\+\_\+pubkey, \textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$keyagg\+\_\+cache, const unsigned char $\ast$tweak32)
\item 
int \textbf{ secp256k1\+\_\+musig\+\_\+pubkey\+\_\+xonly\+\_\+tweak\+\_\+add} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$output\+\_\+pubkey, \textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$keyagg\+\_\+cache, const unsigned char $\ast$tweak32)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{keyagg\_impl.h@{keyagg\_impl.h}!secp256k1\_musig\_pubkey\_agg@{secp256k1\_musig\_pubkey\_agg}}
\index{secp256k1\_musig\_pubkey\_agg@{secp256k1\_musig\_pubkey\_agg}!keyagg\_impl.h@{keyagg\_impl.h}}
\doxysubsubsection{secp256k1\_musig\_pubkey\_agg()}
{\footnotesize\ttfamily \label{keyagg__impl_8h_af9d6ed51342b250644499d9647837757} 
int secp256k1\+\_\+musig\+\_\+pubkey\+\_\+agg (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+xonly\+\_\+pubkey} $\ast$}]{agg\+\_\+pk}{, }\item[{\textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$}]{keyagg\+\_\+cache}{, }\item[{const \textbf{ secp256k1\+\_\+pubkey} $\ast$const $\ast$}]{pubkeys}{, }\item[{size\+\_\+t}]{n\+\_\+pubkeys}{}\end{DoxyParamCaption})}

Computes an aggregate public key and uses it to initialize a keyagg\+\_\+cache

Different orders of {\ttfamily pubkeys} result in different {\ttfamily agg\+\_\+pk}s.

Before aggregating, the pubkeys can be sorted with {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+pubkey\+\_\+sort}{p.}{secp256k1_8h_ace5e4824419ef5e099f920eaa8e7cafb}} which ensures the same {\ttfamily agg\+\_\+pk} result for the same multiset of pubkeys. This is useful to do before {\ttfamily pubkey\+\_\+agg}, such that the order of pubkeys does not affect the aggregate public key.

Returns\+: 0 if the arguments are invalid, 1 otherwise Args\+: ctx\+: pointer to a context object Out\+: agg\+\_\+pk\+: the Mu\+Sig-\/aggregated x-\/only public key. If you do not need it, this arg can be NULL. keyagg\+\_\+cache\+: if non-\/\+NULL, pointer to a musig\+\_\+keyagg\+\_\+cache struct that is required for signing (or observing the signing session and verifying partial signatures). In\+: pubkeys\+: input array of pointers to public keys to aggregate. The order is important; a different order will result in a different aggregate public key. n\+\_\+pubkeys\+: length of pubkeys array. Must be greater than 0. \index{keyagg\_impl.h@{keyagg\_impl.h}!secp256k1\_musig\_pubkey\_ec\_tweak\_add@{secp256k1\_musig\_pubkey\_ec\_tweak\_add}}
\index{secp256k1\_musig\_pubkey\_ec\_tweak\_add@{secp256k1\_musig\_pubkey\_ec\_tweak\_add}!keyagg\_impl.h@{keyagg\_impl.h}}
\doxysubsubsection{secp256k1\_musig\_pubkey\_ec\_tweak\_add()}
{\footnotesize\ttfamily \label{keyagg__impl_8h_ad7db32a46ad915892398ca46fdbe3f55} 
int secp256k1\+\_\+musig\+\_\+pubkey\+\_\+ec\+\_\+tweak\+\_\+add (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{output\+\_\+pubkey}{, }\item[{\textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$}]{keyagg\+\_\+cache}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Apply plain "{}\+EC"{} tweaking to a public key in a given keyagg\+\_\+cache by adding the generator multiplied with {\ttfamily tweak32} to it. This is useful for deriving child keys from an aggregate public key via BIP 32 where {\ttfamily tweak32} is set to a hash as defined in BIP 32.

Callers are responsible for deriving {\ttfamily tweak32} in a way that does not reduce the security of Mu\+Sig (for example, by following BIP 32).

The tweaking method is the same as {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+pubkey\+\_\+tweak\+\_\+add}{p.}{secp256k1_8h_aaac0a0211f7ebfa1af55ab571cd57751}}. So after the following pseudocode buf and buf2 have identical contents (absent earlier failures).

secp256k1\+\_\+musig\+\_\+pubkey\+\_\+agg(..., keyagg\+\_\+cache, pubkeys, ...) secp256k1\+\_\+musig\+\_\+pubkey\+\_\+get(..., agg\+\_\+pk, keyagg\+\_\+cache) secp256k1\+\_\+musig\+\_\+pubkey\+\_\+ec\+\_\+tweak\+\_\+add(..., output\+\_\+pk, tweak32, keyagg\+\_\+cache) secp256k1\+\_\+ec\+\_\+pubkey\+\_\+serialize(..., buf, ..., output\+\_\+pk, ...) secp256k1\+\_\+ec\+\_\+pubkey\+\_\+tweak\+\_\+add(..., agg\+\_\+pk, tweak32) secp256k1\+\_\+ec\+\_\+pubkey\+\_\+serialize(..., buf2, ..., agg\+\_\+pk, ...)

This function is required if you want to {\itshape sign} for a tweaked aggregate key. If you are only computing a public key but not intending to create a signature for it, use {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+pubkey\+\_\+tweak\+\_\+add}{p.}{secp256k1_8h_aaac0a0211f7ebfa1af55ab571cd57751}} instead.

Returns\+: 0 if the arguments are invalid, 1 otherwise Args\+: ctx\+: pointer to a context object Out\+: output\+\_\+pubkey\+: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. If you do not need it, this arg can be NULL. In/\+Out\+: keyagg\+\_\+cache\+: pointer to a {\ttfamily musig\+\_\+keyagg\+\_\+cache} struct initialized by {\ttfamily musig\+\_\+pubkey\+\_\+agg} In\+: tweak32\+: pointer to a 32-\/byte tweak. The tweak is valid if it passes {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify}{p.}{secp256k1_8h_a366f922fc0c787351e82ff8e3a95f652}} and is not equal to the secret key corresponding to the public key represented by keyagg\+\_\+cache or its negation. For uniformly random 32-\/byte arrays the chance of being invalid is negligible (around 1 in 2$^\wedge$128). \index{keyagg\_impl.h@{keyagg\_impl.h}!secp256k1\_musig\_pubkey\_get@{secp256k1\_musig\_pubkey\_get}}
\index{secp256k1\_musig\_pubkey\_get@{secp256k1\_musig\_pubkey\_get}!keyagg\_impl.h@{keyagg\_impl.h}}
\doxysubsubsection{secp256k1\_musig\_pubkey\_get()}
{\footnotesize\ttfamily \label{keyagg__impl_8h_aeb67650b15b67b01abfb3cfdcf28d719} 
int secp256k1\+\_\+musig\+\_\+pubkey\+\_\+get (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{agg\+\_\+pk}{, }\item[{const \textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$}]{keyagg\+\_\+cache}{}\end{DoxyParamCaption})}

Obtain the aggregate public key from a keyagg\+\_\+cache.

This is only useful if you need the non-\/xonly public key, in particular for plain (non-\/xonly) tweaking or batch-\/verifying multiple key aggregations (not implemented).

Returns\+: 0 if the arguments are invalid, 1 otherwise Args\+: ctx\+: pointer to a context object Out\+: agg\+\_\+pk\+: the Mu\+Sig-\/aggregated public key. In\+: keyagg\+\_\+cache\+: pointer to a {\ttfamily musig\+\_\+keyagg\+\_\+cache} struct initialized by {\ttfamily musig\+\_\+pubkey\+\_\+agg} \index{keyagg\_impl.h@{keyagg\_impl.h}!secp256k1\_musig\_pubkey\_xonly\_tweak\_add@{secp256k1\_musig\_pubkey\_xonly\_tweak\_add}}
\index{secp256k1\_musig\_pubkey\_xonly\_tweak\_add@{secp256k1\_musig\_pubkey\_xonly\_tweak\_add}!keyagg\_impl.h@{keyagg\_impl.h}}
\doxysubsubsection{secp256k1\_musig\_pubkey\_xonly\_tweak\_add()}
{\footnotesize\ttfamily \label{keyagg__impl_8h_ab93abf3ae42ca6630555c1025b64b819} 
int secp256k1\+\_\+musig\+\_\+pubkey\+\_\+xonly\+\_\+tweak\+\_\+add (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{output\+\_\+pubkey}{, }\item[{\textbf{ secp256k1\+\_\+musig\+\_\+keyagg\+\_\+cache} $\ast$}]{keyagg\+\_\+cache}{, }\item[{const unsigned char $\ast$}]{tweak32}{}\end{DoxyParamCaption})}

Apply x-\/only tweaking to a public key in a given keyagg\+\_\+cache by adding the generator multiplied with {\ttfamily tweak32} to it. This is useful for creating Taproot outputs where {\ttfamily tweak32} is set to a Tap\+Tweak hash as defined in BIP 341.

Callers are responsible for deriving {\ttfamily tweak32} in a way that does not reduce the security of Mu\+Sig (for example, by following Taproot BIP 341).

The tweaking method is the same as {\ttfamily \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add}{p.}{secp256k1__extrakeys_8h_aaf832fa110c2610d69dee6ca74c856e8}}. So in the following pseudocode xonly\+\_\+pubkey\+\_\+tweak\+\_\+add\+\_\+check (absent earlier failures) returns 1.

secp256k1\+\_\+musig\+\_\+pubkey\+\_\+agg(..., agg\+\_\+pk, keyagg\+\_\+cache, pubkeys, ...) secp256k1\+\_\+musig\+\_\+pubkey\+\_\+xonly\+\_\+tweak\+\_\+add(..., output\+\_\+pk, keyagg\+\_\+cache, tweak32) secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+serialize(..., buf, output\+\_\+pk) secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add\+\_\+check(..., buf, ..., agg\+\_\+pk, tweak32)

This function is required if you want to {\itshape sign} for a tweaked aggregate key. If you are only computing a public key but not intending to create a signature for it, use {\ttfamily \doxyref{secp256k1\+\_\+xonly\+\_\+pubkey\+\_\+tweak\+\_\+add}{p.}{secp256k1__extrakeys_8h_aaf832fa110c2610d69dee6ca74c856e8}} instead.

Returns\+: 0 if the arguments are invalid, 1 otherwise Args\+: ctx\+: pointer to a context object Out\+: output\+\_\+pubkey\+: pointer to a public key to store the result. Will be set to an invalid value if this function returns 0. If you do not need it, this arg can be NULL. In/\+Out\+: keyagg\+\_\+cache\+: pointer to a {\ttfamily musig\+\_\+keyagg\+\_\+cache} struct initialized by {\ttfamily musig\+\_\+pubkey\+\_\+agg} In\+: tweak32\+: pointer to a 32-\/byte tweak. The tweak is valid if it passes {\ttfamily \doxyref{secp256k1\+\_\+ec\+\_\+seckey\+\_\+verify}{p.}{secp256k1_8h_a366f922fc0c787351e82ff8e3a95f652}} and is not equal to the secret key corresponding to the public key represented by keyagg\+\_\+cache or its negation. For uniformly random 32-\/byte arrays the chance of being invalid is negligible (around 1 in 2$^\wedge$128). 