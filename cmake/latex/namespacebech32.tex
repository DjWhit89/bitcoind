\doxysection{bech32 Namespace Reference}
\label{namespacebech32}\index{bech32@{bech32}}
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Decode\+Result}
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Encoding} \{ \textbf{ INVALID}
, \textbf{ BECH32}
, \textbf{ BECH32M}
 \}
\item 
enum \textbf{ Char\+Limit} \+: size\+\_\+t \{ \textbf{ BECH32} = 90
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \textbf{ Encode} (\textbf{ Encoding} encoding, const std\+::string \&hrp, const data \&values)
\item 
\textbf{ Decode\+Result} \textbf{ Decode} (const std\+::string \&str, \textbf{ Char\+Limit} limit)
\item 
std\+::pair$<$ std\+::string, std\+::vector$<$ int $>$ $>$ \textbf{ Locate\+Errors} (const std\+::string \&str, \textbf{ Char\+Limit} limit)
\item 
std\+::string \textbf{ Encode} (\textbf{ Encoding} encoding, const std\+::string \&hrp, const std\+::vector$<$ uint8\+\_\+t $>$ \&values)
\end{DoxyCompactItemize}


\label{doc-enum-members}
\doxysubsection{Enumeration Type Documentation}
\index{bech32@{bech32}!CharLimit@{CharLimit}}
\index{CharLimit@{CharLimit}!bech32@{bech32}}
\doxysubsubsection{CharLimit}
{\footnotesize\ttfamily \label{namespacebech32_a9040836d7f805004b53cd3b2f0552f72} 
enum \textbf{ Char\+Limit} \+: size\+\_\+t}

Character limits for Bech32(m) encoded strings. Character limits are how we provide error location guarantees. These values should never exceed 2$^\wedge$31 -\/ 1 (max value for a 32-\/bit int), since there are places where we may need to convert the Char\+Limit\+::\+VALUE to an int. In practice, this should never happen since this \doxyref{Char\+Limit}{p.}{namespacebech32_a9040836d7f805004b53cd3b2f0552f72} applies to an address encoding and we would never encode an address with such a massive value \begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{BECH32@{BECH32}!bech32@{bech32}}\index{bech32@{bech32}!BECH32@{BECH32}}}\label{namespacebech32_a9040836d7f805004b53cd3b2f0552f72ae4a001b00127c36bab10c00bb86742ee} 
BECH32&BIP173/350 imposed character limit for Bech32(m) encoded addresses. This guarantees finding up to 4 errors. \\
\hline

\end{DoxyEnumFields}
\index{bech32@{bech32}!Encoding@{Encoding}}
\index{Encoding@{Encoding}!bech32@{bech32}}
\doxysubsubsection{Encoding}
{\footnotesize\ttfamily \label{namespacebech32_afb0564821f132bfe74508af8349a0faa} 
enum class \textbf{ Encoding}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{INVALID@{INVALID}!bech32@{bech32}}\index{bech32@{bech32}!INVALID@{INVALID}}}\label{namespacebech32_afb0564821f132bfe74508af8349a0faaaccc0377a8afbf50e7094f5c23a8af223} 
INVALID&Failed decoding. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{BECH32@{BECH32}!bech32@{bech32}}\index{bech32@{bech32}!BECH32@{BECH32}}}\label{namespacebech32_afb0564821f132bfe74508af8349a0faaad4fd7223ebde09ed36b615658d29d7bc} 
BECH32&Bech32 encoding as defined in BIP173. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{BECH32M@{BECH32M}!bech32@{bech32}}\index{bech32@{bech32}!BECH32M@{BECH32M}}}\label{namespacebech32_afb0564821f132bfe74508af8349a0faaae5747421d490e83aa21f61eae1ae3778} 
BECH32M&Bech32m encoding as defined in BIP350. \\
\hline

\end{DoxyEnumFields}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{bech32@{bech32}!Decode@{Decode}}
\index{Decode@{Decode}!bech32@{bech32}}
\doxysubsubsection{Decode()}
{\footnotesize\ttfamily \label{namespacebech32_a550009b85f18ec84a997d97fd050bcfb} 
\textbf{ Decode\+Result} Decode (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str}{, }\item[{\textbf{ Char\+Limit}}]{limit}{}\end{DoxyParamCaption})}

Decode a Bech32 or Bech32m string. \index{bech32@{bech32}!Encode@{Encode}}
\index{Encode@{Encode}!bech32@{bech32}}
\doxysubsubsection{Encode()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespacebech32_a6818280e985bfd7dab1440445cd111de} 
std\+::string Encode (\begin{DoxyParamCaption}\item[{\textbf{ Encoding}}]{encoding}{, }\item[{const std\+::string \&}]{hrp}{, }\item[{const data \&}]{values}{}\end{DoxyParamCaption})}

Encode a Bech32 or Bech32m string. \index{bech32@{bech32}!Encode@{Encode}}
\index{Encode@{Encode}!bech32@{bech32}}
\doxysubsubsection{Encode()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespacebech32_ad055801df5a5064c3817601c8d8bd649} 
std\+::string Encode (\begin{DoxyParamCaption}\item[{\textbf{ Encoding}}]{encoding}{, }\item[{const std\+::string \&}]{hrp}{, }\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{values}{}\end{DoxyParamCaption})}

Encode a Bech32 or Bech32m string. If hrp contains uppercase characters, this will cause an assertion error. \doxyref{Encoding}{p.}{namespacebech32_afb0564821f132bfe74508af8349a0faa} must be one of BECH32 or BECH32M. \index{bech32@{bech32}!LocateErrors@{LocateErrors}}
\index{LocateErrors@{LocateErrors}!bech32@{bech32}}
\doxysubsubsection{LocateErrors()}
{\footnotesize\ttfamily \label{namespacebech32_acde21ed778864b3ec914bd49f5e31f4a} 
std\+::pair$<$ std\+::string, std\+::vector$<$ int $>$ $>$ Locate\+Errors (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str}{, }\item[{\textbf{ Char\+Limit}}]{limit}{}\end{DoxyParamCaption})}

Find index of an incorrect character in a Bech32 string.

Return the positions of errors in a Bech32 string. 