\doxysection{V2\+Transport Class Reference}
\label{class_v2_transport}\index{V2Transport@{V2Transport}}


{\ttfamily \#include $<$net.\+h$>$}

Inheritance diagram for V2\+Transport\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_v2_transport}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ V2\+Transport} (\textbf{ Node\+Id} nodeid, bool initiating) noexcept
\item 
\textbf{ V2\+Transport} (\textbf{ Node\+Id} nodeid, bool initiating, const \textbf{ CKey} \&key, std\+::span$<$ const std\+::byte $>$ ent32, std\+::vector$<$ uint8\+\_\+t $>$ garbage) noexcept
\item 
bool \textbf{ Received\+Message\+Complete} () const noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+recv\+\_\+mutex)
\item 
bool \textbf{ Received\+Bytes} (std\+::span$<$ const uint8\+\_\+t $>$ \&msg\+\_\+bytes) noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+recv\+\_\+mutex
\item 
\textbf{ CNet\+Message} \textbf{ Get\+Received\+Message} (std\+::chrono\+::microseconds time, bool \&reject\+\_\+message) noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+recv\+\_\+mutex)
\item 
bool \textbf{ Set\+Message\+To\+Send} (\textbf{ CSerialized\+Net\+Msg} \&msg) noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+send\+\_\+mutex)
\item 
\textbf{ Bytes\+To\+Send} \textbf{ Get\+Bytes\+To\+Send} (bool have\+\_\+next\+\_\+message) const noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+send\+\_\+mutex)
\item 
void \textbf{ Mark\+Bytes\+Sent} (size\+\_\+t bytes\+\_\+sent) noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+send\+\_\+mutex)
\item 
size\+\_\+t \textbf{ Get\+Send\+Memory\+Usage} () const noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+send\+\_\+mutex)
\item 
bool \textbf{ Should\+Reconnect\+V1} () const noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+recv\+\_\+mutex
\item 
\textbf{ Info} \textbf{ Get\+Info} () const noexcept override \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+recv\+\_\+mutex)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \textbf{ Transport}}
\begin{DoxyCompactItemize}
\item 
virtual \textbf{ $\sim$\+Transport} ()=default
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static constexpr uint32\+\_\+t \textbf{ MAX\+\_\+\+GARBAGE\+\_\+\+LEN} = 4095
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Public Types inherited from \textbf{ Transport}}
\begin{DoxyCompactItemize}
\item 
using \textbf{ Bytes\+To\+Send}
\end{DoxyCompactItemize}


\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{V2Transport@{V2Transport}!V2Transport@{V2Transport}}
\index{V2Transport@{V2Transport}!V2Transport@{V2Transport}}
\doxysubsubsection{V2Transport()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_v2_transport_a8e35b001b48519575f9b2702c9885275} 
\textbf{ V2\+Transport} (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{nodeid}{, }\item[{bool}]{initiating}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Construct a V2 transport with securely generated random keys.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em nodeid} & the node\textquotesingle{}s \doxyref{Node\+Id}{p.}{net_8h_aa637b11e18b77724b35db2229cd12788} (only for debug log output). \\
\hline
\mbox{\texttt{in}}  & {\em initiating} & whether we are the initiator side. \\
\hline
\end{DoxyParams}
\index{V2Transport@{V2Transport}!V2Transport@{V2Transport}}
\index{V2Transport@{V2Transport}!V2Transport@{V2Transport}}
\doxysubsubsection{V2Transport()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_v2_transport_abccf3f4eb2119f48b780a98aa749da2d} 
\textbf{ V2\+Transport} (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{nodeid}{, }\item[{bool}]{initiating}{, }\item[{const \textbf{ CKey} \&}]{key}{, }\item[{std\+::span$<$ const std\+::byte $>$}]{ent32}{, }\item[{std\+::vector$<$ uint8\+\_\+t $>$}]{garbage}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Construct a V2 transport with specified keys and garbage (test use only). 

\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{V2Transport@{V2Transport}!GetBytesToSend@{GetBytesToSend}}
\index{GetBytesToSend@{GetBytesToSend}!V2Transport@{V2Transport}}
\doxysubsubsection{GetBytesToSend()}
{\footnotesize\ttfamily \label{class_v2_transport_a39dcf7de09089dc617df00c6850647b3} 
\textbf{ Transport\+::\+Bytes\+To\+Send} Get\+Bytes\+To\+Send (\begin{DoxyParamCaption}\item[{bool}]{have\+\_\+next\+\_\+message}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Get bytes to send on the wire, if any, along with other information about it.

As a const function, it does not modify the transport\textquotesingle{}s observable state, and is thus safe to be called multiple times.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em have\+\_\+next\+\_\+message} & If true, the "{}more"{} return value reports whether more will be sendable after a Set\+Message\+To\+Send call. It is set by the caller when they know they have another message ready to send, and only care about what happens after that. The have\+\_\+next\+\_\+message argument only affects this "{}more"{} return value and nothing else.\\
\hline
\end{DoxyParams}
Effectively, there are three possible outcomes about whether there are more bytes to send\+:
\begin{DoxyItemize}
\item Yes\+: the transport itself has more bytes to send later. For example, for \doxyref{V1\+Transport}{p.}{class_v1_transport} this happens during the sending of the header of a message, when there is a non-\/empty payload that follows.
\item No\+: the transport itself has no more bytes to send, but will have bytes to send if handed a message through Set\+Message\+To\+Send. In \doxyref{V1\+Transport}{p.}{class_v1_transport} this happens when sending the payload of a message.
\item Blocked\+: the transport itself has no more bytes to send, and is also incapable of sending anything more at all now, if it were handed another message to send. This occurs in \doxyref{V2\+Transport}{p.}{class_v2_transport} before the handshake is complete, as the encryption ciphers are not set up for sending messages before that point.
\end{DoxyItemize}

The boolean \textquotesingle{}more\textquotesingle{} is true for Yes, false for Blocked, and have\+\_\+next\+\_\+message controls what is returned for No.

\begin{DoxyReturn}{Returns}
a \doxyref{Bytes\+To\+Send}{p.}{class_transport_af6ca4dbfbf45f9bd26bc6bf4a6adfb9f} object. The to\+\_\+send member returned acts as a stream which is only ever appended to. This means that with the exception of Mark\+Bytes\+Sent (which pops bytes off the front of later to\+\_\+sends), operations on the transport can only append to what is being returned. Also note that m\+\_\+type and to\+\_\+send refer to data that is internal to the transport, and calling any non-\/const function on this object may invalidate them. 
\end{DoxyReturn}


Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_afe903c5a52b321e189d97c6edbb64e95}.

\index{V2Transport@{V2Transport}!GetInfo@{GetInfo}}
\index{GetInfo@{GetInfo}!V2Transport@{V2Transport}}
\doxysubsubsection{GetInfo()}
{\footnotesize\ttfamily \label{class_v2_transport_a52d0c2171a477c4f78137f806a4871f0} 
\textbf{ Transport\+::\+Info} Get\+Info (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Retrieve information about this transport. 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_a48296f31d432a8809164b3f97bbc1e4a}.

\index{V2Transport@{V2Transport}!GetReceivedMessage@{GetReceivedMessage}}
\index{GetReceivedMessage@{GetReceivedMessage}!V2Transport@{V2Transport}}
\doxysubsubsection{GetReceivedMessage()}
{\footnotesize\ttfamily \label{class_v2_transport_a12316f223ad2873017e085b2aacaa6ec} 
\textbf{ CNet\+Message} Get\+Received\+Message (\begin{DoxyParamCaption}\item[{std\+::chrono\+::microseconds}]{time}{, }\item[{bool \&}]{reject\+\_\+message}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Retrieve a completed message from transport.

This can only be called when \doxyref{Received\+Message\+Complete()}{p.}{class_v2_transport_a4f36f118f8160d80099867d6649af983} is true.

If reject\+\_\+message=true is returned the message itself is invalid, but (other than false returned by Received\+Bytes) the transport is not in an inconsistent state. 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_a65899c32e93818026372178488912881}.

\index{V2Transport@{V2Transport}!GetSendMemoryUsage@{GetSendMemoryUsage}}
\index{GetSendMemoryUsage@{GetSendMemoryUsage}!V2Transport@{V2Transport}}
\doxysubsubsection{GetSendMemoryUsage()}
{\footnotesize\ttfamily \label{class_v2_transport_a6064b63ffba8cdc3f48a4217f75e3f93} 
size\+\_\+t Get\+Send\+Memory\+Usage (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Return the memory usage of this transport attributable to buffered data to send. 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_a091196a6bab12cd2fe571129015bba8b}.

\index{V2Transport@{V2Transport}!MarkBytesSent@{MarkBytesSent}}
\index{MarkBytesSent@{MarkBytesSent}!V2Transport@{V2Transport}}
\doxysubsubsection{MarkBytesSent()}
{\footnotesize\ttfamily \label{class_v2_transport_ac69707799060ee90f662f6139bf01505} 
void Mark\+Bytes\+Sent (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{bytes\+\_\+sent}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Report how many bytes returned by the last \doxyref{Get\+Bytes\+To\+Send()}{p.}{class_v2_transport_a39dcf7de09089dc617df00c6850647b3} have been sent.

bytes\+\_\+sent cannot exceed to\+\_\+send.\+size() of the last \doxyref{Get\+Bytes\+To\+Send()}{p.}{class_v2_transport_a39dcf7de09089dc617df00c6850647b3} result.

If bytes\+\_\+sent=0, this call has no effect. 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_a915249a31c6d363883f933cbbd07d22f}.

\index{V2Transport@{V2Transport}!ReceivedBytes@{ReceivedBytes}}
\index{ReceivedBytes@{ReceivedBytes}!V2Transport@{V2Transport}}
\doxysubsubsection{ReceivedBytes()}
{\footnotesize\ttfamily \label{class_v2_transport_a5691fd1213bde99a8f6b51b0db49c799} 
bool Received\+Bytes (\begin{DoxyParamCaption}\item[{std\+::span$<$ const uint8\+\_\+t $>$ \&}]{msg\+\_\+bytes}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Feed wire bytes to the transport.

\begin{DoxyReturn}{Returns}
false if some bytes were invalid, in which case the transport can\textquotesingle{}t be used anymore.
\end{DoxyReturn}
Consumed bytes are chopped off the front of msg\+\_\+bytes. How many bytes to allocate in the receive buffer at most above what is received so far.

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_af5340b2062e8681b6fb7d8f5a724102d}.

\index{V2Transport@{V2Transport}!ReceivedMessageComplete@{ReceivedMessageComplete}}
\index{ReceivedMessageComplete@{ReceivedMessageComplete}!V2Transport@{V2Transport}}
\doxysubsubsection{ReceivedMessageComplete()}
{\footnotesize\ttfamily \label{class_v2_transport_a4f36f118f8160d80099867d6649af983} 
bool Received\+Message\+Complete (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Returns true if the current message is complete (so Get\+Received\+Message can be called). 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_ad72f1df14e7c2b557c3f780d25361073}.

\index{V2Transport@{V2Transport}!SetMessageToSend@{SetMessageToSend}}
\index{SetMessageToSend@{SetMessageToSend}!V2Transport@{V2Transport}}
\doxysubsubsection{SetMessageToSend()}
{\footnotesize\ttfamily \label{class_v2_transport_ae61bb32e8ff51cb3802156ab3eb10556} 
bool Set\+Message\+To\+Send (\begin{DoxyParamCaption}\item[{\textbf{ CSerialized\+Net\+Msg} \&}]{msg}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Set the next message to send.

If no message can currently be set (perhaps because the previous one is not yet done being sent), returns false, and msg will be unmodified. Otherwise msg is enqueued (and possibly moved-\/from) and true is returned. 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_a7f7875e9c9bf5903f84dba2123309c01}.

\index{V2Transport@{V2Transport}!ShouldReconnectV1@{ShouldReconnectV1}}
\index{ShouldReconnectV1@{ShouldReconnectV1}!V2Transport@{V2Transport}}
\doxysubsubsection{ShouldReconnectV1()}
{\footnotesize\ttfamily \label{class_v2_transport_ab392835ec6771ddb918c7322a2bf1826} 
bool Should\+Reconnect\+V1 (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}

Whether upon disconnections, a reconnect with V1 is warranted. 

Implements \textbf{ Transport} \doxyref{}{p.}{class_transport_ab8e03c4ee651c248fe3c67c55844681c}.



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{V2Transport@{V2Transport}!MAX\_GARBAGE\_LEN@{MAX\_GARBAGE\_LEN}}
\index{MAX\_GARBAGE\_LEN@{MAX\_GARBAGE\_LEN}!V2Transport@{V2Transport}}
\doxysubsubsection{MAX\_GARBAGE\_LEN}
{\footnotesize\ttfamily \label{class_v2_transport_a426eec4f0246a40d6c4b4f3d821b396b} 
uint32\+\_\+t MAX\+\_\+\+GARBAGE\+\_\+\+LEN = 4095\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ net.\+h}\item 
src/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
