\doxysection{src/secp256k1/include/secp256k1\+\_\+recovery.h File Reference}
\label{secp256k1__recovery_8h}\index{src/secp256k1/include/secp256k1\_recovery.h@{src/secp256k1/include/secp256k1\_recovery.h}}
{\ttfamily \#include "{}secp256k1.\+h"{}}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature}
\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig, const unsigned char $\ast$input64, int recid) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+ecdsa\+\_\+signature} $\ast$sig, const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sigin) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$output64, int $\ast$recid, const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} int \textbf{ secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig, const unsigned char $\ast$msghash32, const unsigned char $\ast$seckey, \textbf{ secp256k1\+\_\+nonce\+\_\+function} noncefp, const void $\ast$ndata) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\item 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recover} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$pubkey, const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig, const unsigned char $\ast$msghash32) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(1) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(2) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(3) \textbf{ SECP256\+K1\+\_\+\+ARG\+\_\+\+NONNULL}(4)
\end{DoxyCompactItemize}


\label{doc-typedef-members}
\doxysubsection{Typedef Documentation}
\index{secp256k1\_recovery.h@{secp256k1\_recovery.h}!secp256k1\_ecdsa\_recoverable\_signature@{secp256k1\_ecdsa\_recoverable\_signature}}
\index{secp256k1\_ecdsa\_recoverable\_signature@{secp256k1\_ecdsa\_recoverable\_signature}!secp256k1\_recovery.h@{secp256k1\_recovery.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature}
{\footnotesize\ttfamily \label{secp256k1__recovery_8h_a458eba22320a4df81ccdbd68c0a2e3c4} 
typedef struct secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature}

Opaque data structure that holds a parsed ECDSA signature, supporting pubkey recovery.

The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions. It is however guaranteed to be 65 bytes in size, and can be safely copied/moved. If you need to convert to a format suitable for storage or transmission, use the secp256k1\+\_\+ecdsa\+\_\+signature\+\_\+serialize\+\_\+$\ast$ and secp256k1\+\_\+ecdsa\+\_\+signature\+\_\+parse\+\_\+$\ast$ functions.

Furthermore, it is guaranteed that identical signatures (including their recoverability) will have identical representation, so they can be memcmp\textquotesingle{}ed. 

\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{secp256k1\_recovery.h@{secp256k1\_recovery.h}!secp256k1\_ecdsa\_recover@{secp256k1\_ecdsa\_recover}}
\index{secp256k1\_ecdsa\_recover@{secp256k1\_ecdsa\_recover}!secp256k1\_recovery.h@{secp256k1\_recovery.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recover()}
{\footnotesize\ttfamily \label{secp256k1__recovery_8h_af9f2082776bf8ebdb4c38161a211a02b} 
\textbf{ SECP256\+K1\+\_\+\+API} \textbf{ SECP256\+K1\+\_\+\+WARN\+\_\+\+UNUSED\+\_\+\+RESULT} int secp256k1\+\_\+ecdsa\+\_\+recover (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{, }\item[{const unsigned char $\ast$}]{msghash32}{}\end{DoxyParamCaption})}

Recover an ECDSA public key from a signature.

Successful public key recovery guarantees that the signature, after normalization, passes {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+verify}{p.}{secp256k1_8h_a7dd6acb7ef7100a6aebff91ecb7ede30}}. Thus, explicit verification is not necessary.

However, a recoverable signature that successfully passes {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+recover}{p.}{secp256k1__recovery_8h_af9f2082776bf8ebdb4c38161a211a02b}}, when converted to a non-\/recoverable signature (using {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}{p.}{secp256k1__recovery_8h_ad7a20c9f7ccd9fc6d75a19a3b4195aa5}}), is not guaranteed to be normalized and thus not guaranteed to pass {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+verify}{p.}{secp256k1_8h_a7dd6acb7ef7100a6aebff91ecb7ede30}}. If a normalized signature is required, call {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+signature\+\_\+normalize}{p.}{secp256k1_8h_a93ec36a19229f08acc5ff1ca613ab3a1}} after {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}{p.}{secp256k1__recovery_8h_ad7a20c9f7ccd9fc6d75a19a3b4195aa5}}.

Returns\+: 1\+: public key successfully recovered 0\+: otherwise. Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to the recovered public key. In\+: sig\+: pointer to initialized signature that supports pubkey recovery. msghash32\+: the 32-\/byte message hash assumed to be signed. \index{secp256k1\_recovery.h@{secp256k1\_recovery.h}!secp256k1\_ecdsa\_recoverable\_signature\_convert@{secp256k1\_ecdsa\_recoverable\_signature\_convert}}
\index{secp256k1\_ecdsa\_recoverable\_signature\_convert@{secp256k1\_ecdsa\_recoverable\_signature\_convert}!secp256k1\_recovery.h@{secp256k1\_recovery.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature\_convert()}
{\footnotesize\ttfamily \label{secp256k1__recovery_8h_ad7a20c9f7ccd9fc6d75a19a3b4195aa5} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+ecdsa\+\_\+signature} $\ast$}]{sig}{, }\item[{const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sigin}{}\end{DoxyParamCaption})}

Convert a recoverable signature into a normal signature.

Returns\+: 1 Args\+: ctx\+: pointer to a context object. Out\+: sig\+: pointer to a normal signature. In\+: sigin\+: pointer to a recoverable signature. \index{secp256k1\_recovery.h@{secp256k1\_recovery.h}!secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact}}
\index{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact}!secp256k1\_recovery.h@{secp256k1\_recovery.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact()}
{\footnotesize\ttfamily \label{secp256k1__recovery_8h_a6699b45dc75be70f028ac7d8ffaba46e} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{, }\item[{const unsigned char $\ast$}]{input64}{, }\item[{int}]{recid}{}\end{DoxyParamCaption})}

Parse a compact ECDSA signature (64 bytes + recovery id).

Returns\+: 1 when the signature could be parsed, 0 otherwise Args\+: ctx\+: pointer to a context object Out\+: sig\+: pointer to a signature object In\+: input64\+: pointer to a 64-\/byte compact signature recid\+: the recovery id (0, 1, 2 or 3) \index{secp256k1\_recovery.h@{secp256k1\_recovery.h}!secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact}}
\index{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact}!secp256k1\_recovery.h@{secp256k1\_recovery.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact()}
{\footnotesize\ttfamily \label{secp256k1__recovery_8h_a12f08c89ceb61949c6a4ec6eb2511185} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{output64}{, }\item[{int $\ast$}]{recid}{, }\item[{const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{}\end{DoxyParamCaption})}

Serialize an ECDSA signature in compact format (64 bytes + recovery id).

Returns\+: 1 Args\+: ctx\+: pointer to a context object. Out\+: output64\+: pointer to a 64-\/byte array of the compact signature. recid\+: pointer to an integer to hold the recovery id. In\+: sig\+: pointer to an initialized signature object. \index{secp256k1\_recovery.h@{secp256k1\_recovery.h}!secp256k1\_ecdsa\_sign\_recoverable@{secp256k1\_ecdsa\_sign\_recoverable}}
\index{secp256k1\_ecdsa\_sign\_recoverable@{secp256k1\_ecdsa\_sign\_recoverable}!secp256k1\_recovery.h@{secp256k1\_recovery.h}}
\doxysubsubsection{secp256k1\_ecdsa\_sign\_recoverable()}
{\footnotesize\ttfamily \label{secp256k1__recovery_8h_a7868accd4760afcaeaa0ff3d239afc2a} 
\textbf{ SECP256\+K1\+\_\+\+API} int secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{, }\item[{const unsigned char $\ast$}]{msghash32}{, }\item[{const unsigned char $\ast$}]{seckey}{, }\item[{\textbf{ secp256k1\+\_\+nonce\+\_\+function}}]{noncefp}{, }\item[{const void $\ast$}]{ndata}{}\end{DoxyParamCaption})}

Create a recoverable ECDSA signature.

Returns\+: 1\+: signature created 0\+: the nonce generation function failed, or the secret key was invalid. Args\+: ctx\+: pointer to a context object (not secp256k1\+\_\+context\+\_\+static). Out\+: sig\+: pointer to an array where the signature will be placed. In\+: msghash32\+: the 32-\/byte message hash being signed. seckey\+: pointer to a 32-\/byte secret key. noncefp\+: pointer to a nonce generation function. If NULL, secp256k1\+\_\+nonce\+\_\+function\+\_\+default is used. ndata\+: pointer to arbitrary data used by the nonce generation function (can be NULL for secp256k1\+\_\+nonce\+\_\+function\+\_\+default). 