\doxysection{CNode Class Reference}
\label{class_c_node}\index{CNode@{CNode}}


{\ttfamily \#include $<$net.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::shared\+\_\+ptr$<$ \textbf{ Sock} $>$ m\+\_\+sock \textbf{ GUARDED\+\_\+\+BY} (\textbf{ m\+\_\+sock\+\_\+mutex})
\item 
size\+\_\+t m\+\_\+send\+\_\+memusage \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+v\+Send})
\item 
uint64\+\_\+t n\+Send\+Bytes \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+v\+Send})
\item 
std\+::deque$<$ \textbf{ CSerialized\+Net\+Msg} $>$ v\+Send\+Msg \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+v\+Send})
\item 
uint64\+\_\+t n\+Recv\+Bytes \textbf{ GUARDED\+\_\+\+BY} (\textbf{ cs\+\_\+v\+Recv})
\item 
std\+::string clean\+Sub\+Ver \textbf{ GUARDED\+\_\+\+BY} (\textbf{ m\+\_\+subver\+\_\+mutex})
\item 
bool \textbf{ Has\+Permission} (\textbf{ Net\+Permission\+Flags} permission) const
\item 
void \textbf{ Mark\+Received\+Msgs\+For\+Processing} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+msg\+\_\+process\+\_\+queue\+\_\+mutex)
\item 
std\+::optional$<$ std\+::pair$<$ \textbf{ CNet\+Message}, bool $>$ $>$ \textbf{ Poll\+Message} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+msg\+\_\+process\+\_\+queue\+\_\+mutex)
\item 
void \textbf{ Account\+For\+Sent\+Bytes} (const std\+::string \&msg\+\_\+type, size\+\_\+t sent\+\_\+bytes) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(\textbf{ cs\+\_\+v\+Send})
\item 
bool \textbf{ Is\+Outbound\+Or\+Block\+Relay\+Conn} () const
\item 
bool \textbf{ Is\+Full\+Outbound\+Conn} () const
\item 
bool \textbf{ Is\+Manual\+Conn} () const
\item 
bool \textbf{ Is\+Manual\+Or\+Full\+Outbound\+Conn} () const
\item 
bool \textbf{ Is\+Block\+Only\+Conn} () const
\item 
bool \textbf{ Is\+Feeler\+Conn} () const
\item 
bool \textbf{ Is\+Addr\+Fetch\+Conn} () const
\item 
bool \textbf{ Is\+Inbound\+Conn} () const
\item 
bool \textbf{ Expect\+Services\+From\+Conn} () const
\item 
\textbf{ Network} \textbf{ Connected\+Through\+Network} () const
\item 
bool \textbf{ Is\+Connected\+Through\+Privacy\+Net} () const
\item 
\textbf{ CNode} (\textbf{ Node\+Id} id, std\+::shared\+\_\+ptr$<$ \textbf{ Sock} $>$ sock, const \textbf{ CAddress} \&addr\+In, uint64\+\_\+t n\+Keyed\+Net\+Group\+In, uint64\+\_\+t n\+Local\+Host\+Nonce\+In, const \textbf{ CService} \&addr\+Bind\+In, const std\+::string \&addr\+Name\+In, \textbf{ Connection\+Type} conn\+\_\+type\+\_\+in, bool inbound\+\_\+onion, uint64\+\_\+t network\+\_\+key, \textbf{ CNode\+Options} \&\&node\+\_\+opts=\{\})
\item 
\textbf{ CNode} (const \textbf{ CNode} \&)=delete
\item 
\textbf{ CNode} \& \textbf{ operator=} (const \textbf{ CNode} \&)=delete
\item 
\textbf{ Node\+Id} \textbf{ Get\+Id} () const
\item 
uint64\+\_\+t \textbf{ Get\+Local\+Nonce} () const
\item 
int \textbf{ Get\+Ref\+Count} () const
\item 
bool \textbf{ Receive\+Msg\+Bytes} (std\+::span$<$ const uint8\+\_\+t $>$ msg\+\_\+bytes, bool \&complete) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!\textbf{ cs\+\_\+v\+Recv})
\item 
void \textbf{ Set\+Common\+Version} (int greatest\+\_\+common\+\_\+version)
\item 
int \textbf{ Get\+Common\+Version} () const
\item 
\textbf{ CService} \textbf{ Get\+Addr\+Local} () const \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+addr\+\_\+local\+\_\+mutex)
\item 
void \textbf{ Set\+Addr\+Local} (const \textbf{ CService} \&addr\+Local\+In) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!m\+\_\+addr\+\_\+local\+\_\+mutex)
\begin{DoxyCompactList}\small\item\em May not be called more than once. \end{DoxyCompactList}\item 
\textbf{ CNode} $\ast$ \textbf{ Add\+Ref} ()
\item 
void \textbf{ Release} ()
\item 
void \textbf{ Close\+Socket\+Disconnect} () \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!\textbf{ m\+\_\+sock\+\_\+mutex})
\item 
void \textbf{ Copy\+Stats} (\textbf{ CNode\+Stats} \&stats) \textbf{ EXCLUSIVE\+\_\+\+LOCKS\+\_\+\+REQUIRED}(!\textbf{ m\+\_\+subver\+\_\+mutex}
\item 
std\+::string \textbf{ Connection\+Type\+As\+String} () const
\item 
std\+::string \textbf{ Log\+IP} (bool log\+\_\+ip) const
\item 
std\+::string \textbf{ Disconnect\+Msg} (bool log\+\_\+ip) const
\item 
void \textbf{ Pong\+Received} (std\+::chrono\+::microseconds ping\+\_\+time)
\end{DoxyCompactItemize}
\doxysubsubsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
const std\+::unique\+\_\+ptr$<$ \textbf{ Transport} $>$ \textbf{ m\+\_\+transport}
\item 
const \textbf{ Net\+Permission\+Flags} \textbf{ m\+\_\+permission\+\_\+flags}
\item 
\textbf{ Mutex} \textbf{ cs\+\_\+v\+Send}
\item 
\textbf{ Mutex} \textbf{ m\+\_\+sock\+\_\+mutex}
\item 
\textbf{ Mutex} \textbf{ cs\+\_\+v\+Recv}
\item 
std\+::atomic$<$ std\+::chrono\+::seconds $>$ \textbf{ m\+\_\+last\+\_\+send} \{0s\}
\item 
std\+::atomic$<$ std\+::chrono\+::seconds $>$ \textbf{ m\+\_\+last\+\_\+recv} \{0s\}
\item 
const std\+::chrono\+::seconds \textbf{ m\+\_\+connected}
\begin{DoxyCompactList}\small\item\em Unix epoch time at peer connection. \end{DoxyCompactList}\item 
const \textbf{ CAddress} \textbf{ addr}
\item 
const \textbf{ CService} \textbf{ addr\+Bind}
\item 
const std\+::string \textbf{ m\+\_\+addr\+\_\+name}
\item 
const std\+::string \textbf{ m\+\_\+dest}
\item 
const bool \textbf{ m\+\_\+inbound\+\_\+onion}
\begin{DoxyCompactList}\small\item\em Whether this peer is an inbound onion, i.\+e. connected via our Tor onion service. \end{DoxyCompactList}\item 
std\+::atomic$<$ int $>$ \textbf{ n\+Version} \{0\}
\item 
\textbf{ Mutex} \textbf{ m\+\_\+subver\+\_\+mutex}
\item 
const bool \textbf{ m\+\_\+prefer\+\_\+evict} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ f\+Successfully\+Connected} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ f\+Disconnect} \{false\}
\item 
\textbf{ Counting\+Semaphore\+Grant} \textbf{ grant\+Outbound}
\item 
std\+::atomic$<$ int $>$ \textbf{ n\+Ref\+Count} \{0\}
\item 
const uint64\+\_\+t \textbf{ n\+Keyed\+Net\+Group}
\item 
std\+::atomic\+\_\+bool \textbf{ f\+Pause\+Recv} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ f\+Pause\+Send} \{false\}
\item 
const uint64\+\_\+t \textbf{ m\+\_\+network\+\_\+key}
\item 
const \textbf{ Connection\+Type} \textbf{ m\+\_\+conn\+\_\+type}
\item 
std\+::atomic$<$ bool $>$ \textbf{ m\+\_\+bip152\+\_\+highbandwidth\+\_\+to} \{false\}
\item 
std\+::atomic$<$ bool $>$ \textbf{ m\+\_\+bip152\+\_\+highbandwidth\+\_\+from} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ m\+\_\+has\+\_\+all\+\_\+wanted\+\_\+services} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ m\+\_\+relays\+\_\+txs} \{false\}
\item 
std\+::atomic\+\_\+bool \textbf{ m\+\_\+bloom\+\_\+filter\+\_\+loaded} \{false\}
\item 
std\+::atomic$<$ std\+::chrono\+::seconds $>$ \textbf{ m\+\_\+last\+\_\+block\+\_\+time} \{0s\}
\item 
std\+::atomic$<$ std\+::chrono\+::seconds $>$ \textbf{ m\+\_\+last\+\_\+tx\+\_\+time} \{0s\}
\item 
std\+::atomic$<$ std\+::chrono\+::microseconds $>$ \textbf{ m\+\_\+last\+\_\+ping\+\_\+time} \{0us\}
\item 
std\+::atomic$<$ std\+::chrono\+::microseconds $>$ \textbf{ m\+\_\+min\+\_\+ping\+\_\+time} \{std\+::chrono\+::microseconds\+::max()\}
\item 
void \textbf{ !m\+\_\+addr\+\_\+local\+\_\+mutex}
\item 
void \textbf{ !cs\+\_\+v\+Send}
\item 
void \textbf{ !cs\+\_\+v\+Recv}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Information about a peer 

\label{doc-constructors}
\doxysubsection{Constructor \& Destructor Documentation}
\index{CNode@{CNode}!CNode@{CNode}}
\index{CNode@{CNode}!CNode@{CNode}}
\doxysubsubsection{CNode()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_c_node_a91bc4c04fa6140e8dc79a257f63b8e39} 
\textbf{ CNode} (\begin{DoxyParamCaption}\item[{\textbf{ Node\+Id}}]{id}{, }\item[{std\+::shared\+\_\+ptr$<$ \textbf{ Sock} $>$}]{sock}{, }\item[{const \textbf{ CAddress} \&}]{addr\+In}{, }\item[{uint64\+\_\+t}]{n\+Keyed\+Net\+Group\+In}{, }\item[{uint64\+\_\+t}]{n\+Local\+Host\+Nonce\+In}{, }\item[{const \textbf{ CService} \&}]{addr\+Bind\+In}{, }\item[{const std\+::string \&}]{addr\+Name\+In}{, }\item[{\textbf{ Connection\+Type}}]{conn\+\_\+type\+\_\+in}{, }\item[{bool}]{inbound\+\_\+onion}{, }\item[{uint64\+\_\+t}]{network\+\_\+key}{, }\item[{\textbf{ CNode\+Options} \&\&}]{node\+\_\+opts}{ = {\ttfamily \{\}}}\end{DoxyParamCaption})}

\index{CNode@{CNode}!CNode@{CNode}}
\index{CNode@{CNode}!CNode@{CNode}}
\doxysubsubsection{CNode()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_c_node_aceed67371c3a27ebfe020fb9e7c3c0c6} 
\textbf{ CNode} (\begin{DoxyParamCaption}\item[{const \textbf{ CNode} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}



\label{doc-func-members}
\doxysubsection{Member Function Documentation}
\index{CNode@{CNode}!AccountForSentBytes@{AccountForSentBytes}}
\index{AccountForSentBytes@{AccountForSentBytes}!CNode@{CNode}}
\doxysubsubsection{AccountForSentBytes()}
{\footnotesize\ttfamily \label{class_c_node_ad06923e8aa8c4303a2c6f8479df14310} 
void Account\+For\+Sent\+Bytes (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msg\+\_\+type}{, }\item[{size\+\_\+t}]{sent\+\_\+bytes}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Account for the total size of a sent message in the per msg type connection stats. \index{CNode@{CNode}!AddRef@{AddRef}}
\index{AddRef@{AddRef}!CNode@{CNode}}
\doxysubsubsection{AddRef()}
{\footnotesize\ttfamily \label{class_c_node_a2c3060c42c26754c14ae32ee3b1621b3} 
\textbf{ CNode} $\ast$ Add\+Ref (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!CloseSocketDisconnect@{CloseSocketDisconnect}}
\index{CloseSocketDisconnect@{CloseSocketDisconnect}!CNode@{CNode}}
\doxysubsubsection{CloseSocketDisconnect()}
{\footnotesize\ttfamily \label{class_c_node_a153e70aa7b79aa27f6739044fce4a55a} 
void Close\+Socket\+Disconnect (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\index{CNode@{CNode}!ConnectedThroughNetwork@{ConnectedThroughNetwork}}
\index{ConnectedThroughNetwork@{ConnectedThroughNetwork}!CNode@{CNode}}
\doxysubsubsection{ConnectedThroughNetwork()}
{\footnotesize\ttfamily \label{class_c_node_ae40c7049927e1d53e48bbfa5e8d47d1d} 
\textbf{ Network} Connected\+Through\+Network (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

Get network the peer connected through.

Returns Network\+::\+NET\+\_\+\+ONION for {\itshape inbound} onion connections, and \doxyref{CNet\+Addr\+::\+Get\+Net\+Class()}{p.}{class_c_net_addr_a62dae3ebdb62dbeed260ee47f73c6c94} otherwise. The latter cannot be used directly because it doesn\textquotesingle{}t detect the former, and it\textquotesingle{}s not the responsibility of the \doxyref{CNet\+Addr}{p.}{class_c_net_addr} class to know the actual network a peer is connected through.

\begin{DoxyReturn}{Returns}
network the peer connected through. 
\end{DoxyReturn}
\index{CNode@{CNode}!ConnectionTypeAsString@{ConnectionTypeAsString}}
\index{ConnectionTypeAsString@{ConnectionTypeAsString}!CNode@{CNode}}
\doxysubsubsection{ConnectionTypeAsString()}
{\footnotesize\ttfamily \label{class_c_node_a1366f7f0a8a51ed138660cae429e1aa1} 
std\+::string Connection\+Type\+As\+String (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!CopyStats@{CopyStats}}
\index{CopyStats@{CopyStats}!CNode@{CNode}}
\doxysubsubsection{CopyStats()}
{\footnotesize\ttfamily \label{class_c_node_a01c28cd4f3ce2dcbe05502a1225b3900} 
void Copy\+Stats (\begin{DoxyParamCaption}\item[{\textbf{ CNode\+Stats} \&}]{stats}{}\end{DoxyParamCaption})}

\index{CNode@{CNode}!DisconnectMsg@{DisconnectMsg}}
\index{DisconnectMsg@{DisconnectMsg}!CNode@{CNode}}
\doxysubsubsection{DisconnectMsg()}
{\footnotesize\ttfamily \label{class_c_node_a841208bbd46fc2f0667b580aa224b99e} 
std\+::string Disconnect\+Msg (\begin{DoxyParamCaption}\item[{bool}]{log\+\_\+ip}{}\end{DoxyParamCaption}) const}

Helper function to log disconnects.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em log\+\_\+ip} & whether to include the IP address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
"{}disconnecting peer=..."{} and optionally "{}peeraddr=..."{} 
\end{DoxyReturn}
\index{CNode@{CNode}!ExpectServicesFromConn@{ExpectServicesFromConn}}
\index{ExpectServicesFromConn@{ExpectServicesFromConn}!CNode@{CNode}}
\doxysubsubsection{ExpectServicesFromConn()}
{\footnotesize\ttfamily \label{class_c_node_a15449ecdc579f3a27c591daff6773d5e} 
bool Expect\+Services\+From\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!GetAddrLocal@{GetAddrLocal}}
\index{GetAddrLocal@{GetAddrLocal}!CNode@{CNode}}
\doxysubsubsection{GetAddrLocal()}
{\footnotesize\ttfamily \label{class_c_node_a64184b5e01ec4dc87752f324d758870c} 
\textbf{ CService} Get\+Addr\+Local (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}

\index{CNode@{CNode}!GetCommonVersion@{GetCommonVersion}}
\index{GetCommonVersion@{GetCommonVersion}!CNode@{CNode}}
\doxysubsubsection{GetCommonVersion()}
{\footnotesize\ttfamily \label{class_c_node_af039a299f31c62d63996fd5907c3f953} 
int Get\+Common\+Version (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!GetId@{GetId}}
\index{GetId@{GetId}!CNode@{CNode}}
\doxysubsubsection{GetId()}
{\footnotesize\ttfamily \label{class_c_node_a36083c7e95cc6009bd88d120149ec42d} 
\textbf{ Node\+Id} Get\+Id (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!GetLocalNonce@{GetLocalNonce}}
\index{GetLocalNonce@{GetLocalNonce}!CNode@{CNode}}
\doxysubsubsection{GetLocalNonce()}
{\footnotesize\ttfamily \label{class_c_node_a814aea882a96b7a7422c2170bee869a1} 
uint64\+\_\+t Get\+Local\+Nonce (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!GetRefCount@{GetRefCount}}
\index{GetRefCount@{GetRefCount}!CNode@{CNode}}
\doxysubsubsection{GetRefCount()}
{\footnotesize\ttfamily \label{class_c_node_a41d0b86cdb2c486d34fd9e179fb07cf8} 
int Get\+Ref\+Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CNode@{CNode}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \label{class_c_node_af36fccc4e637e8f6e6e00bb11206159a} 
uint64\+\_\+t n\+Recv\+Bytes GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+v\+Recv}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CNode@{CNode}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \label{class_c_node_a485d1eb1cf0989895a7fa3b53f97197e} 
std\+::deque$<$ \textbf{ CSerialized\+Net\+Msg} $>$ v\+Send\+Msg GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+v\+Send}}]{}{}\end{DoxyParamCaption})}

Messages still to be fed to m\+\_\+transport-\/$>$Set\+Message\+To\+Send. \index{CNode@{CNode}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CNode@{CNode}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \label{class_c_node_a70fcafa6108c0e319b5b32d460678147} 
uint64\+\_\+t n\+Send\+Bytes GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+v\+Send}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Total number of bytes sent on the wire to this peer. \index{CNode@{CNode}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CNode@{CNode}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \label{class_c_node_a1a63e3338b0c8b51a4598ec838bba6ce} 
size\+\_\+t m\+\_\+send\+\_\+memusage GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ cs\+\_\+v\+Send}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sum of Get\+Memory\+Usage of all v\+Send\+Msg entries. \index{CNode@{CNode}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CNode@{CNode}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \label{class_c_node_abd234fc7b24cc9ed6facfb3639c6099f} 
std\+::shared\+\_\+ptr$<$ \textbf{ Sock} $>$ m\+\_\+sock GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ m\+\_\+sock\+\_\+mutex}}]{}{}\end{DoxyParamCaption})}

Socket used for communication with the node. May not own a \doxyref{Sock}{p.}{class_sock} object (after {\ttfamily \doxyref{Close\+Socket\+Disconnect()}{p.}{class_c_node_a153e70aa7b79aa27f6739044fce4a55a}} or during tests). {\ttfamily shared\+\_\+ptr} (instead of {\ttfamily unique\+\_\+ptr}) is used to avoid premature close of the underlying file descriptor by one thread while another thread is poll(2)-\/ing it for activity. \begin{DoxySeeAlso}{See also}
{\texttt{https\+://github.\+com/bitcoin/bitcoin/issues/21744}} \doxyref{for}{p.}{arith__uint256__tests_8cpp_aec8e239ec13a0a2253be548812b40c53} details. 
\end{DoxySeeAlso}
\index{CNode@{CNode}!GUARDED\_BY@{GUARDED\_BY}}
\index{GUARDED\_BY@{GUARDED\_BY}!CNode@{CNode}}
\doxysubsubsection{GUARDED\_BY()\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \label{class_c_node_a9a2db8681096e8fef5be88218dbb0db8} 
std\+::string clean\+Sub\+Ver GUARDED\+\_\+\+BY (\begin{DoxyParamCaption}\item[{\textbf{ m\+\_\+subver\+\_\+mutex}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

clean\+Sub\+Ver is a sanitized string of the user agent byte array we read from the wire. This cleaned string can safely be logged or displayed. \index{CNode@{CNode}!HasPermission@{HasPermission}}
\index{HasPermission@{HasPermission}!CNode@{CNode}}
\doxysubsubsection{HasPermission()}
{\footnotesize\ttfamily \label{class_c_node_ad093ef142d44eddf28162f2aa26d56c2} 
bool Has\+Permission (\begin{DoxyParamCaption}\item[{\textbf{ Net\+Permission\+Flags}}]{permission}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsAddrFetchConn@{IsAddrFetchConn}}
\index{IsAddrFetchConn@{IsAddrFetchConn}!CNode@{CNode}}
\doxysubsubsection{IsAddrFetchConn()}
{\footnotesize\ttfamily \label{class_c_node_a6f655d1fa96f652649182e914c75c7e3} 
bool Is\+Addr\+Fetch\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsBlockOnlyConn@{IsBlockOnlyConn}}
\index{IsBlockOnlyConn@{IsBlockOnlyConn}!CNode@{CNode}}
\doxysubsubsection{IsBlockOnlyConn()}
{\footnotesize\ttfamily \label{class_c_node_a610ec1d1f02cc4bb029acc3cf47b9f4c} 
bool Is\+Block\+Only\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsConnectedThroughPrivacyNet@{IsConnectedThroughPrivacyNet}}
\index{IsConnectedThroughPrivacyNet@{IsConnectedThroughPrivacyNet}!CNode@{CNode}}
\doxysubsubsection{IsConnectedThroughPrivacyNet()}
{\footnotesize\ttfamily \label{class_c_node_ae1d3bb321ae2ddf2f6edf3b3bad78807} 
bool Is\+Connected\+Through\+Privacy\+Net (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [nodiscard]}}

Whether this peer connected through a privacy network. \index{CNode@{CNode}!IsFeelerConn@{IsFeelerConn}}
\index{IsFeelerConn@{IsFeelerConn}!CNode@{CNode}}
\doxysubsubsection{IsFeelerConn()}
{\footnotesize\ttfamily \label{class_c_node_aa2d55484d665a0e541f5dbadd40c8854} 
bool Is\+Feeler\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsFullOutboundConn@{IsFullOutboundConn}}
\index{IsFullOutboundConn@{IsFullOutboundConn}!CNode@{CNode}}
\doxysubsubsection{IsFullOutboundConn()}
{\footnotesize\ttfamily \label{class_c_node_a9d84c3968942baa4d097b52ebcaf6ad2} 
bool Is\+Full\+Outbound\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsInboundConn@{IsInboundConn}}
\index{IsInboundConn@{IsInboundConn}!CNode@{CNode}}
\doxysubsubsection{IsInboundConn()}
{\footnotesize\ttfamily \label{class_c_node_a878e09eabda286e4cabf6ffc0fb24ba3} 
bool Is\+Inbound\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsManualConn@{IsManualConn}}
\index{IsManualConn@{IsManualConn}!CNode@{CNode}}
\doxysubsubsection{IsManualConn()}
{\footnotesize\ttfamily \label{class_c_node_a8f1fe2c0472c960adee75891ac0bf9cd} 
bool Is\+Manual\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsManualOrFullOutboundConn@{IsManualOrFullOutboundConn}}
\index{IsManualOrFullOutboundConn@{IsManualOrFullOutboundConn}!CNode@{CNode}}
\doxysubsubsection{IsManualOrFullOutboundConn()}
{\footnotesize\ttfamily \label{class_c_node_a98a0b36fd4c9400a9572acad44ceb1ef} 
bool Is\+Manual\+Or\+Full\+Outbound\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!IsOutboundOrBlockRelayConn@{IsOutboundOrBlockRelayConn}}
\index{IsOutboundOrBlockRelayConn@{IsOutboundOrBlockRelayConn}!CNode@{CNode}}
\doxysubsubsection{IsOutboundOrBlockRelayConn()}
{\footnotesize\ttfamily \label{class_c_node_a9a98751838e41cb1a4a8b1919ef4a167} 
bool Is\+Outbound\+Or\+Block\+Relay\+Conn (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!LogIP@{LogIP}}
\index{LogIP@{LogIP}!CNode@{CNode}}
\doxysubsubsection{LogIP()}
{\footnotesize\ttfamily \label{class_c_node_a817d9d190e2af5b0bb7c5ed196cdc318} 
std\+::string Log\+IP (\begin{DoxyParamCaption}\item[{bool}]{log\+\_\+ip}{}\end{DoxyParamCaption}) const}

Helper function to optionally log the IP address.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em log\+\_\+ip} & whether to include the IP address \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
"{} peeraddr=..."{} or "{}"{} 
\end{DoxyReturn}
\index{CNode@{CNode}!MarkReceivedMsgsForProcessing@{MarkReceivedMsgsForProcessing}}
\index{MarkReceivedMsgsForProcessing@{MarkReceivedMsgsForProcessing}!CNode@{CNode}}
\doxysubsubsection{MarkReceivedMsgsForProcessing()}
{\footnotesize\ttfamily \label{class_c_node_a598d70dab026524d8de9cf310e844690} 
void Mark\+Received\+Msgs\+For\+Processing (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Move all messages from the received queue to the processing queue. \index{CNode@{CNode}!operator=@{operator=}}
\index{operator=@{operator=}!CNode@{CNode}}
\doxysubsubsection{operator=()}
{\footnotesize\ttfamily \label{class_c_node_a2e4c3640d515e56ef37a6add24f7eead} 
\textbf{ CNode} \& operator= (\begin{DoxyParamCaption}\item[{const \textbf{ CNode} \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

\index{CNode@{CNode}!PollMessage@{PollMessage}}
\index{PollMessage@{PollMessage}!CNode@{CNode}}
\doxysubsubsection{PollMessage()}
{\footnotesize\ttfamily \label{class_c_node_a80e5ed1e109857aff68da9be77297dc3} 
std\+::optional$<$ std\+::pair$<$ \textbf{ CNet\+Message}, bool $>$ $>$ Poll\+Message (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

Poll the next message from the processing queue of this connection.

Returns std\+::nullopt if the processing queue is empty, or a pair consisting of the message and a bool that indicates if the processing queue has more entries. \index{CNode@{CNode}!PongReceived@{PongReceived}}
\index{PongReceived@{PongReceived}!CNode@{CNode}}
\doxysubsubsection{PongReceived()}
{\footnotesize\ttfamily \label{class_c_node_ac11492e59f73bdbea46ae9fde658367b} 
void Pong\+Received (\begin{DoxyParamCaption}\item[{std\+::chrono\+::microseconds}]{ping\+\_\+time}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

A ping-\/pong round trip has completed successfully. Update latest and minimum ping times. \index{CNode@{CNode}!ReceiveMsgBytes@{ReceiveMsgBytes}}
\index{ReceiveMsgBytes@{ReceiveMsgBytes}!CNode@{CNode}}
\doxysubsubsection{ReceiveMsgBytes()}
{\footnotesize\ttfamily \label{class_c_node_ace1ebd9ec06ddff8becbf56329274943} 
bool Receive\+Msg\+Bytes (\begin{DoxyParamCaption}\item[{std\+::span$<$ const uint8\+\_\+t $>$}]{msg\+\_\+bytes}{, }\item[{bool \&}]{complete}{}\end{DoxyParamCaption})}

Receive bytes from the buffer and deserialize them into messages.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{in}}  & {\em msg\+\_\+bytes} & The raw data \\
\hline
\mbox{\texttt{out}}  & {\em complete} & Set True if at least one message has been deserialized and is ready to be processed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the peer should stay connected, False if the peer should be disconnected from. 
\end{DoxyReturn}
\index{CNode@{CNode}!Release@{Release}}
\index{Release@{Release}!CNode@{CNode}}
\doxysubsubsection{Release()}
{\footnotesize\ttfamily \label{class_c_node_a94c93747c8daa99d65c2a04c6be0748c} 
void Release (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\index{CNode@{CNode}!SetAddrLocal@{SetAddrLocal}}
\index{SetAddrLocal@{SetAddrLocal}!CNode@{CNode}}
\doxysubsubsection{SetAddrLocal()}
{\footnotesize\ttfamily \label{class_c_node_a55cf77cf1c90bc01e759c8599632f215} 
void Set\+Addr\+Local (\begin{DoxyParamCaption}\item[{const \textbf{ CService} \&}]{addr\+Local\+In}{}\end{DoxyParamCaption})}



May not be called more than once. 

\index{CNode@{CNode}!SetCommonVersion@{SetCommonVersion}}
\index{SetCommonVersion@{SetCommonVersion}!CNode@{CNode}}
\doxysubsubsection{SetCommonVersion()}
{\footnotesize\ttfamily \label{class_c_node_ad0f5b49c773f2b174cbe51841697ec8d} 
void Set\+Common\+Version (\begin{DoxyParamCaption}\item[{int}]{greatest\+\_\+common\+\_\+version}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\label{doc-variable-members}
\doxysubsection{Field Documentation}
\index{CNode@{CNode}!"!cs\_vRecv@{"!cs\_vRecv}}
\index{"!cs\_vRecv@{"!cs\_vRecv}!CNode@{CNode}}
\doxysubsubsection{"!cs\_vRecv}
{\footnotesize\ttfamily \label{class_c_node_a64f7b0172378948002cf1dc1b1bd415f} 
void !\textbf{ cs\+\_\+v\+Recv}}

\index{CNode@{CNode}!"!cs\_vSend@{"!cs\_vSend}}
\index{"!cs\_vSend@{"!cs\_vSend}!CNode@{CNode}}
\doxysubsubsection{"!cs\_vSend}
{\footnotesize\ttfamily \label{class_c_node_a5255fcec9a89d0742e5a88f9065d769e} 
void !\textbf{ cs\+\_\+v\+Send}}

\index{CNode@{CNode}!"!m\_addr\_local\_mutex@{"!m\_addr\_local\_mutex}}
\index{"!m\_addr\_local\_mutex@{"!m\_addr\_local\_mutex}!CNode@{CNode}}
\doxysubsubsection{"!m\_addr\_local\_mutex}
{\footnotesize\ttfamily \label{class_c_node_a4efcde5fa11d813ea63d84d59053c288} 
void !m\+\_\+addr\+\_\+local\+\_\+mutex}

\index{CNode@{CNode}!addr@{addr}}
\index{addr@{addr}!CNode@{CNode}}
\doxysubsubsection{addr}
{\footnotesize\ttfamily \label{class_c_node_afefbbc75aa05390712188a0f1e13d6f5} 
const \textbf{ CAddress} addr}

\index{CNode@{CNode}!addrBind@{addrBind}}
\index{addrBind@{addrBind}!CNode@{CNode}}
\doxysubsubsection{addrBind}
{\footnotesize\ttfamily \label{class_c_node_a5f77af7902a2183c054bacacefb972ff} 
const \textbf{ CService} addr\+Bind}

\index{CNode@{CNode}!cs\_vRecv@{cs\_vRecv}}
\index{cs\_vRecv@{cs\_vRecv}!CNode@{CNode}}
\doxysubsubsection{cs\_vRecv}
{\footnotesize\ttfamily \label{class_c_node_aa0b59b953307fa96baa87330eb2afb25} 
\textbf{ Mutex} cs\+\_\+v\+Recv}

\index{CNode@{CNode}!cs\_vSend@{cs\_vSend}}
\index{cs\_vSend@{cs\_vSend}!CNode@{CNode}}
\doxysubsubsection{cs\_vSend}
{\footnotesize\ttfamily \label{class_c_node_a69d1532eaa730d4b401baf7639360c22} 
\textbf{ Mutex} cs\+\_\+v\+Send}

\index{CNode@{CNode}!fDisconnect@{fDisconnect}}
\index{fDisconnect@{fDisconnect}!CNode@{CNode}}
\doxysubsubsection{fDisconnect}
{\footnotesize\ttfamily \label{class_c_node_ac8452172979ad5823ab9e1372960789d} 
std\+::atomic\+\_\+bool f\+Disconnect \{false\}}

\index{CNode@{CNode}!fPauseRecv@{fPauseRecv}}
\index{fPauseRecv@{fPauseRecv}!CNode@{CNode}}
\doxysubsubsection{fPauseRecv}
{\footnotesize\ttfamily \label{class_c_node_a92dae24efb262a13829a4e52083a2e15} 
std\+::atomic\+\_\+bool f\+Pause\+Recv \{false\}}

\index{CNode@{CNode}!fPauseSend@{fPauseSend}}
\index{fPauseSend@{fPauseSend}!CNode@{CNode}}
\doxysubsubsection{fPauseSend}
{\footnotesize\ttfamily \label{class_c_node_a0d7c1f3172d1da877e15031b02b54133} 
std\+::atomic\+\_\+bool f\+Pause\+Send \{false\}}

\index{CNode@{CNode}!fSuccessfullyConnected@{fSuccessfullyConnected}}
\index{fSuccessfullyConnected@{fSuccessfullyConnected}!CNode@{CNode}}
\doxysubsubsection{fSuccessfullyConnected}
{\footnotesize\ttfamily \label{class_c_node_a304b58083dbf991d0f448962530c2e94} 
std\+::atomic\+\_\+bool f\+Successfully\+Connected \{false\}}

f\+Successfully\+Connected is set to true on receiving VERACK from the peer. \index{CNode@{CNode}!grantOutbound@{grantOutbound}}
\index{grantOutbound@{grantOutbound}!CNode@{CNode}}
\doxysubsubsection{grantOutbound}
{\footnotesize\ttfamily \label{class_c_node_aae2b54ad1f1bde2e9c606b3cc4ca0dea} 
\textbf{ Counting\+Semaphore\+Grant} grant\+Outbound}

\index{CNode@{CNode}!m\_addr\_name@{m\_addr\_name}}
\index{m\_addr\_name@{m\_addr\_name}!CNode@{CNode}}
\doxysubsubsection{m\_addr\_name}
{\footnotesize\ttfamily \label{class_c_node_a2d49df6ccf2e5770e389f89b13f4432e} 
const std\+::string m\+\_\+addr\+\_\+name}

\index{CNode@{CNode}!m\_bip152\_highbandwidth\_from@{m\_bip152\_highbandwidth\_from}}
\index{m\_bip152\_highbandwidth\_from@{m\_bip152\_highbandwidth\_from}!CNode@{CNode}}
\doxysubsubsection{m\_bip152\_highbandwidth\_from}
{\footnotesize\ttfamily \label{class_c_node_a6fae3240adf466571f06a703e4de7a6c} 
std\+::atomic$<$bool$>$ m\+\_\+bip152\+\_\+highbandwidth\+\_\+from \{false\}}

\index{CNode@{CNode}!m\_bip152\_highbandwidth\_to@{m\_bip152\_highbandwidth\_to}}
\index{m\_bip152\_highbandwidth\_to@{m\_bip152\_highbandwidth\_to}!CNode@{CNode}}
\doxysubsubsection{m\_bip152\_highbandwidth\_to}
{\footnotesize\ttfamily \label{class_c_node_ad565e2a61dff2ebdc4a420bb5b972ac7} 
std\+::atomic$<$bool$>$ m\+\_\+bip152\+\_\+highbandwidth\+\_\+to \{false\}}

\index{CNode@{CNode}!m\_bloom\_filter\_loaded@{m\_bloom\_filter\_loaded}}
\index{m\_bloom\_filter\_loaded@{m\_bloom\_filter\_loaded}!CNode@{CNode}}
\doxysubsubsection{m\_bloom\_filter\_loaded}
{\footnotesize\ttfamily \label{class_c_node_a8e0916692da2c967eb74bc3b7e3e8574} 
std\+::atomic\+\_\+bool m\+\_\+bloom\+\_\+filter\+\_\+loaded \{false\}}

Whether this peer has loaded a bloom filter. Used only in inbound eviction logic. \index{CNode@{CNode}!m\_conn\_type@{m\_conn\_type}}
\index{m\_conn\_type@{m\_conn\_type}!CNode@{CNode}}
\doxysubsubsection{m\_conn\_type}
{\footnotesize\ttfamily \label{class_c_node_a45f173f9b6469252ee5cc394970cf822} 
const \textbf{ Connection\+Type} m\+\_\+conn\+\_\+type}

\index{CNode@{CNode}!m\_connected@{m\_connected}}
\index{m\_connected@{m\_connected}!CNode@{CNode}}
\doxysubsubsection{m\_connected}
{\footnotesize\ttfamily \label{class_c_node_a9d5ec6f76c89a5fb4891fa5a22aa47b2} 
const std\+::chrono\+::seconds m\+\_\+connected}



Unix epoch time at peer connection. 

\index{CNode@{CNode}!m\_dest@{m\_dest}}
\index{m\_dest@{m\_dest}!CNode@{CNode}}
\doxysubsubsection{m\_dest}
{\footnotesize\ttfamily \label{class_c_node_a76c8df50c219f35652ed1114bb6f2957} 
const std\+::string m\+\_\+dest}

The psz\+Dest argument provided to Connect\+Node(). Only used for reconnections. \index{CNode@{CNode}!m\_has\_all\_wanted\_services@{m\_has\_all\_wanted\_services}}
\index{m\_has\_all\_wanted\_services@{m\_has\_all\_wanted\_services}!CNode@{CNode}}
\doxysubsubsection{m\_has\_all\_wanted\_services}
{\footnotesize\ttfamily \label{class_c_node_ab956a8ceda2c6369f2c5d4cfbdef63b3} 
std\+::atomic\+\_\+bool m\+\_\+has\+\_\+all\+\_\+wanted\+\_\+services \{false\}}

Whether this peer provides all services that we want. Used for eviction decisions \index{CNode@{CNode}!m\_inbound\_onion@{m\_inbound\_onion}}
\index{m\_inbound\_onion@{m\_inbound\_onion}!CNode@{CNode}}
\doxysubsubsection{m\_inbound\_onion}
{\footnotesize\ttfamily \label{class_c_node_ac29adabcdf5ca57c96df534b496f04fe} 
const bool m\+\_\+inbound\+\_\+onion}



Whether this peer is an inbound onion, i.\+e. connected via our Tor onion service. 

\index{CNode@{CNode}!m\_last\_block\_time@{m\_last\_block\_time}}
\index{m\_last\_block\_time@{m\_last\_block\_time}!CNode@{CNode}}
\doxysubsubsection{m\_last\_block\_time}
{\footnotesize\ttfamily \label{class_c_node_a187bf49ad10db6ecf4917f24a17048b6} 
std\+::atomic$<$std\+::chrono\+::seconds$>$ m\+\_\+last\+\_\+block\+\_\+time \{0s\}}

UNIX epoch time of the last block received from this peer that we had not yet seen (e.\+g. not already received from another peer), that passed preliminary validity checks and was saved to disk, even if we don\textquotesingle{}t connect the block or it eventually fails connection. Used as an inbound peer eviction criterium in CConnman\+::\+Attempt\+To\+Evict\+Connection. \index{CNode@{CNode}!m\_last\_ping\_time@{m\_last\_ping\_time}}
\index{m\_last\_ping\_time@{m\_last\_ping\_time}!CNode@{CNode}}
\doxysubsubsection{m\_last\_ping\_time}
{\footnotesize\ttfamily \label{class_c_node_a65c6efc0805b2e3794a185ae9a42dd5a} 
std\+::atomic$<$std\+::chrono\+::microseconds$>$ m\+\_\+last\+\_\+ping\+\_\+time \{0us\}}

Last measured round-\/trip time. Used only for RPC/\+GUI stats/debugging. \index{CNode@{CNode}!m\_last\_recv@{m\_last\_recv}}
\index{m\_last\_recv@{m\_last\_recv}!CNode@{CNode}}
\doxysubsubsection{m\_last\_recv}
{\footnotesize\ttfamily \label{class_c_node_a974dbebe4adc9cc8ae4b120f97ffa354} 
std\+::atomic$<$std\+::chrono\+::seconds$>$ m\+\_\+last\+\_\+recv \{0s\}}

\index{CNode@{CNode}!m\_last\_send@{m\_last\_send}}
\index{m\_last\_send@{m\_last\_send}!CNode@{CNode}}
\doxysubsubsection{m\_last\_send}
{\footnotesize\ttfamily \label{class_c_node_a978b3a4584d4ac282238c469ca5b4317} 
std\+::atomic$<$std\+::chrono\+::seconds$>$ m\+\_\+last\+\_\+send \{0s\}}

\index{CNode@{CNode}!m\_last\_tx\_time@{m\_last\_tx\_time}}
\index{m\_last\_tx\_time@{m\_last\_tx\_time}!CNode@{CNode}}
\doxysubsubsection{m\_last\_tx\_time}
{\footnotesize\ttfamily \label{class_c_node_a11b1f23357476880220efd85fe7918be} 
std\+::atomic$<$std\+::chrono\+::seconds$>$ m\+\_\+last\+\_\+tx\+\_\+time \{0s\}}

UNIX epoch time of the last transaction received from this peer that we had not yet seen (e.\+g. not already received from another peer) and that was accepted into our mempool. Used as an inbound peer eviction criterium in CConnman\+::\+Attempt\+To\+Evict\+Connection. \index{CNode@{CNode}!m\_min\_ping\_time@{m\_min\_ping\_time}}
\index{m\_min\_ping\_time@{m\_min\_ping\_time}!CNode@{CNode}}
\doxysubsubsection{m\_min\_ping\_time}
{\footnotesize\ttfamily \label{class_c_node_a95209c4a02d41923b71956e22d304ebe} 
std\+::atomic$<$std\+::chrono\+::microseconds$>$ m\+\_\+min\+\_\+ping\+\_\+time \{std\+::chrono\+::microseconds\+::max()\}}

Lowest measured round-\/trip time. Used as an inbound peer eviction criterium in CConnman\+::\+Attempt\+To\+Evict\+Connection. \index{CNode@{CNode}!m\_network\_key@{m\_network\_key}}
\index{m\_network\_key@{m\_network\_key}!CNode@{CNode}}
\doxysubsubsection{m\_network\_key}
{\footnotesize\ttfamily \label{class_c_node_a1b2452796767909e463719c518ad6fe0} 
const uint64\+\_\+t m\+\_\+network\+\_\+key}

\doxyref{Network}{p.}{netaddress_8h_acc9a38c714afe79b5035cb36f560dac3} key used to prevent fingerprinting our node across networks. Influenced by the network and the bind address (+ bind port for inbounds) \index{CNode@{CNode}!m\_permission\_flags@{m\_permission\_flags}}
\index{m\_permission\_flags@{m\_permission\_flags}!CNode@{CNode}}
\doxysubsubsection{m\_permission\_flags}
{\footnotesize\ttfamily \label{class_c_node_a5e93871fb547b234ab35a0572c7a4fc9} 
const \textbf{ Net\+Permission\+Flags} m\+\_\+permission\+\_\+flags}

\index{CNode@{CNode}!m\_prefer\_evict@{m\_prefer\_evict}}
\index{m\_prefer\_evict@{m\_prefer\_evict}!CNode@{CNode}}
\doxysubsubsection{m\_prefer\_evict}
{\footnotesize\ttfamily \label{class_c_node_a601aead65fd4614dcb74cf7107f1a3c3} 
const bool m\+\_\+prefer\+\_\+evict \{false\}}

\index{CNode@{CNode}!m\_relays\_txs@{m\_relays\_txs}}
\index{m\_relays\_txs@{m\_relays\_txs}!CNode@{CNode}}
\doxysubsubsection{m\_relays\_txs}
{\footnotesize\ttfamily \label{class_c_node_acf03c8775bb1dd2139126ccd062ef9f3} 
std\+::atomic\+\_\+bool m\+\_\+relays\+\_\+txs \{false\}}

Whether we should relay transactions to this peer. This only changes from false to true. It will never change back to false. \index{CNode@{CNode}!m\_sock\_mutex@{m\_sock\_mutex}}
\index{m\_sock\_mutex@{m\_sock\_mutex}!CNode@{CNode}}
\doxysubsubsection{m\_sock\_mutex}
{\footnotesize\ttfamily \label{class_c_node_a04bdcc4f818bd98ec6fe24e8948978a8} 
\textbf{ Mutex} m\+\_\+sock\+\_\+mutex}

\index{CNode@{CNode}!m\_subver\_mutex@{m\_subver\_mutex}}
\index{m\_subver\_mutex@{m\_subver\_mutex}!CNode@{CNode}}
\doxysubsubsection{m\_subver\_mutex}
{\footnotesize\ttfamily \label{class_c_node_ac3049eeaf924a9662c552defeb5cceaf} 
\textbf{ Mutex} m\+\_\+subver\+\_\+mutex}

\index{CNode@{CNode}!m\_transport@{m\_transport}}
\index{m\_transport@{m\_transport}!CNode@{CNode}}
\doxysubsubsection{m\_transport}
{\footnotesize\ttfamily \label{class_c_node_a580c9459c72d5701458920bdeee5859d} 
const std\+::unique\+\_\+ptr$<$\textbf{ Transport}$>$ m\+\_\+transport}

\doxyref{Transport}{p.}{class_transport} serializer/deserializer. The receive side functions are only called under cs\+\_\+v\+Recv, while the sending side functions are only called under cs\+\_\+v\+Send. \index{CNode@{CNode}!nKeyedNetGroup@{nKeyedNetGroup}}
\index{nKeyedNetGroup@{nKeyedNetGroup}!CNode@{CNode}}
\doxysubsubsection{nKeyedNetGroup}
{\footnotesize\ttfamily \label{class_c_node_a26c11dc3970cc15a0eacd1147f0b6e6d} 
const uint64\+\_\+t n\+Keyed\+Net\+Group}

\index{CNode@{CNode}!nRefCount@{nRefCount}}
\index{nRefCount@{nRefCount}!CNode@{CNode}}
\doxysubsubsection{nRefCount}
{\footnotesize\ttfamily \label{class_c_node_afc69b43a7e39a337c1df3f4dac2da7d6} 
std\+::atomic$<$int$>$ n\+Ref\+Count \{0\}}

\index{CNode@{CNode}!nVersion@{nVersion}}
\index{nVersion@{nVersion}!CNode@{CNode}}
\doxysubsubsection{nVersion}
{\footnotesize\ttfamily \label{class_c_node_a52a52a9a2152f8aa8b99bd07a6cf819d} 
std\+::atomic$<$int$>$ n\+Version \{0\}}



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\textbf{ net.\+h}\item 
src/\textbf{ net.\+cpp}\end{DoxyCompactItemize}
