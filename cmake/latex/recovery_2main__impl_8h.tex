\doxysection{src/secp256k1/src/modules/recovery/main\+\_\+impl.h File Reference}
\label{recovery_2main__impl_8h}\index{src/secp256k1/src/modules/recovery/main\_impl.h@{src/secp256k1/src/modules/recovery/main\_impl.h}}
{\ttfamily \#include "{}../../../include/secp256k1\+\_\+recovery.\+h"{}}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig, const unsigned char $\ast$input64, int recid)
\item 
int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$output64, int $\ast$recid, const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig)
\item 
int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+ecdsa\+\_\+signature} $\ast$sig, const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sigin)
\item 
int \textbf{ secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$signature, const unsigned char $\ast$msghash32, const unsigned char $\ast$seckey, \textbf{ secp256k1\+\_\+nonce\+\_\+function} noncefp, const void $\ast$noncedata)
\item 
int \textbf{ secp256k1\+\_\+ecdsa\+\_\+recover} (const \textbf{ secp256k1\+\_\+context} $\ast$ctx, \textbf{ secp256k1\+\_\+pubkey} $\ast$pubkey, const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$signature, const unsigned char $\ast$msghash32)
\end{DoxyCompactItemize}


\label{doc-func-members}
\doxysubsection{Function Documentation}
\index{main\_impl.h@{main\_impl.h}!secp256k1\_ecdsa\_recover@{secp256k1\_ecdsa\_recover}}
\index{secp256k1\_ecdsa\_recover@{secp256k1\_ecdsa\_recover}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recover()}
{\footnotesize\ttfamily \label{recovery_2main__impl_8h_aa87f5523141f798e963300ccd975141d} 
int secp256k1\+\_\+ecdsa\+\_\+recover (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+pubkey} $\ast$}]{pubkey}{, }\item[{const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{, }\item[{const unsigned char $\ast$}]{msghash32}{}\end{DoxyParamCaption})}

Recover an ECDSA public key from a signature.

Successful public key recovery guarantees that the signature, after normalization, passes {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+verify}{p.}{secp256k1_8h_a7dd6acb7ef7100a6aebff91ecb7ede30}}. Thus, explicit verification is not necessary.

However, a recoverable signature that successfully passes {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+recover}{p.}{secp256k1__recovery_8h_af9f2082776bf8ebdb4c38161a211a02b}}, when converted to a non-\/recoverable signature (using {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}{p.}{secp256k1__recovery_8h_ad7a20c9f7ccd9fc6d75a19a3b4195aa5}}), is not guaranteed to be normalized and thus not guaranteed to pass {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+verify}{p.}{secp256k1_8h_a7dd6acb7ef7100a6aebff91ecb7ede30}}. If a normalized signature is required, call {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+signature\+\_\+normalize}{p.}{secp256k1_8h_a93ec36a19229f08acc5ff1ca613ab3a1}} after {\ttfamily \doxyref{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}{p.}{secp256k1__recovery_8h_ad7a20c9f7ccd9fc6d75a19a3b4195aa5}}.

Returns\+: 1\+: public key successfully recovered 0\+: otherwise. Args\+: ctx\+: pointer to a context object. Out\+: pubkey\+: pointer to the recovered public key. In\+: sig\+: pointer to initialized signature that supports pubkey recovery. msghash32\+: the 32-\/byte message hash assumed to be signed. \index{main\_impl.h@{main\_impl.h}!secp256k1\_ecdsa\_recoverable\_signature\_convert@{secp256k1\_ecdsa\_recoverable\_signature\_convert}}
\index{secp256k1\_ecdsa\_recoverable\_signature\_convert@{secp256k1\_ecdsa\_recoverable\_signature\_convert}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature\_convert()}
{\footnotesize\ttfamily \label{recovery_2main__impl_8h_a16ddfc800140d761bc783e571c34548c} 
int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+ecdsa\+\_\+signature} $\ast$}]{sig}{, }\item[{const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sigin}{}\end{DoxyParamCaption})}

Convert a recoverable signature into a normal signature.

Returns\+: 1 Args\+: ctx\+: pointer to a context object. Out\+: sig\+: pointer to a normal signature. In\+: sigin\+: pointer to a recoverable signature. \index{main\_impl.h@{main\_impl.h}!secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact}}
\index{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature\_parse\_compact()}
{\footnotesize\ttfamily \label{recovery_2main__impl_8h_a37101568f72e98d7b29de6c6a825a289} 
int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{, }\item[{const unsigned char $\ast$}]{input64}{, }\item[{int}]{recid}{}\end{DoxyParamCaption})}

Parse a compact ECDSA signature (64 bytes + recovery id).

Returns\+: 1 when the signature could be parsed, 0 otherwise Args\+: ctx\+: pointer to a context object Out\+: sig\+: pointer to a signature object In\+: input64\+: pointer to a 64-\/byte compact signature recid\+: the recovery id (0, 1, 2 or 3) \index{main\_impl.h@{main\_impl.h}!secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact}}
\index{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact@{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_ecdsa\_recoverable\_signature\_serialize\_compact()}
{\footnotesize\ttfamily \label{recovery_2main__impl_8h_ac122392fa6ff6264a7a110875af164b0} 
int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{unsigned char $\ast$}]{output64}{, }\item[{int $\ast$}]{recid}{, }\item[{const \textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{}\end{DoxyParamCaption})}

Serialize an ECDSA signature in compact format (64 bytes + recovery id).

Returns\+: 1 Args\+: ctx\+: pointer to a context object. Out\+: output64\+: pointer to a 64-\/byte array of the compact signature. recid\+: pointer to an integer to hold the recovery id. In\+: sig\+: pointer to an initialized signature object. \index{main\_impl.h@{main\_impl.h}!secp256k1\_ecdsa\_sign\_recoverable@{secp256k1\_ecdsa\_sign\_recoverable}}
\index{secp256k1\_ecdsa\_sign\_recoverable@{secp256k1\_ecdsa\_sign\_recoverable}!main\_impl.h@{main\_impl.h}}
\doxysubsubsection{secp256k1\_ecdsa\_sign\_recoverable()}
{\footnotesize\ttfamily \label{recovery_2main__impl_8h_a8c69d8d94dcf300ec40684a12f77092b} 
int secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable (\begin{DoxyParamCaption}\item[{const \textbf{ secp256k1\+\_\+context} $\ast$}]{ctx}{, }\item[{\textbf{ secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}{, }\item[{const unsigned char $\ast$}]{msghash32}{, }\item[{const unsigned char $\ast$}]{seckey}{, }\item[{\textbf{ secp256k1\+\_\+nonce\+\_\+function}}]{noncefp}{, }\item[{const void $\ast$}]{ndata}{}\end{DoxyParamCaption})}

Create a recoverable ECDSA signature.

Returns\+: 1\+: signature created 0\+: the nonce generation function failed, or the secret key was invalid. Args\+: ctx\+: pointer to a context object (not secp256k1\+\_\+context\+\_\+static). Out\+: sig\+: pointer to an array where the signature will be placed. In\+: msghash32\+: the 32-\/byte message hash being signed. seckey\+: pointer to a 32-\/byte secret key. noncefp\+: pointer to a nonce generation function. If NULL, secp256k1\+\_\+nonce\+\_\+function\+\_\+default is used. ndata\+: pointer to arbitrary data used by the nonce generation function (can be NULL for secp256k1\+\_\+nonce\+\_\+function\+\_\+default). 