.TH "src/core_io.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/core_io.h
.SH SYNOPSIS
.br
.PP
\fR#include <consensus/amount\&.h>\fP
.br
\fR#include <util/result\&.h>\fP
.br
\fR#include <string>\fP
.br
\fR#include <vector>\fP
.br
\fR#include <optional>\fP
.br

.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBTxVerbosity\fP { \fBSHOW_TXID\fP, \fBSHOW_DETAILS\fP, \fBSHOW_DETAILS_AND_PREVOUT\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBCScript\fP \fBParseScript\fP (const std::string &s)"
.br
.ti -1c
.RI "std::string \fBScriptToAsmStr\fP (const \fBCScript\fP &\fBscript\fP, const bool fAttemptSighashDecode=false)"
.br
.ti -1c
.RI "bool \fBDecodeHexTx\fP (\fBCMutableTransaction\fP &tx, const std::string &hex_tx, bool try_no_witness=false, bool try_witness=true)"
.br
.ti -1c
.RI "bool \fBDecodeHexBlk\fP (\fBCBlock\fP &, const std::string &strHexBlk)"
.br
.ti -1c
.RI "bool \fBDecodeHexBlockHeader\fP (\fBCBlockHeader\fP &, const std::string &hex_header)"
.br
.ti -1c
.RI "\fButil::Result\fP< int > \fBSighashFromStr\fP (const std::string &sighash)"
.br
.ti -1c
.RI "\fBUniValue\fP \fBValueFromAmount\fP (const \fBCAmount\fP amount)"
.br
.ti -1c
.RI "std::string \fBFormatScript\fP (const \fBCScript\fP &\fBscript\fP)"
.br
.ti -1c
.RI "std::string \fBEncodeHexTx\fP (const \fBCTransaction\fP &tx)"
.br
.ti -1c
.RI "std::string \fBSighashToStr\fP (unsigned char sighash_type)"
.br
.ti -1c
.RI "void \fBScriptToUniv\fP (const \fBCScript\fP &\fBscript\fP, \fBUniValue\fP &out, bool include_hex=true, bool include_address=false, const \fBSigningProvider\fP *provider=nullptr)"
.br
.ti -1c
.RI "void \fBTxToUniv\fP (const \fBCTransaction\fP &tx, const \fBuint256\fP &block_hash, \fBUniValue\fP &entry, bool include_hex=true, const \fBCTxUndo\fP *txundo=nullptr, \fBTxVerbosity\fP verbosity=\fBTxVerbosity::SHOW_DETAILS\fP, std::function< bool(const \fBCTxOut\fP &)> is_change_func={})"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBTxVerbosity\fP\fR [strong]\fP"
Verbose level for block's transaction 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISHOW_TXID \fP
Only TXID for each block's transaction\&. 
.TP
\f(BISHOW_DETAILS \fP
Include TXID, inputs, outputs, and other common block's transaction information\&. 
.TP
\f(BISHOW_DETAILS_AND_PREVOUT \fP
The same as previous option with information about prevouts if available\&. 
.SH "Function Documentation"
.PP 
.SS "bool DecodeHexBlk (\fBCBlock\fP & block, const std::string & strHexBlk)\fR [nodiscard]\fP"

.SS "bool DecodeHexBlockHeader (\fBCBlockHeader\fP & header, const std::string & hex_header)"

.SS "bool DecodeHexTx (\fBCMutableTransaction\fP & tx, const std::string & hex_tx, bool try_no_witness = \fRfalse\fP, bool try_witness = \fRtrue\fP)\fR [nodiscard]\fP"

.SS "std::string EncodeHexTx (const \fBCTransaction\fP & tx)"

.SS "std::string FormatScript (const \fBCScript\fP & script)"

.SS "\fBCScript\fP ParseScript (const std::string & s)"

.SS "std::string ScriptToAsmStr (const \fBCScript\fP & script, const bool fAttemptSighashDecode)"
Create the assembly string representation of a \fBCScript\fP object\&. 
.PP
\fBParameters\fP
.RS 4
\fIscript\fP \fBCScript\fP object to convert into the asm string representation\&. 
.br
\fIfAttemptSighashDecode\fP Whether to attempt to decode sighash types on data within the script that matches the format of a signature\&. Only pass true for scripts you believe could contain signatures\&. For example, pass false, or omit the this argument (defaults to false), for scriptPubKeys\&. 
.RE
.PP

.SS "void ScriptToUniv (const \fBCScript\fP & script, \fBUniValue\fP & out, bool include_hex = \fRtrue\fP, bool include_address = \fRfalse\fP, const \fBSigningProvider\fP * provider = \fRnullptr\fP)"

.SS "\fButil::Result\fP< int > SighashFromStr (const std::string & sighash)\fR [nodiscard]\fP"

.SS "std::string SighashToStr (unsigned char sighash_type)"

.SS "void TxToUniv (const \fBCTransaction\fP & tx, const \fBuint256\fP & block_hash, \fBUniValue\fP & entry, bool include_hex = \fRtrue\fP, const \fBCTxUndo\fP * txundo = \fRnullptr\fP, \fBTxVerbosity\fP verbosity = \fR\fBTxVerbosity::SHOW_DETAILS\fP\fP, std::function< bool(const \fBCTxOut\fP &)> is_change_func = \fR{}\fP)"

.SS "\fBUniValue\fP ValueFromAmount (const \fBCAmount\fP amount)"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
