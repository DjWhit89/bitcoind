.TH "src/serialize.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/serialize.h
.SH SYNOPSIS
.br
.PP
\fR#include <attributes\&.h>\fP
.br
\fR#include <compat/assumptions\&.h>\fP
.br
\fR#include <compat/endian\&.h>\fP
.br
\fR#include <prevector\&.h>\fP
.br
\fR#include <span\&.h>\fP
.br
\fR#include <algorithm>\fP
.br
\fR#include <concepts>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <cstring>\fP
.br
\fR#include <ios>\fP
.br
\fR#include <limits>\fP
.br
\fR#include <map>\fP
.br
\fR#include <memory>\fP
.br
\fR#include <set>\fP
.br
\fR#include <string>\fP
.br
\fR#include <utility>\fP
.br
\fR#include <vector>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBdeserialize_type\fP"
.br
.ti -1c
.RI "struct \fBCheckVarIntMode< Mode, I >\fP"
.br
.ti -1c
.RI "class \fBWrapper< Formatter, T >\fP"
.br
.ti -1c
.RI "struct \fBVarIntFormatter< Mode >\fP"
.br
.ti -1c
.RI "struct \fBCustomUintFormatter< Bytes, BigEndian >\fP"
.br
.ti -1c
.RI "struct \fBCompactSizeFormatter< RangeCheck >\fP"
.br
.ti -1c
.RI "struct \fBChronoFormatter< U, LOSSY >\fP"
.br
.ti -1c
.RI "class \fBCompactSizeWriter\fP"
.br
.ti -1c
.RI "struct \fBLimitedStringFormatter< Limit >\fP"
.br
.ti -1c
.RI "struct \fBVectorFormatter< Formatter >\fP"
.br
.ti -1c
.RI "struct \fBDefaultFormatter\fP"
.br
.ti -1c
.RI "struct \fBActionSerialize\fP"
.br
.ti -1c
.RI "struct \fBActionUnserialize\fP"
.br
.ti -1c
.RI "class \fBSizeComputer\fP"
.br
.ti -1c
.RI "class \fBParamsStream< SubStream, Params >\fP"
.br
.ti -1c
.RI "class \fBParamsWrapper< Params, T >\fP"
.br
.in -1c
.SS "Concepts"

.in +1c
.ti -1c
.RI "concept \fBCharNotInt8\fP"
.br
.ti -1c
.RI "concept \fBSerializable\fP"
.br
.ti -1c
.RI "concept \fBUnserializable\fP"
.br
.ti -1c
.RI "concept \fBContainsStream\fP"
.br
.RI "Check if type contains a stream by seeing if has a GetStream() method\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBREADWRITE\fP(\&.\&.\&.)"
.br
.ti -1c
.RI "#define \fBSER_READ\fP(obj,  code)"
.br
.ti -1c
.RI "#define \fBSER_WRITE\fP(obj,  code)"
.br
.ti -1c
.RI "#define \fBFORMATTER_METHODS\fP(cls,  obj)"
.br
.ti -1c
.RI "#define \fBSER_PARAMS\fP(type)"
.br
.ti -1c
.RI "#define \fBBASE_SERIALIZE_METHODS\fP(cls)"
.br
.ti -1c
.RI "#define \fBSERIALIZE_METHODS\fP(cls,  obj)"
.br
.ti -1c
.RI "#define \fBVARINT_MODE\fP(obj,  mode)"
.br
.ti -1c
.RI "#define \fBVARINT\fP(obj)"
.br
.ti -1c
.RI "#define \fBCOMPACTSIZE\fP(obj)"
.br
.ti -1c
.RI "#define \fBLIMITED_STRING\fP(obj,  n)"
.br
.ti -1c
.RI "#define \fBSER_PARAMS_OPFUNC\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<int Bytes> using \fBBigEndianFormatter\fP = \fBCustomUintFormatter\fP<Bytes, true>"
.br
.ti -1c
.RI "template<typename U> using \fBLossyChronoFormatter\fP = \fBChronoFormatter\fP<U, true>"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBVarIntMode\fP { \fBDEFAULT\fP, \fBNONNEGATIVE_SIGNED\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename Stream> void \fBser_writedata8\fP (Stream &s, uint8_t obj)"
.br
.ti -1c
.RI "template<typename Stream> void \fBser_writedata16\fP (Stream &s, uint16_t obj)"
.br
.ti -1c
.RI "template<typename Stream> void \fBser_writedata32\fP (Stream &s, uint32_t obj)"
.br
.ti -1c
.RI "template<typename Stream> void \fBser_writedata32be\fP (Stream &s, uint32_t obj)"
.br
.ti -1c
.RI "template<typename Stream> void \fBser_writedata64\fP (Stream &s, uint64_t obj)"
.br
.ti -1c
.RI "template<typename Stream> uint8_t \fBser_readdata8\fP (Stream &s)"
.br
.ti -1c
.RI "template<typename Stream> uint16_t \fBser_readdata16\fP (Stream &s)"
.br
.ti -1c
.RI "template<typename Stream> uint32_t \fBser_readdata32\fP (Stream &s)"
.br
.ti -1c
.RI "template<typename Stream> uint32_t \fBser_readdata32be\fP (Stream &s)"
.br
.ti -1c
.RI "template<typename Stream> uint64_t \fBser_readdata64\fP (Stream &s)"
.br
.ti -1c
.RI "template<class Out, class In> Out & \fBAsBase\fP (In &x)"
.br
.ti -1c
.RI "template<class Out, class In> const Out & \fBAsBase\fP (const In &x)"
.br
.ti -1c
.RI "template<typename Stream, \fBCharNotInt8\fP V> void \fBSerialize\fP (Stream &, V)=delete"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, std::byte a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, int8_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, uint8_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, int16_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, uint16_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, int32_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, uint32_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, int64_t a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, uint64_t a)"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B, size_t N> void \fBSerialize\fP (Stream &s, const \fBB\fP(&a)[N])"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B, size_t N> void \fBSerialize\fP (Stream &s, const std::array< \fBB\fP, N > &a)"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B, size_t N> void \fBSerialize\fP (Stream &s, std::span< \fBB\fP, N > span)"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B> void \fBSerialize\fP (Stream &s, std::span< \fBB\fP > span)"
.br
.ti -1c
.RI "template<typename Stream, \fBCharNotInt8\fP V> void \fBUnserialize\fP (Stream &, V)=delete"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, std::byte &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, int8_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, uint8_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, int16_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, uint16_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, int32_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, uint32_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, int64_t &a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, uint64_t &a)"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B, size_t N> void \fBUnserialize\fP (Stream &s, \fBB\fP(&a)[N])"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B, size_t N> void \fBUnserialize\fP (Stream &s, std::array< \fBB\fP, N > &a)"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B, size_t N> void \fBUnserialize\fP (Stream &s, std::span< \fBB\fP, N > span)"
.br
.ti -1c
.RI "template<typename Stream, \fBBasicByte\fP B> void \fBUnserialize\fP (Stream &s, std::span< \fBB\fP > span)"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s, bool a)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s, bool &a)"
.br
.ti -1c
.RI "constexpr unsigned int \fBGetSizeOfCompactSize\fP (uint64_t nSize)"
.br
.ti -1c
.RI "void \fBWriteCompactSize\fP (\fBSizeComputer\fP &os, uint64_t nSize)"
.br
.ti -1c
.RI "template<typename Stream> void \fBWriteCompactSize\fP (Stream &os, uint64_t nSize)"
.br
.ti -1c
.RI "template<typename Stream> uint64_t \fBReadCompactSize\fP (Stream &is, bool range_check=true)"
.br
.ti -1c
.RI "template<\fBVarIntMode\fP Mode, typename I> unsigned int \fBGetSizeOfVarInt\fP (I n)"
.br
.ti -1c
.RI "template<typename I> void \fBWriteVarInt\fP (\fBSizeComputer\fP &os, I n)"
.br
.ti -1c
.RI "template<typename Stream, \fBVarIntMode\fP Mode, typename I> void \fBWriteVarInt\fP (Stream &os, I n)"
.br
.ti -1c
.RI "template<typename Stream, \fBVarIntMode\fP Mode, typename I> I \fBReadVarInt\fP (Stream &is)"
.br
.ti -1c
.RI "template<typename Stream, typename C> void \fBSerialize\fP (Stream &os, const std::basic_string< C > &str)"
.br
.ti -1c
.RI "template<typename Stream, typename C> void \fBUnserialize\fP (Stream &is, std::basic_string< C > &str)"
.br
.ti -1c
.RI "template<typename Stream, unsigned int N, typename \fBT\fP> void \fBSerialize\fP (Stream &os, const \fBprevector\fP< N, \fBT\fP > &v)"
.br
.ti -1c
.RI "template<typename Stream, unsigned int N, typename \fBT\fP> void \fBUnserialize\fP (Stream &is, \fBprevector\fP< N, \fBT\fP > &v)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP, typename A> void \fBSerialize\fP (Stream &os, const std::vector< \fBT\fP, A > &v)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP, typename A> void \fBUnserialize\fP (Stream &is, std::vector< \fBT\fP, A > &v)"
.br
.ti -1c
.RI "template<typename Stream, typename K, typename \fBT\fP> void \fBSerialize\fP (Stream &os, const std::pair< K, \fBT\fP > &item)"
.br
.ti -1c
.RI "template<typename Stream, typename K, typename \fBT\fP> void \fBUnserialize\fP (Stream &is, std::pair< K, \fBT\fP > &item)"
.br
.ti -1c
.RI "template<typename Stream, typename K, typename \fBT\fP, typename Pred, typename A> void \fBSerialize\fP (Stream &os, const std::map< K, \fBT\fP, Pred, A > &m)"
.br
.ti -1c
.RI "template<typename Stream, typename K, typename \fBT\fP, typename Pred, typename A> void \fBUnserialize\fP (Stream &is, std::map< K, \fBT\fP, Pred, A > &m)"
.br
.ti -1c
.RI "template<typename Stream, typename K, typename Pred, typename A> void \fBSerialize\fP (Stream &os, const std::set< K, Pred, A > &m)"
.br
.ti -1c
.RI "template<typename Stream, typename K, typename Pred, typename A> void \fBUnserialize\fP (Stream &is, std::set< K, Pred, A > &m)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP> void \fBSerialize\fP (Stream &os, const std::shared_ptr< const \fBT\fP > &p)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP> void \fBUnserialize\fP (Stream &os, std::shared_ptr< const \fBT\fP > &p)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP> void \fBSerialize\fP (Stream &os, const std::unique_ptr< const \fBT\fP > &p)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP> void \fBUnserialize\fP (Stream &os, std::unique_ptr< const \fBT\fP > &p)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP> 
.br
requires \fBSerializable\fP<\fBT\fP, Stream>void \fBSerialize\fP (Stream &os, const \fBT\fP &a)"
.br
.ti -1c
.RI "template<typename Stream, typename \fBT\fP> 
.br
requires \fBUnserializable\fP<\fBT\fP, Stream>void \fBUnserialize\fP (Stream &is, \fBT\fP &&a)"
.br
.ti -1c
.RI "template<typename Stream, typename\&.\&.\&. Args> void \fBSerializeMany\fP (Stream &s, const Args &\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename Stream, typename\&.\&.\&. Args> void \fBUnserializeMany\fP (Stream &s, Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename \fBT\fP> uint64_t \fBGetSerializeSize\fP (const \fBT\fP &t)"
.br
.ti -1c
.RI "template<typename Substream, typename \fBParams\fP> \fBParamsStream\fP (Substream &&, const \fBParams\fP &) \-> ParamsStream< Substream, \fBParams\fP >"
.br
.ti -1c
.RI "template<typename Substream, typename Params1, typename Params2, typename\&.\&.\&. Params> \fBParamsStream\fP (Substream &&s, const Params1 &params1, const Params2 &params2, const \fBParams\fP &\&.\&.\&. params) \-> ParamsStream< decltype(ParamsStream{std::forward< Substream >(s), params2, params\&.\&.\&.}), Params1 >"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "constexpr \fBdeserialize_type\fP \fBdeserialize\fP {}"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define BASE_SERIALIZE_METHODS( cls)"
\fBValue:\fP
.nf
    template <typename Stream>                                                                      \\
    void Serialize(Stream& s) const                                                                 \\
    {                                                                                               \\
        static_assert(std::is_same_v<const cls&, decltype(*this)>, "Serialize type mismatch");      \\
        Ser(s, *this);                                                                              \\
    }                                                                                               \\
    template <typename Stream>                                                                      \\
    void Unserialize(Stream& s)                                                                     \\
    {                                                                                               \\
        static_assert(std::is_same_v<cls&, decltype(*this)>, "Unserialize type mismatch");          \\
        Unser(s, *this);                                                                            \\
    }
.PP
.fi

.SS "#define COMPACTSIZE( obj)"
\fBValue:\fP
.nf
Using<CompactSizeFormatter<true>>(obj)
.PP
.fi

.SS "#define FORMATTER_METHODS( cls,  obj)"
\fBValue:\fP
.nf
    template<typename Stream> \\
    static void Ser(Stream& s, const cls& obj) { SerializationOps(obj, s, ActionSerialize{}); } \\
    template<typename Stream> \\
    static void Unser(Stream& s, cls& obj) { SerializationOps(obj, s, ActionUnserialize{}); } \\
    template<typename Stream, typename Type, typename Operation> \\
    static void SerializationOps(Type& obj, Stream& s, Operation ser_action)
.PP
.fi
Implement the Ser and Unser methods needed for implementing a formatter (see Using below)\&.

.PP
Both Ser and Unser are delegated to a single static method SerializationOps, which is polymorphic in the serialized/deserialized type (allowing it to be const when serializing, and non-const when deserializing)\&.

.PP
Example use: struct FooFormatter { \fBFORMATTER_METHODS(Class, obj)\fP { READWRITE(obj\&.val1, VARINT(obj\&.val2)); } } would define a class FooFormatter that defines a serialization of Class objects consisting of serializing its val1 member using the default serialization, and its val2 member using VARINT serialization\&. That FooFormatter can then be used in statements like READWRITE(Using<FooFormatter>(obj\&.bla))\&. 
.SS "#define LIMITED_STRING( obj,  n)"
\fBValue:\fP
.nf
Using<LimitedStringFormatter<n>>(obj)
.PP
.fi

.SS "#define READWRITE( \&.\&.\&.)"
\fBValue:\fP
.nf
(ser_action\&.SerReadWriteMany(s, __VA_ARGS__))
.PP
.fi

.SS "#define SER_PARAMS( type)"
\fBValue:\fP
.nf
(s\&.template GetParams<type>())
.PP
.fi
Formatter methods can retrieve parameters attached to a stream using the \fBSER_PARAMS(type)\fP macro as long as the stream is created directly or indirectly with a parameter of that type\&. This permits making serialization depend on run-time context in a type-safe way\&.

.PP
Example use: struct BarParameter { bool fancy; \&.\&.\&. }; struct Bar { \&.\&.\&. }; struct FooFormatter { \fBFORMATTER_METHODS(Bar, obj)\fP { auto& param = \fBSER_PARAMS(BarParameter)\fP; if (param\&.fancy) { READWRITE(VARINT(obj\&.value)); } else { READWRITE(obj\&.value); } } }; which would then be invoked as READWRITE(BarParameter{\&.\&.\&.}(Using<FooFormatter>(obj\&.foo)))

.PP
parameter(obj) can be invoked anywhere in the call stack; it is passed down recursively into all serialization code, until another serialization parameter overrides it\&.

.PP
Parameters will be implicitly converted where appropriate\&. This means that "parent" serialization code can use a parameter that derives from, or is convertible to, a "child" formatter's parameter type\&.

.PP
Compilation will fail in any context where serialization is invoked but no parameter of a type convertible to BarParameter is provided\&. 
.SS "#define SER_PARAMS_OPFUNC"
\fBValue:\fP
.nf
                                                                                  \\
    template <typename T>                                                                \\
    auto operator()(T&& t) const                                                         \\
    {                                                                                    \\
        return ParamsWrapper{*this, t};                                                  \\
    }
.PP
.fi
Helper macro for SerParams structs

.PP
Allows you define SerParams instances and then apply them directly to an object via function call syntax, eg:

.PP
constexpr SerParams FOO{\&.\&.\&.\&.}; ss << FOO(obj); 
.SS "#define SER_READ( obj,  code)"
\fBValue:\fP
.nf
ser_action\&.SerRead(s, obj, [&](Stream& s, std::remove_const_t<Type>& obj) { code; })
.PP
.fi

.SS "#define SER_WRITE( obj,  code)"
\fBValue:\fP
.nf
ser_action\&.SerWrite(s, obj, [&](Stream& s, const Type& obj) { code; })
.PP
.fi

.SS "#define SERIALIZE_METHODS( cls,  obj)"
\fBValue:\fP
.nf
    BASE_SERIALIZE_METHODS(cls)     \\
    FORMATTER_METHODS(cls, obj)
.PP
.fi
Implement the Serialize and Unserialize methods by delegating to a single templated static method that takes the to-be-(de)serialized object as a parameter\&. This approach has the advantage that the constness of the object becomes a template parameter, and thus allows a single implementation that sees the object as const for serializing and non-const for deserializing, without casts\&. 
.SS "#define VARINT( obj)"
\fBValue:\fP
.nf
Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj)
.PP
.fi

.SS "#define VARINT_MODE( obj,  mode)"
\fBValue:\fP
.nf
Using<VarIntFormatter<mode>>(obj)
.PP
.fi

.SH "Typedef Documentation"
.PP 
.SS "template<int Bytes> using \fBBigEndianFormatter\fP = \fBCustomUintFormatter\fP<Bytes, true>"

.SS "template<typename U> using \fBLossyChronoFormatter\fP = \fBChronoFormatter\fP<U, true>"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBVarIntMode\fP\fR [strong]\fP"
Variable-length integers: bytes are a MSB base-128 encoding of the number\&. The high bit in each byte signifies whether another digit follows\&. To make sure the encoding is one-to-one, one is subtracted from all but the last digit\&. Thus, the byte sequence a[] with length len, where all but the last byte has bit 128 set, encodes the number:

.PP
(a[len-1] & 0x7F) + sum(i=1\&.\&.len-1, 128^i*((a[len-i-1] & 0x7F)+1))

.PP
Properties:
.IP "\(bu" 2
Very small (0-127: 1 byte, 128-16511: 2 bytes, 16512-2113663: 3 bytes)
.IP "\(bu" 2
Every integer has exactly one encoding
.IP "\(bu" 2
Encoding does not depend on size of original integer type
.IP "\(bu" 2
No redundancy: every (infinite) byte sequence corresponds to a list of encoded integers\&.
.PP

.PP
0: [0x00] 256: [0x81 0x00] 1: [0x01] 16383: [0xFE 0x7F] 127: [0x7F] 16384: [0xFF 0x00] 128: [0x80 0x00] 16511: [0xFF 0x7F] 255: [0x80 0x7F] 65535: [0x82 0xFE 0x7F] 2^32: [0x8E 0xFE 0xFE 0xFF 0x00] Mode for encoding VarInts\&.

.PP
Currently there is no support for signed encodings\&. The default mode will not compile with signed values, and the legacy "nonnegative signed" mode will accept signed values, but improperly encode and decode them if they are negative\&. In the future, the DEFAULT mode could be extended to support negative numbers in a backwards compatible way, and additional modes could be added to support different varint formats (e\&.g\&. zigzag encoding)\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDEFAULT \fP
.TP
\f(BINONNEGATIVE_SIGNED \fP
.SH "Function Documentation"
.PP 
.SS "template<class Out, class In> const Out & AsBase (const In & x)"

.SS "template<class Out, class In> Out & AsBase (In & x)"
Convert any argument to a reference to X, maintaining constness\&.

.PP
This can be used in serialization code to invoke a base class's serialization routines\&.

.PP
Example use: class \fBBase\fP { \&.\&.\&. }; class Child : public \fBBase\fP { int m_data; public: \fBSERIALIZE_METHODS(Child, obj)\fP { READWRITE(AsBase<Base>(obj), obj\&.m_data); } };

.PP
static_cast cannot easily be used here, as the type of Obj will be const Child& during serialization and Child& during deserialization\&. AsBase will convert to const \fBBase\fP& and \fBBase\fP& appropriately\&. 
.SS "template<typename \fBT\fP> uint64_t GetSerializeSize (const \fBT\fP & t)"

.SS "unsigned int GetSizeOfCompactSize (uint64_t nSize)\fR [inline]\fP, \fR [constexpr]\fP"
Compact Size size < 253 -- 1 byte size <= USHRT_MAX -- 3 bytes (253 + 2 bytes) size <= UINT_MAX -- 5 bytes (254 + 4 bytes) size > UINT_MAX -- 9 bytes (255 + 8 bytes) 
.SS "template<\fBVarIntMode\fP Mode, typename I> unsigned int GetSizeOfVarInt (I n)\fR [inline]\fP"

.SS "template<typename Substream, typename \fBParams\fP> ParamsStream (Substream && , const \fBParams\fP & )\->ParamsStream< Substream, \fBParams\fP >"
Explicit template deduction guide is required for single-parameter constructor so Substream&& is treated as a forwarding reference, and SubStream is deduced as reference type for lvalue arguments\&. 
.SS "template<typename Substream, typename Params1, typename Params2, typename\&.\&.\&. Params> ParamsStream (Substream && s, const Params1 & params1, const Params2 & params2, const \fBParams\fP &\&.\&.\&. params)\->ParamsStream< decltype(ParamsStream{std::forward< Substream >(s), params2, params\&.\&.\&.}), Params1 >"
Template deduction guide for multiple params arguments that creates a nested \fBParamsStream\fP\&. 
.SS "template<typename Stream> uint64_t ReadCompactSize (Stream & is, bool range_check = \fRtrue\fP)"
Decode a CompactSize-encoded variable-length integer\&.

.PP
As these are primarily used to encode the size of vector-like serializations, by default a range check is performed\&. When used as a generic number encoding, range_check should be set to false\&. 
.SS "template<typename Stream, \fBVarIntMode\fP Mode, typename I> I ReadVarInt (Stream & is)"

.SS "template<typename Stream> uint16_t ser_readdata16 (Stream & s)\fR [inline]\fP"

.SS "template<typename Stream> uint32_t ser_readdata32 (Stream & s)\fR [inline]\fP"

.SS "template<typename Stream> uint32_t ser_readdata32be (Stream & s)\fR [inline]\fP"

.SS "template<typename Stream> uint64_t ser_readdata64 (Stream & s)\fR [inline]\fP"

.SS "template<typename Stream> uint8_t ser_readdata8 (Stream & s)\fR [inline]\fP"

.SS "template<typename Stream> void ser_writedata16 (Stream & s, uint16_t obj)\fR [inline]\fP"

.SS "template<typename Stream> void ser_writedata32 (Stream & s, uint32_t obj)\fR [inline]\fP"

.SS "template<typename Stream> void ser_writedata32be (Stream & s, uint32_t obj)\fR [inline]\fP"

.SS "template<typename Stream> void ser_writedata64 (Stream & s, uint64_t obj)\fR [inline]\fP"

.SS "template<typename Stream> void ser_writedata8 (Stream & s, uint8_t obj)\fR [inline]\fP"

.SS "template<typename Stream, \fBCharNotInt8\fP V> void Serialize (Stream & , V )\fR [delete]\fP"

.SS "template<typename Stream, unsigned int N, typename \fBT\fP> void Serialize (Stream & os, const \fBprevector\fP< N, \fBT\fP > & v)\fR [inline]\fP"
prevector 
.SS "template<typename Stream, typename C> void Serialize (Stream & os, const std::basic_string< C > & str)"
Forward declarations string

.PP
string 
.SS "template<typename Stream, typename K, typename \fBT\fP, typename Pred, typename A> void Serialize (Stream & os, const std::map< K, \fBT\fP, Pred, A > & m)"
map 
.SS "template<typename Stream, typename K, typename \fBT\fP> void Serialize (Stream & os, const std::pair< K, \fBT\fP > & item)"
pair 
.SS "template<typename Stream, typename K, typename Pred, typename A> void Serialize (Stream & os, const std::set< K, Pred, A > & m)"
set 
.SS "template<typename Stream, typename \fBT\fP> void Serialize (Stream & os, const std::shared_ptr< const \fBT\fP > & p)"
shared_ptr 
.SS "template<typename Stream, typename \fBT\fP> void Serialize (Stream & os, const std::unique_ptr< const \fBT\fP > & p)"
unique_ptr 
.SS "template<typename Stream, typename \fBT\fP, typename A> void Serialize (Stream & os, const std::vector< \fBT\fP, A > & v)\fR [inline]\fP"
vector 
.SS "template<typename Stream, typename \fBT\fP> 
.br
requires \fBSerializable\fP<\fBT\fP, Stream>void Serialize (Stream & os, const \fBT\fP & a)"

.SS "template<typename Stream> void Serialize (Stream & s, bool a)"

.SS "template<typename Stream, \fBBasicByte\fP B, size_t N> void Serialize (Stream & s, const \fBB\fP(&) a[N])"

.SS "template<typename Stream, \fBBasicByte\fP B, size_t N> void Serialize (Stream & s, const std::array< \fBB\fP, N > & a)"

.SS "template<typename Stream> void Serialize (Stream & s, int16_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, int32_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, int64_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, int8_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, std::byte a)"

.SS "template<typename Stream, \fBBasicByte\fP B> void Serialize (Stream & s, std::span< \fBB\fP > span)"

.SS "template<typename Stream, \fBBasicByte\fP B, size_t N> void Serialize (Stream & s, std::span< \fBB\fP, N > span)"

.SS "template<typename Stream> void Serialize (Stream & s, uint16_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, uint32_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, uint64_t a)"

.SS "template<typename Stream> void Serialize (Stream & s, uint8_t a)"

.SS "template<typename Stream, typename\&.\&.\&. Args> void SerializeMany (Stream & s, const Args &\&.\&.\&. args)"
Support for (un)serializing many things at once 
.SS "template<typename Stream, \fBCharNotInt8\fP V> void Unserialize (Stream & , V )\fR [delete]\fP"

.SS "template<typename Stream, unsigned int N, typename \fBT\fP> void Unserialize (Stream & is, \fBprevector\fP< N, \fBT\fP > & v)\fR [inline]\fP"

.SS "template<typename Stream, typename C> void Unserialize (Stream & is, std::basic_string< C > & str)"

.SS "template<typename Stream, typename K, typename \fBT\fP, typename Pred, typename A> void Unserialize (Stream & is, std::map< K, \fBT\fP, Pred, A > & m)"

.SS "template<typename Stream, typename K, typename \fBT\fP> void Unserialize (Stream & is, std::pair< K, \fBT\fP > & item)"

.SS "template<typename Stream, typename K, typename Pred, typename A> void Unserialize (Stream & is, std::set< K, Pred, A > & m)"

.SS "template<typename Stream, typename \fBT\fP, typename A> void Unserialize (Stream & is, std::vector< \fBT\fP, A > & v)\fR [inline]\fP"

.SS "template<typename Stream, typename \fBT\fP> 
.br
requires \fBUnserializable\fP<\fBT\fP, Stream>void Unserialize (Stream & is, \fBT\fP && a)"

.SS "template<typename Stream, typename \fBT\fP> void Unserialize (Stream & os, std::shared_ptr< const \fBT\fP > & p)"

.SS "template<typename Stream, typename \fBT\fP> void Unserialize (Stream & os, std::unique_ptr< const \fBT\fP > & p)"

.SS "template<typename Stream, \fBBasicByte\fP B, size_t N> void Unserialize (Stream & s, \fBB\fP(&) a[N])"

.SS "template<typename Stream> void Unserialize (Stream & s, bool & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, int16_t & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, int32_t & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, int64_t & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, int8_t & a)"

.SS "template<typename Stream, \fBBasicByte\fP B, size_t N> void Unserialize (Stream & s, std::array< \fBB\fP, N > & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, std::byte & a)"

.SS "template<typename Stream, \fBBasicByte\fP B> void Unserialize (Stream & s, std::span< \fBB\fP > span)"

.SS "template<typename Stream, \fBBasicByte\fP B, size_t N> void Unserialize (Stream & s, std::span< \fBB\fP, N > span)"

.SS "template<typename Stream> void Unserialize (Stream & s, uint16_t & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, uint32_t & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, uint64_t & a)"

.SS "template<typename Stream> void Unserialize (Stream & s, uint8_t & a)"

.SS "template<typename Stream, typename\&.\&.\&. Args> void UnserializeMany (Stream & s, Args &&\&.\&.\&. args)\fR [inline]\fP"

.SS "void WriteCompactSize (\fBSizeComputer\fP & os, uint64_t nSize)\fR [inline]\fP"

.SS "template<typename Stream> void WriteCompactSize (Stream & os, uint64_t nSize)"

.SS "template<typename I> void WriteVarInt (\fBSizeComputer\fP & os, I n)\fR [inline]\fP"

.SS "template<typename Stream, \fBVarIntMode\fP Mode, typename I> void WriteVarInt (Stream & os, I n)"

.SH "Variable Documentation"
.PP 
.SS "\fBdeserialize_type\fP deserialize {}\fR [constexpr]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
