.TH "MemPoolTest" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MemPoolTest
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBCTxMemPool\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCFeeRate\fP \fBGetMinFee\fP (size_t sizelimit) const"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBGetMinFee\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBCTxMemPool\fP
.in +1c
.ti -1c
.RI "std::unique_ptr< \fBTxGraph\fP > m_txgraph \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "std::unique_ptr< \fBTxGraph::BlockBuilder\fP > m_builder \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "\fBindexed_transaction_set\fP mapTx \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< std::pair< \fBWtxid\fP, \fBtxiter\fP > > txns_randomized \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.RI "All transactions in mapTx with their wtxids, in arbitrary order\&. "
.ti -1c
.RI "std::tuple< size_t, size_t, \fBCAmount\fP > \fBCalculateAncestorData\fP (const \fBCTxMemPoolEntry\fP &entry) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::tuple< size_t, size_t, \fBCAmount\fP > \fBCalculateDescendantData\fP (const \fBCTxMemPoolEntry\fP &entry) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "int64_t \fBGetDescendantCount\fP (\fBtxiter\fP \fBit\fP) const"
.br
.ti -1c
.RI "int64_t \fBGetDescendantCount\fP (const \fBCTxMemPoolEntry\fP &e) const"
.br
.ti -1c
.RI "int64_t \fBGetAncestorCount\fP (const \fBCTxMemPoolEntry\fP &e) const"
.br
.ti -1c
.RI "std::vector< \fBCTxMemPoolEntry::CTxMemPoolEntryRef\fP > \fBGetChildren\fP (const \fBCTxMemPoolEntry\fP &entry) const"
.br
.ti -1c
.RI "std::vector< \fBCTxMemPoolEntry::CTxMemPoolEntryRef\fP > \fBGetParents\fP (const \fBCTxMemPoolEntry\fP &entry) const"
.br
.ti -1c
.RI "\fBindirectmap\fP< \fBCOutPoint\fP, \fBtxiter\fP > mapNextTx \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "std::map< \fBTxid\fP, \fBCAmount\fP > mapDeltas \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "\fBCTxMemPool\fP (\fBOptions\fP\fBOptions\fP opts, \fBbilingual_str\fP &error)"
.br
.ti -1c
.RI "void \fBremoveForReorg\fP (\fBCChain\fP &chain, std::function< bool(\fBtxiter\fP)> filter_final_and_mature) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP"
.br
.ti -1c
.RI "void \fBremoveForBlock\fP (const std::vector< \fBCTransactionRef\fP > &vtx, unsigned int nBlockHeight) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "bool \fBCompareMiningScoreWithTopology\fP (const \fBWtxid\fP &hasha, const \fBWtxid\fP &hashb) const"
.br
.ti -1c
.RI "bool \fBisSpent\fP (const \fBCOutPoint\fP &outpoint) const"
.br
.ti -1c
.RI "unsigned int \fBGetTransactionsUpdated\fP () const"
.br
.ti -1c
.RI "void \fBAddTransactionsUpdated\fP (unsigned int n)"
.br
.ti -1c
.RI "bool \fBHasNoInputsOf\fP (const \fBCTransaction\fP &tx) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBPrioritiseTransaction\fP (const \fBTxid\fP &hash, const \fBCAmount\fP &nFeeDelta)"
.br
.ti -1c
.RI "void \fBApplyDelta\fP (const \fBTxid\fP &hash, \fBCAmount\fP &nFeeDelta) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBClearPrioritisation\fP (const \fBTxid\fP &hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< \fBdelta_info\fP > \fBGetPrioritisedTransactions\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "const \fBCTransaction\fP * \fBGetConflictTx\fP (const \fBCOutPoint\fP &prevout) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::optional< \fBtxiter\fP > \fBGetIter\fP (const \fBTxid\fP &txid) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::optional< \fBtxiter\fP > \fBGetIter\fP (const \fBWtxid\fP &wtxid) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBsetEntries\fP \fBGetIterSet\fP (const std::set< \fBTxid\fP > &hashes) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< \fBtxiter\fP > \fBGetIterVec\fP (const std::vector< \fBTxid\fP > &txids) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBUpdateTransactionsFromBlock\fP (const std::vector< \fBTxid\fP > &vHashesToUpdate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP"
.br
.ti -1c
.RI "void \fBcs_main\fP \fBLOCKS_EXCLUDED\fP (\fBm_epoch\fP)"
.br
.ti -1c
.RI "std::vector< \fBFeePerWeight\fP > \fBGetFeerateDiagram\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBFeePerWeight\fP \fBGetMainChunkFeerate\fP (const \fBCTxMemPoolEntry\fP &tx) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< const \fBCTxMemPoolEntry\fP * > \fBGetCluster\fP (\fBTxid\fP txid) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "size_t \fBGetUniqueClusterCount\fP (const \fBsetEntries\fP &iters_conflicting) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBsetEntries\fP \fBCalculateMemPoolAncestors\fP (const \fBCTxMemPoolEntry\fP &entry) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "bool \fBHasDescendants\fP (const \fBTxid\fP &txid) const"
.br
.ti -1c
.RI "std::vector< \fBtxiter\fP > \fBGatherClusters\fP (const std::vector< \fBTxid\fP > &txids) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBCalculateDescendants\fP (\fBtxiter\fP \fBit\fP, \fBsetEntries\fP &setDescendants) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBCTxMemPool::txiter\fP \fBCalculateDescendants\fP (const \fBCTxMemPoolEntry\fP &entry, \fBsetEntries\fP &setDescendants) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBGetMinFee\fP () const"
.br
.ti -1c
.RI "void \fBTrimToSize\fP (size_t sizelimit, std::vector< \fBCOutPoint\fP > *pvNoSpendsRemaining=nullptr) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "int \fBExpire\fP (std::chrono::seconds time) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBGetTransactionAncestry\fP (const \fBTxid\fP &txid, size_t &ancestors, size_t &cluster_count, size_t *ancestorsize=nullptr, \fBCAmount\fP *ancestorfees=nullptr) const"
.br
.ti -1c
.RI "bool \fBGetLoadTried\fP () const"
.br
.ti -1c
.RI "void \fBSetLoadTried\fP (bool load_tried)"
.br
.ti -1c
.RI "unsigned long \fBsize\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetTotalTxSize\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetTotalFee\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "bool \fBexists\fP (const \fBTxid\fP &txid) const"
.br
.ti -1c
.RI "bool \fBexists\fP (const \fBWtxid\fP &wtxid) const"
.br
.ti -1c
.RI "const \fBCTxMemPoolEntry\fP * \fBGetEntry\fP (const \fBTxid\fP &txid) const \fBLIFETIMEBOUND\fP \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBCTransactionRef\fP \fBget\fP (const \fBTxid\fP &hash) const"
.br
.ti -1c
.RI "template<\fBTxidOrWtxid\fP T> \fBTxMempoolInfo\fP \fBinfo\fP (const \fBT\fP &id) const"
.br
.ti -1c
.RI "template<\fBTxidOrWtxid\fP T> \fBTxMempoolInfo\fP \fBinfo_for_relay\fP (const \fBT\fP &id, uint64_t last_sequence) const"
.br
.ti -1c
.RI "std::vector< \fBCTxMemPoolEntryRef\fP > \fBentryAll\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< \fBTxMempoolInfo\fP > \fBinfoAll\fP () const"
.br
.ti -1c
.RI "size_t \fBDynamicMemoryUsage\fP () const"
.br
.ti -1c
.RI "void \fBAddUnbroadcastTx\fP (const \fBTxid\fP &txid)"
.br
.ti -1c
.RI "bool \fBCheckPolicyLimits\fP (const \fBCTransactionRef\fP &tx)"
.br
.ti -1c
.RI "void \fBRemoveUnbroadcastTx\fP (const \fBTxid\fP &txid, const bool unchecked=false)"
.br
.ti -1c
.RI "std::set< \fBTxid\fP > \fBGetUnbroadcastTxs\fP () const"
.br
.ti -1c
.RI "bool \fBIsUnbroadcastTx\fP (const \fBTxid\fP &txid) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "uint64_t \fBGetAndIncrementSequence\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "uint64_t \fBGetSequence\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "bool \fBvisited\fP (const \fBtxiter\fP \fBit\fP) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP"
.br
.ti -1c
.RI "bool \fBvisited\fP (std::optional< \fBtxiter\fP > \fBit\fP) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP"
.br
.ti -1c
.RI "std::unique_ptr< \fBChangeSet\fP > \fBGetChangeSet\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "bool m_have_changeset \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "void \fBStartBlockBuilding\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "\fBFeePerWeight\fP \fBGetBlockBuilderChunk\fP (std::vector< \fBCTxMemPoolEntry::CTxMemPoolEntryRef\fP > &entries) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBIncludeBuilderChunk\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBSkipBuilderChunk\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBStopBlockBuilding\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBCTxMemPool\fP
.in +1c
.ti -1c
.RI "typedef boost::multi_index_container< \fBCTxMemPoolEntry\fP, \fBCTxMemPoolEntry_Indices\fP > \fBindexed_transaction_set\fP"
.br
.ti -1c
.RI "using \fBtxiter\fP = indexed_transaction_set::nth_index<0>::type::const_iterator"
.br
.ti -1c
.RI "typedef std::set< \fBtxiter\fP, \fBCompareIteratorByHash\fP > \fBsetEntries\fP"
.br
.ti -1c
.RI "using \fBLimits\fP = \fBkernel::MemPoolLimits\fP"
.br
.ti -1c
.RI "using \fBOptions\fP = \fBkernel::MemPoolOptions\fP"
.br
.in -1c

Data Fields inherited from \fBCTxMemPool\fP
.in +1c
.ti -1c
.RI "\fBRecursiveMutex\fP \fBcs\fP"
.br
.ti -1c
.RI "const \fBOptions\fP\fBOptions\fP \fBm_opts\fP"
.br
.ti -1c
.RI "void check(const \fBCCoinsViewCache\fP &active_coins_tip, int64_t spendheight) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(voi \fBremoveRecursive\fP )(const \fBCTransaction\fP &tx, \fBMemPoolRemovalReason\fP reason) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "void \fBcs_main\fP"
.br
.ti -1c
.RI "bool \fBm_epoch\fP"
.br
.ti -1c
.RI "return !it \fBvisited\fP * \fBit\fP"
.br
.in -1c

Static Public Attributes inherited from \fBCTxMemPool\fP
.in +1c
.ti -1c
.RI "static const int \fBROLLING_FEE_HALFLIFE\fP = 60 * 60 * 12"
.br
.in -1c

Protected Member Functions inherited from \fBCTxMemPool\fP
.in +1c
.ti -1c
.RI "uint64_t totalTxSize \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "\fBCAmount\fP m_total_fee \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.RI "sum of all mempool tx's virtual sizes\&. Differs from serialized tx size since witness data is discounted\&. Defined in BIP 141\&. "
.ti -1c
.RI "uint64_t cachedInnerUsage \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.RI "sum of all mempool tx's fees (NOT modified fee) "
.ti -1c
.RI "int64_t lastRollingFeeUpdate \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.RI "sum of dynamic memory usage of all the map elements (NOT the maps themselves) "
.ti -1c
.RI "bool blockSinceLastRollingFeeBump \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "double rollingMinimumFeeRate \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "\fBEpoch\fP \fBm_epoch\fP \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.RI "minimum fee to get into the pool, decreases exponentially "
.ti -1c
.RI "uint64_t m_sequence_number \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "void \fBtrackPackageRemoved\fP (const \fBCFeeRate\fP &rate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs\fP)"
.br
.ti -1c
.RI "bool m_load_tried \fBGUARDED_BY\fP (\fBcs\fP)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBGetMinFee\fP (size_t sizelimit) const"
.br
.in -1c

Protected Attributes inherited from \fBCTxMemPool\fP
.in +1c
.ti -1c
.RI "std::atomic< unsigned int > \fBnTransactionsUpdated\fP {0}"
.br
.RI "Used by getblocktemplate to trigger CreateNewBlock() invocation\&. "
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "\fBCFeeRate\fP GetMinFee () const\fR [inline]\fP"
The minimum fee to get into the mempool, which may itself not be enough for larger-sized transactions\&. The m_incremental_relay_feerate policy variable is used to bound the time it takes the fee rate to go back down all the way to 0\&. When the feerate would otherwise be half of this, it is set to 0 instead\&. 
.SS "\fBCFeeRate\fP GetMinFee (size_t sizelimit) const"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
