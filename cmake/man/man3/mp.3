.TH "mp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mp \- Functions to serialize / deserialize common bitcoin types\&.  

.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBtest\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBInvokeContext\fP"
.br
.ti -1c
.RI "struct \fBClientInvokeContext\fP"
.br
.ti -1c
.RI "struct \fBServerInvokeContext\fP"
.br
.ti -1c
.RI "struct \fBProxyClient< Thread >\fP"
.br
.ti -1c
.RI "struct \fBProxyServer< Thread >\fP"
.br
.ti -1c
.RI "class \fBLoggingErrorHandler\fP"
.br
.RI "\fBHandler\fP for kj::TaskSet failed task events\&. "
.ti -1c
.RI "struct \fBLogMessage\fP"
.br
.ti -1c
.RI "struct \fBLogOptions\fP"
.br
.ti -1c
.RI "class \fBLogger\fP"
.br
.ti -1c
.RI "class \fBEventLoop\fP"
.br
.ti -1c
.RI "struct \fBWaiter\fP"
.br
.ti -1c
.RI "class \fBConnection\fP"
.br
.ti -1c
.RI "struct \fBServerVatId\fP"
.br
.ti -1c
.RI "struct \fBThreadContext\fP"
.br
.ti -1c
.RI "class \fBValueField\fP"
.br
.ti -1c
.RI "struct \fBStructField\fP"
.br
.ti -1c
.RI "struct \fBReadDestEmplace\fP"
.br
.ti -1c
.RI "struct \fBReadDestUpdate\fP"
.br
.ti -1c
.RI "struct \fBListOutput\fP"
.br
.ti -1c
.RI "struct \fBListOutput<::capnp::List< T, kind > >\fP"
.br
.ti -1c
.RI "struct \fBIterateFieldsHelper\fP"
.br
.ti -1c
.RI "struct \fBIterateFields\fP"
.br
.ti -1c
.RI "struct \fBClientException\fP"
.br
.ti -1c
.RI "struct \fBClientParam\fP"
.br
.ti -1c
.RI "struct \fBServerCall\fP"
.br
.ti -1c
.RI "struct \fBServerDestroy\fP"
.br
.ti -1c
.RI "struct \fBServerRet\fP"
.br
.ti -1c
.RI "struct \fBServerExcept\fP"
.br
.ti -1c
.RI "struct \fBServerField\fP"
.br
.ti -1c
.RI "struct \fBCapRequestTraits\fP"
.br
.ti -1c
.RI "struct \fBCapRequestTraits<::capnp::Request< _Params, _Results > >\fP"
.br
.ti -1c
.RI "struct \fBProxyTypeRegister\fP"
.br
.ti -1c
.RI "struct \fBProxyClient\fP"
.br
.ti -1c
.RI "struct \fBProxyServer\fP"
.br
.ti -1c
.RI "struct \fBProxyMethod\fP"
.br
.RI "Mapping from capnp method params type to method traits (specializations are generated by proxy-codegen\&.cpp)\&. "
.ti -1c
.RI "struct \fBProxyStruct\fP"
.br
.RI "Mapping from capnp struct type to struct traits (specializations are generated by proxy-codegen\&.cpp)\&. "
.ti -1c
.RI "struct \fBProxyType\fP"
.br
.RI "Mapping from local c++ type to capnp type and traits (specializations are generated by proxy-codegen\&.cpp)\&. "
.ti -1c
.RI "class \fBEventLoopRef\fP"
.br
.ti -1c
.RI "struct \fBProxyContext\fP"
.br
.RI "Context data associated with proxy client and server classes\&. "
.ti -1c
.RI "class \fBProxyClientBase\fP"
.br
.ti -1c
.RI "class \fBProxyClientCustom\fP"
.br
.ti -1c
.RI "struct \fBProxyServerBase\fP"
.br
.ti -1c
.RI "struct \fBProxyServerCustom\fP"
.br
.ti -1c
.RI "struct \fBFunctionTraits\fP"
.br
.ti -1c
.RI "struct \fBFunctionTraits< _Result(_Class::*const)(_Params\&.\&.\&.)>\fP"
.br
.ti -1c
.RI "struct \fBProxyMethodTraits\fP"
.br
.ti -1c
.RI "struct \fBProxyMethodTraits< MethodParams, Require< decltype(ProxyMethod< MethodParams >::impl)> >\fP"
.br
.ti -1c
.RI "struct \fBProxyClientMethodTraits\fP"
.br
.ti -1c
.RI "struct \fBProxyServerMethodTraits\fP"
.br
.ti -1c
.RI "struct \fBAccessor\fP"
.br
.RI "\fBAccessor\fP type holding flags that determine how to access a message field\&. "
.ti -1c
.RI "class \fBProxyCallback\fP"
.br
.RI "\fBWrapper\fP around std::function for passing std::function objects between client and servers\&. "
.ti -1c
.RI "class \fBProxyCallback< std::function< Result(Args\&.\&.\&.)> >\fP"
.br
.RI "Specialization of above to separate Result and Arg types\&. "
.ti -1c
.RI "class \fBProxyCallbackImpl\fP"
.br
.RI "Adapter to convert \fBProxyCallback\fP object call to function object call\&. "
.ti -1c
.RI "struct \fBProxyCallFn\fP"
.br
.ti -1c
.RI "struct \fBProxyServer< ThreadMap >\fP"
.br
.ti -1c
.RI "struct \fBTypeList\fP"
.br
.RI "Generic utility functions used by capnp code\&. "
.ti -1c
.RI "struct \fBSplit\fP"
.br
.ti -1c
.RI "struct \fBSplit< 0, _Second, _First, true >\fP"
.br
.RI "Specialization of above (base case)\&. "
.ti -1c
.RI "struct \fBSplit< index, TypeList< Type, _Second\&.\&.\&. >, TypeList< _First\&.\&.\&. >, false >\fP"
.br
.RI "Specialization of above (recursive case)\&. "
.ti -1c
.RI "struct \fB_Require\fP"
.br
.RI "SFINAE helper, see using \fBRequire\fP below\&. "
.ti -1c
.RI "struct \fBPriority\fP"
.br
.ti -1c
.RI "struct \fBPriority< 0 >\fP"
.br
.RI "Specialization of above (base case)\&. "
.ti -1c
.RI "struct \fBPtrOrValue\fP"
.br
.RI "Convenient wrapper around std::variant<T*, T>\&. "
.ti -1c
.RI "class \fBLock\fP"
.br
.ti -1c
.RI "struct \fBGuardedRef\fP"
.br
.ti -1c
.RI "struct \fBUnlockGuard\fP"
.br
.RI "Analog to std::lock_guard that unlocks instead of locks\&. "
.in -1c
.SS "Concepts"

.in +1c
.ti -1c
.RI "concept \fBIsSpanOf\fP"
.br
.ti -1c
.RI "concept \fBIsByteSpan\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "template<typename Interface, typename \fBParams\fP, typename Results> using \fBServerContext\fP = \fBServerInvokeContext\fP<\fBProxyServer\fP<Interface>, ::capnp::CallContext<\fBParams\fP, Results>>"
.br
.ti -1c
.RI "using \fBLogFn\fP = std::function<void(\fBLogMessage\fP)>"
.br
.ti -1c
.RI "using \fBConnThreads\fP = std::map<\fBConnection\fP*, std::optional<\fBProxyClient\fP<Thread>>>"
.br
.ti -1c
.RI "using \fBConnThread\fP = ConnThreads::iterator"
.br
.ti -1c
.RI "using \fBCleanupList\fP = std::list<std::function<void()>>"
.br
.ti -1c
.RI "using \fBCleanupIt\fP = typename CleanupList::iterator"
.br
.ti -1c
.RI "template<typename Callable> using \fBResultOf\fP = decltype(std::declval<Callable>()())"
.br
.RI "Type helper giving return type of a callable type\&. "
.ti -1c
.RI "template<typename \fBT\fP> using \fBRemoveCvRef\fP = std::remove_cv_t<std::remove_reference_t<\fBT\fP>>"
.br
.RI "Substitutue for std::remove_cvref_t\&. "
.ti -1c
.RI "template<typename \fBT\fP> using \fBDecay\fP = std::decay_t<\fBT\fP>"
.br
.RI "Type helper abbreviating std::decay\&. "
.ti -1c
.RI "template<typename SfinaeExpr, typename Result = void> using \fBRequire\fP = typename \fB_Require\fP<SfinaeExpr, Result>::Result"
.br
.RI "SFINAE helper, basically the same as to C++17's void_t, but allowing types other than void to be returned\&. "
.ti -1c
.RI "using \fBFdToArgsFn\fP = std::function<std::vector<std::string>(int fd)>"
.br
.RI "Callback type used by SpawnProcess below\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBLog\fP { \fBTrace\fP = 0, \fBDebug\fP, \fBInfo\fP, \fBWarning\fP, \fBError\fP, \fBRaise\fP }"
.br
.RI "Log flags\&. Update stringify function if changed! "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> 
.br
requires \fBSerializable\fP<LocalType, \fBDataStream\fP> && std::is_same_v<LocalType, std::remove_cv_t<std::remove_reference_t<LocalType>>>void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> 
.br
requires \fBUnserializable\fP<LocalType, \fBDataStream\fP> && (!\fBipc::capnp::Deserializable\fP<LocalType>)decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> 
.br
requires \fBipc::capnp::Deserializable\fP<LocalType>decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< \fBUniValue\fP >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< \fBUniValue\fP >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "kj::StringPtr \fBKJ_STRINGIFY\fP (\fBLog\fP \fBflags\fP)"
.br
.ti -1c
.RI "std::string \fBLongThreadName\fP (const char *exe_name)"
.br
.ti -1c
.RI "std::tuple< \fBConnThread\fP, bool > \fBSetThread\fP (\fBGuardedRef\fP< \fBConnThreads\fP > threads, \fBConnection\fP *connection, const std::function< Thread::Client()> &make_thread)"
.br
.ti -1c
.RI "template<typename InitInterface> std::unique_ptr< \fBProxyClient\fP< InitInterface > > \fBConnectStream\fP (\fBEventLoop\fP &loop, int fd)"
.br
.ti -1c
.RI "template<typename InitInterface, typename \fBInitImpl\fP> void \fB_Serve\fP (\fBEventLoop\fP &loop, kj::Own< kj::AsyncIoStream > &&stream, \fBInitImpl\fP &\fBinit\fP)"
.br
.ti -1c
.RI "template<typename InitInterface, typename \fBInitImpl\fP> void \fB_Listen\fP (\fBEventLoop\fP &loop, kj::Own< kj::ConnectionReceiver > &&listener, \fBInitImpl\fP &\fBinit\fP)"
.br
.ti -1c
.RI "template<typename InitInterface, typename \fBInitImpl\fP> void \fBServeStream\fP (\fBEventLoop\fP &loop, int fd, \fBInitImpl\fP &\fBinit\fP)"
.br
.ti -1c
.RI "template<typename InitInterface, typename \fBInitImpl\fP> void \fBListenConnections\fP (\fBEventLoop\fP &loop, int fd, \fBInitImpl\fP &\fBinit\fP)"
.br
.ti -1c
.RI "template<typename LocalType> auto \fBReadDestTemp\fP ()"
.br
.ti -1c
.RI "template<typename\&.\&.\&. LocalTypes, typename\&.\&.\&. Args> decltype(auto) \fBReadField\fP (\fBTypeList\fP< LocalTypes\&.\&.\&. >, Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input> void \fBThrowField\fP (\fBTypeList\fP< LocalType >, \fBInvokeContext\fP &invoke_context, Input &&input)"
.br
.ti -1c
.RI "template<typename Input> void \fBThrowField\fP (\fBTypeList\fP< std::exception >, \fBInvokeContext\fP &invoke_context, Input &&input)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Values> bool \fBCustomHasValue\fP (\fBInvokeContext\fP &invoke_context, const Values &\&.\&.\&. value)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. LocalTypes, typename Context, typename\&.\&.\&. Values, typename Output> void \fBBuildField\fP (\fBTypeList\fP< LocalTypes\&.\&.\&. >, Context &context, Output &&output, Values &&\&.\&.\&. values)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 0 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename LocalType, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> auto \fBPassField\fP (\fBPriority\fP< 1 >, \fBTypeList\fP< LocalType & >, \fBServerContext\fP &server_context, Fn &&fn, Args &&\&.\&.\&. \fBargs\fP) \-> \fBRequire\fP< typename decltype(Accessor::get(server_context\&.call_context\&.getParams()))::Calls >"
.br
.RI "PassField override for callable interface reference arguments\&. "
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBMaybeBuildField\fP (std::true_type, Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBMaybeBuildField\fP (std::false_type, Args &&\&.\&.\&.)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBMaybeReadField\fP (std::true_type, Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBMaybeReadField\fP (std::false_type, Args &&\&.\&.\&.)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBMaybeSetWant\fP (\fBTypeList\fP< LocalType * >, \fBPriority\fP< 1 >, const Value &value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalTypes, typename\&.\&.\&. Args> void \fBMaybeSetWant\fP (LocalTypes, \fBPriority\fP< 0 >, const Args &\&.\&.\&.)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename LocalType, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> void \fBPassField\fP (\fBPriority\fP< 0 >, \fBTypeList\fP< LocalType >, \fBServerContext\fP &server_context, Fn &&fn, Args &&\&.\&.\&. \fBargs\fP)"
.br
.RI "Default PassField implementation calling MaybeReadField/MaybeBuildField\&. "
.ti -1c
.RI "template<typename \fBAccessor\fP, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> void \fBPassField\fP (\fBPriority\fP< 0 >, \fBTypeList\fP<>, \fBServerContext\fP &server_context, const Fn &fn, Args &&\&.\&.\&. \fBargs\fP)"
.br
.RI "Default PassField implementation for count(0) arguments, calling ReadField/BuildField\&. "
.ti -1c
.RI "template<typename \fBAccessor\fP, typename\&.\&.\&. Types> \fBClientParam\fP< \fBAccessor\fP, Types\&.\&.\&. > \fBMakeClientParam\fP (Types &&\&.\&.\&. values)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename Message> decltype(auto) \fBMaybeGet\fP (Message &&message, decltype(Accessor::get(message)) *enable=nullptr)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP> ::capnp::Void \fBMaybeGet\fP (\&.\&.\&.)"
.br
.ti -1c
.RI "template<class \fBAccessor\fP> void \fBCustomPassField\fP ()"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename\&.\&.\&. Args> auto \fBPassField\fP (\fBPriority\fP< 2 >, Args &&\&.\&.\&. \fBargs\fP) \-> decltype(\fBCustomPassField\fP< \fBAccessor\fP >(std::forward< Args >(\fBargs\fP)\&.\&.\&.))"
.br
.ti -1c
.RI "template<int argc, typename \fBAccessor\fP, typename Parent> \fBServerField\fP< argc, \fBAccessor\fP, Parent > \fBMakeServerField\fP (Parent parent)"
.br
.ti -1c
.RI "template<typename Client> void \fBclientDestroy\fP (Client &client)"
.br
.ti -1c
.RI "template<typename Server> void \fBserverDestroy\fP (Server &server)"
.br
.ti -1c
.RI "template<typename \fBProxyClient\fP, typename GetRequest, typename\&.\&.\&. FieldObjs> void \fBclientInvoke\fP (\fBProxyClient\fP &proxy_client, const GetRequest &get_request, FieldObjs &&\&.\&.\&. fields)"
.br
.ti -1c
.RI "template<typename Fn, typename Ret> auto \fBReplaceVoid\fP (Fn &&fn, Ret &&\fBret\fP)"
.br
.ti -1c
.RI "template<typename Server, typename CallContext, typename Fn> kj::Promise< void > \fBserverInvoke\fP (Server &server, CallContext &call_context, Fn fn)"
.br
.ti -1c
.RI "void \fBCleanupRun\fP (\fBCleanupList\fP &fns)"
.br
.ti -1c
.RI "template<typename Output, size_t size> void \fBCustomBuildField\fP (\fBTypeList\fP< const unsigned char * >, \fBPriority\fP< 3 >, \fBInvokeContext\fP &invoke_context, const unsigned char(&value)[size], Output &&output)"
.br
.ti -1c
.RI "template<size_t size, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< unsigned char[size]>, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<class Rep, class Period, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::chrono::duration< Rep, Period > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<class Rep, class Period, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::chrono::duration< Rep, Period > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP<>, \fBPriority\fP< 1 >, \fBClientInvokeContext\fP &invoke_context, Output &&output, typename std::enable_if< std::is_same< decltype(output\&.get()), Context::Builder >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> auto \fBPassField\fP (\fBPriority\fP< 1 >, \fBTypeList\fP<>, \fBServerContext\fP &server_context, const Fn &fn, Args &&\&.\&.\&. \fBargs\fP) \-> typename std::enable_if< std::is_same< decltype(Accessor::get(server_context\&.call_context\&.getParams())), Context::Reader >::value, kj::Promise< typename \fBServerContext::CallContext\fP > >::type"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> 
.br
requires (std::is_same_v<decltype(output\&.get()), ::capnp::Data::Builder> && IsByteSpan<LocalType>)void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 2 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> 
.br
requires (std::is_same_v<decltype(input\&.get()), ::capnp::Data::Reader> && IsByteSpan<LocalType>)decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 2 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< const LocalType >, \fBPriority\fP< 0 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType & >, \fBPriority\fP< 0 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType && >, \fBPriority\fP< 0 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::exception >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, const std::exception &value, Output &&output)"
.br
.ti -1c
.RI "template<typename Value, typename FnR, typename\&.\&.\&. FnParams, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::function< FnR(FnParams\&.\&.\&.)> >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename FnR, typename\&.\&.\&. FnParams, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::function< FnR(FnParams\&.\&.\&.)> >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename Interface, typename Impl> kj::Own< typename Interface::Server > \fBMakeProxyServer\fP (\fBInvokeContext\fP &context, std::shared_ptr< Impl > impl)"
.br
.ti -1c
.RI "template<typename Interface, typename Impl> kj::Own< typename Interface::Server > \fBCustomMakeProxyServer\fP (\fBInvokeContext\fP &context, std::shared_ptr< Impl > &&impl)"
.br
.ti -1c
.RI "template<typename Impl, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::unique_ptr< Impl > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output, typename \fBDecay\fP< decltype(output\&.get())>::Calls *enable=nullptr)"
.br
.ti -1c
.RI "template<typename Impl, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::shared_ptr< Impl > >, \fBPriority\fP< 2 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output, typename \fBDecay\fP< decltype(output\&.get())>::Calls *enable=nullptr)"
.br
.ti -1c
.RI "template<typename Impl, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< Impl & >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Impl &value, Output &&output, typename decltype(output\&.get())::Calls *enable=nullptr)"
.br
.ti -1c
.RI "template<typename Interface, typename Impl> std::unique_ptr< Impl > \fBMakeProxyClient\fP (\fBInvokeContext\fP &context, typename Interface::Client &&client)"
.br
.ti -1c
.RI "template<typename Interface, typename Impl> std::unique_ptr< Impl > \fBCustomMakeProxyClient\fP (\fBInvokeContext\fP &context, typename Interface::Client &&client)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::unique_ptr< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest, typename \fBDecay\fP< decltype(input\&.get())>::Calls *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::shared_ptr< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest, typename \fBDecay\fP< decltype(input\&.get())>::Calls *enable=nullptr)"
.br
.ti -1c
.RI "template<typename KeyLocalType, typename ValueLocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::map< KeyLocalType, ValueLocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename KeyLocalType, typename ValueLocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::map< KeyLocalType, ValueLocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 2 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output, decltype(\fBCustomBuildMessage\fP(invoke_context, value, std::move(output\&.get()))) *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Reader, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 2 >, \fBInvokeContext\fP &invoke_context, Reader &&reader, ReadDest &&read_dest, decltype(\fBCustomReadMessage\fP(invoke_context, reader\&.get(), std::declval< LocalType & >())) *enable=nullptr)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename Message> decltype(auto) \fBMaybeInit\fP (Message &&message, decltype(Accessor::get(message)) *enable=nullptr)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP> ::capnp::Void \fBMaybeInit\fP (\&.\&.\&.)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename\&.\&.\&. LocalTypes, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> auto \fBCustomPassField\fP (\fBTypeList\fP< LocalTypes\&.\&.\&. >, \fBServerContext\fP &server_context, Fn &&fn, Args &&\&.\&.\&. \fBargs\fP) \-> decltype(\fBCustomPassMessage\fP(server_context, \fBMaybeGet\fP< \fBAccessor\fP >(server_context\&.call_context\&.getParams()), \fBMaybeGet\fP< \fBAccessor\fP >(server_context\&.call_context\&.getResults()), nullptr))"
.br
.ti -1c
.RI "template<typename LocalType, typename Value> LocalType \fBBuildPrimitive\fP (\fBInvokeContext\fP &invoke_context, const Value &value, \fBTypeList\fP< LocalType >, typename std::enable_if< std::is_enum< Value >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value> LocalType \fBBuildPrimitive\fP (\fBInvokeContext\fP &invoke_context, const Value &value, \fBTypeList\fP< LocalType >, typename std::enable_if< std::is_integral< Value >::value, int >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value> LocalType \fBBuildPrimitive\fP (\fBInvokeContext\fP &invoke_context, const Value &value, \fBTypeList\fP< LocalType >, typename std::enable_if< std::is_floating_point< Value >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest, typename std::enable_if< std::is_enum< LocalType >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest, typename std::enable_if< std::is_integral< LocalType >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest, typename std::enable_if< std::is_floating_point< LocalType >::value >::type *enable=0)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::optional< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::optional< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename KeyLocalType, typename ValueLocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::pair< KeyLocalType, ValueLocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename KeyLocalType, typename ValueLocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::pair< KeyLocalType, ValueLocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType * >, \fBPriority\fP< 3 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::shared_ptr< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType * >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::shared_ptr< LocalType > >, \fBPriority\fP< 0 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::shared_ptr< const LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename \fBAccessor\fP, typename LocalType, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> void \fBPassField\fP (\fBPriority\fP< 1 >, \fBTypeList\fP< LocalType * >, \fBServerContext\fP &server_context, const Fn &fn, Args &&\&.\&.\&. \fBargs\fP)"
.br
.RI "PassField override for C++ pointer arguments\&. "
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::set< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::set< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::string >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::string >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<size_t index, typename LocalType, typename Value, typename Output> void \fBBuildOne\fP (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP &invoke_context, Output &&output, Value &&value, typename std::enable_if< index< \fBProxyType\fP< LocalType >::fields >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<size_t index, typename LocalType, typename Value, typename Output> void \fBBuildOne\fP (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP &invoke_context, Output &&output, Value &&value, typename std::enable_if< index==\fBProxyType\fP< LocalType >::fields >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType > local_type, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output, typename \fBProxyType\fP< LocalType >::Struct *enable=nullptr)"
.br
.ti -1c
.RI "template<size_t index, typename LocalType, typename Input, typename Value> void \fBReadOne\fP (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP &invoke_context, Input &&input, Value &&value, typename std::enable_if< index !=\fBProxyType\fP< LocalType >::fields >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<size_t index, typename LocalType, typename Input, typename Value> void \fBReadOne\fP (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP &invoke_context, Input &input, Value &value, typename std::enable_if< index==\fBProxyType\fP< LocalType >::fields >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< LocalType > param, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest, typename \fBProxyType\fP< LocalType >::Struct *enable=nullptr)"
.br
.ti -1c
.RI "template<typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP<>, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Output &&output, typename std::enable_if< std::is_same< decltype(output\&.get()), ThreadMap::Client >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename Input> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP<>, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, typename std::enable_if< std::is_same< decltype(input\&.get()), ThreadMap::Client >::value >::type *enable=nullptr)"
.br
.ti -1c
.RI "template<typename KeyLocalType, typename ValueLocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::tuple< KeyLocalType, ValueLocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename KeyLocalType, typename ValueLocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::tuple< KeyLocalType, ValueLocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename LocalType, typename Value, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< std::vector< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Value &&value, Output &&output)"
.br
.ti -1c
.RI "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::vector< LocalType > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename Input, typename ReadDest> decltype(auto) \fBCustomReadField\fP (\fBTypeList\fP< std::vector< bool > >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, Input &&input, ReadDest &&read_dest)"
.br
.ti -1c
.RI "template<typename Value> ::capnp::Void \fBBuildPrimitive\fP (\fBInvokeContext\fP &invoke_context, Value &&, \fBTypeList\fP<::capnp::Void >)"
.br
.ti -1c
.RI "template<typename LocalType, typename Output> void \fBCustomBuildField\fP (\fBTypeList\fP< LocalType >, \fBPriority\fP< 1 >, \fBInvokeContext\fP &invoke_context, ::capnp::Void, Output &&output)"
.br
.ti -1c
.RI "template<template< typename\&.\&.\&. > class Class, typename\&.\&.\&. Types, typename\&.\&.\&. Args> Class< Types\&.\&.\&., std::remove_reference_t< Args >\&.\&.\&. > \fBMake\fP (Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename \fBT\fP> const char * \fBTypeName\fP ()"
.br
.RI "Return capnp type name with filename prefix removed\&. "
.ti -1c
.RI "class \fBMP_CAPABILITY\fP ('mutex') \fBMutex\fP"
.br
.ti -1c
.RI "template<class U> \fBGuardedRef\fP (\fBMutex\fP &, U &) \-> GuardedRef< U >"
.br
.ti -1c
.RI "template<typename \fBLock\fP, typename Callback> void \fBUnlock\fP (\fBLock\fP &lock, Callback &&callback)"
.br
.ti -1c
.RI "std::string \fBThreadName\fP (const char *exe_name)"
.br
.RI "\fBFormat\fP current thread name as "{exe_name}-{$pid}/{thread_name}-{$tid}"\&. "
.ti -1c
.RI "std::string \fBLogEscape\fP (const kj::StringTree &string, size_t max_size)"
.br
.ti -1c
.RI "int \fBSpawnProcess\fP (int &pid, \fBFdToArgsFn\fP &&fd_to_args)"
.br
.ti -1c
.RI "void \fBExecProcess\fP (const std::vector< std::string > &\fBargs\fP)"
.br
.RI "Call execvp with vector args\&. "
.ti -1c
.RI "int \fBWaitProcess\fP (int pid)"
.br
.RI "Wait for a process to exit and return its exit code\&. "
.ti -1c
.RI "char * \fBCharCast\fP (char *c)"
.br
.ti -1c
.RI "char * \fBCharCast\fP (unsigned char *c)"
.br
.ti -1c
.RI "const char * \fBCharCast\fP (const char *c)"
.br
.ti -1c
.RI "const char * \fBCharCast\fP (const unsigned char *c)"
.br
.ti -1c
.RI "void \fBCustomBuildMessage\fP (\fBInvokeContext\fP &invoke_context, const \fBtest::FooMessage\fP &src, test::messages::FooMessage::Builder &&builder)"
.br
.ti -1c
.RI "void \fBCustomReadMessage\fP (\fBInvokeContext\fP &invoke_context, const test::messages::FooMessage::Reader &reader, \fBtest::FooMessage\fP &dest)"
.br
.ti -1c
.RI "void \fBCustomBuildMessage\fP (\fBInvokeContext\fP &invoke_context, const \fBtest::FooMutable\fP &src, test::messages::FooMutable::Builder &&builder)"
.br
.ti -1c
.RI "void \fBCustomReadMessage\fP (\fBInvokeContext\fP &invoke_context, const test::messages::FooMutable::Reader &reader, \fBtest::FooMutable\fP &dest)"
.br
.ti -1c
.RI "void \fBCustomPassMessage\fP (\fBInvokeContext\fP &invoke_context, const test::messages::FooMutable::Reader &reader, test::messages::FooMutable::Builder builder, std::function< void(\fBtest::FooMutable\fP &)> &&fn)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBThreadContext\fP \fBg_thread_context\fP"
.br
.ti -1c
.RI "std::atomic< int > \fBserver_reqs\fP {0}"
.br
.in -1c
.SH "Detailed Description"
.PP 
Functions to serialize / deserialize common bitcoin types\&. 
.SH "Typedef Documentation"
.PP 
.SS "using \fBCleanupIt\fP = typename CleanupList::iterator"

.SS "using \fBCleanupList\fP = std::list<std::function<void()>>"

.SS "using \fBConnThread\fP = ConnThreads::iterator"

.SS "using \fBConnThreads\fP = std::map<\fBConnection\fP*, std::optional<\fBProxyClient\fP<Thread>>>"
Map from \fBConnection\fP to local or remote thread handle which will be used over that connection\&. This map will typically only contain one entry, but can contain multiple if a single thread makes IPC calls over multiple connections\&. A std::optional value type is used to avoid the map needing to be locked while \fBProxyClient<Thread>\fP objects are constructed, see \fBThreadContext\fP "Synchronization note" below\&. 
.SS "template<typename \fBT\fP> using \fBDecay\fP = std::decay_t<\fBT\fP>"

.PP
Type helper abbreviating std::decay\&. 
.SS "using \fBFdToArgsFn\fP = std::function<std::vector<std::string>(int fd)>"

.PP
Callback type used by SpawnProcess below\&. 
.SS "using \fBLogFn\fP = std::function<void(\fBLogMessage\fP)>"

.SS "template<typename \fBT\fP> using \fBRemoveCvRef\fP = std::remove_cv_t<std::remove_reference_t<\fBT\fP>>"

.PP
Substitutue for std::remove_cvref_t\&. 
.SS "template<typename SfinaeExpr, typename Result = void> using \fBRequire\fP = typename \fB_Require\fP<SfinaeExpr, Result>::Result"

.PP
SFINAE helper, basically the same as to C++17's void_t, but allowing types other than void to be returned\&. 
.SS "template<typename Callable> using \fBResultOf\fP = decltype(std::declval<Callable>()())"

.PP
Type helper giving return type of a callable type\&. 
.SS "template<typename Interface, typename \fBParams\fP, typename Results> using \fBServerContext\fP = \fBServerInvokeContext\fP<\fBProxyServer\fP<Interface>, ::capnp::CallContext<\fBParams\fP, Results>>"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBLog\fP\fR [strong]\fP"

.PP
\fBLog\fP flags\&. Update stringify function if changed! 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BITrace \fP
.TP
\f(BIDebug \fP
.TP
\f(BIInfo \fP
.TP
\f(BIWarning \fP
.TP
\f(BIError \fP
.TP
\f(BIRaise \fP
.SH "Function Documentation"
.PP 
.SS "template<typename InitInterface, typename \fBInitImpl\fP> void _Listen (\fBEventLoop\fP & loop, kj::Own< kj::ConnectionReceiver > && listener, \fBInitImpl\fP & init)"
Given connection receiver and an init object, handle incoming connections by calling _Serve, to create \fBProxyServer\fP objects and forward requests to the init object\&. 
.SS "template<typename InitInterface, typename \fBInitImpl\fP> void _Serve (\fBEventLoop\fP & loop, kj::Own< kj::AsyncIoStream > && stream, \fBInitImpl\fP & init)"
Given stream and init objects, construct a new \fBProxyServer\fP object that handles requests from the stream by calling the init object\&. Embed the \fBProxyServer\fP in a \fBConnection\fP object that is stored and erased if disconnected\&. This should be called from the event loop thread\&. 
.SS "template<typename\&.\&.\&. LocalTypes, typename Context, typename\&.\&.\&. Values, typename Output> void BuildField (\fBTypeList\fP< LocalTypes\&.\&.\&. > , Context & context, Output && output, Values &&\&.\&.\&. values)"

.SS "template<size_t index, typename LocalType, typename Value, typename Output> void BuildOne (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP & invoke_context, Output && output, Value && value)"

.SS "template<size_t index, typename LocalType, typename Value, typename Output> void BuildOne (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP & invoke_context, Output && output, Value && value, typename std::enable_if< index==\fBProxyType\fP< LocalType >::fields >::type * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value> LocalType BuildPrimitive (\fBInvokeContext\fP & invoke_context, const Value & value, \fBTypeList\fP< LocalType > , typename std::enable_if< std::is_enum< Value >::value >::type * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value> LocalType BuildPrimitive (\fBInvokeContext\fP & invoke_context, const Value & value, \fBTypeList\fP< LocalType > , typename std::enable_if< std::is_floating_point< Value >::value >::type * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value> LocalType BuildPrimitive (\fBInvokeContext\fP & invoke_context, const Value & value, \fBTypeList\fP< LocalType > , typename std::enable_if< std::is_integral< Value >::value, int >::type * enable = \fRnullptr\fP)"

.SS "template<typename Value> ::capnp::Void BuildPrimitive (\fBInvokeContext\fP & invoke_context, Value && , \fBTypeList\fP<::capnp::Void > )"

.SS "char * CharCast (char * c)\fR [inline]\fP"

.SS "const char * CharCast (const char * c)\fR [inline]\fP"

.SS "const char * CharCast (const unsigned char * c)\fR [inline]\fP"

.SS "char * CharCast (unsigned char * c)\fR [inline]\fP"

.SS "void CleanupRun (\fBCleanupList\fP & fns)\fR [inline]\fP"

.SS "template<typename Client> void clientDestroy (Client & client)"
Entry point called by all generated \fBProxyClient\fP destructors\&. This only logs the object destruction\&. The actual cleanup happens in the \fBProxyClient\fP base destructor\&. 
.SS "template<typename \fBProxyClient\fP, typename GetRequest, typename\&.\&.\&. FieldObjs> void clientInvoke (\fBProxyClient\fP & proxy_client, const GetRequest & get_request, FieldObjs &&\&.\&.\&. fields)"
Entry point called by generated client code that looks like:

.PP
ProxyClient<ClassName>::M0::Result ProxyClient<ClassName>::methodName(M0::Param<0> arg0, M0::Param<1> arg1) { typename M0::Result result; clientInvoke(*this, &InterfaceName::Client::methodNameRequest, MakeClientParam<\&.\&.\&.>(M0::Fwd<0>(arg0)), MakeClientParam<\&.\&.\&.>(M0::Fwd<1>(arg1)), MakeClientParam<\&.\&.\&.>(result)); return result; }

.PP
Ellipses above are where generated \fBAccessor<>\fP type declarations are inserted\&. 
.SS "template<typename InitInterface> std::unique_ptr< \fBProxyClient\fP< InitInterface > > ConnectStream (\fBEventLoop\fP & loop, int fd)"
Given stream file descriptor, make a new \fBProxyClient\fP object to send requests over the stream\&. Also create a new \fBConnection\fP object embedded in the client that is freed when the client is closed\&. 
.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< const LocalType > , \fBPriority\fP< 0 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename Output, size_t size> void CustomBuildField (\fBTypeList\fP< const unsigned char * > , \fBPriority\fP< 3 > , \fBInvokeContext\fP & invoke_context, const unsigned char(&) value[size], Output && output)"

.SS "template<typename Impl, typename Output> void CustomBuildField (\fBTypeList\fP< Impl & > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Impl & value, Output && output, typename decltype(output\&.get())::Calls * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType & > , \fBPriority\fP< 0 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType && > , \fBPriority\fP< 0 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType * > , \fBPriority\fP< 3 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType > local_type, \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output, typename \fBProxyType\fP< LocalType >::Struct * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 0 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename LocalType, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, ::capnp::Void , Output && output)"

.SS "template<typename LocalType, typename Value, typename Output> 
.br
requires \fBSerializable\fP<LocalType, \fBDataStream\fP> && std::is_same_v<LocalType, std::remove_cv_t<std::remove_reference_t<LocalType>>>void CustomBuildField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"
Overload multiprocess library's CustomBuildField hook to allow any serializable object to be stored in a capnproto Data field or passed to a capnproto interface\&. Use \fBPriority<1>\fP so this hook has medium priority, and higher priority hooks could take precedence over this one\&. 
.SS "template<typename LocalType, typename Value, typename Output> 
.br
requires (std::is_same_v<decltype(output\&.get()), ::capnp::Data::Builder> && IsByteSpan<LocalType>)void CustomBuildField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 2 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"
Generic ::capnp::Data field builder for any C++ type that can be converted to a span of bytes, like std::vector<char> or std::array<uint8_t>, or custom blob types like \fBuint256\fP or \fBPKHash\fP with data() and size() methods pointing to bytes\&. 
.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 2 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output, decltype(\fBCustomBuildMessage\fP(invoke_context, value, std::move(output\&.get()))) * enable = \fRnullptr\fP)"
Overload CustomBuildField to serialize objects that have CustomBuildMessage overloads\&. Defining a CustomBuildMessage overload is simpler than defining a CustomBuildField overload because it only requires defining a normal function, not a template function, but less flexible\&. 
.SS "template<class Rep, class Period, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::chrono::duration< Rep, Period > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"
Overload CustomBuildField and CustomReadField to serialize std::chrono parameters and return values as numbers\&. 
.SS "template<typename Output> void CustomBuildField (\fBTypeList\fP< std::exception > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, const std::exception & value, Output && output)"

.SS "template<typename Value, typename FnR, typename\&.\&.\&. FnParams, typename Output> void CustomBuildField (\fBTypeList\fP< std::function< FnR(FnParams\&.\&.\&.)> > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename KeyLocalType, typename ValueLocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::map< KeyLocalType, ValueLocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::optional< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename KeyLocalType, typename ValueLocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::pair< KeyLocalType, ValueLocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::set< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename Impl, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::shared_ptr< Impl > > , \fBPriority\fP< 2 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output, typename \fBDecay\fP< decltype(output\&.get())>::Calls * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::shared_ptr< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::string > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename KeyLocalType, typename ValueLocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::tuple< KeyLocalType, ValueLocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename Impl, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::unique_ptr< Impl > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output, typename \fBDecay\fP< decltype(output\&.get())>::Calls * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< std::vector< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"

.SS "template<typename Value, typename Output> void CustomBuildField (\fBTypeList\fP< \fBUniValue\fP > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Value && value, Output && output)"
Overload CustomBuildField and CustomReadField to serialize \fBUniValue\fP parameters and return values as JSON strings\&. 
.SS "template<typename Output> void CustomBuildField (\fBTypeList\fP<> , \fBPriority\fP< 1 > , \fBClientInvokeContext\fP & invoke_context, Output && output, typename std::enable_if< std::is_same< decltype(output\&.get()), Context::Builder >::value >::type * enable = \fRnullptr\fP)"

.SS "template<typename Output> void CustomBuildField (\fBTypeList\fP<> , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Output && output, typename std::enable_if< std::is_same< decltype(output\&.get()), ThreadMap::Client >::value >::type * enable = \fRnullptr\fP)"

.SS "void CustomBuildMessage (\fBInvokeContext\fP & invoke_context, const \fBtest::FooMessage\fP & src, test::messages::FooMessage::Builder && builder)\fR [inline]\fP"

.SS "void CustomBuildMessage (\fBInvokeContext\fP & invoke_context, const \fBtest::FooMutable\fP & src, test::messages::FooMutable::Builder && builder)\fR [inline]\fP"

.SS "template<typename\&.\&.\&. Values> bool CustomHasValue (\fBInvokeContext\fP & invoke_context, const Values &\&.\&.\&. value)"

.SS "template<typename Interface, typename Impl> std::unique_ptr< Impl > CustomMakeProxyClient (\fBInvokeContext\fP & context, typename Interface::Client && client)"

.SS "template<typename Interface, typename Impl> kj::Own< typename Interface::Server > CustomMakeProxyServer (\fBInvokeContext\fP & context, std::shared_ptr< Impl > && impl)"

.SS "template<class \fBAccessor\fP> void CustomPassField ()"

.SS "template<typename \fBAccessor\fP, typename\&.\&.\&. LocalTypes, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> auto CustomPassField (\fBTypeList\fP< LocalTypes\&.\&.\&. > , \fBServerContext\fP & server_context, Fn && fn, Args &&\&.\&.\&. args)\->decltype(\fBCustomPassMessage\fP(server_context, \fBMaybeGet\fP< \fBAccessor\fP >(server_context\&.call_context\&.getParams()), \fBMaybeGet\fP< \fBAccessor\fP >(server_context\&.call_context\&.getResults()), nullptr))"
Overload CustomPassField to serialize objects that have CustomPassMessage overloads\&. Defining a CustomPassMessage overload is simpler than defining a CustomPassField overload because it only requires defining a normal function, not a template function, but less flexible\&. 
.SS "void CustomPassMessage (\fBInvokeContext\fP & invoke_context, const test::messages::FooMutable::Reader & reader, test::messages::FooMutable::Builder builder, std::function< void(\fBtest::FooMutable\fP &)> && fn)\fR [inline]\fP"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< LocalType * > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > param, \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest, typename \fBProxyType\fP< LocalType >::Struct * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Input, typename ReadDest> 
.br
requires \fBipc::capnp::Deserializable\fP<LocalType>decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"
Overload multiprocess library's CustomReadField hook to allow any object with a deserialize constructor to be read from a capnproto Data field or returned from capnproto interface\&. Use \fBPriority<1>\fP so this hook has medium priority, and higher priority hooks could take precedence over this one\&. 
.SS "template<typename LocalType, typename Input, typename ReadDest> 
.br
requires \fBUnserializable\fP<LocalType, \fBDataStream\fP> && (!\fBipc::capnp::Deserializable\fP<LocalType>)decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"
Overload multiprocess library's CustomReadField hook to allow any object with an Unserialize method to be read from a capnproto Data field or returned from capnproto interface\&. Use \fBPriority<1>\fP so this hook has medium priority, and higher priority hooks could take precedence over this one\&. 
.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest, typename std::enable_if< std::is_enum< LocalType >::value >::type * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest, typename std::enable_if< std::is_floating_point< LocalType >::value >::type * enable = \fR0\fP)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest, typename std::enable_if< std::is_integral< LocalType >::value >::type * enable = \fRnullptr\fP)"

.SS "template<typename LocalType, typename Input, typename ReadDest> 
.br
requires (std::is_same_v<decltype(input\&.get()), ::capnp::Data::Reader> && IsByteSpan<LocalType>)decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 2 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Reader, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< LocalType > , \fBPriority\fP< 2 > , \fBInvokeContext\fP & invoke_context, Reader && reader, ReadDest && read_dest, decltype(\fBCustomReadMessage\fP(invoke_context, reader\&.get(), std::declval< LocalType & >())) * enable = \fRnullptr\fP)"
Overload CustomReadField to serialize objects that have CustomReadMessage overloads\&. Defining a CustomReadMessage overload is simpler than defining a CustomReadField overload because it only requires defining a normal function, not a template function, but less flexible\&. 
.SS "template<class Rep, class Period, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::chrono::duration< Rep, Period > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename FnR, typename\&.\&.\&. FnParams, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::function< FnR(FnParams\&.\&.\&.)> > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename KeyLocalType, typename ValueLocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::map< KeyLocalType, ValueLocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::optional< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename KeyLocalType, typename ValueLocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::pair< KeyLocalType, ValueLocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::set< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::shared_ptr< const LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::shared_ptr< LocalType > > , \fBPriority\fP< 0 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::shared_ptr< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest, typename \fBDecay\fP< decltype(input\&.get())>::Calls * enable = \fRnullptr\fP)"

.SS "template<typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::string > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename KeyLocalType, typename ValueLocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::tuple< KeyLocalType, ValueLocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::unique_ptr< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest, typename \fBDecay\fP< decltype(input\&.get())>::Calls * enable = \fRnullptr\fP)"

.SS "template<typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::vector< bool > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename LocalType, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< std::vector< LocalType > > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< \fBUniValue\fP > , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<size_t size, typename Input, typename ReadDest> decltype(auto) CustomReadField (\fBTypeList\fP< unsigned char[size]> , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, ReadDest && read_dest)"

.SS "template<typename Input> decltype(auto) CustomReadField (\fBTypeList\fP<> , \fBPriority\fP< 1 > , \fBInvokeContext\fP & invoke_context, Input && input, typename std::enable_if< std::is_same< decltype(input\&.get()), ThreadMap::Client >::value >::type * enable = \fRnullptr\fP)"

.SS "void CustomReadMessage (\fBInvokeContext\fP & invoke_context, const test::messages::FooMessage::Reader & reader, \fBtest::FooMessage\fP & dest)\fR [inline]\fP"

.SS "void CustomReadMessage (\fBInvokeContext\fP & invoke_context, const test::messages::FooMutable::Reader & reader, \fBtest::FooMutable\fP & dest)\fR [inline]\fP"

.SS "void ExecProcess (const std::vector< std::string > & args)"

.PP
Call execvp with vector args\&. 
.SS "template<class U> GuardedRef (\fBMutex\fP & , U & )\->GuardedRef< U >"

.SS "kj::StringPtr KJ_STRINGIFY (\fBLog\fP flags)"

.SS "template<typename InitInterface, typename \fBInitImpl\fP> void ListenConnections (\fBEventLoop\fP & loop, int fd, \fBInitImpl\fP & init)"
Given listening socket file descriptor and an init object, handle incoming connections and requests by calling methods on the \fBInit\fP object\&. 
.SS "std::string LogEscape (const kj::StringTree & string, size_t max_size)"
Escape binary string for use in log so it doesn't trigger unicode decode errors in python unit tests\&. 
.SS "std::string LongThreadName (const char * exe_name)"

.SS "template<template< typename\&.\&.\&. > class Class, typename\&.\&.\&. Types, typename\&.\&.\&. Args> Class< Types\&.\&.\&., std::remove_reference_t< Args >\&.\&.\&. > Make (Args &&\&.\&.\&. args)"
Construct a template class value by deducing template arguments from the types of constructor arguments, so they don't need to be specified manually\&.

.PP
Uses of this can go away with class template deduction in C++17 (https://en.cppreference.com/w/cpp/language/class_template_argument_deduction)

.PP
Example: Make<std::pair>(5, true) // Constructs std::pair<int, bool>(5, true); 
.SS "template<typename \fBAccessor\fP, typename\&.\&.\&. Types> \fBClientParam\fP< \fBAccessor\fP, Types\&.\&.\&. > MakeClientParam (Types &&\&.\&.\&. values)"

.SS "template<typename Interface, typename Impl> std::unique_ptr< Impl > MakeProxyClient (\fBInvokeContext\fP & context, typename Interface::Client && client)"

.SS "template<typename Interface, typename Impl> kj::Own< typename Interface::Server > MakeProxyServer (\fBInvokeContext\fP & context, std::shared_ptr< Impl > impl)"

.SS "template<int argc, typename \fBAccessor\fP, typename Parent> \fBServerField\fP< argc, \fBAccessor\fP, Parent > MakeServerField (Parent parent)"

.SS "template<typename\&.\&.\&. Args> void MaybeBuildField (std::false_type , Args && \&.\&.\&.)"

.SS "template<typename\&.\&.\&. Args> void MaybeBuildField (std::true_type , Args &&\&.\&.\&. args)"

.SS "template<typename \fBAccessor\fP> ::capnp::Void MaybeGet ( \&.\&.\&.)"

.SS "template<typename \fBAccessor\fP, typename Message> decltype(auto) MaybeGet (Message && message, decltype(Accessor::get(message)) * enable = \fRnullptr\fP)"
Helper for CustomPassField below\&. Call Accessor::get method if it has one, otherwise return capnp::Void\&. 
.SS "template<typename \fBAccessor\fP> ::capnp::Void MaybeInit ( \&.\&.\&.)"

.SS "template<typename \fBAccessor\fP, typename Message> decltype(auto) MaybeInit (Message && message, decltype(Accessor::get(message)) * enable = \fRnullptr\fP)"
Helper for CustomPassField below\&. Call Accessor::init method if it has one, otherwise do nothing\&. 
.SS "template<typename\&.\&.\&. Args> void MaybeReadField (std::false_type , Args && \&.\&.\&.)"

.SS "template<typename\&.\&.\&. Args> void MaybeReadField (std::true_type , Args &&\&.\&.\&. args)"

.SS "template<typename LocalTypes, typename\&.\&.\&. Args> void MaybeSetWant (LocalTypes , \fBPriority\fP< 0 > , const Args & \&.\&.\&.)"

.SS "template<typename LocalType, typename Value, typename Output> void MaybeSetWant (\fBTypeList\fP< LocalType * > , \fBPriority\fP< 1 > , const Value & value, Output && output)"

.SS "class MP_CAPABILITY ('mutex' )"

.SS "template<typename \fBAccessor\fP, typename LocalType, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> void PassField (\fBPriority\fP< 0 > , \fBTypeList\fP< LocalType > , \fBServerContext\fP & server_context, Fn && fn, Args &&\&.\&.\&. args)"

.PP
Default PassField implementation calling MaybeReadField/MaybeBuildField\&. 
.SS "template<typename \fBAccessor\fP, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> void PassField (\fBPriority\fP< 0 > , \fBTypeList\fP<> , \fBServerContext\fP & server_context, const Fn & fn, Args &&\&.\&.\&. args)"

.PP
Default PassField implementation for count(0) arguments, calling ReadField/BuildField\&. 
.SS "template<typename \fBAccessor\fP, typename LocalType, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> auto PassField (\fBPriority\fP< 1 > , \fBTypeList\fP< LocalType & > , \fBServerContext\fP & server_context, Fn && fn, Args &&\&.\&.\&. args)\->\fBRequire\fP< typenamedecltype(Accessor::get(server_context\&.call_context\&.getParams()))::Calls >"

.PP
PassField override for callable interface reference arguments\&. 
.SS "template<typename \fBAccessor\fP, typename LocalType, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> void PassField (\fBPriority\fP< 1 > , \fBTypeList\fP< LocalType * > , \fBServerContext\fP & server_context, const Fn & fn, Args &&\&.\&.\&. args)"

.PP
PassField override for C++ pointer arguments\&. 
.SS "template<typename \fBAccessor\fP, typename \fBServerContext\fP, typename Fn, typename\&.\&.\&. Args> auto PassField (\fBPriority\fP< 1 > , \fBTypeList\fP<> , \fBServerContext\fP & server_context, const Fn & fn, Args &&\&.\&.\&. args)\->typenamestd::enable_if< std::is_same< decltype(Accessor::get(server_context\&.call_context\&.getParams())), Context::Reader >::value, kj::Promise< typenameServerContext::CallContext > >::type"
PassField override for mp\&.Context arguments\&. Return asynchronously and call function on other thread found in context\&. 
.SS "template<typename \fBAccessor\fP, typename\&.\&.\&. Args> auto PassField (\fBPriority\fP< 2 > , Args &&\&.\&.\&. args)\->decltype(\fBCustomPassField\fP< \fBAccessor\fP >(std::forward< Args >(\fBargs\fP)\&.\&.\&.))"
PassField override calling CustomPassField function, if it exists\&. Defining a CustomPassField or CustomPassMessage overload is useful for input/output parameters\&. If an overload is not defined these parameters will just be deserialized on the server side with ReadField into a temporary variable, then the server method will be called passing the temporary variable as a parameter, then the temporary variable will be serialized and sent back to the client with BuildField\&. But if a PassField or PassMessage overload is defined, the overload is called with a callback to invoke and pass parameters to the server side function, and run arbitrary code before and after invoking the function\&. 
.SS "template<typename LocalType> auto ReadDestTemp ()"
Helper function to create a \fBReadDestEmplace\fP object that constructs a temporary, ReadField can return\&. 
.SS "template<typename\&.\&.\&. LocalTypes, typename\&.\&.\&. Args> decltype(auto) ReadField (\fBTypeList\fP< LocalTypes\&.\&.\&. > , Args &&\&.\&.\&. args)"

.SS "template<size_t index, typename LocalType, typename Input, typename Value> void ReadOne (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP & invoke_context, Input && input, Value && value, typename std::enable_if< index !=\fBProxyType\fP< LocalType >::fields >::type * enable = \fRnullptr\fP)"

.SS "template<size_t index, typename LocalType, typename Input, typename Value> void ReadOne (\fBTypeList\fP< LocalType > param, \fBInvokeContext\fP & invoke_context, Input & input, Value & value, typename std::enable_if< index==\fBProxyType\fP< LocalType >::fields >::type * enable = \fRnullptr\fP)"

.SS "template<typename Fn, typename Ret> auto ReplaceVoid (Fn && fn, Ret && ret)"
Invoke callable \fRfn()\fP that may return void\&. If it does return void, replace return value with value of \fR\fBret()\fP\fP\&. This is useful for avoiding code duplication and branching in generic code that forwards calls to functions\&. 
.SS "template<typename Server> void serverDestroy (Server & server)"

.SS "template<typename Server, typename CallContext, typename Fn> kj::Promise< void > serverInvoke (Server & server, CallContext & call_context, Fn fn)"
Entry point called by generated server code that looks like:

.PP
kj::Promise<void> ProxyServer<InterfaceName>::methodName(CallContext call_context) { return serverInvoke(*this, call_context, MakeServerField<0, \&.\&.\&.>(MakeServerField<1, \&.\&.\&.>(Make<ServerRet, \&.\&.\&.>(ServerCall())))); }

.PP
Ellipses above are where generated \fBAccessor<>\fP type declarations are inserted\&. 
.SS "template<typename InitInterface, typename \fBInitImpl\fP> void ServeStream (\fBEventLoop\fP & loop, int fd, \fBInitImpl\fP & init)"
Given stream file descriptor and an init object, handle requests on the stream by calling methods on the \fBInit\fP object\&. 
.SS "std::tuple< \fBConnThread\fP, bool > SetThread (\fBGuardedRef\fP< \fBConnThreads\fP > threads, \fBConnection\fP * connection, const std::function< Thread::Client()> & make_thread)"

.SS "int SpawnProcess (int & pid, \fBFdToArgsFn\fP && fd_to_args)"
Spawn a new process that communicates with the current process over a socket pair\&. Returns pid through an output argument, and file descriptor for the local side of the socket\&. Invokes fd_to_args callback with the remote file descriptor number which returns the command line arguments that should be used to execute the process, and which should have the remote file descriptor embedded in whatever format the child process expects\&. 
.SS "std::string ThreadName (const char * exe_name)"

.PP
\fBFormat\fP current thread name as "{exe_name}-{$pid}/{thread_name}-{$tid}"\&. 
.SS "template<typename LocalType, typename Input> void ThrowField (\fBTypeList\fP< LocalType > , \fBInvokeContext\fP & invoke_context, Input && input)"

.SS "template<typename Input> void ThrowField (\fBTypeList\fP< std::exception > , \fBInvokeContext\fP & invoke_context, Input && input)"
Special case for generic std::exception\&. It's an abstract type so it can't be created directly\&. Rethrow as std::runtime_error so callers expecting it will still catch it\&. 
.SS "template<typename \fBT\fP> const char * TypeName ()"

.PP
Return capnp type name with filename prefix removed\&. 
.SS "template<typename \fBLock\fP, typename Callback> void Unlock (\fBLock\fP & lock, Callback && callback)"

.SS "int WaitProcess (int pid)"

.PP
Wait for a process to exit and return its exit code\&. 
.SH "Variable Documentation"
.PP 
.SS "\fBThreadContext\fP g_thread_context\fR [thread_local]\fP"

.SS "std::atomic< int > server_reqs {0}"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
