.TH "Chainstate" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Chainstate
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <validation\&.h>\fP
.PP
Inherited by \fBDummyChainState\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBChainstate\fP (\fBCTxMemPool\fP *mempool, \fBnode::BlockManager\fP &blockman, \fBChainstateManager\fP &chainman, std::optional< \fBuint256\fP > from_snapshot_blockhash=std::nullopt)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBStoragePath\fP () const"
.br
.RI "Return path to chainstate leveldb directory\&. "
.ti -1c
.RI "\fBkernel::ChainstateRole\fP GetRole() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void \fBInitCoinsDB\fP (size_t cache_size_bytes, bool in_memory, bool should_wipe)"
.br
.ti -1c
.RI "void InitCoinsCache(size_t cache_size_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool \fBCanFlushToDisk\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBAssumeutxo\fP m_assumeutxo \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "std::optional< \fBuint256\fP > m_target_blockhash \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "std::optional< \fBAssumeutxoHash\fP > m_target_utxohash \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "\fBCCoinsViewCache\fP & \fBCoinsTip\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBCCoinsViewDB\fP & \fBCoinsDB\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBCTxMemPool\fP * \fBGetMempool\fP ()"
.br
.ti -1c
.RI "\fBCCoinsViewErrorCatcher\fP & \fBCoinsErrorCatcher\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "void \fBResetCoinsViews\fP ()"
.br
.RI "Destructs all objects related to accessing the UTXO set\&. "
.ti -1c
.RI "bool ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool \fBFlushStateToDisk\fP (\fBBlockValidationState\fP &state, \fBFlushStateMode\fP mode, int nManualPruneHeight=0)"
.br
.ti -1c
.RI "void \fBForceFlushStateToDisk\fP ()"
.br
.RI "Unconditionally flush all changes to disk\&. "
.ti -1c
.RI "void \fBPruneAndFlush\fP ()"
.br
.ti -1c
.RI "bool \fBDisconnectTip\fP (\fBBlockValidationState\fP &state, \fBDisconnectedBlockTransactions\fP *disconnectpool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.ti -1c
.RI "bool \fBReplayBlocks\fP ()"
.br
.ti -1c
.RI "bool \fBNeedsRedownload\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBLoadGenesisBlock\fP ()"
.br
.ti -1c
.RI "void \fBTryAddBlockIndexCandidate\fP (\fBCBlockIndex\fP *pindex) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBPruneBlockIndexCandidates\fP ()"
.br
.ti -1c
.RI "void ClearBlockIndexCandidates() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP * \fBFindForkInGlobalIndex\fP (const \fBCBlockLocator\fP &locator) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBLoadChainTip\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCoinsCacheSizeState\fP GetCoinsCacheSizeState() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCoinsCacheSizeState\fP GetCoinsCacheSizeState(size_t max_coins_cache_size_bytes, size_t max_mempool_size_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::string \fBToString\fP() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBRecursiveMutex\fP * \fBMempoolMutex\fP () const \fBLOCK_RETURNED\fP(\fBm_mempool\fP \-> \fBcs\fP)"
.br
.RI "Indirection necessary to make lock annotations work with an optional mempool\&. "
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBnode::BlockManager\fP & \fBm_blockman\fP"
.br
.ti -1c
.RI "\fBChainstateManager\fP & \fBm_chainman\fP"
.br
.ti -1c
.RI "\fBCChain\fP \fBm_chain\fP"
.br
.ti -1c
.RI "const std::optional< \fBuint256\fP > \fBm_from_snapshot_blockhash\fP"
.br
.ti -1c
.RI "const \fBCBlockIndex\fP *SnapshotBase() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP *TargetBlock() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void SetTargetBlock(\fBCBlockIndex\fP *block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void SetTargetBlockHash(\fBuint256\fP block_hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo \fBReachedTarget\fP )() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.RI "Return true if chainstate reached target block\&. "
.ti -1c
.RI "std::set< \fBCBlockIndex\fP *, \fBnode::CBlockIndexWorkComparator\fP > \fBsetBlockIndexCandidates\fP"
.br
.ti -1c
.RI "size_t \fBm_coinsdb_cache_size_bytes\fP {0}"
.br
.RI "The cache size of the on-disk coins view\&. "
.ti -1c
.RI "size_t \fBm_coinstip_cache_size_bytes\fP {0}"
.br
.RI "The cache size of the in-memory coins view\&. "
.ti -1c
.RI "bool ActivateBestChain(\fBBlockValidationState\fP &state, std::shared_ptr< const \fBCBlock\fP > pblock=nullptr) \fBLOCKS_EXCLUDED\fP(\fBDisconnectResult\fP DisconnectBlock(const \fBCBlock\fP &block, const \fBCBlockIndex\fP *pindex, \fBCCoinsViewCache\fP &view) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo \fBConnectBlock\fP )(const \fBCBlock\fP &block, \fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindex, \fBCCoinsViewCache\fP &view, bool fJustCheck=false) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBm_mempool\fP \fBcs\fP"
.br
.ti -1c
.RI "bool PreciousBlock(\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindex) \fBLOCKS_EXCLUDED\fP(bool \fBInvalidateBlock\fP(\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindex) \fBLOCKS_EXCLUDED\fP(void SetBlockFailureFlags(\fBCBlockIndex\fP *pindex) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(voi \fBResetBlockFailureFlags\fP )(\fBCBlockIndex\fP *pindex) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "const \fBCBlockIndex\fP *m_cached_snapshot_base \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.RI "Cached result of LookupBlockIndex(*m_from_snapshot_blockhash)\&. "
.ti -1c
.RI "const \fBCBlockIndex\fP *m_cached_target_block \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.RI "Cached result of LookupBlockIndex(*m_target_blockhash)\&. "
.ti -1c
.RI "std::optional< const char * > m_last_script_check_reason_logged \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "bool \fBActivateBestChainStep\fP (\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindexMostWork, const std::shared_ptr< const \fBCBlock\fP > &pblock, bool &fInvalidFound, \fBConnectTrace\fP &connectTrace) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.ti -1c
.RI "bool \fBConnectTip\fP (\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindexNew, std::shared_ptr< const \fBCBlock\fP > block_to_connect, \fBConnectTrace\fP &connectTrace, \fBDisconnectedBlockTransactions\fP &disconnectpool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.ti -1c
.RI "void \fBInvalidBlockFound\fP (\fBCBlockIndex\fP *pindex, const \fBBlockValidationState\fP &state) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBFindMostWorkChain\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBRollforwardBlock\fP (const \fBCBlockIndex\fP *pindex, \fBCCoinsViewCache\fP &inputs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBCheckForkWarningConditions\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBInvalidChainFound\fP (\fBCBlockIndex\fP *pindexNew) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBMaybeUpdateMempoolForReorg\fP (\fBDisconnectedBlockTransactions\fP &disconnectpool, bool fAddToMempool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBMutex\fP \fBm_chainstate_mutex\fP"
.br
.ti -1c
.RI "\fBCTxMemPool\fP * \fBm_mempool\fP"
.br
.ti -1c
.RI "std::unique_ptr< \fBCoinsViews\fP > \fBm_coins_views\fP"
.br
.RI "Manages the UTXO set, which is a reflection of the contents of \fR\fBm_chain\fP\fP\&. "
.ti -1c
.RI "void \fBm_mempool\fP \fBcs\fP"
.br
.ti -1c
.RI "void UpdateTip(const \fBCBlockIndex\fP *pindexNew) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(NodeClock::time_poin \fBm_next_write\fP ) {NodeClock::time_point::max()}"
.br
.ti -1c
.RI "\fButil::Result\fP< void > InvalidateCoinsDBOnDisk() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(friend \fBChainstateManager\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBChainstate\fP stores and provides an API to update our local knowledge of the current best chain\&.

.PP
Eventually, the API here is targeted at being exposed externally as a consumable library, so any functions added must only call other class member functions, pure functions in other parts of the consensus library, callbacks via the validation interface, or read/write-to-disk functions (eventually this will also be via callbacks)\&.

.PP
Anything that is contingent on the current tip of the chain is stored here, whereas block information and metadata independent of the current tip is kept in \fR\fBBlockManager\fP\fP\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBChainstate\fP (\fBCTxMemPool\fP * mempool, \fBnode::BlockManager\fP & blockman, \fBChainstateManager\fP & chainman, std::optional< \fBuint256\fP > from_snapshot_blockhash = \fRstd::nullopt\fP)\fR [explicit]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool ActivateBestChainStep (\fBBlockValidationState\fP & state, \fBCBlockIndex\fP * pindexMostWork, const std::shared_ptr< const \fBCBlock\fP > & pblock, bool & fInvalidFound, \fBConnectTrace\fP & connectTrace)\fR [protected]\fP"
Return the [start, end] (inclusive) of block heights we can prune\&.

.PP
start > end is possible, meaning no blocks can be pruned\&.

.PP
Try to make some progress towards making pindexMostWork the active block\&. pblock is either nullptr or a pointer to a \fBCBlock\fP corresponding to pindexMostWork\&.

.PP
\fBReturns\fP
.RS 4
true unless a system error occurred 
.RE
.PP

.SS "void InitCoinsCache(size_t cache_size_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool CanFlushToDisk () const\fR [inline]\fP"
Initialize the in-memory coins cache (to be done after the health of the on-disk database is verified)\&.

.PP
\fBReturns\fP
.RS 4
whether or not the \fBCoinsViews\fP object has been fully initialized and we can safely flush this object to disk\&. 
.RE
.PP

.SS "void CheckForkWarningConditions ()\fR [protected]\fP"

.SS "\fBCCoinsViewDB\fP & CoinsDB ()\fR [inline]\fP"

.PP
\fBReturns\fP
.RS 4
A reference to the on-disk UTXO set database\&. 
.RE
.PP

.SS "\fBCCoinsViewErrorCatcher\fP & CoinsErrorCatcher ()\fR [inline]\fP"

.PP
\fBReturns\fP
.RS 4
A reference to a wrapped view of the in-memory UTXO set that handles disk read errors gracefully\&. 
.RE
.PP

.SS "\fBCCoinsViewCache\fP & CoinsTip ()\fR [inline]\fP"

.PP
\fBReturns\fP
.RS 4
A reference to the in-memory cache of the UTXO set\&. 
.RE
.PP

.SS "bool ConnectTip (\fBBlockValidationState\fP & state, \fBCBlockIndex\fP * pindexNew, std::shared_ptr< const \fBCBlock\fP > block_to_connect, \fBConnectTrace\fP & connectTrace, \fBDisconnectedBlockTransactions\fP & disconnectpool)\fR [protected]\fP"
Connect a new block to m_chain\&. block_to_connect is either nullptr or a pointer to a \fBCBlock\fP corresponding to pindexNew, to bypass loading it again from disk\&.

.PP
The block is added to connectTrace if connection succeeds\&. 
.SS "bool DisconnectTip (\fBBlockValidationState\fP & state, \fBDisconnectedBlockTransactions\fP * disconnectpool)"
Disconnect m_chain's tip\&. After calling, the mempool will be in an inconsistent state, with transactions from disconnected blocks being added to disconnectpool\&. You should make the mempool consistent again by calling MaybeUpdateMempoolForReorg\&. with cs_main held\&.

.PP
If disconnectpool is nullptr, then no disconnected transactions are added to disconnectpool (note that the caller is responsible for mempool consistency in any case)\&. 
.SS "const \fBCBlockIndex\fP * FindForkInGlobalIndex (const \fBCBlockLocator\fP & locator) const"
Find the last common block of this chain and a locator\&. 
.SS "\fBCBlockIndex\fP * FindMostWorkChain ()\fR [protected]\fP"
Return the tip of the chain with the most work in it, that isn't known to be invalid (it's however far from certain to be valid)\&. 
.SS "bool FlushStateToDisk (\fBBlockValidationState\fP & state, \fBFlushStateMode\fP mode, int nManualPruneHeight = \fR0\fP)"
Resize the \fBCoinsViews\fP caches dynamically and flush state to disk\&. 
.PP
\fBReturns\fP
.RS 4
true unless an error occurred during the flush\&. Update the on-disk chain state\&. The caches and indexes are flushed depending on the mode we're called with if they're too large, if it's been a while since the last write, or always and in all cases if we're in prune mode and are deleting files\&.
.RE
.PP
If \fBFlushStateMode::NONE\fP is used, then FlushStateToDisk(\&.\&.\&.) won't do anything besides checking if we need to prune\&.

.PP
\fBReturns\fP
.RS 4
true unless a system error occurred 
.RE
.PP

.SS "void ForceFlushStateToDisk ()"

.PP
Unconditionally flush all changes to disk\&. 
.SS "\fBCTxMemPool\fP * GetMempool ()\fR [inline]\fP"

.PP
\fBReturns\fP
.RS 4
A pointer to the mempool\&. 
.RE
.PP

.SS "std::optional< \fBAssumeutxoHash\fP > m_target_utxohash GUARDED_BY (\fB::cs_main\fP )"
Hash of the UTXO set at the target block, computed when the chainstate reaches the target block, and null before then\&. 
.SS "std::optional< \fBuint256\fP > m_target_blockhash GUARDED_BY (\fB::cs_main\fP )"
Target block for this chainstate\&. If this is not set, chainstate will target the most-work, valid block\&. If this is set, \fBChainstateManager\fP considers this a "historical" chainstate since it will only contain old blocks up to the target block, not newer blocks\&. 
.SS "\fBAssumeutxo\fP m_assumeutxo GUARDED_BY (\fB::cs_main\fP )"
\fBAssumeutxo\fP state indicating whether all blocks in the chain were validated, or if the chainstate is based on an assumeutxo snapshot and the snapshot has not been validated\&. 
.SS "std::optional< const char * > m_last_script_check_reason_logged GUARDED_BY (\fB::cs_main\fP )\fR [inline]\fP, \fR [protected]\fP"

.SS "const \fBCBlockIndex\fP *m_cached_target_block GUARDED_BY (\fB::cs_main\fP )\fR [inline]\fP, \fR [mutable]\fP, \fR [protected]\fP"

.PP
Cached result of LookupBlockIndex(*m_target_blockhash)\&. 
.SS "const \fBCBlockIndex\fP *m_cached_snapshot_base GUARDED_BY (\fB::cs_main\fP )\fR [inline]\fP, \fR [mutable]\fP, \fR [protected]\fP"

.PP
Cached result of LookupBlockIndex(*m_from_snapshot_blockhash)\&. 
.SS "void InitCoinsDB (size_t cache_size_bytes, bool in_memory, bool should_wipe)"
Return the current role of the chainstate\&. See \fR\fBChainstateManager\fP\fP documentation for a description of the different types of chainstates\&.

.PP
\fBSee also\fP
.RS 4
\fBChainstateRole\fP Initialize the \fBCoinsViews\fP UTXO set database management data structures\&. The in-memory cache is initialized separately\&.
.RE
.PP
All parameters forwarded to \fBCoinsViews\fP\&. 
.SS "void InvalidBlockFound (\fBCBlockIndex\fP * pindex, const \fBBlockValidationState\fP & state)\fR [protected]\fP"

.SS "void InvalidChainFound (\fBCBlockIndex\fP * pindexNew)\fR [protected]\fP"

.SS "bool LoadChainTip ()"
Update the chain tip based on database information, i\&.e\&. \fBCoinsTip()\fP's best block\&. 
.SS "bool LoadGenesisBlock ()"
Ensures we have a genesis block in the block tree, possibly writing one to disk\&. 
.SS "void MaybeUpdateMempoolForReorg (\fBDisconnectedBlockTransactions\fP & disconnectpool, bool fAddToMempool)\fR [protected]\fP"
Make mempool consistent after a reorg, by re-adding or recursively erasing disconnected block transactions from the mempool, and also removing any other transactions from the mempool that are no longer valid given the new tip/height\&.

.PP
Note: we assume that disconnectpool only contains transactions that are NOT confirmed in the current chain nor already in the mempool (otherwise, in-mempool descendants of such transactions would be removed)\&.

.PP
Passing fAddToMempool=false will skip trying to add the transactions back, and instead just erase from the mempool as needed\&. 
.SS "\fBCoinsCacheSizeState\fP GetCoinsCacheSizeState() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCoinsCacheSizeState\fP GetCoinsCacheSizeState(size_t max_coins_cache_size_bytes, size_t max_mempool_size_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::string \fBToString\fP() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBRecursiveMutex\fP * MempoolMutex () const\->\fBcs\fP)\fR [inline]\fP"

.PP
Indirection necessary to make lock annotations work with an optional mempool\&. Dictates whether we need to flush the cache to disk or not\&.

.PP
\fBReturns\fP
.RS 4
the state of the size of the coins cache\&. 
.RE
.PP

.SS "bool NeedsRedownload () const\fR [nodiscard]\fP"
Whether the chain state needs to be redownloaded due to lack of witness data 
.SS "void PruneAndFlush ()"
Prune blockfiles from the disk if necessary and then flush chainstate changes if we pruned\&. 
.SS "void PruneBlockIndexCandidates ()"
Delete all entries in setBlockIndexCandidates that are worse than the current tip\&. 
.SS "bool ReplayBlocks ()"
Replay blocks that aren't fully applied to the database\&. 
.SS "void ResetCoinsViews ()\fR [inline]\fP"

.PP
Destructs all objects related to accessing the UTXO set\&. 
.SS "bool RollforwardBlock (const \fBCBlockIndex\fP * pindex, \fBCCoinsViewCache\fP & inputs)\fR [protected]\fP"
Apply the effects of a block on the utxo cache, ignoring that it may already have been applied\&. 
.SS "\fBfs::path\fP StoragePath () const"

.PP
Return path to chainstate leveldb directory\&. 
.SS "void TryAddBlockIndexCandidate (\fBCBlockIndex\fP * pindex)"

.SH "Field Documentation"
.PP 
.SS "\fButil::Result\fP<void> InvalidateCoinsDBOnDisk () \fBEXCLUSIVE_LOCKS_REQUIRED\fP( friend \fBChainstateManager\fP\fR [nodiscard]\fP, \fR [protected]\fP"
In case of an invalid snapshot, rename the coins leveldb directory so that it can be examined for issue diagnosis\&. 
.SS "bool ConnectBlock"
Find the best known block, and make it the tip of the block chain\&. The result is either failure or an activated best chain\&. pblock is either nullptr or a pointer to a block that is already loaded (to avoid loading it again from disk)\&.

.PP
ActivateBestChain is split into steps (see ActivateBestChainStep) so that we avoid holding cs_main for an extended period of time; the length of this call may be quite long during reindexing or a substantial reorg\&.

.PP
May not be called with cs_main held\&. May not be called in a validationinterface callback\&.

.PP
Note that if this is called while a snapshot chainstate is active, and if it is called on a validated chainstate whose tip has reached the base block of the snapshot, its execution will take \fIMINUTES\fP while it hashes the UTXO set to verify the assumeutxo value the snapshot was activated with\&. \fR\fBcs_main\fP\fP will be held during this time\&.

.PP
\fBReturns\fP
.RS 4
true unless a system error occurred
.RE
.PP
Apply the effects of this block (with given index) on the UTXO set represented by coins\&. Validity checks that depend on the UTXO set are also done; \fBConnectBlock()\fP can fail if those validity checks fail (among other reasons)\&. 
.SS "void \fBm_mempool\fP cs\fR [protected]\fP"

.SS "bool \fBm_mempool\fP cs"

.SS "\fBnode::BlockManager\fP& m_blockman"
Reference to a \fBBlockManager\fP instance which itself is shared across all \fBChainstate\fP instances\&. 
.SS "\fBCChain\fP m_chain"
The current chain of blockheaders we consult and build on\&. 
.PP
\fBSee also\fP
.RS 4
\fBCChain\fP, \fBCBlockIndex\fP\&. 
.RE
.PP

.SS "\fBChainstateManager\fP& m_chainman"
The chainstate manager that owns this chainstate\&. The reference is necessary so that this instance can check whether it is the active chainstate within deeply nested method calls\&. 
.SS "\fBMutex\fP m_chainstate_mutex\fR [protected]\fP"
The ChainState \fBMutex\fP A lock that must be held when modifying this ChainState - held in ActivateBestChain() and \fBInvalidateBlock()\fP 
.SS "std::unique_ptr<\fBCoinsViews\fP> m_coins_views\fR [protected]\fP"

.PP
Manages the UTXO set, which is a reflection of the contents of \fR\fBm_chain\fP\fP\&. 
.SS "size_t m_coinsdb_cache_size_bytes {0}"

.PP
The cache size of the on-disk coins view\&. 
.SS "size_t m_coinstip_cache_size_bytes {0}"

.PP
The cache size of the in-memory coins view\&. 
.SS "const std::optional<\fBuint256\fP> m_from_snapshot_blockhash"
The blockhash which is the base of the snapshot this chainstate was created from\&.

.PP
std::nullopt if this chainstate was not created from a snapshot\&. 
.SS "\fBCTxMemPool\fP* m_mempool\fR [protected]\fP"
Optional mempool that is kept in sync with the chain\&. Only the active chainstate has a mempool\&. 
.SS "void UpdateTip (const \fBCBlockIndex\fP* pindexNew) \fBEXCLUSIVE_LOCKS_REQUIRED\fP( NodeClock::time_poin m_next_write)  {NodeClock::time_point::max()}\fR [protected]\fP"
Check warning conditions and do some notifications on new chain tip set\&. 
.SS "const \fBCBlockIndex\fP *SnapshotBase() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP *TargetBlock() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void SetTargetBlock(\fBCBlockIndex\fP *block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void SetTargetBlockHash(\fBuint256\fP block_hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo ReachedTarget) () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fR [inline]\fP"

.PP
Return true if chainstate reached target block\&. The base of the snapshot this chainstate was created from\&.

.PP
nullptr if this chainstate was not created from a snapshot\&.

.PP
Return target block which chainstate tip is expected to reach, if this is a historic chainstate being used to validate a snapshot, or null if chainstate targets the most-work block\&.

.PP
Set target block for this chainstate\&. If null, chainstate will target the most-work valid block\&. If non-null chainstate will be a historic chainstate and target the specified block\&.

.PP
Set target block for this chainstate using just a block hash\&. Useful when the block database has not been loaded yet\&. 
.SS "void ResetBlockFailureFlags"
Mark a block as precious and reorganize\&.

.PP
May not be called in a validationinterface callback\&. Mark a block as invalid\&. Set invalidity status to all descendants of a block Remove invalidity status from a block, its descendants and ancestors and reconsider them for activation 
.SS "std::set<\fBCBlockIndex\fP*, \fBnode::CBlockIndexWorkComparator\fP> setBlockIndexCandidates"
The set of all \fBCBlockIndex\fP entries that have as much work as our current tip or more, and transaction data needed to be validated (with BLOCK_VALID_TRANSACTIONS for each block and its parents back to the genesis block or an assumeutxo snapshot block)\&. Entries may be failed, though, and pruning nodes may be missing the data for the block\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
