.TH "src/secp256k1/src/field.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/secp256k1/src/field.h
.SH SYNOPSIS
.br
.PP
\fR#include 'util\&.h'\fP
.br
\fR#include 'field_5x52\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSECP256K1_FE_VERIFY_FIELDS\fP"
.br
.ti -1c
.RI "#define \fBSECP256K1_FE_VERIFY_CONST\fP(d7,  d6,  d5,  d4,  d3,  d2,  d1,  d0)"
.br
.ti -1c
.RI "#define \fBSECP256K1_FE_CONST\fP(d7,  d6,  d5,  d4,  d3,  d2,  d1,  d0)"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_normalize\fP   secp256k1_fe_impl_normalize"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_normalize_weak\fP   secp256k1_fe_impl_normalize_weak"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_normalize_var\fP   secp256k1_fe_impl_normalize_var"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_normalizes_to_zero\fP   secp256k1_fe_impl_normalizes_to_zero"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_normalizes_to_zero_var\fP   secp256k1_fe_impl_normalizes_to_zero_var"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_set_int\fP   secp256k1_fe_impl_set_int"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_is_zero\fP   secp256k1_fe_impl_is_zero"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_is_odd\fP   secp256k1_fe_impl_is_odd"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_cmp_var\fP   secp256k1_fe_impl_cmp_var"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_set_b32_mod\fP   secp256k1_fe_impl_set_b32_mod"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_set_b32_limit\fP   secp256k1_fe_impl_set_b32_limit"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_get_b32\fP   secp256k1_fe_impl_get_b32"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_negate_unchecked\fP   secp256k1_fe_impl_negate_unchecked"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_mul_int_unchecked\fP   secp256k1_fe_impl_mul_int_unchecked"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_add\fP   secp256k1_fe_impl_add"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_mul\fP   secp256k1_fe_impl_mul"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_sqr\fP   secp256k1_fe_impl_sqr"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_cmov\fP   secp256k1_fe_impl_cmov"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_to_storage\fP   secp256k1_fe_impl_to_storage"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_from_storage\fP   secp256k1_fe_impl_from_storage"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_inv\fP   secp256k1_fe_impl_inv"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_inv_var\fP   secp256k1_fe_impl_inv_var"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_get_bounds\fP   secp256k1_fe_impl_get_bounds"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_half\fP   secp256k1_fe_impl_half"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_add_int\fP   secp256k1_fe_impl_add_int"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_is_square_var\fP   secp256k1_fe_impl_is_square_var"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_negate\fP(r,  a,  m)"
.br
.ti -1c
.RI "#define \fBsecp256k1_fe_mul_int\fP(r,  a)"
.br
.ti -1c
.RI "#define \fBSECP256K1_FE_VERIFY\fP(a)"
.br
.ti -1c
.RI "#define \fBSECP256K1_FE_VERIFY_MAGNITUDE\fP(a,  m)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define secp256k1_fe_add   secp256k1_fe_impl_add"

.SS "#define secp256k1_fe_add_int   secp256k1_fe_impl_add_int"

.SS "#define secp256k1_fe_cmov   secp256k1_fe_impl_cmov"

.SS "#define secp256k1_fe_cmp_var   secp256k1_fe_impl_cmp_var"

.SS "#define SECP256K1_FE_CONST( d7,  d6,  d5,  d4,  d3,  d2,  d1,  d0)"
\fBValue:\fP
.nf
{SECP256K1_FE_CONST_INNER((d7), (d6), (d5), (d4), (d3), (d2), (d1), (d0)) SECP256K1_FE_VERIFY_CONST((d7), (d6), (d5), (d4), (d3), (d2), (d1), (d0)) }
.PP
.fi
This expands to an initializer for a \fBsecp256k1_fe\fP valued sum((i*32) * d_i, i=0\&.\&.7) mod p\&.

.PP
It has magnitude 1, unless d_i are all 0, in which case the magnitude is 0\&. It is normalized, unless sum(2^(i*32) * d_i, i=0\&.\&.7) >= p\&.

.PP
SECP256K1_FE_CONST_INNER is provided by the implementation\&. 
.SS "#define secp256k1_fe_from_storage   secp256k1_fe_impl_from_storage"

.SS "#define secp256k1_fe_get_b32   secp256k1_fe_impl_get_b32"

.SS "#define secp256k1_fe_get_bounds   secp256k1_fe_impl_get_bounds"

.SS "#define secp256k1_fe_half   secp256k1_fe_impl_half"

.SS "#define secp256k1_fe_inv   secp256k1_fe_impl_inv"

.SS "#define secp256k1_fe_inv_var   secp256k1_fe_impl_inv_var"

.SS "#define secp256k1_fe_is_odd   secp256k1_fe_impl_is_odd"

.SS "#define secp256k1_fe_is_square_var   secp256k1_fe_impl_is_square_var"

.SS "#define secp256k1_fe_is_zero   secp256k1_fe_impl_is_zero"

.SS "#define secp256k1_fe_mul   secp256k1_fe_impl_mul"

.SS "#define secp256k1_fe_mul_int( r,  a)"
\fBValue:\fP
.nf
ASSERT_INT_CONST_AND_DO(a, secp256k1_fe_mul_int_unchecked(r, a))
.PP
.fi
Multiply a field element with a small integer\&.

.PP
On input, r must be a valid field element\&. a must be an integer constant expression in [0,32]\&. The magnitude of r times a must not exceed 32\&. Performs {r *= a}\&. On output, r's magnitude is multiplied by a, and r will not be normalized\&. 
.SS "#define secp256k1_fe_mul_int_unchecked   secp256k1_fe_impl_mul_int_unchecked"

.SS "#define secp256k1_fe_negate( r,  a,  m)"
\fBValue:\fP
.nf
ASSERT_INT_CONST_AND_DO(m, secp256k1_fe_negate_unchecked(r, a, m))
.PP
.fi
Negate a field element\&.

.PP
On input, r does not need to be initialized\&. a must be a valid field element with magnitude not exceeding m\&. m must be an integer constant expression in [0,31]\&. Performs {r = -a}\&. On output, r will not be normalized, and will have magnitude m+1\&. 
.SS "#define secp256k1_fe_negate_unchecked   secp256k1_fe_impl_negate_unchecked"

.SS "#define secp256k1_fe_normalize   secp256k1_fe_impl_normalize"

.SS "#define secp256k1_fe_normalize_var   secp256k1_fe_impl_normalize_var"

.SS "#define secp256k1_fe_normalize_weak   secp256k1_fe_impl_normalize_weak"

.SS "#define secp256k1_fe_normalizes_to_zero   secp256k1_fe_impl_normalizes_to_zero"

.SS "#define secp256k1_fe_normalizes_to_zero_var   secp256k1_fe_impl_normalizes_to_zero_var"

.SS "#define secp256k1_fe_set_b32_limit   secp256k1_fe_impl_set_b32_limit"

.SS "#define secp256k1_fe_set_b32_mod   secp256k1_fe_impl_set_b32_mod"

.SS "#define secp256k1_fe_set_int   secp256k1_fe_impl_set_int"

.SS "#define secp256k1_fe_sqr   secp256k1_fe_impl_sqr"

.SS "#define secp256k1_fe_to_storage   secp256k1_fe_impl_to_storage"

.SS "#define SECP256K1_FE_VERIFY( a)"
\fBValue:\fP
.nf
secp256k1_fe_verify(a)
.PP
.fi

.SS "#define SECP256K1_FE_VERIFY_CONST( d7,  d6,  d5,  d4,  d3,  d2,  d1,  d0)"

.SS "#define SECP256K1_FE_VERIFY_FIELDS"

.SS "#define SECP256K1_FE_VERIFY_MAGNITUDE( a,  m)"
\fBValue:\fP
.nf
secp256k1_fe_verify_magnitude(a, m)
.PP
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
