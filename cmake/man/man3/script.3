.TH "script" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
script
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBConst\fP (const std::string &str, std::span< const char > &sp, bool skip)"
.br
.ti -1c
.RI "bool \fBFunc\fP (const std::string &str, std::span< const char > &sp)"
.br
.ti -1c
.RI "std::span< const char > \fBExpr\fP (std::span< const char > &sp)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "bool Const (const std::string & str, std::span< const char > & sp, bool skip = \fRtrue\fP)"
Parse a constant\&.

.PP
If sp's initial part matches str, sp is optionally updated to skip that part, and true is returned\&. Otherwise sp is unmodified and false is returned\&. 
.SS "std::span< const char > Expr (std::span< const char > & sp)"
Extract the expression that sp begins with\&.

.PP
This function will return the initial part of sp, up to (but not including) the first comma or closing brace, skipping ones that are surrounded by braces\&. So for example, for "foo(bar(1),2),3" the initial part "foo(bar(1),2)" will be returned\&. sp will be updated to skip the initial part that is returned\&. 
.SS "bool Func (const std::string & str, std::span< const char > & sp)"
Parse a function call\&.

.PP
If sp's initial part matches str + "(", and sp ends with ")", sp is updated to be the section between the braces, and true is returned\&. Otherwise sp is unmodified and false is returned\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
