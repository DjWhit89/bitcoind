.TH "src/util/strencodings.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/util/strencodings.h
.SH SYNOPSIS
.br
.PP
\fR#include <crypto/hex_base\&.h>\fP
.br
\fR#include <span\&.h>\fP
.br
\fR#include <util/string\&.h>\fP
.br
\fR#include <array>\fP
.br
\fR#include <bit>\fP
.br
\fR#include <charconv>\fP
.br
\fR#include <cstddef>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <limits>\fP
.br
\fR#include <optional>\fP
.br
\fR#include <string>\fP
.br
\fR#include <string_view>\fP
.br
\fR#include <system_error>\fP
.br
\fR#include <type_traits>\fP
.br
\fR#include <vector>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBHex< N >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fButil\fP"
.br
.ti -1c
.RI "namespace \fButil::detail\fP"
.br
.ti -1c
.RI "namespace \fButil::hex_literals\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBSafeChars\fP { \fBSAFE_CHARS_DEFAULT\fP, \fBSAFE_CHARS_UA_COMMENT\fP, \fBSAFE_CHARS_FILENAME\fP, \fBSAFE_CHARS_URI\fP }"
.br
.ti -1c
.RI "enum class \fBByteUnit\fP : uint64_t { \fBNOOP\fP = 1ULL, \fBk\fP = 1000ULL, \fBK\fP = 1024ULL, \fBm\fP = 1'000'000ULL, \fBM\fP = 1ULL << 20, \fBg\fP = 1'000'000'000ULL, \fBG\fP = 1ULL << 30, \fBt\fP = 1'000'000'000'000ULL, \fBT\fP = 1ULL << 40 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "std::string \fBSanitizeString\fP (std::string_view str, int rule=\fBSAFE_CHARS_DEFAULT\fP)"
.br
.ti -1c
.RI "template<typename Byte = std::byte> std::optional< std::vector< Byte > > \fBTryParseHex\fP (std::string_view str)"
.br
.ti -1c
.RI "template<typename Byte = uint8_t> std::vector< Byte > \fBParseHex\fP (std::string_view hex_str)"
.br
.ti -1c
.RI "bool \fBIsHex\fP (std::string_view str)"
.br
.ti -1c
.RI "std::optional< std::vector< unsigned char > > \fBDecodeBase64\fP (std::string_view str)"
.br
.ti -1c
.RI "std::string \fBEncodeBase64\fP (std::span< const unsigned char > input)"
.br
.ti -1c
.RI "std::string \fBEncodeBase64\fP (std::span< const std::byte > input)"
.br
.ti -1c
.RI "std::string \fBEncodeBase64\fP (std::string_view str)"
.br
.ti -1c
.RI "std::optional< std::vector< unsigned char > > \fBDecodeBase32\fP (std::string_view str)"
.br
.ti -1c
.RI "std::string \fBEncodeBase32\fP (std::span< const unsigned char > input, bool pad=true)"
.br
.ti -1c
.RI "std::string \fBEncodeBase32\fP (std::string_view str, bool pad=true)"
.br
.ti -1c
.RI "bool \fBSplitHostPort\fP (std::string_view in, uint16_t &portOut, std::string &hostOut)"
.br
.ti -1c
.RI "template<typename \fBT\fP> \fBT\fP \fBLocaleIndependentAtoi\fP (std::string_view str)"
.br
.ti -1c
.RI "constexpr bool \fBIsDigit\fP (char c)"
.br
.ti -1c
.RI "constexpr bool \fBIsSpace\fP (char c) noexcept"
.br
.ti -1c
.RI "template<typename \fBT\fP> std::optional< \fBT\fP > \fBToIntegral\fP (std::string_view str)"
.br
.ti -1c
.RI "std::string \fBFormatParagraph\fP (std::string_view in, size_t width=79, size_t indent=0)"
.br
.ti -1c
.RI "template<typename \fBT\fP> bool \fBTimingResistantEqual\fP (const \fBT\fP &a, const \fBT\fP &b)"
.br
.ti -1c
.RI "bool \fBParseFixedPoint\fP (std::string_view, int decimals, int64_t *amount_out)"
.br
.ti -1c
.RI "template<int frombits, int tobits, bool pad, typename O, typename It, typename I = IntIdentity> bool \fBConvertBits\fP (O outfn, It it, It end, I infn={})"
.br
.ti -1c
.RI "constexpr char \fBToLower\fP (char c)"
.br
.ti -1c
.RI "std::string \fBToLower\fP (std::string_view str)"
.br
.ti -1c
.RI "constexpr char \fBToUpper\fP (char c)"
.br
.ti -1c
.RI "std::string \fBToUpper\fP (std::string_view str)"
.br
.ti -1c
.RI "std::string \fBCapitalize\fP (std::string str)"
.br
.ti -1c
.RI "std::optional< uint64_t > \fBParseByteUnits\fP (std::string_view str, \fBByteUnit\fP default_multiplier)"
.br
.ti -1c
.RI "consteval uint8_t \fBConstevalHexDigit\fP (const char c)"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> constexpr auto \fBoperator''_hex\fP ()"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> constexpr auto \fBoperator''_hex_u8\fP ()"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> constexpr auto \fBoperator''_hex_v\fP ()"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> auto \fBoperator''_hex_v_u8\fP ()"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBByteUnit\fP : uint64_t\fR [strong]\fP"
Used by \fBParseByteUnits()\fP Lowercase base 1000 Uppercase base 1024 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BINOOP \fP
.TP
\f(BIk \fP
.TP
\f(BIK \fP
.TP
\f(BIm \fP
.TP
\f(BIM \fP
.TP
\f(BIg \fP
.TP
\f(BIG \fP
.TP
\f(BIt \fP
.TP
\f(BIT \fP
.SS "enum \fBSafeChars\fP"
Utilities for converting data from/to strings\&. Used by \fBSanitizeString()\fP 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISAFE_CHARS_DEFAULT \fP
The full set of allowed chars\&. 
.TP
\f(BISAFE_CHARS_UA_COMMENT \fP
BIP-0014 subset\&. 
.TP
\f(BISAFE_CHARS_FILENAME \fP
Chars allowed in filenames\&. 
.TP
\f(BISAFE_CHARS_URI \fP
Chars allowed in URIs (RFC 3986)\&. 
.SH "Function Documentation"
.PP 
.SS "std::string Capitalize (std::string str)"
Capitalizes the first character of the given string\&. This function is locale independent\&. It only converts lowercase characters in the standard 7-bit ASCII range\&. This is a feature, not a limitation\&.

.PP
\fBParameters\fP
.RS 4
\fIstr\fP the string to capitalize\&. 
.RE
.PP
\fBReturns\fP
.RS 4
string with the first letter capitalized\&. 
.RE
.PP

.SS "template<int frombits, int tobits, bool pad, typename O, typename It, typename I = IntIdentity> bool ConvertBits (O outfn, It it, It end, I infn = \fR{}\fP)"
Convert from one power-of-2 number base to another\&. 
.SS "std::optional< std::vector< unsigned char > > DecodeBase32 (std::string_view str)"

.SS "std::optional< std::vector< unsigned char > > DecodeBase64 (std::string_view str)"

.SS "std::string EncodeBase32 (std::span< const unsigned char > input, bool pad = \fRtrue\fP)"
Base32 encode\&. If \fRpad\fP is true, then the output will be padded with '=' so that its length is a multiple of 8\&. 
.SS "std::string EncodeBase32 (std::string_view str, bool pad = \fRtrue\fP)"
Base32 encode\&. If \fRpad\fP is true, then the output will be padded with '=' so that its length is a multiple of 8\&. 
.SS "std::string EncodeBase64 (std::span< const std::byte > input)\fR [inline]\fP"

.SS "std::string EncodeBase64 (std::span< const unsigned char > input)"

.SS "std::string EncodeBase64 (std::string_view str)\fR [inline]\fP"

.SS "std::string FormatParagraph (std::string_view in, size_t width = \fR79\fP, size_t indent = \fR0\fP)"
\fBFormat\fP a paragraph of text to a fixed width, adding spaces for indentation to any added line\&. 
.SS "bool IsDigit (char c)\fR [constexpr]\fP"
Tests if the given character is a decimal digit\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP character to test 
.RE
.PP
\fBReturns\fP
.RS 4
true if the argument is a decimal digit; otherwise false\&. 
.RE
.PP

.SS "bool IsHex (std::string_view str)"

.SS "bool IsSpace (char c)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Tests if the given character is a whitespace character\&. The whitespace characters are: space, form-feed ('\\f'), newline ('
.br
'), carriage return ('\\r'), horizontal tab ('\\t'), and vertical tab ('\\v')\&.

.PP
This function is locale independent\&. Under the C locale this function gives the same result as std::isspace\&.

.PP
\fBParameters\fP
.RS 4
\fIc\fP character to test 
.RE
.PP
\fBReturns\fP
.RS 4
true if the argument is a whitespace character; otherwise false 
.RE
.PP

.SS "template<typename \fBT\fP> \fBT\fP LocaleIndependentAtoi (std::string_view str)"

.SS "std::optional< uint64_t > ParseByteUnits (std::string_view str, \fBByteUnit\fP default_multiplier)"
Parse a string with suffix unit [k|K|m|M|g|G|t|T]\&. Must be a whole integer, fractions not allowed (0\&.5t), no whitespace or +- Lowercase units are 1000 base\&. Uppercase units are 1024 base\&. Examples: 2m,27M,19g,41T

.PP
\fBParameters\fP
.RS 4
\fIstr\fP the string to convert into bytes 
.br
\fIdefault_multiplier\fP if no unit is found in str use this unit 
.RE
.PP
\fBReturns\fP
.RS 4
optional uint64_t bytes from str or nullopt if ToIntegral is false, str is empty, trailing whitespace or overflow 
.RE
.PP

.SS "bool ParseFixedPoint (std::string_view val, int decimals, int64_t * amount_out)\fR [nodiscard]\fP"
Parse number as fixed point according to JSON number syntax\&. 
.PP
\fBReturns\fP
.RS 4
true on success, false on error\&. 
.RE
.PP
\fBNote\fP
.RS 4
The result must be in the range (-10^18,10^18), otherwise an overflow error will trigger\&. 
.RE
.PP

.SS "template<typename Byte = uint8_t> std::vector< Byte > ParseHex (std::string_view hex_str)"
Like TryParseHex, but returns an empty vector on invalid input\&. 
.SS "std::string SanitizeString (std::string_view str, int rule = \fR\fBSAFE_CHARS_DEFAULT\fP\fP)"
Remove unsafe chars\&. Safe chars chosen to allow simple messages/URLs/email addresses, but avoid anything even possibly remotely dangerous like & or > 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to sanitize 
.br
\fIrule\fP The set of safe chars to choose (default: least restrictive) 
.RE
.PP
\fBReturns\fP
.RS 4
A new string without unsafe chars 
.RE
.PP

.SS "bool SplitHostPort (std::string_view in, uint16_t & portOut, std::string & hostOut)"
Splits socket address string into host string and port value\&. Validates port value\&.

.PP
\fBParameters\fP
.RS 4
\fIin\fP The socket address string to split\&. 
.br
\fIportOut\fP Port-portion of the input, if found and parsable\&. 
.br
\fIhostOut\fP Host-portion of the input, if found\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if port-portion is absent or within its allowed range, otherwise false 
.RE
.PP

.SS "template<typename \fBT\fP> bool TimingResistantEqual (const \fBT\fP & a, const \fBT\fP & b)"
Timing-attack-resistant comparison\&. Takes time proportional to length of first argument\&. 
.SS "template<typename \fBT\fP> std::optional< \fBT\fP > ToIntegral (std::string_view str)"
Convert string to integral type T\&. Leading whitespace, a leading +, or any trailing character fail the parsing\&. The required format expressed as regex is \fR-?[0-9]+\fP\&. The minus sign is only permitted for signed integer types\&.

.PP
\fBReturns\fP
.RS 4
std::nullopt if the entire string could not be parsed, or if the parsed value is not in the range representable by the type T\&. 
.RE
.PP

.SS "char ToLower (char c)\fR [constexpr]\fP"
Converts the given character to its lowercase equivalent\&. This function is locale independent\&. It only converts uppercase characters in the standard 7-bit ASCII range\&. This is a feature, not a limitation\&.

.PP
\fBParameters\fP
.RS 4
\fIc\fP the character to convert to lowercase\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the lowercase equivalent of c; or the argument if no conversion is possible\&. 
.RE
.PP

.SS "std::string ToLower (std::string_view str)"
Returns the lowercase equivalent of the given string\&. This function is locale independent\&. It only converts uppercase characters in the standard 7-bit ASCII range\&. This is a feature, not a limitation\&.

.PP
\fBParameters\fP
.RS 4
\fIstr\fP the string to convert to lowercase\&. 
.RE
.PP
\fBReturns\fP
.RS 4
lowercased equivalent of str 
.RE
.PP

.SS "char ToUpper (char c)\fR [constexpr]\fP"
Converts the given character to its uppercase equivalent\&. This function is locale independent\&. It only converts lowercase characters in the standard 7-bit ASCII range\&. This is a feature, not a limitation\&.

.PP
\fBParameters\fP
.RS 4
\fIc\fP the character to convert to uppercase\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the uppercase equivalent of c; or the argument if no conversion is possible\&. 
.RE
.PP

.SS "std::string ToUpper (std::string_view str)"
Returns the uppercase equivalent of the given string\&. This function is locale independent\&. It only converts lowercase characters in the standard 7-bit ASCII range\&. This is a feature, not a limitation\&.

.PP
\fBParameters\fP
.RS 4
\fIstr\fP the string to convert to uppercase\&. 
.RE
.PP
\fBReturns\fP
.RS 4
UPPERCASED EQUIVALENT OF str 
.RE
.PP

.SS "template<typename Byte = std::byte> std::optional< std::vector< Byte > > TryParseHex (std::string_view str)"
Parse the hex string into bytes (uint8_t or std::byte)\&. Ignores whitespace\&. Returns nullopt on invalid input\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
