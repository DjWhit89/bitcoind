.TH "AddrManImpl" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AddrManImpl
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <addrman_impl\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAddrManImpl\fP (const \fBNetGroupManager\fP &netgroupman, bool deterministic, int32_t consistency_check_ratio)"
.br
.ti -1c
.RI "\fB~AddrManImpl\fP ()"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s_) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s_) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "size_t \fBSize\fP (std::optional< \fBNetwork\fP > net, std::optional< bool > in_new) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "bool \fBAdd\fP (const std::vector< \fBCAddress\fP > &vAddr, const \fBCNetAddr\fP &source, std::chrono::seconds time_penalty) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "bool \fBGood\fP (const \fBCService\fP &addr, \fBNodeSeconds\fP time) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "void \fBAttempt\fP (const \fBCService\fP &addr, bool fCountFailure, \fBNodeSeconds\fP time) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "void \fBResolveCollisions\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > \fBSelectTriedCollision\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > \fBSelect\fP (bool new_only, const std::unordered_set< \fBNetwork\fP > &networks) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< \fBCAddress\fP > \fBGetAddr\fP (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered=true) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "std::vector< std::pair< \fBAddrInfo\fP, \fBAddressPosition\fP > > \fBGetEntries\fP (bool from_tried) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "void \fBConnected\fP (const \fBCService\fP &addr, \fBNodeSeconds\fP time) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "void \fBSetServices\fP (const \fBCService\fP &addr, \fBServiceFlags\fP nServices) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.ti -1c
.RI "std::optional< \fBAddressPosition\fP > \fBFindAddressEntry\fP (const \fBCAddress\fP &addr) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs\fP)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBAddrManDeterministic\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBAddrManImpl\fP (const \fBNetGroupManager\fP & netgroupman, bool deterministic, int32_t consistency_check_ratio)"

.SS "~\fBAddrManImpl\fP ()"

.SH "Member Function Documentation"
.PP 
.SS "bool Add (const std::vector< \fBCAddress\fP > & vAddr, const \fBCNetAddr\fP & source, std::chrono::seconds time_penalty)"

.SS "void Attempt (const \fBCService\fP & addr, bool fCountFailure, \fBNodeSeconds\fP time)"

.SS "void Connected (const \fBCService\fP & addr, \fBNodeSeconds\fP time)"

.SS "std::optional< \fBAddressPosition\fP > FindAddressEntry (const \fBCAddress\fP & addr)"

.SS "std::vector< \fBCAddress\fP > GetAddr (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered = \fRtrue\fP) const"

.SS "std::vector< std::pair< \fBAddrInfo\fP, \fBAddressPosition\fP > > GetEntries (bool from_tried) const"

.SS "bool Good (const \fBCService\fP & addr, \fBNodeSeconds\fP time)"

.SS "void ResolveCollisions ()"

.SS "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > Select (bool new_only, const std::unordered_set< \fBNetwork\fP > & networks) const"

.SS "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > SelectTriedCollision ()"

.SS "template<typename Stream> void Serialize (Stream & s_) const"
Serialized format\&.
.IP "\(bu" 2
format version byte (
.PP
\fBSee also\fP
.RS 4
\fR\fBFormat\fP\fP)
.RE
.PP

.IP "\(bu" 2
lowest compatible format version byte\&. This is used to help old software decide whether to parse the file\&. For example:
.IP "  \(bu" 4
Bitcoin Core version N knows how to parse up to format=3\&. If a new format=4 is introduced in version N+1 that is compatible with format=3 and it is known that version N will be able to parse it, then version N+1 will write (format=4, lowest_compatible=3) in the first two bytes of the file, and so version N will still try to parse it\&.
.IP "  \(bu" 4
Bitcoin Core version N+2 introduces a new incompatible format=5\&. It will write (format=5, lowest_compatible=5) and so any versions that do not know how to parse format=5 will not try to read the file\&.
.PP

.IP "\(bu" 2
nKey
.IP "\(bu" 2
nNew
.IP "\(bu" 2
nTried
.IP "\(bu" 2
number of "new" buckets XOR 2**30
.IP "\(bu" 2
all new addresses (total count: nNew)
.IP "\(bu" 2
all tried addresses (total count: nTried)
.IP "\(bu" 2
for each new bucket:
.IP "  \(bu" 4
number of elements
.IP "  \(bu" 4
for each element: index in the serialized "all new addresses"
.PP

.IP "\(bu" 2
asmap checksum
.PP

.PP
2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it as incompatible\&. This is necessary because it did not check the version number on deserialization\&.

.PP
vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly; they are instead reconstructed from the other information\&.

.PP
This format is more complex, but significantly smaller (at most 1\&.5 MiB), and supports changes to the ADDRMAN_ parameters without breaking the on-disk structure\&.

.PP
We don't use SERIALIZE_METHODS since the serialization and deserialization code has very little in common\&.
.SS "void SetServices (const \fBCService\fP & addr, \fBServiceFlags\fP nServices)"

.SS "size_t Size (std::optional< \fBNetwork\fP > net, std::optional< bool > in_new) const"

.SS "template<typename Stream> void Unserialize (Stream & s_)"

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBAddrManDeterministic\fP\fR [friend]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
