.TH "TxGraph" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TxGraph
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <txgraph\&.h>\fP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBBlockBuilder\fP"
.br
.ti -1c
.RI "class \fBRef\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum class \fBLevel\fP { \fBTOP\fP, \fBMAIN\fP }"
.br
.ti -1c
.RI "using \fBGraphIndex\fP = uint32_t"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~TxGraph\fP ()=default"
.br
.ti -1c
.RI "virtual \fBRef\fP \fBAddTransaction\fP (const \fBFeePerWeight\fP &feerate) noexcept=0"
.br
.ti -1c
.RI "virtual void \fBRemoveTransaction\fP (const \fBRef\fP &arg) noexcept=0"
.br
.ti -1c
.RI "virtual void \fBAddDependency\fP (const \fBRef\fP &parent, const \fBRef\fP &child) noexcept=0"
.br
.ti -1c
.RI "virtual void \fBSetTransactionFee\fP (const \fBRef\fP &arg, int64_t \fBfee\fP) noexcept=0"
.br
.ti -1c
.RI "virtual bool \fBDoWork\fP (uint64_t iters) noexcept=0"
.br
.ti -1c
.RI "virtual void \fBStartStaging\fP () noexcept=0"
.br
.ti -1c
.RI "virtual void \fBAbortStaging\fP () noexcept=0"
.br
.ti -1c
.RI "virtual void \fBCommitStaging\fP () noexcept=0"
.br
.ti -1c
.RI "virtual bool \fBHaveStaging\fP () const noexcept=0"
.br
.ti -1c
.RI "virtual bool \fBIsOversized\fP (\fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual bool \fBExists\fP (const \fBRef\fP &arg, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual \fBFeePerWeight\fP \fBGetIndividualFeerate\fP (const \fBRef\fP &arg) noexcept=0"
.br
.ti -1c
.RI "virtual \fBFeePerWeight\fP \fBGetMainChunkFeerate\fP (const \fBRef\fP &arg) noexcept=0"
.br
.ti -1c
.RI "virtual std::vector< \fBRef\fP * > \fBGetCluster\fP (const \fBRef\fP &arg, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual std::vector< \fBRef\fP * > \fBGetAncestors\fP (const \fBRef\fP &arg, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual std::vector< \fBRef\fP * > \fBGetDescendants\fP (const \fBRef\fP &arg, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual std::vector< \fBRef\fP * > \fBGetAncestorsUnion\fP (std::span< const \fBRef\fP *const > \fBargs\fP, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual std::vector< \fBRef\fP * > \fBGetDescendantsUnion\fP (std::span< const \fBRef\fP *const > \fBargs\fP, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual \fBGraphIndex\fP \fBGetTransactionCount\fP (\fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual std::strong_ordering \fBCompareMainOrder\fP (const \fBRef\fP &a, const \fBRef\fP &b) noexcept=0"
.br
.ti -1c
.RI "virtual \fBGraphIndex\fP \fBCountDistinctClusters\fP (std::span< const \fBRef\fP *const >, \fBLevel\fP level) noexcept=0"
.br
.ti -1c
.RI "virtual std::pair< std::vector< \fBFeeFrac\fP >, std::vector< \fBFeeFrac\fP > > \fBGetMainStagingDiagrams\fP () noexcept=0"
.br
.ti -1c
.RI "virtual std::vector< \fBRef\fP * > \fBTrim\fP () noexcept=0"
.br
.ti -1c
.RI "virtual std::unique_ptr< \fBBlockBuilder\fP > \fBGetBlockBuilder\fP () noexcept=0"
.br
.ti -1c
.RI "virtual std::pair< std::vector< \fBRef\fP * >, \fBFeePerWeight\fP > \fBGetWorstMainChunk\fP () noexcept=0"
.br
.ti -1c
.RI "virtual size_t \fBGetMainMemoryUsage\fP () noexcept=0"
.br
.ti -1c
.RI "virtual void \fBSanityCheck\fP () const =0"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual void \fBUpdateRef\fP (\fBGraphIndex\fP index, \fBRef\fP &new_location) noexcept=0"
.br
.ti -1c
.RI "virtual void \fBUnlinkRef\fP (\fBGraphIndex\fP index) noexcept=0"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static \fBTxGraph\fP *& \fBGetRefGraph\fP (\fBRef\fP &arg) noexcept"
.br
.ti -1c
.RI "static \fBTxGraph\fP * \fBGetRefGraph\fP (const \fBRef\fP &arg) noexcept"
.br
.ti -1c
.RI "static \fBGraphIndex\fP & \fBGetRefIndex\fP (\fBRef\fP &arg) noexcept"
.br
.ti -1c
.RI "static \fBGraphIndex\fP \fBGetRefIndex\fP (const \fBRef\fP &arg) noexcept"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBTxGraph::Ref\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Data structure to encapsulate fees, sizes, and dependencies for a set of transactions\&.

.PP
Each \fBTxGraph\fP represents one or two such graphs ("main", and optionally "staging"), to allow for working with batches of changes that may still be discarded\&.

.PP
The connected components within each transaction graph are called clusters: whenever one transaction is reachable from another, through any sequence of is-parent-of or is-child-of relations, they belong to the same cluster (so clusters include parents, children, but also grandparents, siblings, cousins twice removed, \&.\&.\&.)\&.

.PP
For each graph, \fBTxGraph\fP implicitly defines an associated total ordering on its transactions (its linearization) that respects topology (parents go before their children), aiming for it to be close to the optimal order those transactions should be mined in if the goal is fee maximization, though this is a best effort only, not a strong guarantee\&.

.PP
For more explanation, see https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032

.PP
This linearization is partitioned into chunks: groups of transactions that according to this order would be mined together\&. Each chunk consists of the highest-feerate prefix of what remains of the linearization after removing previous chunks\&. \fBTxGraph\fP guarantees that the maintained linearization always results in chunks consisting of transactions that are connected\&. A chunk's transactions always belong to the same cluster\&.

.PP
The interface is designed to accommodate an implementation that only stores the transitive closure of dependencies, so if B spends C, it does not distinguish between "A spending B" and "A spending both B and C"\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBGraphIndex\fP = uint32_t"
Internal identifier for a transaction within a \fBTxGraph\fP\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum class \fBLevel\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BITOP \fP
Refers to staging if it exists, main otherwise\&. 
.TP
\f(BIMAIN \fP
Always refers to the main graph, whether staging is present or not\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "virtual ~\fBTxGraph\fP ()\fR [virtual]\fP, \fR [default]\fP"
Virtual destructor, so inheriting is safe\&. 
.SH "Member Function Documentation"
.PP 
.SS "virtual void AbortStaging ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Discard the existing active staging graph (which must exist)\&. 
.SS "virtual void AddDependency (const \fBRef\fP & parent, const \fBRef\fP & child)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Add a dependency between two specified transactions\&. If a staging graph exists, the dependency is only added there\&. Parent may not be a descendant of child already (but may be an ancestor of it already, in which case this is a no-op)\&. If either transaction is already removed, this is a no-op\&. 
.SS "virtual \fBRef\fP AddTransaction (const \fBFeePerWeight\fP & feerate)\fR [nodiscard]\fP, \fR [pure virtual]\fP, \fR [noexcept]\fP"
Construct a new transaction with the specified feerate, and return a \fBRef\fP to it\&. If a staging graph exists, the new transaction is only created there\&. feerate\&.size must be strictly positive\&. In all further calls, only Refs created by \fBAddTransaction()\fP are allowed to be passed to this \fBTxGraph\fP object (or empty \fBRef\fP objects)\&. \fBRef\fP objects may outlive the \fBTxGraph\fP they were created for\&. 
.SS "virtual void CommitStaging ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Replace the main graph with the staging graph (which must exist)\&. 
.SS "virtual std::strong_ordering CompareMainOrder (const \fBRef\fP & a, const \fBRef\fP & b)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Compare two transactions according to their order in the main graph\&. Both transactions must be in the main graph\&. The main graph must not be oversized\&. 
.SS "virtual \fBGraphIndex\fP CountDistinctClusters (std::span< const \fBRef\fP *const > , \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Count the number of distinct clusters that the specified transactions belong to\&. Refs that do not exist in the queried graph are ignored\&. Refs can not be null\&. The queried graph must not be oversized\&. 
.SS "virtual bool DoWork (uint64_t iters)\fR [pure virtual]\fP, \fR [noexcept]\fP"
\fBTxGraph\fP is internally lazy, and will not compute many things until they are needed\&. Calling DoWork will perform some work now (controlled by iters) so that future operations are fast, if there is any\&. Returns whether all currently-available work is done\&. This can be invoked while oversized, but oversized graphs will be skipped by this call\&. 
.SS "virtual bool Exists (const \fBRef\fP & arg, \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Determine whether arg exists in the graph (i\&.e\&., was not removed)\&. This is available even for oversized graphs\&. 
.SS "virtual std::vector< \fBRef\fP * > GetAncestors (const \fBRef\fP & arg, \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get pointers to all ancestors of the specified transaction (including the transaction itself), in unspecified order\&. The queried graph must not be oversized\&. Returns {} if arg does not exist in the graph\&. 
.SS "virtual std::vector< \fBRef\fP * > GetAncestorsUnion (std::span< const \fBRef\fP *const > args, \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Like GetAncestors, but return the Refs for all transactions in the union of the provided arguments' ancestors (each transaction is only reported once)\&. Refs that do not exist in the queried graph are ignored\&. Null refs are not allowed\&. 
.SS "virtual std::unique_ptr< \fBBlockBuilder\fP > GetBlockBuilder ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Construct a block builder, drawing chunks in order, from the main graph, which cannot be oversized\&. While the returned object exists, no mutators on the main graph are allowed\&. The \fBBlockBuilder\fP object must not outlive the \fBTxGraph\fP it was created with\&. 
.SS "virtual std::vector< \fBRef\fP * > GetCluster (const \fBRef\fP & arg, \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get pointers to all transactions in the cluster which arg is in\&. The transactions are returned in graph order\&. The queried graph must not be oversized\&. Returns {} if arg does not exist in the queried graph\&. 
.SS "virtual std::vector< \fBRef\fP * > GetDescendants (const \fBRef\fP & arg, \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get pointers to all descendants of the specified transaction (including the transaction itself), in unspecified order\&. The queried graph must not be oversized\&. Returns {} if arg does not exist in the graph\&. 
.SS "virtual std::vector< \fBRef\fP * > GetDescendantsUnion (std::span< const \fBRef\fP *const > args, \fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Like GetDescendants, but return the Refs for all transactions in the union of the provided arguments' descendants (each transaction is only reported once)\&. Refs that do not exist in the queried graph are ignored\&. Null refs are not allowed\&. 
.SS "virtual \fBFeePerWeight\fP GetIndividualFeerate (const \fBRef\fP & arg)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get the individual transaction feerate of transaction arg\&. Returns the empty \fBFeePerWeight\fP if arg does not exist in either main or staging\&. This is available even for oversized graphs\&. 
.SS "virtual \fBFeePerWeight\fP GetMainChunkFeerate (const \fBRef\fP & arg)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get the feerate of the chunk which transaction arg is in, in the main graph\&. Returns the empty \fBFeePerWeight\fP if arg does not exist in the main graph\&. The main graph must not be oversized\&. 
.SS "virtual size_t GetMainMemoryUsage ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get the approximate memory usage for this object, just counting the main graph\&. If a staging graph is present, return a number corresponding to memory usage after \fBAbortStaging()\fP would be called\&. BlockBuilders' memory usage, memory usage of internally queued operations, and memory due to temporary caches, is not included here\&. Can always be called\&. 
.SS "virtual std::pair< std::vector< \fBFeeFrac\fP >, std::vector< \fBFeeFrac\fP > > GetMainStagingDiagrams ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
For both main and staging (which must both exist and not be oversized), return the combined respective feerate diagrams, including chunks from all clusters, but excluding clusters that appear identically in both\&. Use \fBFeeFrac\fP rather than \fBFeePerWeight\fP so CompareChunks is usable without type-conversion\&. 
.SS "\fBTxGraph\fP * GetRefGraph (const \fBRef\fP & arg)\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [noexcept]\fP"

.SS "\fBTxGraph\fP *& GetRefGraph (\fBRef\fP & arg)\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [noexcept]\fP"

.SS "\fBGraphIndex\fP GetRefIndex (const \fBRef\fP & arg)\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [noexcept]\fP"

.SS "\fBGraphIndex\fP & GetRefIndex (\fBRef\fP & arg)\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP, \fR [noexcept]\fP"

.SS "virtual \fBGraphIndex\fP GetTransactionCount (\fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get the total number of transactions in the graph\&. This is available even for oversized graphs\&. 
.SS "virtual std::pair< std::vector< \fBRef\fP * >, \fBFeePerWeight\fP > GetWorstMainChunk ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get the last chunk in the main graph, i\&.e\&., the last chunk that would be returned by a \fBBlockBuilder\fP created now, together with its feerate\&. The chunk is returned in reverse-topological order, so every element is preceded by all its descendants\&. The main graph must not be oversized\&. If the graph is empty, {{}, \fBFeePerWeight\fP{}} is returned\&. 
.SS "virtual bool HaveStaging () const\fR [pure virtual]\fP, \fR [noexcept]\fP"
Check whether a staging graph exists\&. 
.SS "virtual bool IsOversized (\fBLevel\fP level)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Determine whether the graph is oversized (contains a connected component of more than the configured maximum cluster count)\&. Some of the functions below are not available for oversized graphs\&. The mutators above are always available\&. Removing a transaction by destroying its \fBRef\fP while staging exists will not clear main's oversizedness until staging is aborted or committed\&. 
.SS "virtual void RemoveTransaction (const \fBRef\fP & arg)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Remove the specified transaction\&. If a staging graph exists, the removal only happens there\&. This is a no-op if the transaction was already removed\&.

.PP
\fBTxGraph\fP may internally reorder transaction removals with dependency additions for performance reasons\&. If together with any transaction removal all its descendants, or all its ancestors, are removed as well (which is what always happens in realistic scenarios), this reordering will not affect the behavior of \fBTxGraph\fP\&.

.PP
As an example, imagine 3 transactions A,B,C where B depends on A\&. If a dependency of C on B is added, and then B is deleted, C will still depend on A\&. If the deletion of B is reordered before the C->B dependency is added, the dependency adding has no effect\&. If, together with the deletion of B also either A or C is deleted, there is no distinction between the original order case and the reordered case\&. 
.SS "virtual void SanityCheck () const\fR [pure virtual]\fP"
Perform an internal consistency check on this object\&. 
.SS "virtual void SetTransactionFee (const \fBRef\fP & arg, int64_t fee)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Modify the fee of the specified transaction, in both the main graph and the staging graph if it exists\&. Wherever the transaction does not exist (or was removed), this has no effect\&. 
.SS "virtual void StartStaging ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Create a staging graph (which cannot exist already)\&. This acts as if a full copy of the transaction graph is made, upon which further modifications are made\&. This copy can be inspected, and then either discarded, or the main graph can be replaced by it by committing it\&. 
.SS "virtual std::vector< \fBRef\fP * > Trim ()\fR [pure virtual]\fP, \fR [noexcept]\fP"
Remove transactions (including their own descendants) according to a fast but best-effort strategy such that the \fBTxGraph\fP's cluster and size limits are respected\&. Applies to staging if it exists, and to main otherwise\&. Returns the list of all removed transactions in unspecified order\&. This has no effect unless the relevant graph is oversized\&. 
.SS "virtual void UnlinkRef (\fBGraphIndex\fP index)\fR [protected]\fP, \fR [pure virtual]\fP, \fR [noexcept]\fP"
Inform the \fBTxGraph\fP implementation that a \fBTxGraph::Ref\fP was destroyed\&. 
.SS "virtual void UpdateRef (\fBGraphIndex\fP index, \fBRef\fP & new_location)\fR [protected]\fP, \fR [pure virtual]\fP, \fR [noexcept]\fP"
Inform the \fBTxGraph\fP implementation that a \fBTxGraph::Ref\fP has moved\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class TxGraph::Ref\fR [friend]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
