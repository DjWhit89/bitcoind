.TH "CKey" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CKey
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <key\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCKey\fP () noexcept=default"
.br
.ti -1c
.RI "\fBCKey\fP (\fBCKey\fP &&) noexcept=default"
.br
.ti -1c
.RI "\fBCKey\fP & \fBoperator=\fP (\fBCKey\fP &&) noexcept=default"
.br
.ti -1c
.RI "\fBCKey\fP & \fBoperator=\fP (const \fBCKey\fP &other)"
.br
.ti -1c
.RI "\fBCKey\fP (const \fBCKey\fP &other)"
.br
.ti -1c
.RI "template<typename \fBT\fP> void \fBSet\fP (const \fBT\fP pbegin, const \fBT\fP pend, bool fCompressedIn)"
.br
.RI "Initialize using begin and end iterators to byte data\&. "
.ti -1c
.RI "unsigned int \fBsize\fP () const"
.br
.RI "Simple read-only vector-like interface\&. "
.ti -1c
.RI "const std::byte * \fBdata\fP () const"
.br
.ti -1c
.RI "const std::byte * \fBbegin\fP () const"
.br
.ti -1c
.RI "const std::byte * \fBend\fP () const"
.br
.ti -1c
.RI "bool \fBIsValid\fP () const"
.br
.RI "Check whether this private key is valid\&. "
.ti -1c
.RI "bool \fBIsCompressed\fP () const"
.br
.RI "Check whether the public key corresponding to this private key is (to be) compressed\&. "
.ti -1c
.RI "void \fBMakeNewKey\fP (bool fCompressed)"
.br
.RI "Generate a new private key using a cryptographic PRNG\&. "
.ti -1c
.RI "\fBCPrivKey\fP \fBGetPrivKey\fP () const"
.br
.ti -1c
.RI "\fBCPubKey\fP \fBGetPubKey\fP () const"
.br
.ti -1c
.RI "bool \fBSign\fP (const \fBuint256\fP &hash, std::vector< unsigned char > &vchSig, bool grind=true, uint32_t test_case=0) const"
.br
.ti -1c
.RI "bool \fBSignCompact\fP (const \fBuint256\fP &hash, std::vector< unsigned char > &vchSig) const"
.br
.ti -1c
.RI "bool \fBSignSchnorr\fP (const \fBuint256\fP &hash, std::span< unsigned char > sig, const \fBuint256\fP *merkle_root, const \fBuint256\fP &aux) const"
.br
.ti -1c
.RI "bool \fBDerive\fP (\fBCKey\fP &keyChild, \fBChainCode\fP &ccChild, unsigned int nChild, const \fBChainCode\fP &cc) const"
.br
.RI "Derive BIP32 child key\&. "
.ti -1c
.RI "bool \fBVerifyPubKey\fP (const \fBCPubKey\fP &vchPubKey) const"
.br
.ti -1c
.RI "bool \fBLoad\fP (const \fBCPrivKey\fP &privkey, const \fBCPubKey\fP &vchPubKey, bool fSkipCheck)"
.br
.RI "Load private key and check that public key matches\&. "
.ti -1c
.RI "\fBEllSwiftPubKey\fP \fBEllSwiftCreate\fP (std::span< const std::byte > entropy) const"
.br
.ti -1c
.RI "\fBECDHSecret\fP \fBComputeBIP324ECDHSecret\fP (const \fBEllSwiftPubKey\fP &their_ellswift, const \fBEllSwiftPubKey\fP &our_ellswift, bool initiating) const"
.br
.ti -1c
.RI "\fBKeyPair\fP \fBComputeKeyPair\fP (const \fBuint256\fP *merkle_root) const"
.br
.ti -1c
.RI "std::vector< uint8_t > \fBCreateMuSig2Nonce\fP (\fBMuSig2SecNonce\fP &secnonce, const \fBuint256\fP &sighash, const \fBCPubKey\fP &aggregate_pubkey, const std::vector< \fBCPubKey\fP > &pubkeys)"
.br
.ti -1c
.RI "std::optional< \fBuint256\fP > \fBCreateMuSig2PartialSig\fP (const \fBuint256\fP &hash, const \fBCPubKey\fP &aggregate_pubkey, const std::vector< \fBCPubKey\fP > &pubkeys, const std::map< \fBCPubKey\fP, std::vector< uint8_t > > &pubnonces, \fBMuSig2SecNonce\fP &secnonce, const std::vector< std::pair< \fBuint256\fP, bool > > &tweaks)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const unsigned int \fBSIZE\fP = 279"
.br
.ti -1c
.RI "static const unsigned int \fBCOMPRESSED_SIZE\fP = 214"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator==\fP (const \fBCKey\fP &a, const \fBCKey\fP &b)"
.br
.in -1c
.SH "Detailed Description"
.PP 
An encapsulated private key\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCKey\fP ()\fR [default]\fP, \fR [noexcept]\fP"

.SS "\fBCKey\fP (\fBCKey\fP && )\fR [default]\fP, \fR [noexcept]\fP"

.SS "\fBCKey\fP (const \fBCKey\fP & other)\fR [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "const std::byte * begin () const\fR [inline]\fP"

.SS "\fBECDHSecret\fP ComputeBIP324ECDHSecret (const \fBEllSwiftPubKey\fP & their_ellswift, const \fBEllSwiftPubKey\fP & our_ellswift, bool initiating) const"
Compute a BIP324-style ECDH shared secret\&.

.PP
.IP "\(bu" 2
their_ellswift: \fBEllSwiftPubKey\fP that was received from the other side\&.
.IP "\(bu" 2
our_ellswift: \fBEllSwiftPubKey\fP that was sent to the other side (must have been generated from *this using \fBEllSwiftCreate()\fP)\&.
.IP "\(bu" 2
initiating: whether we are the initiating party (true) or responding party (false)\&. 
.PP

.SS "\fBKeyPair\fP ComputeKeyPair (const \fBuint256\fP * merkle_root) const"
Compute a \fBKeyPair\fP

.PP
Wraps a \fR\fBsecp256k1_keypair\fP\fP type\&.

.PP
\fRmerkle_root\fP is used to optionally perform tweaking of the internal key, as specified in BIP341:

.PP
.IP "\(bu" 2
If merkle_root == nullptr: no tweaking is done, use the internal key directly (this is used for signatures in BIP342 script)\&.
.IP "\(bu" 2
If merkle_root->IsNull(): tweak the internal key with H_TapTweak(pubkey) (this is used for key path spending when no scripts are present)\&.
.IP "\(bu" 2
Otherwise: tweak the internal key with H_TapTweak(pubkey || *merkle_root) (this is used for key path spending with the Merkle root of the script tree)\&. 
.PP

.SS "std::vector< uint8_t > CreateMuSig2Nonce (\fBMuSig2SecNonce\fP & secnonce, const \fBuint256\fP & sighash, const \fBCPubKey\fP & aggregate_pubkey, const std::vector< \fBCPubKey\fP > & pubkeys)"

.SS "std::optional< \fBuint256\fP > CreateMuSig2PartialSig (const \fBuint256\fP & hash, const \fBCPubKey\fP & aggregate_pubkey, const std::vector< \fBCPubKey\fP > & pubkeys, const std::map< \fBCPubKey\fP, std::vector< uint8_t > > & pubnonces, \fBMuSig2SecNonce\fP & secnonce, const std::vector< std::pair< \fBuint256\fP, bool > > & tweaks)"

.SS "const std::byte * data () const\fR [inline]\fP"

.SS "bool Derive (\fBCKey\fP & keyChild, \fBChainCode\fP & ccChild, unsigned int nChild, const \fBChainCode\fP & cc) const\fR [nodiscard]\fP"

.PP
Derive BIP32 child key\&. 
.SS "\fBEllSwiftPubKey\fP EllSwiftCreate (std::span< const std::byte > entropy) const"
Create an ellswift-encoded public key for this key, with specified entropy\&.

.PP
entropy must be a 32-byte span with additional entropy to use in the encoding\&. Every public key has ~2^256 different encodings, and this function will deterministically pick one of them, based on entropy\&. Note that even without truly random entropy, the resulting encoding will be indistinguishable from uniform to any adversary who does not know the private key (because the private key itself is always used as entropy as well)\&. 
.SS "const std::byte * end () const\fR [inline]\fP"

.SS "\fBCPrivKey\fP GetPrivKey () const"
Convert the private key to a \fBCPrivKey\fP (serialized OpenSSL private key data)\&. This is expensive\&. 
.SS "\fBCPubKey\fP GetPubKey () const"
Compute the public key from a private key\&. This is expensive\&. 
.SS "bool IsCompressed () const\fR [inline]\fP"

.PP
Check whether the public key corresponding to this private key is (to be) compressed\&. 
.SS "bool IsValid () const\fR [inline]\fP"

.PP
Check whether this private key is valid\&. 
.SS "bool Load (const \fBCPrivKey\fP & privkey, const \fBCPubKey\fP & vchPubKey, bool fSkipCheck = \fRfalse\fP)"

.PP
Load private key and check that public key matches\&. 
.SS "void MakeNewKey (bool fCompressed)"

.PP
Generate a new private key using a cryptographic PRNG\&. 
.SS "\fBCKey\fP & operator= (\fBCKey\fP && )\fR [default]\fP, \fR [noexcept]\fP"

.SS "\fBCKey\fP & operator= (const \fBCKey\fP & other)\fR [inline]\fP"

.SS "template<typename \fBT\fP> void Set (const \fBT\fP pbegin, const \fBT\fP pend, bool fCompressedIn)\fR [inline]\fP"

.PP
Initialize using begin and end iterators to byte data\&. 
.SS "bool Sign (const \fBuint256\fP & hash, std::vector< unsigned char > & vchSig, bool grind = \fRtrue\fP, uint32_t test_case = \fR0\fP) const"
Create a DER-serialized signature\&. The test_case parameter tweaks the deterministic nonce\&. 
.SS "bool SignCompact (const \fBuint256\fP & hash, std::vector< unsigned char > & vchSig) const"
Create a compact signature (65 bytes), which allows reconstructing the used public key\&. The format is one header byte, followed by two times 32 bytes for the serialized r and s values\&. The header byte: 0x1B = first key with even y, 0x1C = first key with odd y, 0x1D = second key with even y, 0x1E = second key with odd y, add 0x04 for compressed keys\&. 
.SS "bool SignSchnorr (const \fBuint256\fP & hash, std::span< unsigned char > sig, const \fBuint256\fP * merkle_root, const \fBuint256\fP & aux) const"
Create a BIP-340 Schnorr signature, for the xonly-pubkey corresponding to *this, optionally tweaked by *merkle_root\&. Additional nonce entropy is provided through aux\&.

.PP
merkle_root is used to optionally perform tweaking of the private key, as specified in BIP341:
.IP "\(bu" 2
If merkle_root == nullptr: no tweaking is done, sign with key directly (this is used for signatures in BIP342 script)\&.
.IP "\(bu" 2
If merkle_root->IsNull(): sign with key + H_TapTweak(pubkey) (this is used for key path spending when no scripts are present)\&.
.IP "\(bu" 2
Otherwise: sign with key + H_TapTweak(pubkey || *merkle_root) (this is used for key path spending, with specific Merkle root of the script tree)\&. 
.PP

.SS "unsigned int size () const\fR [inline]\fP"

.PP
Simple read-only vector-like interface\&. 
.SS "bool VerifyPubKey (const \fBCPubKey\fP & vchPubKey) const"
Verify thoroughly whether a private key and a public key match\&. This is done using a different mechanism than just regenerating it\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "bool operator== (const \fBCKey\fP & a, const \fBCKey\fP & b)\fR [friend]\fP"

.SH "Field Documentation"
.PP 
.SS "const unsigned int COMPRESSED_SIZE = 214\fR [static]\fP"

.SS "const unsigned int SIZE = 279\fR [static]\fP"
secp256k1: 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
