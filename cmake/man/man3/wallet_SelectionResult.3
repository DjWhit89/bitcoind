.TH "SelectionResult" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SelectionResult
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <coinselection\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSelectionResult\fP (const \fBCAmount\fP target, \fBSelectionAlgorithm\fP algo)"
.br
.ti -1c
.RI "\fBSelectionResult\fP ()=delete"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetSelectedValue\fP () const"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetSelectedEffectiveValue\fP () const"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetTotalBumpFees\fP () const"
.br
.ti -1c
.RI "void \fBClear\fP ()"
.br
.ti -1c
.RI "void \fBAddInput\fP (const \fBOutputGroup\fP &group)"
.br
.ti -1c
.RI "void \fBAddInputs\fP (const std::set< std::shared_ptr< \fBCOutput\fP > > &inputs, bool subtract_fee_outputs)"
.br
.ti -1c
.RI "void \fBSetBumpFeeDiscount\fP (const \fBCAmount\fP discount)"
.br
.ti -1c
.RI "void \fBRecalculateWaste\fP (const \fBCAmount\fP min_viable_change, const \fBCAmount\fP change_cost, const \fBCAmount\fP change_fee)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetWaste\fP () const"
.br
.ti -1c
.RI "void \fBSetAlgoCompleted\fP (bool algo_completed)"
.br
.ti -1c
.RI "bool \fBGetAlgoCompleted\fP () const"
.br
.ti -1c
.RI "void \fBSetSelectionsEvaluated\fP (size_t attempts)"
.br
.ti -1c
.RI "size_t \fBGetSelectionsEvaluated\fP () const"
.br
.ti -1c
.RI "void \fBMerge\fP (const \fBSelectionResult\fP &other)"
.br
.ti -1c
.RI "const std::set< std::shared_ptr< \fBCOutput\fP > > & \fBGetInputSet\fP () const"
.br
.ti -1c
.RI "std::vector< std::shared_ptr< \fBCOutput\fP > > \fBGetShuffledInputVector\fP () const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (\fBSelectionResult\fP other) const"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetChange\fP (const \fBCAmount\fP min_viable_change, const \fBCAmount\fP change_fee) const"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetTarget\fP () const"
.br
.ti -1c
.RI "\fBSelectionAlgorithm\fP \fBGetAlgo\fP () const"
.br
.ti -1c
.RI "int \fBGetWeight\fP () const"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "SelectionResult (const \fBCAmount\fP target, \fBSelectionAlgorithm\fP algo)\fR [inline]\fP, \fR [explicit]\fP"

.SS "SelectionResult ()\fR [delete]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void AddInput (const \fBOutputGroup\fP & group)"

.SS "void AddInputs (const std::set< std::shared_ptr< \fBCOutput\fP > > & inputs, bool subtract_fee_outputs)"

.SS "void Clear ()"

.SS "\fBSelectionAlgorithm\fP GetAlgo () const\fR [inline]\fP"

.SS "bool GetAlgoCompleted () const"
Get m_algo_completed 
.SS "\fBCAmount\fP GetChange (const \fBCAmount\fP min_viable_change, const \fBCAmount\fP change_fee) const"
Get the amount for the change output after paying needed fees\&.

.PP
The change amount is not 100% precise due to discrepancies in fee calculation\&. The final change amount (if any) should be corrected after calculating the final tx fees\&. When there is a discrepancy, most of the time the final change would be slightly bigger than estimated\&.

.PP
Following are the possible factors of discrepancy:
.IP "\(bu" 2
non-input fees always include segwit flags
.IP "\(bu" 2
input fee estimation always include segwit stack size
.IP "\(bu" 2
input fees are rounded individually and not collectively, which leads to small rounding errors
.IP "\(bu" 2
input counter size is always assumed to be 1vbyte
.PP

.PP
\fBParameters\fP
.RS 4
\fImin_viable_change\fP Minimum amount for change output, if change would be less then we forgo change 
.br
\fIchange_fee\fP Fees to include change output in the tx 
.RE
.PP
\fBReturns\fP
.RS 4
Amount for change output, 0 when there is no change\&. 
.RE
.PP

.SS "const std::set< std::shared_ptr< \fBCOutput\fP > > & GetInputSet () const"
Get m_selected_inputs 
.SS "\fBCAmount\fP GetSelectedEffectiveValue () const\fR [nodiscard]\fP"

.SS "\fBCAmount\fP GetSelectedValue () const\fR [nodiscard]\fP"
Get the sum of the input values 
.SS "size_t GetSelectionsEvaluated () const"
Get selections_evaluated 
.SS "std::vector< std::shared_ptr< \fBCOutput\fP > > GetShuffledInputVector () const"
Get the vector of COutputs that will be used to fill in a \fBCTransaction\fP's vin 
.SS "\fBCAmount\fP GetTarget () const\fR [inline]\fP"

.SS "\fBCAmount\fP GetTotalBumpFees () const\fR [nodiscard]\fP"

.SS "\fBCAmount\fP GetWaste () const\fR [nodiscard]\fP"

.SS "int GetWeight () const\fR [inline]\fP"

.SS "void Merge (const \fBSelectionResult\fP & other)"
Combines the
.PP
\fBParameters\fP
.RS 4
\fIother\fP selection result into 'this' selection result\&.
.RE
.PP
Important note: There must be no shared '\fBCOutput\fP' among the two selection results being combined\&. 
.SS "bool operator< (\fBSelectionResult\fP other) const"

.SS "void RecalculateWaste (const \fBCAmount\fP min_viable_change, const \fBCAmount\fP change_cost, const \fBCAmount\fP change_fee)"
Calculates and stores the waste for this result given the cost of change and the opportunity cost of spending these inputs now vs in the future\&. If change exists, waste = change_cost + inputs * (effective_feerate - long_term_feerate) - bump_fee_group_discount If no change, waste = excess + inputs * (effective_feerate - long_term_feerate) - bump_fee_group_discount where excess = selected_effective_value - target change_cost = effective_feerate * change_output_size + long_term_feerate * change_spend_size

.PP
\fBParameters\fP
.RS 4
\fImin_viable_change\fP The minimum amount necessary to make a change output economic 
.br
\fIchange_cost\fP The cost of creating a change output and spending it in the future\&. Only used if there is change, in which case it must be non-negative\&. 
.br
\fIchange_fee\fP The fee for creating a change output 
.RE
.PP

.SS "void SetAlgoCompleted (bool algo_completed)"
Tracks that algorithm was able to exhaustively search the entire combination space before hitting limit of tries 
.SS "void SetBumpFeeDiscount (const \fBCAmount\fP discount)"
How much individual inputs overestimated the bump fees for shared ancestries 
.SS "void SetSelectionsEvaluated (size_t attempts)"
Record the number of selections that were evaluated 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
