.TH "BufferedFile" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BufferedFile
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <streams\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBufferedFile\fP (\fBAutoFile\fP &file \fBLIFETIMEBOUND\fP, uint64_t nBufSize, uint64_t nRewindIn)"
.br
.ti -1c
.RI "bool \fBeof\fP () const"
.br
.RI "check whether we're at the end of the source file "
.ti -1c
.RI "void \fBread\fP (std::span< std::byte > dst)"
.br
.RI "read a number of bytes "
.ti -1c
.RI "void \fBSkipTo\fP (const uint64_t file_pos)"
.br
.ti -1c
.RI "uint64_t \fBGetPos\fP () const"
.br
.RI "return the current reading position "
.ti -1c
.RI "bool \fBSetPos\fP (uint64_t nPos)"
.br
.RI "rewind to a given reading position "
.ti -1c
.RI "bool \fBSetLimit\fP (uint64_t nPos=std::numeric_limits< uint64_t >::max())"
.br
.ti -1c
.RI "template<typename \fBT\fP> \fBBufferedFile\fP & \fBoperator>>\fP (\fBT\fP &&obj)"
.br
.ti -1c
.RI "void \fBFindByte\fP (std::byte byte)"
.br
.RI "search for a given byte in the stream, and remain positioned on it "
.in -1c
.SH "Detailed Description"
.PP 
\fBWrapper\fP around an \fBAutoFile\fP& that implements a ring buffer to deserialize from\&. It guarantees the ability to rewind a given number of bytes\&.

.PP
Will automatically close the file when it goes out of scope if not null\&. If you need to close the file early, use file\&.fclose() instead of fclose(file)\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBBufferedFile\fP (\fBAutoFile\fP &file LIFETIMEBOUND, uint64_t nBufSize, uint64_t nRewindIn)\fR [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool eof () const\fR [inline]\fP"

.PP
check whether we're at the end of the source file 
.SS "void FindByte (std::byte byte)\fR [inline]\fP"

.PP
search for a given byte in the stream, and remain positioned on it 
.SS "uint64_t GetPos () const\fR [inline]\fP"

.PP
return the current reading position 
.SS "template<typename \fBT\fP> \fBBufferedFile\fP & operator>> (\fBT\fP && obj)\fR [inline]\fP"

.SS "void read (std::span< std::byte > dst)\fR [inline]\fP"

.PP
read a number of bytes 
.SS "bool SetLimit (uint64_t nPos = \fRstd::numeric_limits<uint64_t>::max()\fP)\fR [inline]\fP"
prevent reading beyond a certain position no argument removes the limit 
.SS "bool SetPos (uint64_t nPos)\fR [inline]\fP"

.PP
rewind to a given reading position 
.SS "void SkipTo (const uint64_t file_pos)\fR [inline]\fP"
Move the read position ahead in the stream to the given position\&. Use \fBSetPos()\fP to back up in the stream, not \fBSkipTo()\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
