.TH "src/secp256k1/include/secp256k1_extrakeys.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/secp256k1/include/secp256k1_extrakeys.h
.SH SYNOPSIS
.br
.PP
\fR#include 'secp256k1\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsecp256k1_xonly_pubkey\fP"
.br
.ti -1c
.RI "struct \fBsecp256k1_keypair\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct secp256k1_xonly_pubkey \fBsecp256k1_xonly_pubkey\fP"
.br
.ti -1c
.RI "typedef struct secp256k1_keypair \fBsecp256k1_keypair\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_xonly_pubkey_parse\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_xonly_pubkey\fP *pubkey, const unsigned char *input32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_xonly_pubkey_serialize\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *output32, const \fBsecp256k1_xonly_pubkey\fP *pubkey) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_xonly_pubkey_cmp\fP (const \fBsecp256k1_context\fP *ctx, const \fBsecp256k1_xonly_pubkey\fP *pk1, const \fBsecp256k1_xonly_pubkey\fP *pk2) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_xonly_pubkey_from_pubkey\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_xonly_pubkey\fP *xonly_pubkey, int *pk_parity, const \fBsecp256k1_pubkey\fP *pubkey) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_xonly_pubkey_tweak_add\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_pubkey\fP *output_pubkey, const \fBsecp256k1_xonly_pubkey\fP *internal_pubkey, const unsigned char *tweak32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_xonly_pubkey_tweak_add_check\fP (const \fBsecp256k1_context\fP *ctx, const unsigned char *tweaked_pubkey32, int tweaked_pk_parity, const \fBsecp256k1_xonly_pubkey\fP *internal_pubkey, const unsigned char *tweak32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(4) \fBSECP256K1_ARG_NONNULL\fP(5)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_keypair_create\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_keypair\fP *keypair, const unsigned char *seckey) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_keypair_sec\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *seckey, const \fBsecp256k1_keypair\fP *keypair) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_keypair_pub\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_pubkey\fP *pubkey, const \fBsecp256k1_keypair\fP *keypair) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_keypair_xonly_pub\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_xonly_pubkey\fP *pubkey, int *pk_parity, const \fBsecp256k1_keypair\fP *keypair) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_keypair_xonly_tweak_add\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_keypair\fP *keypair, const unsigned char *tweak32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct secp256k1_keypair secp256k1_keypair"
Opaque data structure that holds a keypair consisting of a secret and a public key\&.

.PP
The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions\&. It is however guaranteed to be 96 bytes in size, and can be safely copied/moved\&. 
.SS "typedef struct secp256k1_xonly_pubkey secp256k1_xonly_pubkey"
Opaque data structure that holds a parsed and valid "x-only" public key\&. An x-only pubkey encodes a point whose Y coordinate is even\&. It is serialized using only its X coordinate (32 bytes)\&. See BIP-340 for more information about x-only pubkeys\&.

.PP
The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions\&. It is however guaranteed to be 64 bytes in size, and can be safely copied/moved\&. If you need to convert to a format suitable for storage, transmission, use use secp256k1_xonly_pubkey_serialize and secp256k1_xonly_pubkey_parse\&. To compare keys, use secp256k1_xonly_pubkey_cmp\&. 
.SH "Function Documentation"
.PP 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_keypair_create (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_keypair\fP * keypair, const unsigned char * seckey)"
Compute the keypair for a valid secret key\&.

.PP
See the documentation of \fR\fBsecp256k1_ec_seckey_verify\fP\fP for more information about the validity of secret keys\&.

.PP
Returns: 1: secret key is valid 0: secret key is invalid Args: ctx: pointer to a context object (not secp256k1_context_static)\&. Out: keypair: pointer to the created keypair\&. In: seckey: pointer to a 32-byte secret key\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_keypair_pub (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_pubkey\fP * pubkey, const \fBsecp256k1_keypair\fP * keypair)"
Get the public key from a keypair\&.

.PP
Returns: 1 always\&. Args: ctx: pointer to a context object\&. Out: pubkey: pointer to a pubkey object, set to the keypair public key\&. In: keypair: pointer to a keypair\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_keypair_sec (const \fBsecp256k1_context\fP * ctx, unsigned char * seckey, const \fBsecp256k1_keypair\fP * keypair)"
Get the secret key from a keypair\&.

.PP
Returns: 1 always\&. Args: ctx: pointer to a context object\&. Out: seckey: pointer to a 32-byte buffer for the secret key\&. In: keypair: pointer to a keypair\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_keypair_xonly_pub (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_xonly_pubkey\fP * pubkey, int * pk_parity, const \fBsecp256k1_keypair\fP * keypair)"
Get the x-only public key from a keypair\&.

.PP
This is the same as calling secp256k1_keypair_pub and then secp256k1_xonly_pubkey_from_pubkey\&.

.PP
Returns: 1 always\&. Args: ctx: pointer to a context object\&. Out: pubkey: pointer to an xonly_pubkey object, set to the keypair public key after converting it to an xonly_pubkey\&. pk_parity: Ignored if NULL\&. Otherwise, pointer to an integer that will be set to the pk_parity argument of secp256k1_xonly_pubkey_from_pubkey\&. In: keypair: pointer to a keypair\&. 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_keypair_xonly_tweak_add (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_keypair\fP * keypair, const unsigned char * tweak32)"
Tweak a keypair by adding tweak32 to the secret key and updating the public key accordingly\&.

.PP
Calling this function and then secp256k1_keypair_pub results in the same public key as calling secp256k1_keypair_xonly_pub and then secp256k1_xonly_pubkey_tweak_add\&.

.PP
Returns: 0 if the arguments are invalid or the resulting keypair would be invalid (only when the tweak is the negation of the keypair's secret key)\&. 1 otherwise\&.

.PP
Args: ctx: pointer to a context object\&. In/Out: keypair: pointer to a keypair to apply the tweak to\&. Will be set to an invalid value if this function returns 0\&. In: tweak32: pointer to a 32-byte tweak, which must be valid according to secp256k1_ec_seckey_verify or 32 zero bytes\&. For uniformly random 32-byte tweaks, the chance of being invalid is negligible (around 1 in 2^128)\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_xonly_pubkey_cmp (const \fBsecp256k1_context\fP * ctx, const \fBsecp256k1_xonly_pubkey\fP * pk1, const \fBsecp256k1_xonly_pubkey\fP * pk2)"
Compare two x-only public keys using lexicographic order

.PP
Returns: <0 if the first public key is less than the second >0 if the first public key is greater than the second 0 if the two public keys are equal Args: ctx: pointer to a context object\&. In: pubkey1: first public key to compare pubkey2: second public key to compare 
.SS "\fBSECP256K1_API\fP int secp256k1_xonly_pubkey_from_pubkey (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_xonly_pubkey\fP * xonly_pubkey, int * pk_parity, const \fBsecp256k1_pubkey\fP * pubkey)"
Converts a \fBsecp256k1_pubkey\fP into a \fBsecp256k1_xonly_pubkey\fP\&.

.PP
Returns: 1 always\&.

.PP
Args: ctx: pointer to a context object\&. Out: xonly_pubkey: pointer to an x-only public key object for placing the converted public key\&. pk_parity: Ignored if NULL\&. Otherwise, pointer to an integer that will be set to 1 if the point encoded by xonly_pubkey is the negation of the pubkey and set to 0 otherwise\&. In: pubkey: pointer to a public key that is converted\&. 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_xonly_pubkey_parse (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_xonly_pubkey\fP * pubkey, const unsigned char * input32)"
Parse a 32-byte sequence into a xonly_pubkey object\&.

.PP
Returns: 1 if the public key was fully valid\&. 0 if the public key could not be parsed or is invalid\&.

.PP
Args: ctx: pointer to a context object\&. Out: pubkey: pointer to a pubkey object\&. If 1 is returned, it is set to a parsed version of input\&. If not, it's set to an invalid value\&. In: input32: pointer to a serialized xonly_pubkey\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_xonly_pubkey_serialize (const \fBsecp256k1_context\fP * ctx, unsigned char * output32, const \fBsecp256k1_xonly_pubkey\fP * pubkey)"
Serialize an xonly_pubkey object into a 32-byte sequence\&.

.PP
Returns: 1 always\&.

.PP
Args: ctx: pointer to a context object\&. Out: output32: pointer to a 32-byte array to place the serialized key in\&. In: pubkey: pointer to a \fBsecp256k1_xonly_pubkey\fP containing an initialized public key\&. 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_xonly_pubkey_tweak_add (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_pubkey\fP * output_pubkey, const \fBsecp256k1_xonly_pubkey\fP * internal_pubkey, const unsigned char * tweak32)"
Tweak an x-only public key by adding the generator multiplied with tweak32 to it\&.

.PP
Note that the resulting point can not in general be represented by an x-only pubkey because it may have an odd Y coordinate\&. Instead, the output_pubkey is a normal \fBsecp256k1_pubkey\fP\&.

.PP
Returns: 0 if the arguments are invalid or the resulting public key would be invalid (only when the tweak is the negation of the corresponding secret key)\&. 1 otherwise\&.

.PP
Args: ctx: pointer to a context object\&. Out: output_pubkey: pointer to a public key to store the result\&. Will be set to an invalid value if this function returns 0\&. In: internal_pubkey: pointer to an x-only pubkey to apply the tweak to\&. tweak32: pointer to a 32-byte tweak, which must be valid according to secp256k1_ec_seckey_verify or 32 zero bytes\&. For uniformly random 32-byte tweaks, the chance of being invalid is negligible (around 1 in 2^128)\&. 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_xonly_pubkey_tweak_add_check (const \fBsecp256k1_context\fP * ctx, const unsigned char * tweaked_pubkey32, int tweaked_pk_parity, const \fBsecp256k1_xonly_pubkey\fP * internal_pubkey, const unsigned char * tweak32)"
Checks that a tweaked pubkey is the result of calling secp256k1_xonly_pubkey_tweak_add with internal_pubkey and tweak32\&.

.PP
The tweaked pubkey is represented by its 32-byte x-only serialization and its pk_parity, which can both be obtained by converting the result of tweak_add to a \fBsecp256k1_xonly_pubkey\fP\&.

.PP
Note that this alone does \fInot\fP verify that the tweaked pubkey is a commitment\&. If the tweak is not chosen in a specific way, the tweaked pubkey can easily be the result of a different internal_pubkey and tweak\&.

.PP
Returns: 0 if the arguments are invalid or the tweaked pubkey is not the result of tweaking the internal_pubkey with tweak32\&. 1 otherwise\&. Args: ctx: pointer to a context object\&. In: tweaked_pubkey32: pointer to a serialized xonly_pubkey\&. tweaked_pk_parity: the parity of the tweaked pubkey (whose serialization is passed in as tweaked_pubkey32)\&. This must match the pk_parity value that is returned when calling \fBsecp256k1_xonly_pubkey\fP with the tweaked pubkey, or this function will fail\&. internal_pubkey: pointer to an x-only public key object to apply the tweak to\&. tweak32: pointer to a 32-byte tweak\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
