.TH "CCheckQueue< T, R >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CCheckQueue< T, R >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <checkqueue\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCCheckQueue\fP (unsigned int batch_size, int worker_threads_num)"
.br
.RI "Create a new check queue\&. "
.ti -1c
.RI "\fBCCheckQueue\fP (const \fBCCheckQueue\fP &)=delete"
.br
.ti -1c
.RI "\fBCCheckQueue\fP & \fBoperator=\fP (const \fBCCheckQueue\fP &)=delete"
.br
.ti -1c
.RI "\fBCCheckQueue\fP (\fBCCheckQueue\fP &&)=delete"
.br
.ti -1c
.RI "\fBCCheckQueue\fP & \fBoperator=\fP (\fBCCheckQueue\fP &&)=delete"
.br
.ti -1c
.RI "std::optional< R > \fBComplete\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_mutex)"
.br
.ti -1c
.RI "void \fBAdd\fP (std::vector< \fBT\fP > &&vChecks) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_mutex)"
.br
.RI "Add a batch of checks to the queue\&. "
.ti -1c
.RI "\fB~CCheckQueue\fP ()"
.br
.ti -1c
.RI "bool \fBHasThreads\fP () const"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBMutex\fP \fBm_control_mutex\fP"
.br
.RI "\fBMutex\fP to ensure only one concurrent \fBCCheckQueueControl\fP\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>>
.br
class CCheckQueue< T, R >"Queue for verifications that have to be performed\&. The verifications are represented by a type T, which must provide an operator(), returning an std::optional<R>\&.

.PP
The overall result of the computation is std::nullopt if all invocations return std::nullopt, or one of the other results otherwise\&.

.PP
One thread (the master) is assumed to push batches of verifications onto the queue, where they are processed by N-1 worker threads\&. When the master is done adding work, it temporarily joins the worker pool as an N'th worker, until all jobs are done\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> \fBCCheckQueue\fP (unsigned int batch_size, int worker_threads_num)\fR [inline]\fP, \fR [explicit]\fP"

.PP
Create a new check queue\&. 
.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> \fBCCheckQueue\fP (const \fBCCheckQueue\fP< \fBT\fP, R > & )\fR [delete]\fP"

.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> \fBCCheckQueue\fP (\fBCCheckQueue\fP< \fBT\fP, R > && )\fR [delete]\fP"

.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> ~\fBCCheckQueue\fP ()\fR [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> void Add (std::vector< \fBT\fP > && vChecks)\fR [inline]\fP"

.PP
Add a batch of checks to the queue\&. 
.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> std::optional< R > Complete ()\fR [inline]\fP"
Join the execution until completion\&. If at least one evaluation wasn't successful, return its error\&. 
.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> bool HasThreads () const\fR [inline]\fP"

.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> \fBCCheckQueue\fP & operator= (\fBCCheckQueue\fP< \fBT\fP, R > && )\fR [delete]\fP"

.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> \fBCCheckQueue\fP & operator= (const \fBCCheckQueue\fP< \fBT\fP, R > & )\fR [delete]\fP"

.SH "Field Documentation"
.PP 
.SS "template<typename \fBT\fP, typename R = std::remove_cvref_t<decltype(std::declval<T>()()\&.value())>> \fBMutex\fP m_control_mutex"

.PP
\fBMutex\fP to ensure only one concurrent \fBCCheckQueueControl\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
