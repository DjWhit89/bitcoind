.TH "src/test/headers_sync_chainwork_tests.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/test/headers_sync_chainwork_tests.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <chain\&.h>\fP
.br
\fR#include <chainparams\&.h>\fP
.br
\fR#include <consensus/params\&.h>\fP
.br
\fR#include <headerssync\&.h>\fP
.br
\fR#include <net_processing\&.h>\fP
.br
\fR#include <pow\&.h>\fP
.br
\fR#include <test/util/setup_common\&.h>\fP
.br
\fR#include <validation\&.h>\fP
.br
\fR#include <cstddef>\fP
.br
\fR#include <vector>\fP
.br
\fR#include <boost/test/unit_test\&.hpp>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBHeadersGeneratorSetup\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCHECK_RESULT\fP(result_expression,  hss,  exp_state,  exp_success,  exp_request_more,  exp_headers_size,  exp_pow_validated_prev,  exp_locator_hash)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBState\fP = \fBHeadersSyncState::State\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (sneaky_redownload)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (happy_path)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (too_little_work)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "constexpr size_t \fBTARGET_BLOCKS\fP {15'000}"
.br
.ti -1c
.RI "constexpr \fBarith_uint256\fP \fBCHAIN_WORK\fP {\fBTARGET_BLOCKS\fP * 2}"
.br
.ti -1c
.RI "constexpr size_t \fBREDOWNLOAD_BUFFER_SIZE\fP {\fBTARGET_BLOCKS\fP \- (MAX_HEADERS_RESULTS + 123)}"
.br
.ti -1c
.RI "constexpr size_t \fBCOMMITMENT_PERIOD\fP {600}"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define CHECK_RESULT( result_expression,  hss,  exp_state,  exp_success,  exp_request_more,  exp_headers_size,  exp_pow_validated_prev,  exp_locator_hash)"
\fBValue:\fP
.nf
    do {                                                                                                 \\
        const auto result{result_expression};                                                            \\
        BOOST_REQUIRE_EQUAL(hss\&.GetState(), exp_state);                                                  \\
        BOOST_CHECK_EQUAL(result\&.success, exp_success);                                                  \\
        BOOST_CHECK_EQUAL(result\&.request_more, exp_request_more);                                        \\
        BOOST_CHECK_EQUAL(result\&.pow_validated_headers\&.size(), exp_headers_size);                        \\
        const std::optional<uint256> pow_validated_prev_opt{exp_pow_validated_prev};                     \\
        if (pow_validated_prev_opt) {                                                                    \\
            BOOST_CHECK_EQUAL(result\&.pow_validated_headers\&.at(0)\&.hashPrevBlock, pow_validated_prev_opt); \\
        } else {                                                                                         \\
            BOOST_CHECK_EQUAL(exp_headers_size, 0);                                                      \\
        }                                                                                                \\
        const std::optional<uint256> locator_hash_opt{exp_locator_hash};                                 \\
        if (locator_hash_opt) {                                                                          \\
            BOOST_CHECK_EQUAL(hss\&.NextHeadersRequestLocator()\&.vHave\&.at(0), locator_hash_opt);            \\
        } else {                                                                                         \\
            BOOST_CHECK_EQUAL(exp_state, State::FINAL);                                                  \\
        }                                                                                                \\
    } while (false)
.PP
.fi

.SH "Typedef Documentation"
.PP 
.SS "using \fBState\fP = \fBHeadersSyncState::State\fP"

.SH "Function Documentation"
.PP 
.SS "BOOST_AUTO_TEST_CASE (happy_path )"

.SS "BOOST_AUTO_TEST_CASE (sneaky_redownload )"

.SS "BOOST_AUTO_TEST_CASE (too_little_work )"

.SH "Variable Documentation"
.PP 
.SS "\fBarith_uint256\fP CHAIN_WORK {\fBTARGET_BLOCKS\fP * 2}\fR [constexpr]\fP"

.SS "size_t COMMITMENT_PERIOD {600}\fR [constexpr]\fP"

.SS "size_t REDOWNLOAD_BUFFER_SIZE {\fBTARGET_BLOCKS\fP \- (MAX_HEADERS_RESULTS + 123)}\fR [constexpr]\fP"

.SS "size_t TARGET_BLOCKS {15'000}\fR [constexpr]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
