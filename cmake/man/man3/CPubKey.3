.TH "CPubKey" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CPubKey
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <pubkey\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCPubKey\fP ()"
.br
.RI "Construct an invalid public key\&. "
.ti -1c
.RI "template<typename \fBT\fP> void \fBSet\fP (const \fBT\fP pbegin, const \fBT\fP pend)"
.br
.RI "Initialize a public key using begin/end iterators to byte data\&. "
.ti -1c
.RI "template<typename \fBT\fP> \fBCPubKey\fP (const \fBT\fP pbegin, const \fBT\fP pend)"
.br
.RI "Construct a public key using begin/end iterators to byte data\&. "
.ti -1c
.RI "\fBCPubKey\fP (std::span< const uint8_t > _vch)"
.br
.RI "Construct a public key from a byte vector\&. "
.ti -1c
.RI "unsigned int \fBsize\fP () const"
.br
.RI "Simple read-only vector-like interface to the pubkey data\&. "
.ti -1c
.RI "const unsigned char * \fBdata\fP () const"
.br
.ti -1c
.RI "const unsigned char * \fBbegin\fP () const"
.br
.ti -1c
.RI "const unsigned char * \fBend\fP () const"
.br
.ti -1c
.RI "const unsigned char & \fBoperator[]\fP (unsigned int pos) const"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s) const"
.br
.RI "Implement serialization, as if this was a byte vector\&. "
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s)"
.br
.ti -1c
.RI "\fBCKeyID\fP \fBGetID\fP () const"
.br
.RI "Get the KeyID of this public key (hash of its serialization)\&. "
.ti -1c
.RI "\fBuint256\fP \fBGetHash\fP () const"
.br
.RI "Get the 256-bit hash of this public key\&. "
.ti -1c
.RI "bool \fBIsValid\fP () const"
.br
.ti -1c
.RI "bool \fBIsValidNonHybrid\fP () const noexcept"
.br
.ti -1c
.RI "bool \fBIsFullyValid\fP () const"
.br
.RI "fully validate whether this is a valid public key (more expensive than \fBIsValid()\fP) "
.ti -1c
.RI "bool \fBIsCompressed\fP () const"
.br
.RI "Check whether this is a compressed public key\&. "
.ti -1c
.RI "bool \fBVerify\fP (const \fBuint256\fP &hash, const std::vector< unsigned char > &vchSig) const"
.br
.ti -1c
.RI "bool \fBRecoverCompact\fP (const \fBuint256\fP &hash, const std::vector< unsigned char > &vchSig)"
.br
.RI "Recover a public key from a compact signature\&. "
.ti -1c
.RI "bool \fBDecompress\fP ()"
.br
.RI "Turn this public key into an uncompressed public key\&. "
.ti -1c
.RI "bool \fBDerive\fP (\fBCPubKey\fP &pubkeyChild, \fBChainCode\fP &ccChild, unsigned int nChild, const \fBChainCode\fP &cc, \fBuint256\fP *bip32_tweak_out=nullptr) const"
.br
.RI "Derive BIP32 child pubkey\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBValidSize\fP (const std::vector< unsigned char > &vch)"
.br
.ti -1c
.RI "static bool \fBCheckLowS\fP (const std::vector< unsigned char > &vchSig)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr unsigned int \fBSIZE\fP = 65"
.br
.ti -1c
.RI "static constexpr unsigned int \fBCOMPRESSED_SIZE\fP = 33"
.br
.ti -1c
.RI "static constexpr unsigned int \fBSIGNATURE_SIZE\fP = 72"
.br
.ti -1c
.RI "static constexpr unsigned int \fBCOMPACT_SIGNATURE_SIZE\fP = 65"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator==\fP (const \fBCPubKey\fP &a, const \fBCPubKey\fP &b)"
.br
.RI "\fBComparator\fP implementation\&. "
.ti -1c
.RI "bool \fBoperator<\fP (const \fBCPubKey\fP &a, const \fBCPubKey\fP &b)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (const \fBCPubKey\fP &a, const \fBCPubKey\fP &b)"
.br
.in -1c
.SH "Detailed Description"
.PP 
An encapsulated public key\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCPubKey\fP ()\fR [inline]\fP"

.PP
Construct an invalid public key\&. 
.SS "template<typename \fBT\fP> \fBCPubKey\fP (const \fBT\fP pbegin, const \fBT\fP pend)\fR [inline]\fP"

.PP
Construct a public key using begin/end iterators to byte data\&. 
.SS "\fBCPubKey\fP (std::span< const uint8_t > _vch)\fR [inline]\fP, \fR [explicit]\fP"

.PP
Construct a public key from a byte vector\&. 
.SH "Member Function Documentation"
.PP 
.SS "const unsigned char * begin () const\fR [inline]\fP"

.SS "bool CheckLowS (const std::vector< unsigned char > & vchSig)\fR [static]\fP"
Check whether a signature is normalized (lower-S)\&. 
.SS "const unsigned char * data () const\fR [inline]\fP"

.SS "bool Decompress ()"

.PP
Turn this public key into an uncompressed public key\&. 
.SS "bool Derive (\fBCPubKey\fP & pubkeyChild, \fBChainCode\fP & ccChild, unsigned int nChild, const \fBChainCode\fP & cc, \fBuint256\fP * bip32_tweak_out = \fRnullptr\fP) const\fR [nodiscard]\fP"

.PP
Derive BIP32 child pubkey\&. 
.SS "const unsigned char * end () const\fR [inline]\fP"

.SS "\fBuint256\fP GetHash () const\fR [inline]\fP"

.PP
Get the 256-bit hash of this public key\&. 
.SS "\fBCKeyID\fP GetID () const\fR [inline]\fP"

.PP
Get the KeyID of this public key (hash of its serialization)\&. 
.SS "bool IsCompressed () const\fR [inline]\fP"

.PP
Check whether this is a compressed public key\&. 
.SS "bool IsFullyValid () const"

.PP
fully validate whether this is a valid public key (more expensive than \fBIsValid()\fP) 
.SS "bool IsValid () const\fR [inline]\fP"

.SS "bool IsValidNonHybrid () const\fR [inline]\fP, \fR [noexcept]\fP"
Check if a public key is a syntactically valid compressed or uncompressed key\&. 
.SS "const unsigned char & operator[] (unsigned int pos) const\fR [inline]\fP"

.SS "bool RecoverCompact (const \fBuint256\fP & hash, const std::vector< unsigned char > & vchSig)"

.PP
Recover a public key from a compact signature\&. 
.SS "template<typename Stream> void Serialize (Stream & s) const\fR [inline]\fP"

.PP
Implement serialization, as if this was a byte vector\&. 
.SS "template<typename \fBT\fP> void Set (const \fBT\fP pbegin, const \fBT\fP pend)\fR [inline]\fP"

.PP
Initialize a public key using begin/end iterators to byte data\&. 
.SS "unsigned int size () const\fR [inline]\fP"

.PP
Simple read-only vector-like interface to the pubkey data\&. 
.SS "template<typename Stream> void Unserialize (Stream & s)\fR [inline]\fP"

.SS "bool ValidSize (const std::vector< unsigned char > & vch)\fR [inline]\fP, \fR [static]\fP"

.SS "bool Verify (const \fBuint256\fP & hash, const std::vector< unsigned char > & vchSig) const"
Verify a DER signature (~72 bytes)\&. If this public key is not fully valid, the return value will be false\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "bool operator< (const \fBCPubKey\fP & a, const \fBCPubKey\fP & b)\fR [friend]\fP"

.SS "bool operator== (const \fBCPubKey\fP & a, const \fBCPubKey\fP & b)\fR [friend]\fP"

.PP
\fBComparator\fP implementation\&. 
.SS "bool operator> (const \fBCPubKey\fP & a, const \fBCPubKey\fP & b)\fR [friend]\fP"

.SH "Field Documentation"
.PP 
.SS "unsigned int COMPACT_SIGNATURE_SIZE = 65\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned int COMPRESSED_SIZE = 33\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned int SIGNATURE_SIZE = 72\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned int SIZE = 65\fR [static]\fP, \fR [constexpr]\fP"
secp256k1: 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
