.TH "base_blob< BITS >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
base_blob< BITS >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <uint256\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "constexpr \fBbase_blob\fP ()"
.br
.ti -1c
.RI "constexpr \fBbase_blob\fP (uint8_t v)"
.br
.ti -1c
.RI "constexpr \fBbase_blob\fP (std::span< const unsigned char > vch)"
.br
.ti -1c
.RI "consteval \fBbase_blob\fP (std::string_view hex_str)"
.br
.ti -1c
.RI "constexpr bool \fBIsNull\fP () const"
.br
.ti -1c
.RI "constexpr void \fBSetNull\fP ()"
.br
.ti -1c
.RI "constexpr int \fBCompare\fP (const \fBbase_blob\fP &other) const"
.br
.ti -1c
.RI "constexpr const unsigned char * \fBdata\fP () const"
.br
.ti -1c
.RI "constexpr unsigned char * \fBdata\fP ()"
.br
.ti -1c
.RI "constexpr unsigned char * \fBbegin\fP ()"
.br
.ti -1c
.RI "constexpr unsigned char * \fBend\fP ()"
.br
.ti -1c
.RI "constexpr const unsigned char * \fBbegin\fP () const"
.br
.ti -1c
.RI "constexpr const unsigned char * \fBend\fP () const"
.br
.ti -1c
.RI "constexpr uint64_t \fBGetUint64\fP (int pos) const"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s) const"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s)"
.br
.in -1c
.PP
.RI "\fBHex representation\fP"
.br
The hex representation used by \fBGetHex()\fP, \fBToString()\fP, and FromHex() is unusual, since it shows bytes of the \fBbase_blob\fP in reverse order\&. For example, a 4-byte blob {0x12, 0x34, 0x56, 0x78} is represented as "78563412" instead of the more typical "12345678" representation that would be shown in a hex editor or used by typical byte-array / hex conversion functions like python's bytes\&.hex() and bytes\&.fromhex()\&.

.PP
The nice thing about the reverse-byte representation, even though it is unusual, is that if a blob contains an arithmetic number in little endian format (with least significant bytes first, and most significant bytes last), the \fBGetHex()\fP output will match the way the number would normally be written in base-16 (with most significant digits first and least significant digits last)\&.

.PP
This means, for example, that ArithToUint256(num)\&.\fBGetHex()\fP can be used to display an \fBarith_uint256\fP num value as a number, because \fBArithToUint256()\fP converts the number to a blob in little-endian format, so the \fBarith_uint256\fP class doesn't need to have its own number parsing and formatting functions\&. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "std::string \fBGetHex\fP () const"
.br
.ti -1c
.RI "std::string \fBToString\fP () const"
.br
.in -1c
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static constexpr unsigned int \fBsize\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::array< uint8_t, \fBWIDTH\fP > \fBm_data\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static constexpr int \fBWIDTH\fP = BITS / 8"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "constexpr bool \fBoperator==\fP (const \fBbase_blob\fP &a, const \fBbase_blob\fP &b)"
.br
.ti -1c
.RI "constexpr bool \fBoperator<\fP (const \fBbase_blob\fP &a, const \fBbase_blob\fP &b)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<unsigned int BITS>
.br
class base_blob< BITS >"Template base class for fixed-sized opaque blobs\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<unsigned int BITS> \fBbase_blob\fP ()\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> \fBbase_blob\fP (uint8_t v)\fR [inline]\fP, \fR [explicit]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> \fBbase_blob\fP (std::span< const unsigned char > vch)\fR [inline]\fP, \fR [explicit]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> \fBbase_blob\fP (std::string_view hex_str)\fR [explicit]\fP, \fR [consteval]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<unsigned int BITS> unsigned char * begin ()\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> const unsigned char * begin () const\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> int Compare (const \fBbase_blob\fP< BITS > & other) const\fR [inline]\fP, \fR [constexpr]\fP"
Lexicographic ordering 
.PP
\fBNote\fP
.RS 4
Does NOT match the ordering on the corresponding \fBCompareTo\fP, which starts comparing from the end\&. 
.RE
.PP

.SS "template<unsigned int BITS> unsigned char * data ()\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> const unsigned char * data () const\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> unsigned char * end ()\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> const unsigned char * end () const\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> template std::string GetHex () const"

.SS "template<unsigned int BITS> uint64_t GetUint64 (int pos) const\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> bool IsNull () const\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> template<typename Stream> void Serialize (Stream & s) const\fR [inline]\fP"

.SS "template<unsigned int BITS> void SetNull ()\fR [inline]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> constexpr unsigned int size ()\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP"

.SS "template<unsigned int BITS> template std::string ToString () const"

.SS "template<unsigned int BITS> template<typename Stream> void Unserialize (Stream & s)\fR [inline]\fP"

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<unsigned int BITS> bool operator< (const \fBbase_blob\fP< BITS > & a, const \fBbase_blob\fP< BITS > & b)\fR [friend]\fP"

.SS "template<unsigned int BITS> bool operator== (const \fBbase_blob\fP< BITS > & a, const \fBbase_blob\fP< BITS > & b)\fR [friend]\fP"

.SH "Field Documentation"
.PP 
.SS "template<unsigned int BITS> std::array<uint8_t, \fBWIDTH\fP> m_data\fR [protected]\fP"

.SS "template<unsigned int BITS> int WIDTH = BITS / 8\fR [static]\fP, \fR [constexpr]\fP, \fR [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
