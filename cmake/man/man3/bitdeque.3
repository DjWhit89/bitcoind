.TH "bitdeque< BITS_PER_WORD >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
bitdeque< BITS_PER_WORD >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <bitdeque\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBvalue_type\fP = bool"
.br
.ti -1c
.RI "using \fBsize_type\fP = std::size_t"
.br
.ti -1c
.RI "using \fBdifference_type\fP = typename deque_type::difference_type"
.br
.ti -1c
.RI "using \fBreference\fP = typename word_type::reference"
.br
.ti -1c
.RI "using \fBconst_reference\fP = bool"
.br
.ti -1c
.RI "using \fBiterator\fP = \fBIterator\fP<false>"
.br
.ti -1c
.RI "using \fBconst_iterator\fP = \fBIterator\fP<true>"
.br
.ti -1c
.RI "using \fBpointer\fP = void"
.br
.ti -1c
.RI "using \fBconst_pointer\fP = void"
.br
.ti -1c
.RI "using \fBreverse_iterator\fP = std::reverse_iterator<\fBiterator\fP>"
.br
.ti -1c
.RI "using \fBconst_reverse_iterator\fP = std::reverse_iterator<\fBconst_iterator\fP>"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbitdeque\fP ()"
.br
.ti -1c
.RI "void \fBassign\fP (\fBsize_type\fP count, bool val)"
.br
.ti -1c
.RI "\fBbitdeque\fP (\fBsize_type\fP count, bool val)"
.br
.ti -1c
.RI "\fBbitdeque\fP (size_t count)"
.br
.ti -1c
.RI "\fBbitdeque\fP (const \fBbitdeque\fP &)=default"
.br
.ti -1c
.RI "\fBbitdeque\fP (\fBbitdeque\fP &&) noexcept=default"
.br
.ti -1c
.RI "\fBbitdeque\fP & \fBoperator=\fP (const \fBbitdeque\fP &other)=default"
.br
.ti -1c
.RI "\fBbitdeque\fP & \fBoperator=\fP (\fBbitdeque\fP &&other) noexcept=default"
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP () noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const noexcept"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "\fBsize_type\fP \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "\fBsize_type\fP \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "template<typename It> void \fBassign\fP (It first, It last)"
.br
.ti -1c
.RI "void \fBassign\fP (std::initializer_list< bool > ilist)"
.br
.ti -1c
.RI "\fBbitdeque\fP & \fBoperator=\fP (std::initializer_list< bool > ilist)"
.br
.ti -1c
.RI "template<typename It> \fBbitdeque\fP (It first, It last)"
.br
.ti -1c
.RI "\fBbitdeque\fP (std::initializer_list< bool > ilist)"
.br
.ti -1c
.RI "\fBreference\fP \fBat\fP (\fBsize_type\fP position)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBat\fP (\fBsize_type\fP position) const"
.br
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (\fBsize_type\fP position)"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBoperator[]\fP (\fBsize_type\fP position) const"
.br
.ti -1c
.RI "\fBreference\fP \fBfront\fP ()"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBfront\fP () const"
.br
.ti -1c
.RI "\fBreference\fP \fBback\fP ()"
.br
.ti -1c
.RI "\fBconst_reference\fP \fBback\fP () const"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "void \fBpush_back\fP (bool val)"
.br
.ti -1c
.RI "\fBreference\fP \fBemplace_back\fP (bool val)"
.br
.ti -1c
.RI "void \fBpush_front\fP (bool val)"
.br
.ti -1c
.RI "\fBreference\fP \fBemplace_front\fP (bool val)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBresize\fP (\fBsize_type\fP n)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBbitdeque\fP &other) noexcept"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP first, \fBconst_iterator\fP last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP first, \fBiterator\fP last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBconst_iterator\fP pos)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP pos)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, bool val)"
.br
.ti -1c
.RI "\fBiterator\fP \fBemplace\fP (\fBconst_iterator\fP pos, bool val)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, \fBsize_type\fP count, bool val)"
.br
.ti -1c
.RI "template<typename It> \fBiterator\fP \fBinsert\fP (\fBconst_iterator\fP pos, It first, It last)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<bool Const> class \fBIterator\fP"
.br
.ti -1c
.RI "void \fBswap\fP (\fBbitdeque\fP &b1, \fBbitdeque\fP &b2) noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<int BITS_PER_WORD = 4096 * 8>
.br
class bitdeque< BITS_PER_WORD >"Class that mimics std::deque<bool>, but with std::vector<bool>'s bit packing\&.

.PP
BITS_PER_WORD selects the (minimum) number of bits that are allocated at once\&. Larger values reduce the asymptotic memory usage overhead, at the cost of needing larger up-front allocations\&. The default is 4096 bytes\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBconst_iterator\fP = \fBIterator\fP<true>"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBconst_pointer\fP = void"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBconst_reference\fP = bool"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBconst_reverse_iterator\fP = std::reverse_iterator<\fBconst_iterator\fP>"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBdifference_type\fP = typename deque_type::difference_type"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBiterator\fP = \fBIterator\fP<false>"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBpointer\fP = void"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBreference\fP = typename word_type::reference"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBreverse_iterator\fP = std::reverse_iterator<\fBiterator\fP>"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBsize_type\fP = std::size_t"

.SS "template<int BITS_PER_WORD = 4096 * 8> using \fBvalue_type\fP = bool"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP ()\fR [inline]\fP, \fR [explicit]\fP"
Construct an empty container\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP (\fBsize_type\fP count, bool val)\fR [inline]\fP"
Construct a container containing count times the value of val\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP (size_t count)\fR [inline]\fP, \fR [explicit]\fP"
Construct a container containing count false values\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP (const \fBbitdeque\fP< BITS_PER_WORD > & )\fR [default]\fP"
Copy constructor\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP (\fBbitdeque\fP< BITS_PER_WORD > && )\fR [default]\fP, \fR [noexcept]\fP"
Move constructor\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> template<typename It> \fBbitdeque\fP (It first, It last)\fR [inline]\fP"
Construct a container containing the bits in [first,last)\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP (std::initializer_list< bool > ilist)\fR [inline]\fP"
Construct a container containing the bits in ilist\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<int BITS_PER_WORD = 4096 * 8> template<typename It> void assign (It first, It last)\fR [inline]\fP"
Set the container equal to the bits in [first,last)\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> void assign (\fBsize_type\fP count, bool val)\fR [inline]\fP"
Set the container equal to count times the value of val\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> void assign (std::initializer_list< bool > ilist)\fR [inline]\fP"
Set the container equal to the bits in ilist\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreference\fP at (\fBsize_type\fP position)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reference\fP at (\fBsize_type\fP position) const\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreference\fP back ()\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reference\fP back () const\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_iterator\fP begin () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP begin ()\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_iterator\fP cbegin () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_iterator\fP cend () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void clear ()\fR [inline]\fP, \fR [noexcept]\fP"
Empty the container\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reverse_iterator\fP crbegin () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reverse_iterator\fP crend () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP emplace (\fBconst_iterator\fP pos, bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreference\fP emplace_back (bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreference\fP emplace_front (bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> bool empty () const\fR [inline]\fP, \fR [noexcept]\fP"
Determine whether the container is empty\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_iterator\fP end () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP end ()\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP erase (\fBconst_iterator\fP first, \fBconst_iterator\fP last)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP erase (\fBconst_iterator\fP pos)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP erase (\fBiterator\fP first, \fBiterator\fP last)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP erase (\fBiterator\fP pos)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreference\fP front ()\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reference\fP front () const\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP insert (\fBconst_iterator\fP pos, bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> template<typename It> \fBiterator\fP insert (\fBconst_iterator\fP pos, It first, It last)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBiterator\fP insert (\fBconst_iterator\fP pos, \fBsize_type\fP count, bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBsize_type\fP max_size () const\fR [inline]\fP, \fR [noexcept]\fP"
Return the maximum size of the container\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP & operator= (\fBbitdeque\fP< BITS_PER_WORD > && other)\fR [default]\fP, \fR [noexcept]\fP"
Move assignment operator\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP & operator= (const \fBbitdeque\fP< BITS_PER_WORD > & other)\fR [default]\fP"
Copy assignment operator\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBbitdeque\fP & operator= (std::initializer_list< bool > ilist)\fR [inline]\fP"
Set the container equal to the bits in ilist\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreference\fP operator[] (\fBsize_type\fP position)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reference\fP operator[] (\fBsize_type\fP position) const\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void pop_back ()\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void pop_front ()\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void push_back (bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void push_front (bool val)\fR [inline]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reverse_iterator\fP rbegin () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreverse_iterator\fP rbegin ()\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBconst_reverse_iterator\fP rend () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> \fBreverse_iterator\fP rend ()\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void resize (\fBsize_type\fP n)\fR [inline]\fP"
Resize the container\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> void shrink_to_fit ()\fR [inline]\fP"
Release unused memory\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> \fBsize_type\fP size () const\fR [inline]\fP, \fR [noexcept]\fP"
Count the number of bits in the container\&. 
.SS "template<int BITS_PER_WORD = 4096 * 8> void swap (\fBbitdeque\fP< BITS_PER_WORD > & other)\fR [inline]\fP, \fR [noexcept]\fP"

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<int BITS_PER_WORD = 4096 * 8> template<bool Const> friend class \fBIterator\fP\fR [friend]\fP"

.SS "template<int BITS_PER_WORD = 4096 * 8> void swap (\fBbitdeque\fP< BITS_PER_WORD > & b1, \fBbitdeque\fP< BITS_PER_WORD > & b2)\fR [friend]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
