.TH "miniscript::internal" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
miniscript::internal
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBInputStack\fP"
.br
.RI "An object representing a sequence of witness stack elements\&. "
.ti -1c
.RI "struct \fBInputResult\fP"
.br
.RI "A pair of a satisfaction and a dissatisfaction \fBInputStack\fP\&. "
.ti -1c
.RI "struct \fBMaxInt\fP"
.br
.RI "Class whose objects represent the maximum of a list of integers\&. "
.ti -1c
.RI "struct \fBOps\fP"
.br
.ti -1c
.RI "struct \fBSatInfo\fP"
.br
.ti -1c
.RI "struct \fBStackSize\fP"
.br
.ti -1c
.RI "struct \fBWitnessSize\fP"
.br
.ti -1c
.RI "struct \fBNoDupCheck\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBParseContext\fP { \fBWRAPPED_EXPR\fP, \fBEXPR\fP, \fBSWAP\fP, \fBALT\fP, \fBCHECK\fP, \fBDUP_IF\fP, \fBVERIFY\fP, \fBNON_ZERO\fP, \fBZERO_NOTEQUAL\fP, \fBWRAP_U\fP, \fBWRAP_T\fP, \fBAND_N\fP, \fBAND_V\fP, \fBAND_B\fP, \fBANDOR\fP, \fBOR_B\fP, \fBOR_C\fP, \fBOR_D\fP, \fBOR_I\fP, \fBTHRESH\fP, \fBCOMMA\fP, \fBCLOSE_BRACKET\fP }"
.br
.ti -1c
.RI "enum class \fBDecodeContext\fP { \fBSINGLE_BKV_EXPR\fP, \fBBKV_EXPR\fP, \fBW_EXPR\fP, \fBSWAP\fP, \fBALT\fP, \fBCHECK\fP, \fBDUP_IF\fP, \fBVERIFY\fP, \fBNON_ZERO\fP, \fBZERO_NOTEQUAL\fP, \fBMAYBE_AND_V\fP, \fBAND_V\fP, \fBAND_B\fP, \fBANDOR\fP, \fBOR_B\fP, \fBOR_C\fP, \fBOR_D\fP, \fBTHRESH_W\fP, \fBTHRESH_E\fP, \fBENDIF\fP, \fBENDIF_NOTIF\fP, \fBENDIF_ELSE\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBType\fP \fBSanitizeType\fP (\fBType\fP x)"
.br
.RI "A helper sanitizer/checker for the output of CalcType\&. "
.ti -1c
.RI "\fBType\fP \fBComputeType\fP (\fBFragment\fP fragment, \fBType\fP x, \fBType\fP y, \fBType\fP z, const std::vector< \fBType\fP > &sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys, \fBMiniscriptContext\fP ms_ctx)"
.br
.RI "Helper function for Node::CalcType\&. "
.ti -1c
.RI "size_t \fBComputeScriptLen\fP (\fBFragment\fP fragment, \fBType\fP sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys, \fBMiniscriptContext\fP ms_ctx)"
.br
.RI "Helper function for Node::CalcScriptLen\&. "
.ti -1c
.RI "\fBInputStack\fP \fBoperator+\fP (\fBInputStack\fP a, \fBInputStack\fP b)"
.br
.ti -1c
.RI "\fBInputStack\fP \fBoperator|\fP (\fBInputStack\fP a, \fBInputStack\fP b)"
.br
.ti -1c
.RI "std::optional< std::vector< \fBOpcode\fP > > \fBDecomposeScript\fP (const \fBCScript\fP &\fBscript\fP)"
.br
.ti -1c
.RI "std::optional< int64_t > \fBParseScriptNumber\fP (const \fBOpcode\fP &in)"
.br
.ti -1c
.RI "int \fBFindNextChar\fP (std::span< const char > sp, const char m)"
.br
.ti -1c
.RI "constexpr uint32_t \fBMaxScriptSize\fP (\fBMiniscriptContext\fP ms_ctx)"
.br
.ti -1c
.RI "template<typename Key, typename Ctx> std::optional< std::pair< Key, int > > \fBParseKeyEnd\fP (std::span< const char > in, const Ctx &ctx)"
.br
.ti -1c
.RI "template<typename Ctx> std::optional< std::pair< std::vector< unsigned char >, int > > \fBParseHexStrEnd\fP (std::span< const char > in, const size_t expected_size, const Ctx &ctx)"
.br
.ti -1c
.RI "template<typename Key> void \fBBuildBack\fP (const \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > &constructed, const bool reverse=false)"
.br
.ti -1c
.RI "template<typename Key, typename Ctx> \fBNodeRef\fP< Key > \fBParse\fP (std::span< const char > in, const Ctx &ctx)"
.br
.ti -1c
.RI "template<typename Key, typename Ctx, typename I> \fBNodeRef\fP< Key > \fBDecodeScript\fP (I &in, I last, const Ctx &ctx)"
.br
.RI "Parse a miniscript from a bitcoin script\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "constexpr uint32_t \fBTX_OVERHEAD\fP {4 + 4}"
.br
.RI "version + nLockTime "
.ti -1c
.RI "constexpr uint32_t \fBTXIN_BYTES_NO_WITNESS\fP {36 + 4 + 1}"
.br
.RI "prevout + nSequence + scriptSig "
.ti -1c
.RI "constexpr uint32_t \fBP2WSH_TXOUT_BYTES\fP {8 + 1 + 1 + 33}"
.br
.RI "nValue + script len + OP_0 + pushdata 32\&. "
.ti -1c
.RI "constexpr uint32_t \fBTX_BODY_LEEWAY_WEIGHT\fP {(\fBTX_OVERHEAD\fP + \fBGetSizeOfCompactSize\fP(1) + \fBTXIN_BYTES_NO_WITNESS\fP + \fBGetSizeOfCompactSize\fP(1) + \fBP2WSH_TXOUT_BYTES\fP) * WITNESS_SCALE_FACTOR + 2}"
.br
.RI "Data other than the witness in a transaction\&. Overhead + vin count + one vin + vout count + one vout + segwit marker\&. "
.ti -1c
.RI "constexpr uint32_t \fBMAX_TAPSCRIPT_SAT_SIZE\fP {\fBGetSizeOfCompactSize\fP(MAX_STACK_SIZE) + (\fBGetSizeOfCompactSize\fP(MAX_TAPMINISCRIPT_STACK_ELEM_SIZE) + MAX_TAPMINISCRIPT_STACK_ELEM_SIZE) * MAX_STACK_SIZE + \fBGetSizeOfCompactSize\fP(TAPROOT_CONTROL_MAX_SIZE) + TAPROOT_CONTROL_MAX_SIZE}"
.br
.RI "Maximum possible stack size to spend a Taproot output (excluding the script itself)\&. "
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBDecodeContext\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISINGLE_BKV_EXPR \fP
A single expression of type B, K, or V\&. Specifically, this can't be an and_v or an expression of type W (a: and s: wrappers)\&. 
.TP
\f(BIBKV_EXPR \fP
Potentially multiple SINGLE_BKV_EXPRs as children of (potentially multiple) and_v expressions\&. Syntactic sugar for MAYBE_AND_V + SINGLE_BKV_EXPR\&. 
.TP
\f(BIW_EXPR \fP
An expression of type W (a: or s: wrappers)\&. 
.TP
\f(BISWAP \fP
SWAP expects the next element to be OP_SWAP (inside a W-type expression that didn't end with FROMALTSTACK), and wraps the top of the constructed stack with s: 
.TP
\f(BIALT \fP
ALT expects the next element to be TOALTSTACK (we must have already read a FROMALTSTACK earlier), and wraps the top of the constructed stack with a: 
.TP
\f(BICHECK \fP
CHECK wraps the top constructed node with c: 
.TP
\f(BIDUP_IF \fP
DUP_IF wraps the top constructed node with d: 
.TP
\f(BIVERIFY \fP
VERIFY wraps the top constructed node with v: 
.TP
\f(BINON_ZERO \fP
NON_ZERO wraps the top constructed node with j: 
.TP
\f(BIZERO_NOTEQUAL \fP
ZERO_NOTEQUAL wraps the top constructed node with n: 
.TP
\f(BIMAYBE_AND_V \fP
MAYBE_AND_V will check if the next part of the script could be a valid miniscript sub-expression, and if so it will push AND_V and SINGLE_BKV_EXPR to decode it and construct the and_v node\&. This is recursive, to deal with multiple and_v nodes inside each other\&. 
.TP
\f(BIAND_V \fP
AND_V will construct an and_v node from the last two constructed nodes\&. 
.TP
\f(BIAND_B \fP
AND_B will construct an and_b node from the last two constructed nodes\&. 
.TP
\f(BIANDOR \fP
ANDOR will construct an andor node from the last three constructed nodes\&. 
.TP
\f(BIOR_B \fP
OR_B will construct an or_b node from the last two constructed nodes\&. 
.TP
\f(BIOR_C \fP
OR_C will construct an or_c node from the last two constructed nodes\&. 
.TP
\f(BIOR_D \fP
OR_D will construct an or_d node from the last two constructed nodes\&. 
.TP
\f(BITHRESH_W \fP
In a thresh expression, all sub-expressions other than the first are W-type, and end in OP_ADD\&. THRESH_W will check for this OP_ADD and either push a W_EXPR or a SINGLE_BKV_EXPR and jump to THRESH_E accordingly\&. 
.TP
\f(BITHRESH_E \fP
THRESH_E constructs a thresh node from the appropriate number of constructed children\&. 
.TP
\f(BIENDIF \fP
ENDIF signals that we are inside some sort of OP_IF structure, which could be or_d, or_c, or_i, andor, d:, or j: wrapper, depending on what follows\&. We read a BKV_EXPR and then deal with the next opcode case-by-case\&. 
.TP
\f(BIENDIF_NOTIF \fP
If, inside an ENDIF context, we find an OP_NOTIF before finding an OP_ELSE, we could either be in an or_d or an or_c node\&. We then check for IFDUP to distinguish these cases\&. 
.TP
\f(BIENDIF_ELSE \fP
If, inside an ENDIF context, we find an OP_ELSE, then we could be in either an or_i or an andor node\&. Read the next BKV_EXPR and find either an OP_IF or an OP_NOTIF\&. 
.SS "enum class \fBParseContext\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIWRAPPED_EXPR \fP
An expression which may be begin with wrappers followed by a colon\&. 
.TP
\f(BIEXPR \fP
A miniscript expression which does not begin with wrappers\&. 
.TP
\f(BISWAP \fP
SWAP wraps the top constructed node with s: 
.TP
\f(BIALT \fP
ALT wraps the top constructed node with a: 
.TP
\f(BICHECK \fP
CHECK wraps the top constructed node with c: 
.TP
\f(BIDUP_IF \fP
DUP_IF wraps the top constructed node with d: 
.TP
\f(BIVERIFY \fP
VERIFY wraps the top constructed node with v: 
.TP
\f(BINON_ZERO \fP
NON_ZERO wraps the top constructed node with j: 
.TP
\f(BIZERO_NOTEQUAL \fP
ZERO_NOTEQUAL wraps the top constructed node with n: 
.TP
\f(BIWRAP_U \fP
WRAP_U will construct an or_i(X,0) node from the top constructed node\&. 
.TP
\f(BIWRAP_T \fP
WRAP_T will construct an and_v(X,1) node from the top constructed node\&. 
.TP
\f(BIAND_N \fP
AND_N will construct an andor(X,Y,0) node from the last two constructed nodes\&. 
.TP
\f(BIAND_V \fP
AND_V will construct an and_v node from the last two constructed nodes\&. 
.TP
\f(BIAND_B \fP
AND_B will construct an and_b node from the last two constructed nodes\&. 
.TP
\f(BIANDOR \fP
ANDOR will construct an andor node from the last three constructed nodes\&. 
.TP
\f(BIOR_B \fP
OR_B will construct an or_b node from the last two constructed nodes\&. 
.TP
\f(BIOR_C \fP
OR_C will construct an or_c node from the last two constructed nodes\&. 
.TP
\f(BIOR_D \fP
OR_D will construct an or_d node from the last two constructed nodes\&. 
.TP
\f(BIOR_I \fP
OR_I will construct an or_i node from the last two constructed nodes\&. 
.TP
\f(BITHRESH \fP
THRESH will read a wrapped expression, and then look for a COMMA\&. If no comma follows, it will construct a thresh node from the appropriate number of constructed children\&. Otherwise, it will recurse with another THRESH\&. 
.TP
\f(BICOMMA \fP
COMMA expects the next element to be ',' and fails if not\&. 
.TP
\f(BICLOSE_BRACKET \fP
CLOSE_BRACKET expects the next element to be ')' and fails if not\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename Key> void BuildBack (const \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > & constructed, const bool reverse = \fRfalse\fP)"
BuildBack pops the last two elements off \fRconstructed\fP and wraps them in the specified \fBFragment\fP 
.SS "size_t ComputeScriptLen (\fBFragment\fP fragment, \fBType\fP sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys, \fBMiniscriptContext\fP ms_ctx)"

.PP
Helper function for Node::CalcScriptLen\&. 
.SS "\fBType\fP ComputeType (\fBFragment\fP fragment, \fBType\fP x, \fBType\fP y, \fBType\fP z, const std::vector< \fBType\fP > & sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys, \fBMiniscriptContext\fP ms_ctx)"

.PP
Helper function for Node::CalcType\&. 
.SS "template<typename Key, typename Ctx, typename I> \fBNodeRef\fP< Key > DecodeScript (I & in, I last, const Ctx & ctx)\fR [inline]\fP"

.PP
Parse a miniscript from a bitcoin script\&. In the following wrappers, we only need to push SINGLE_BKV_EXPR rather than BKV_EXPR, because and_v commutes with these wrappers\&. For example, c:and_v(X,Y) produces the same script as and_v(X,c:Y)\&.

.PP
In and_b and or_b nodes, we only look for SINGLE_BKV_EXPR, because or_b(and_v(X,Y),Z) has script [X] [Y] [Z] OP_BOOLOR, the same as and_v(X,or_b(Y,Z))\&. In this example, the former of these is invalid as miniscript, while the latter is valid\&. So we leave the and_v "outside" while decoding\&.
.SS "std::optional< std::vector< \fBOpcode\fP > > DecomposeScript (const \fBCScript\fP & script)"
Decode a script into opcode/push pairs\&.

.PP
Construct a vector with one element per opcode in the script, in reverse order\&. Each element is a pair consisting of the opcode, as well as the data pushed by the opcode (including OP_n), if any\&. OP_CHECKSIGVERIFY, OP_CHECKMULTISIGVERIFY, OP_NUMEQUALVERIFY and OP_EQUALVERIFY are decomposed into OP_CHECKSIG, OP_CHECKMULTISIG, OP_EQUAL and OP_NUMEQUAL respectively, plus OP_VERIFY\&. 
.SS "int FindNextChar (std::span< const char > sp, const char m)"

.SS "uint32_t MaxScriptSize (\fBMiniscriptContext\fP ms_ctx)\fR [constexpr]\fP"
The maximum size of a script depending on the context\&. 
.SS "\fBInputStack\fP operator+ (\fBInputStack\fP a, \fBInputStack\fP b)"

.SS "\fBInputStack\fP operator| (\fBInputStack\fP a, \fBInputStack\fP b)"

.SS "template<typename Key, typename Ctx> \fBNodeRef\fP< Key > Parse (std::span< const char > in, const Ctx & ctx)\fR [inline]\fP"
Parse a miniscript from its textual descriptor form\&. This does not check whether the script is valid, let alone sane\&. The caller is expected to use the \fRIsValidTopLevel()\fP and \fRIsSaneTopLevel()\fP to check for these properties on the node\&. 
.SS "template<typename Ctx> std::optional< std::pair< std::vector< unsigned char >, int > > ParseHexStrEnd (std::span< const char > in, const size_t expected_size, const Ctx & ctx)"
Parse a hex string ending at the end of the fragment's text representation\&. 
.SS "template<typename Key, typename Ctx> std::optional< std::pair< Key, int > > ParseKeyEnd (std::span< const char > in, const Ctx & ctx)"
Parse a key string ending at the end of the fragment's text representation\&. 
.SS "std::optional< int64_t > ParseScriptNumber (const \fBOpcode\fP & in)"
Determine whether the passed pair (created by DecomposeScript) is pushing a number\&. 
.SS "\fBType\fP SanitizeType (\fBType\fP e)"

.PP
A helper sanitizer/checker for the output of CalcType\&. 
.SH "Variable Documentation"
.PP 
.SS "uint32_t MAX_TAPSCRIPT_SAT_SIZE {\fBGetSizeOfCompactSize\fP(MAX_STACK_SIZE) + (\fBGetSizeOfCompactSize\fP(MAX_TAPMINISCRIPT_STACK_ELEM_SIZE) + MAX_TAPMINISCRIPT_STACK_ELEM_SIZE) * MAX_STACK_SIZE + \fBGetSizeOfCompactSize\fP(TAPROOT_CONTROL_MAX_SIZE) + TAPROOT_CONTROL_MAX_SIZE}\fR [constexpr]\fP"

.PP
Maximum possible stack size to spend a Taproot output (excluding the script itself)\&. 
.SS "uint32_t P2WSH_TXOUT_BYTES {8 + 1 + 1 + 33}\fR [constexpr]\fP"

.PP
nValue + script len + OP_0 + pushdata 32\&. 
.SS "uint32_t TX_BODY_LEEWAY_WEIGHT {(\fBTX_OVERHEAD\fP + \fBGetSizeOfCompactSize\fP(1) + \fBTXIN_BYTES_NO_WITNESS\fP + \fBGetSizeOfCompactSize\fP(1) + \fBP2WSH_TXOUT_BYTES\fP) * WITNESS_SCALE_FACTOR + 2}\fR [constexpr]\fP"

.PP
Data other than the witness in a transaction\&. Overhead + vin count + one vin + vout count + one vout + segwit marker\&. 
.SS "uint32_t TX_OVERHEAD {4 + 4}\fR [constexpr]\fP"

.PP
version + nLockTime 
.SS "uint32_t TXIN_BYTES_NO_WITNESS {36 + 4 + 1}\fR [constexpr]\fP"

.PP
prevout + nSequence + scriptSig 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
