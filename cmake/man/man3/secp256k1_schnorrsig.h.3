.TH "src/secp256k1/include/secp256k1_schnorrsig.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/secp256k1/include/secp256k1_schnorrsig.h
.SH SYNOPSIS
.br
.PP
\fR#include 'secp256k1\&.h'\fP
.br
\fR#include 'secp256k1_extrakeys\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsecp256k1_schnorrsig_extraparams\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC\fP   { 0xda, 0x6f, 0xb3, 0x8c }"
.br
.ti -1c
.RI "#define \fBSECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int(* \fBsecp256k1_nonce_function_hardened\fP) (unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data)"
.br
.ti -1c
.RI "typedef struct secp256k1_schnorrsig_extraparams \fBsecp256k1_schnorrsig_extraparams\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_schnorrsig_sign32\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *sig64, const unsigned char *msg32, const \fBsecp256k1_keypair\fP *keypair, const unsigned char *aux_rand32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_schnorrsig_sign\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *sig64, const unsigned char *msg32, const \fBsecp256k1_keypair\fP *keypair, const unsigned char *aux_rand32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4) \fBSECP256K1_DEPRECATED\fP('Use \fBsecp256k1_schnorrsig_sign32\fP instead')"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_schnorrsig_sign_custom\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *sig64, const unsigned char *msg, size_t msglen, const \fBsecp256k1_keypair\fP *keypair, \fBsecp256k1_schnorrsig_extraparams\fP *extraparams) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(5)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_schnorrsig_verify\fP (const \fBsecp256k1_context\fP *ctx, const unsigned char *sig64, const unsigned char *msg, size_t msglen, const \fBsecp256k1_xonly_pubkey\fP *pubkey) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(5)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBSECP256K1_API\fP const \fBsecp256k1_nonce_function_hardened\fP \fBsecp256k1_nonce_function_bip340\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT"
\fBValue:\fP
.nf
    {\\
    SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC,\\
    NULL,\\
    NULL\\
}
.PP
.fi

.SS "#define SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC   { 0xda, 0x6f, 0xb3, 0x8c }"

.SH "Typedef Documentation"
.PP 
.SS "typedef int(* secp256k1_nonce_function_hardened) (unsigned char *nonce32, const unsigned char *msg, size_t msglen, const unsigned char *key32, const unsigned char *xonly_pk32, const unsigned char *algo, size_t algolen, void *data)"
This module implements a variant of Schnorr signatures compliant with Bitcoin Improvement Proposal 340 "Schnorr Signatures for secp256k1" (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)\&. A pointer to a function to deterministically generate a nonce\&.

.PP
Same as secp256k1_nonce function with the exception of accepting an additional pubkey argument and not requiring an attempt argument\&. The pubkey argument can protect signature schemes with key-prefixed challenge hash inputs against reusing the nonce when signing with the wrong precomputed pubkey\&.

.PP
Returns: 1 if a nonce was successfully generated\&. 0 will cause signing to return an error\&. Out: nonce32: pointer to a 32-byte array to be filled by the function In: msg: the message being verified\&. Is NULL if and only if msglen is 0\&. msglen: the length of the message key32: pointer to a 32-byte secret key (will not be NULL) xonly_pk32: the 32-byte serialized xonly pubkey corresponding to key32 (will not be NULL) algo: pointer to an array describing the signature algorithm (will not be NULL) algolen: the length of the algo array data: arbitrary data pointer that is passed through

.PP
Except for test cases, this function should compute some cryptographic hash of the message, the key, the pubkey, the algorithm description, and data\&. 
.SS "typedef struct secp256k1_schnorrsig_extraparams secp256k1_schnorrsig_extraparams"
Data structure that contains additional arguments for schnorrsig_sign_custom\&.

.PP
A schnorrsig_extraparams structure object can be initialized correctly by setting it to SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT\&.

.PP
Members: magic: set to SECP256K1_SCHNORRSIG_EXTRAPARAMS_MAGIC at initialization and has no other function than making sure the object is initialized\&. noncefp: pointer to a nonce generation function\&. If NULL, secp256k1_nonce_function_bip340 is used ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)\&. If it is non-NULL and secp256k1_nonce_function_bip340 is used, then ndata must be a pointer to 32-byte auxiliary randomness as per BIP-340\&. 
.SH "Function Documentation"
.PP 
.SS "\fBSECP256K1_API\fP int secp256k1_schnorrsig_sign (const \fBsecp256k1_context\fP * ctx, unsigned char * sig64, const unsigned char * msg32, const \fBsecp256k1_keypair\fP * keypair, const unsigned char * aux_rand32)"
Same as secp256k1_schnorrsig_sign32, but DEPRECATED\&. Will be removed in future versions\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_schnorrsig_sign32 (const \fBsecp256k1_context\fP * ctx, unsigned char * sig64, const unsigned char * msg32, const \fBsecp256k1_keypair\fP * keypair, const unsigned char * aux_rand32)"
Create a Schnorr signature\&.

.PP
Does \fInot\fP strictly follow BIP-340 because it does not verify the resulting signature\&. Instead, you can manually use secp256k1_schnorrsig_verify and abort if it fails\&.

.PP
This function only signs 32-byte messages\&. If you have messages of a different size (or the same size but without a context-specific tag prefix), it is recommended to create a 32-byte message hash with secp256k1_tagged_sha256 and then sign the hash\&. Tagged hashing allows providing an context-specific tag for domain separation\&. This prevents signatures from being valid in multiple contexts by accident\&.

.PP
Returns 1 on success, 0 on failure\&. Args: ctx: pointer to a context object (not secp256k1_context_static)\&. Out: sig64: pointer to a 64-byte array to store the serialized signature\&. In: msg32: the 32-byte message being signed\&. keypair: pointer to an initialized keypair\&. aux_rand32: 32 bytes of fresh randomness\&. While recommended to provide this, it is only supplemental to security and can be NULL\&. A NULL argument is treated the same as an all-zero one\&. See BIP-340 "Default Signing" for a full explanation of this argument and for guidance if randomness is expensive\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_schnorrsig_sign_custom (const \fBsecp256k1_context\fP * ctx, unsigned char * sig64, const unsigned char * msg, size_t msglen, const \fBsecp256k1_keypair\fP * keypair, \fBsecp256k1_schnorrsig_extraparams\fP * extraparams)"
Create a Schnorr signature with a more flexible API\&.

.PP
Same arguments as secp256k1_schnorrsig_sign except that it allows signing variable length messages and accepts a pointer to an extraparams object that allows customizing signing by passing additional arguments\&.

.PP
Equivalent to secp256k1_schnorrsig_sign32(\&.\&.\&., aux_rand32) if msglen is 32 and extraparams is initialized as follows: 
.PP
.nf
secp256k1_schnorrsig_extraparams extraparams = SECP256K1_SCHNORRSIG_EXTRAPARAMS_INIT;
extraparams\&.ndata = (unsigned char*)aux_rand32;

.fi
.PP

.PP
Returns 1 on success, 0 on failure\&. Args: ctx: pointer to a context object (not secp256k1_context_static)\&. Out: sig64: pointer to a 64-byte array to store the serialized signature\&. In: msg: the message being signed\&. Can only be NULL if msglen is 0\&. msglen: length of the message\&. keypair: pointer to an initialized keypair\&. extraparams: pointer to an extraparams object (can be NULL)\&. 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_schnorrsig_verify (const \fBsecp256k1_context\fP * ctx, const unsigned char * sig64, const unsigned char * msg, size_t msglen, const \fBsecp256k1_xonly_pubkey\fP * pubkey)"
Verify a Schnorr signature\&.

.PP
Returns: 1: correct signature 0: incorrect signature Args: ctx: pointer to a context object\&. In: sig64: pointer to the 64-byte signature to verify\&. msg: the message being verified\&. Can only be NULL if msglen is 0\&. msglen: length of the message pubkey: pointer to an x-only public key to verify with 
.SH "Variable Documentation"
.PP 
.SS "\fBSECP256K1_API\fP const \fBsecp256k1_nonce_function_hardened\fP secp256k1_nonce_function_bip340"
An implementation of the nonce generation function as defined in Bitcoin Improvement Proposal 340 "Schnorr Signatures for secp256k1" (https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)\&.

.PP
If a data pointer is passed, it is assumed to be a pointer to 32 bytes of auxiliary random data as defined in BIP-340\&. If the data pointer is NULL, the nonce derivation procedure follows BIP-340 by setting the auxiliary random data to zero\&. The algo argument must be non-NULL, otherwise the function will fail and return 0\&. The hash will be tagged with algo\&. Therefore, to create BIP-340 compliant signatures, algo must be set to "BIP0340/nonce" and algolen to 13\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
