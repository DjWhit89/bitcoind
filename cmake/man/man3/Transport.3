.TH "Transport" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Transport
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <net\&.h>\fP
.PP
Inherited by \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBInfo\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBBytesToSend\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~Transport\fP ()=default"
.br
.ti -1c
.RI "virtual \fBInfo\fP \fBGetInfo\fP () const noexcept=0"
.br
.ti -1c
.RI "virtual bool \fBReceivedMessageComplete\fP () const =0"
.br
.ti -1c
.RI "virtual bool \fBReceivedBytes\fP (std::span< const uint8_t > &msg_bytes)=0"
.br
.ti -1c
.RI "virtual \fBCNetMessage\fP \fBGetReceivedMessage\fP (std::chrono::microseconds time, bool &reject_message)=0"
.br
.ti -1c
.RI "virtual bool \fBSetMessageToSend\fP (\fBCSerializedNetMsg\fP &msg) noexcept=0"
.br
.ti -1c
.RI "virtual \fBBytesToSend\fP \fBGetBytesToSend\fP (bool have_next_message) const noexcept=0"
.br
.ti -1c
.RI "virtual void \fBMarkBytesSent\fP (size_t bytes_sent) noexcept=0"
.br
.ti -1c
.RI "virtual size_t \fBGetSendMemoryUsage\fP () const noexcept=0"
.br
.ti -1c
.RI "virtual bool \fBShouldReconnectV1\fP () const noexcept=0"
.br
.in -1c
.SH "Detailed Description"
.PP 
The \fBTransport\fP converts one connection's sent messages to wire bytes, and received bytes back\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBBytesToSend\fP"
\fBInitial value:\fP
.nf
 std::tuple<
        std::span<const uint8_t> ,
        bool ,
        const std::string& 
    >
.PP
.fi
Return type for GetBytesToSend, consisting of:
.IP "\(bu" 2
std::span<const uint8_t> to_send: span of bytes to be sent over the wire (possibly empty)\&.
.IP "\(bu" 2
bool more: whether there will be more bytes to be sent after the ones in to_send are all sent (as signaled by \fBMarkBytesSent()\fP)\&.
.IP "\(bu" 2
const std::string& m_type: message type on behalf of which this is being sent ("" for bytes that are not on behalf of any message)\&. 
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "virtual ~\fBTransport\fP ()\fR [virtual]\fP, \fR [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "virtual \fBBytesToSend\fP GetBytesToSend (bool have_next_message) const\fR [pure virtual]\fP, \fR [noexcept]\fP"
Get bytes to send on the wire, if any, along with other information about it\&.

.PP
As a const function, it does not modify the transport's observable state, and is thus safe to be called multiple times\&.

.PP
\fBParameters\fP
.RS 4
\fIhave_next_message\fP If true, the "more" return value reports whether more will be sendable after a SetMessageToSend call\&. It is set by the caller when they know they have another message ready to send, and only care about what happens after that\&. The have_next_message argument only affects this "more" return value and nothing else\&.
.RE
.PP
Effectively, there are three possible outcomes about whether there are more bytes to send:
.IP "\(bu" 2
Yes: the transport itself has more bytes to send later\&. For example, for \fBV1Transport\fP this happens during the sending of the header of a message, when there is a non-empty payload that follows\&.
.IP "\(bu" 2
No: the transport itself has no more bytes to send, but will have bytes to send if handed a message through SetMessageToSend\&. In \fBV1Transport\fP this happens when sending the payload of a message\&.
.IP "\(bu" 2
Blocked: the transport itself has no more bytes to send, and is also incapable of sending anything more at all now, if it were handed another message to send\&. This occurs in \fBV2Transport\fP before the handshake is complete, as the encryption ciphers are not set up for sending messages before that point\&.
.PP

.PP
The boolean 'more' is true for Yes, false for Blocked, and have_next_message controls what is returned for No\&.

.PP
\fBReturns\fP
.RS 4
a \fBBytesToSend\fP object\&. The to_send member returned acts as a stream which is only ever appended to\&. This means that with the exception of MarkBytesSent (which pops bytes off the front of later to_sends), operations on the transport can only append to what is being returned\&. Also note that m_type and to_send refer to data that is internal to the transport, and calling any non-const function on this object may invalidate them\&. 
.RE
.PP

.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual \fBInfo\fP GetInfo () const\fR [pure virtual]\fP, \fR [noexcept]\fP"
Retrieve information about this transport\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual \fBCNetMessage\fP GetReceivedMessage (std::chrono::microseconds time, bool & reject_message)\fR [pure virtual]\fP"
Retrieve a completed message from transport\&.

.PP
This can only be called when \fBReceivedMessageComplete()\fP is true\&.

.PP
If reject_message=true is returned the message itself is invalid, but (other than false returned by ReceivedBytes) the transport is not in an inconsistent state\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual size_t GetSendMemoryUsage () const\fR [pure virtual]\fP, \fR [noexcept]\fP"
Return the memory usage of this transport attributable to buffered data to send\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual void MarkBytesSent (size_t bytes_sent)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Report how many bytes returned by the last \fBGetBytesToSend()\fP have been sent\&.

.PP
bytes_sent cannot exceed to_send\&.size() of the last \fBGetBytesToSend()\fP result\&.

.PP
If bytes_sent=0, this call has no effect\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual bool ReceivedBytes (std::span< const uint8_t > & msg_bytes)\fR [pure virtual]\fP"
Feed wire bytes to the transport\&.

.PP
\fBReturns\fP
.RS 4
false if some bytes were invalid, in which case the transport can't be used anymore\&.
.RE
.PP
Consumed bytes are chopped off the front of msg_bytes\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual bool ReceivedMessageComplete () const\fR [pure virtual]\fP"
Returns true if the current message is complete (so GetReceivedMessage can be called)\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual bool SetMessageToSend (\fBCSerializedNetMsg\fP & msg)\fR [pure virtual]\fP, \fR [noexcept]\fP"
Set the next message to send\&.

.PP
If no message can currently be set (perhaps because the previous one is not yet done being sent), returns false, and msg will be unmodified\&. Otherwise msg is enqueued (and possibly moved-from) and true is returned\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.
.SS "virtual bool ShouldReconnectV1 () const\fR [pure virtual]\fP, \fR [noexcept]\fP"
Whether upon disconnections, a reconnect with V1 is warranted\&. 
.PP
Implemented in \fBV1Transport\fP, and \fBV2Transport\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
