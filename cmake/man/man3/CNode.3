.TH "CNode" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CNode
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <net\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBSock\fP > m_sock \fBGUARDED_BY\fP (\fBm_sock_mutex\fP)"
.br
.ti -1c
.RI "size_t m_send_memusage \fBGUARDED_BY\fP (\fBcs_vSend\fP)"
.br
.ti -1c
.RI "uint64_t nSendBytes \fBGUARDED_BY\fP (\fBcs_vSend\fP)"
.br
.ti -1c
.RI "std::deque< \fBCSerializedNetMsg\fP > vSendMsg \fBGUARDED_BY\fP (\fBcs_vSend\fP)"
.br
.ti -1c
.RI "uint64_t nRecvBytes \fBGUARDED_BY\fP (\fBcs_vRecv\fP)"
.br
.ti -1c
.RI "std::string cleanSubVer \fBGUARDED_BY\fP (\fBm_subver_mutex\fP)"
.br
.ti -1c
.RI "bool \fBHasPermission\fP (\fBNetPermissionFlags\fP permission) const"
.br
.ti -1c
.RI "void \fBMarkReceivedMsgsForProcessing\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_msg_process_queue_mutex)"
.br
.ti -1c
.RI "std::optional< std::pair< \fBCNetMessage\fP, bool > > \fBPollMessage\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_msg_process_queue_mutex)"
.br
.ti -1c
.RI "void \fBAccountForSentBytes\fP (const std::string &msg_type, size_t sent_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_vSend\fP)"
.br
.ti -1c
.RI "bool \fBIsOutboundOrBlockRelayConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsFullOutboundConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsManualConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsManualOrFullOutboundConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsBlockOnlyConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsFeelerConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsAddrFetchConn\fP () const"
.br
.ti -1c
.RI "bool \fBIsInboundConn\fP () const"
.br
.ti -1c
.RI "bool \fBExpectServicesFromConn\fP () const"
.br
.ti -1c
.RI "\fBNetwork\fP \fBConnectedThroughNetwork\fP () const"
.br
.ti -1c
.RI "bool \fBIsConnectedThroughPrivacyNet\fP () const"
.br
.ti -1c
.RI "\fBCNode\fP (\fBNodeId\fP id, std::shared_ptr< \fBSock\fP > sock, const \fBCAddress\fP &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const \fBCService\fP &addrBindIn, const std::string &addrNameIn, \fBConnectionType\fP conn_type_in, bool inbound_onion, uint64_t network_key, \fBCNodeOptions\fP &&node_opts={})"
.br
.ti -1c
.RI "\fBCNode\fP (const \fBCNode\fP &)=delete"
.br
.ti -1c
.RI "\fBCNode\fP & \fBoperator=\fP (const \fBCNode\fP &)=delete"
.br
.ti -1c
.RI "\fBNodeId\fP \fBGetId\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetLocalNonce\fP () const"
.br
.ti -1c
.RI "int \fBGetRefCount\fP () const"
.br
.ti -1c
.RI "bool \fBReceiveMsgBytes\fP (std::span< const uint8_t > msg_bytes, bool &complete) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBcs_vRecv\fP)"
.br
.ti -1c
.RI "void \fBSetCommonVersion\fP (int greatest_common_version)"
.br
.ti -1c
.RI "int \fBGetCommonVersion\fP () const"
.br
.ti -1c
.RI "\fBCService\fP \fBGetAddrLocal\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_addr_local_mutex)"
.br
.ti -1c
.RI "void \fBSetAddrLocal\fP (const \fBCService\fP &addrLocalIn) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_addr_local_mutex)"
.br
.RI "May not be called more than once\&. "
.ti -1c
.RI "\fBCNode\fP * \fBAddRef\fP ()"
.br
.ti -1c
.RI "void \fBRelease\fP ()"
.br
.ti -1c
.RI "void \fBCloseSocketDisconnect\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBm_sock_mutex\fP)"
.br
.ti -1c
.RI "void \fBCopyStats\fP (\fBCNodeStats\fP &stats) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!\fBm_subver_mutex\fP"
.br
.ti -1c
.RI "std::string \fBConnectionTypeAsString\fP () const"
.br
.ti -1c
.RI "std::string \fBLogIP\fP (bool log_ip) const"
.br
.ti -1c
.RI "std::string \fBDisconnectMsg\fP (bool log_ip) const"
.br
.ti -1c
.RI "void \fBPongReceived\fP (std::chrono::microseconds ping_time)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "const std::unique_ptr< \fBTransport\fP > \fBm_transport\fP"
.br
.ti -1c
.RI "const \fBNetPermissionFlags\fP \fBm_permission_flags\fP"
.br
.ti -1c
.RI "\fBMutex\fP \fBcs_vSend\fP"
.br
.ti -1c
.RI "\fBMutex\fP \fBm_sock_mutex\fP"
.br
.ti -1c
.RI "\fBMutex\fP \fBcs_vRecv\fP"
.br
.ti -1c
.RI "std::atomic< std::chrono::seconds > \fBm_last_send\fP {0s}"
.br
.ti -1c
.RI "std::atomic< std::chrono::seconds > \fBm_last_recv\fP {0s}"
.br
.ti -1c
.RI "const std::chrono::seconds \fBm_connected\fP"
.br
.RI "Unix epoch time at peer connection\&. "
.ti -1c
.RI "const \fBCAddress\fP \fBaddr\fP"
.br
.ti -1c
.RI "const \fBCService\fP \fBaddrBind\fP"
.br
.ti -1c
.RI "const std::string \fBm_addr_name\fP"
.br
.ti -1c
.RI "const std::string \fBm_dest\fP"
.br
.ti -1c
.RI "const bool \fBm_inbound_onion\fP"
.br
.RI "Whether this peer is an inbound onion, i\&.e\&. connected via our Tor onion service\&. "
.ti -1c
.RI "std::atomic< int > \fBnVersion\fP {0}"
.br
.ti -1c
.RI "\fBMutex\fP \fBm_subver_mutex\fP"
.br
.ti -1c
.RI "const bool \fBm_prefer_evict\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBfSuccessfullyConnected\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBfDisconnect\fP {false}"
.br
.ti -1c
.RI "\fBCountingSemaphoreGrant\fP \fBgrantOutbound\fP"
.br
.ti -1c
.RI "std::atomic< int > \fBnRefCount\fP {0}"
.br
.ti -1c
.RI "const uint64_t \fBnKeyedNetGroup\fP"
.br
.ti -1c
.RI "std::atomic_bool \fBfPauseRecv\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBfPauseSend\fP {false}"
.br
.ti -1c
.RI "const uint64_t \fBm_network_key\fP"
.br
.ti -1c
.RI "const \fBConnectionType\fP \fBm_conn_type\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fBm_bip152_highbandwidth_to\fP {false}"
.br
.ti -1c
.RI "std::atomic< bool > \fBm_bip152_highbandwidth_from\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBm_has_all_wanted_services\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBm_relays_txs\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBm_bloom_filter_loaded\fP {false}"
.br
.ti -1c
.RI "std::atomic< std::chrono::seconds > \fBm_last_block_time\fP {0s}"
.br
.ti -1c
.RI "std::atomic< std::chrono::seconds > \fBm_last_tx_time\fP {0s}"
.br
.ti -1c
.RI "std::atomic< std::chrono::microseconds > \fBm_last_ping_time\fP {0us}"
.br
.ti -1c
.RI "std::atomic< std::chrono::microseconds > \fBm_min_ping_time\fP {std::chrono::microseconds::max()}"
.br
.ti -1c
.RI "void \fB!m_addr_local_mutex\fP"
.br
.ti -1c
.RI "void \fB!cs_vSend\fP"
.br
.ti -1c
.RI "void \fB!cs_vRecv\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Information about a peer 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCNode\fP (\fBNodeId\fP id, std::shared_ptr< \fBSock\fP > sock, const \fBCAddress\fP & addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const \fBCService\fP & addrBindIn, const std::string & addrNameIn, \fBConnectionType\fP conn_type_in, bool inbound_onion, uint64_t network_key, \fBCNodeOptions\fP && node_opts = \fR{}\fP)"

.SS "\fBCNode\fP (const \fBCNode\fP & )\fR [delete]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void AccountForSentBytes (const std::string & msg_type, size_t sent_bytes)\fR [inline]\fP"
Account for the total size of a sent message in the per msg type connection stats\&. 
.SS "\fBCNode\fP * AddRef ()\fR [inline]\fP"

.SS "void CloseSocketDisconnect ()"

.SS "\fBNetwork\fP ConnectedThroughNetwork () const"
Get network the peer connected through\&.

.PP
Returns Network::NET_ONION for \fIinbound\fP onion connections, and \fBCNetAddr::GetNetClass()\fP otherwise\&. The latter cannot be used directly because it doesn't detect the former, and it's not the responsibility of the \fBCNetAddr\fP class to know the actual network a peer is connected through\&.

.PP
\fBReturns\fP
.RS 4
network the peer connected through\&. 
.RE
.PP

.SS "std::string ConnectionTypeAsString () const\fR [inline]\fP"

.SS "void CopyStats (\fBCNodeStats\fP & stats)"

.SS "std::string DisconnectMsg (bool log_ip) const"
Helper function to log disconnects\&.

.PP
\fBParameters\fP
.RS 4
\fIlog_ip\fP whether to include the IP address 
.RE
.PP
\fBReturns\fP
.RS 4
"disconnecting peer=\&.\&.\&." and optionally "peeraddr=\&.\&.\&." 
.RE
.PP

.SS "bool ExpectServicesFromConn () const\fR [inline]\fP"

.SS "\fBCService\fP GetAddrLocal () const"

.SS "int GetCommonVersion () const\fR [inline]\fP"

.SS "\fBNodeId\fP GetId () const\fR [inline]\fP"

.SS "uint64_t GetLocalNonce () const\fR [inline]\fP"

.SS "int GetRefCount () const\fR [inline]\fP"

.SS "uint64_t nRecvBytes GUARDED_BY (\fBcs_vRecv\fP )\fR [inline]\fP"

.SS "std::deque< \fBCSerializedNetMsg\fP > vSendMsg GUARDED_BY (\fBcs_vSend\fP )"
Messages still to be fed to m_transport->SetMessageToSend\&. 
.SS "uint64_t nSendBytes GUARDED_BY (\fBcs_vSend\fP )\fR [inline]\fP"
Total number of bytes sent on the wire to this peer\&. 
.SS "size_t m_send_memusage GUARDED_BY (\fBcs_vSend\fP )\fR [inline]\fP"
Sum of GetMemoryUsage of all vSendMsg entries\&. 
.SS "std::shared_ptr< \fBSock\fP > m_sock GUARDED_BY (\fBm_sock_mutex\fP )"
Socket used for communication with the node\&. May not own a \fBSock\fP object (after \fR\fBCloseSocketDisconnect()\fP\fP or during tests)\&. \fRshared_ptr\fP (instead of \fRunique_ptr\fP) is used to avoid premature close of the underlying file descriptor by one thread while another thread is poll(2)-ing it for activity\&. 
.PP
\fBSee also\fP
.RS 4
https://github.com/bitcoin/bitcoin/issues/21744 \fBfor\fP details\&. 
.RE
.PP

.SS "std::string cleanSubVer GUARDED_BY (\fBm_subver_mutex\fP )\fR [inline]\fP"
cleanSubVer is a sanitized string of the user agent byte array we read from the wire\&. This cleaned string can safely be logged or displayed\&. 
.SS "bool HasPermission (\fBNetPermissionFlags\fP permission) const\fR [inline]\fP"

.SS "bool IsAddrFetchConn () const\fR [inline]\fP"

.SS "bool IsBlockOnlyConn () const\fR [inline]\fP"

.SS "bool IsConnectedThroughPrivacyNet () const\fR [nodiscard]\fP"
Whether this peer connected through a privacy network\&. 
.SS "bool IsFeelerConn () const\fR [inline]\fP"

.SS "bool IsFullOutboundConn () const\fR [inline]\fP"

.SS "bool IsInboundConn () const\fR [inline]\fP"

.SS "bool IsManualConn () const\fR [inline]\fP"

.SS "bool IsManualOrFullOutboundConn () const\fR [inline]\fP"

.SS "bool IsOutboundOrBlockRelayConn () const\fR [inline]\fP"

.SS "std::string LogIP (bool log_ip) const"
Helper function to optionally log the IP address\&.

.PP
\fBParameters\fP
.RS 4
\fIlog_ip\fP whether to include the IP address 
.RE
.PP
\fBReturns\fP
.RS 4
" peeraddr=\&.\&.\&." or "" 
.RE
.PP

.SS "void MarkReceivedMsgsForProcessing ()"
Move all messages from the received queue to the processing queue\&. 
.SS "\fBCNode\fP & operator= (const \fBCNode\fP & )\fR [delete]\fP"

.SS "std::optional< std::pair< \fBCNetMessage\fP, bool > > PollMessage ()"
Poll the next message from the processing queue of this connection\&.

.PP
Returns std::nullopt if the processing queue is empty, or a pair consisting of the message and a bool that indicates if the processing queue has more entries\&. 
.SS "void PongReceived (std::chrono::microseconds ping_time)\fR [inline]\fP"
A ping-pong round trip has completed successfully\&. Update latest and minimum ping times\&. 
.SS "bool ReceiveMsgBytes (std::span< const uint8_t > msg_bytes, bool & complete)"
Receive bytes from the buffer and deserialize them into messages\&.

.PP
\fBParameters\fP
.RS 4
\fImsg_bytes\fP The raw data 
.br
\fIcomplete\fP Set True if at least one message has been deserialized and is ready to be processed 
.RE
.PP
\fBReturns\fP
.RS 4
True if the peer should stay connected, False if the peer should be disconnected from\&. 
.RE
.PP

.SS "void Release ()\fR [inline]\fP"

.SS "void SetAddrLocal (const \fBCService\fP & addrLocalIn)"

.PP
May not be called more than once\&. 
.SS "void SetCommonVersion (int greatest_common_version)\fR [inline]\fP"

.SH "Field Documentation"
.PP 
.SS "void !\fBcs_vRecv\fP"

.SS "void !\fBcs_vSend\fP"

.SS "void !m_addr_local_mutex"

.SS "const \fBCAddress\fP addr"

.SS "const \fBCService\fP addrBind"

.SS "\fBMutex\fP cs_vRecv"

.SS "\fBMutex\fP cs_vSend"

.SS "std::atomic_bool fDisconnect {false}"

.SS "std::atomic_bool fPauseRecv {false}"

.SS "std::atomic_bool fPauseSend {false}"

.SS "std::atomic_bool fSuccessfullyConnected {false}"
fSuccessfullyConnected is set to true on receiving VERACK from the peer\&. 
.SS "\fBCountingSemaphoreGrant\fP grantOutbound"

.SS "const std::string m_addr_name"

.SS "std::atomic<bool> m_bip152_highbandwidth_from {false}"

.SS "std::atomic<bool> m_bip152_highbandwidth_to {false}"

.SS "std::atomic_bool m_bloom_filter_loaded {false}"
Whether this peer has loaded a bloom filter\&. Used only in inbound eviction logic\&. 
.SS "const \fBConnectionType\fP m_conn_type"

.SS "const std::chrono::seconds m_connected"

.PP
Unix epoch time at peer connection\&. 
.SS "const std::string m_dest"
The pszDest argument provided to ConnectNode()\&. Only used for reconnections\&. 
.SS "std::atomic_bool m_has_all_wanted_services {false}"
Whether this peer provides all services that we want\&. Used for eviction decisions 
.SS "const bool m_inbound_onion"

.PP
Whether this peer is an inbound onion, i\&.e\&. connected via our Tor onion service\&. 
.SS "std::atomic<std::chrono::seconds> m_last_block_time {0s}"
UNIX epoch time of the last block received from this peer that we had not yet seen (e\&.g\&. not already received from another peer), that passed preliminary validity checks and was saved to disk, even if we don't connect the block or it eventually fails connection\&. Used as an inbound peer eviction criterium in CConnman::AttemptToEvictConnection\&. 
.SS "std::atomic<std::chrono::microseconds> m_last_ping_time {0us}"
Last measured round-trip time\&. Used only for RPC/GUI stats/debugging\&. 
.SS "std::atomic<std::chrono::seconds> m_last_recv {0s}"

.SS "std::atomic<std::chrono::seconds> m_last_send {0s}"

.SS "std::atomic<std::chrono::seconds> m_last_tx_time {0s}"
UNIX epoch time of the last transaction received from this peer that we had not yet seen (e\&.g\&. not already received from another peer) and that was accepted into our mempool\&. Used as an inbound peer eviction criterium in CConnman::AttemptToEvictConnection\&. 
.SS "std::atomic<std::chrono::microseconds> m_min_ping_time {std::chrono::microseconds::max()}"
Lowest measured round-trip time\&. Used as an inbound peer eviction criterium in CConnman::AttemptToEvictConnection\&. 
.SS "const uint64_t m_network_key"
\fBNetwork\fP key used to prevent fingerprinting our node across networks\&. Influenced by the network and the bind address (+ bind port for inbounds) 
.SS "const \fBNetPermissionFlags\fP m_permission_flags"

.SS "const bool m_prefer_evict {false}"

.SS "std::atomic_bool m_relays_txs {false}"
Whether we should relay transactions to this peer\&. This only changes from false to true\&. It will never change back to false\&. 
.SS "\fBMutex\fP m_sock_mutex"

.SS "\fBMutex\fP m_subver_mutex"

.SS "const std::unique_ptr<\fBTransport\fP> m_transport"
\fBTransport\fP serializer/deserializer\&. The receive side functions are only called under cs_vRecv, while the sending side functions are only called under cs_vSend\&. 
.SS "const uint64_t nKeyedNetGroup"

.SS "std::atomic<int> nRefCount {0}"

.SS "std::atomic<int> nVersion {0}"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
