.TH "CConnman" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CConnman
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <net\&.h>\fP
.PP
Inherited by \fBConnmanTestMsg\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBOptions\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBNodeFn\fP = std::function<void(\fBCNode\fP*)>"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBInit\fP (const \fBOptions\fP &connOptions) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex"
.br
.ti -1c
.RI "const bool \fBuse_v2transport\fP (\fBGetLocalServices\fP() &\fBNODE_P2P_V2\fP)"
.br
.ti -1c
.RI "\fBfor\fP (const std::string &added_node :connOptions\&.m_added_nodes)"
.br
.ti -1c
.RI "void \fBSetCaptureMessages\fP (bool cap)"
.br
.ti -1c
.RI "\fBCConnman\fP (uint64_t seed0, uint64_t seed1, \fBAddrMan\fP &addrman, const \fBNetGroupManager\fP &netgroupman, const \fBCChainParams\fP &params, bool network_active=true, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt_net=std::make_shared< \fBCThreadInterrupt\fP >())"
.br
.ti -1c
.RI "\fB~CConnman\fP ()"
.br
.ti -1c
.RI "bool \fBStart\fP (\fBCScheduler\fP &scheduler, const \fBOptions\fP &options) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex"
.br
.ti -1c
.RI "void \fBStopThreads\fP ()"
.br
.ti -1c
.RI "void \fBStopNodes\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_reconnections_mutex)"
.br
.ti -1c
.RI "void \fBStop\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_reconnections_mutex)"
.br
.ti -1c
.RI "void \fBInterrupt\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!mutexMsgProc)"
.br
.ti -1c
.RI "bool \fBGetNetworkActive\fP () const"
.br
.ti -1c
.RI "bool \fBGetUseAddrmanOutgoing\fP () const"
.br
.ti -1c
.RI "void \fBSetNetworkActive\fP (bool active)"
.br
.ti -1c
.RI "bool \fBOpenNetworkConnection\fP (const \fBCAddress\fP &addrConnect, bool fCountFailure, \fBCountingSemaphoreGrant\fP<> &&grant_outbound, const char *pszDest, \fBConnectionType\fP conn_type, bool \fBuse_v2transport\fP, const std::optional< \fBProxy\fP > &proxy_override=std::nullopt) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_unused_i2p_sessions_mutex)"
.br
.ti -1c
.RI "bool \fBCheckIncomingNonce\fP (uint64_t \fBnonce\fP)"
.br
.ti -1c
.RI "void \fBASMapHealthCheck\fP ()"
.br
.ti -1c
.RI "\fBRecursiveMutex\fP & \fBGetNodesMutex\fP () const \fBLOCK_RETURNED\fP(m_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBForNode\fP (\fBNodeId\fP id, std::function< bool(\fBCNode\fP *pnode)> func)"
.br
.ti -1c
.RI "void \fBPushMessage\fP (\fBCNode\fP *pnode, \fBCSerializedNetMsg\fP &&msg) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "void \fBForEachNode\fP (const \fBNodeFn\fP &func)"
.br
.ti -1c
.RI "void \fBForEachNode\fP (const \fBNodeFn\fP &func) const"
.br
.ti -1c
.RI "std::vector< \fBCAddress\fP > \fBGetAddressesUnsafe\fP (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered=true) const"
.br
.ti -1c
.RI "std::vector< \fBCAddress\fP > \fBGetAddresses\fP (\fBCNode\fP &requestor, size_t max_addresses, size_t max_pct)"
.br
.ti -1c
.RI "void \fBSetTryNewOutboundPeer\fP (bool flag)"
.br
.ti -1c
.RI "bool \fBGetTryNewOutboundPeer\fP () const"
.br
.ti -1c
.RI "void \fBStartExtraBlockRelayPeers\fP ()"
.br
.ti -1c
.RI "int \fBGetFullOutboundConnCount\fP () const"
.br
.ti -1c
.RI "int \fBGetExtraFullOutboundCount\fP () const"
.br
.ti -1c
.RI "int \fBGetExtraBlockRelayCount\fP () const"
.br
.ti -1c
.RI "bool \fBAddNode\fP (const \fBAddedNodeParams\fP &add) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBRemoveAddedNode\fP (std::string_view \fBnode\fP) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBAddedNodesContain\fP (const \fBCAddress\fP &addr) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "std::vector< \fBAddedNodeInfo\fP > \fBGetAddedNodeInfo\fP (bool include_connected) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBAddConnection\fP (const std::string &address, \fBConnectionType\fP conn_type, bool \fBuse_v2transport\fP) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_unused_i2p_sessions_mutex)"
.br
.ti -1c
.RI "size_t \fBGetNodeCount\fP (\fBConnectionDirection\fP) const"
.br
.ti -1c
.RI "std::map< \fBCNetAddr\fP, \fBLocalServiceInfo\fP > \fBgetNetLocalAddresses\fP () const"
.br
.ti -1c
.RI "uint32_t \fBGetMappedAS\fP (const \fBCNetAddr\fP &addr) const"
.br
.ti -1c
.RI "void \fBGetNodeStats\fP (std::vector< \fBCNodeStats\fP > &vstats) const"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (std::string_view \fBnode\fP)"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (const \fBCSubNet\fP &subnet)"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (const \fBCNetAddr\fP &addr)"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (\fBNodeId\fP id)"
.br
.ti -1c
.RI "\fBServiceFlags\fP \fBGetLocalServices\fP () const"
.br
.ti -1c
.RI "void \fBAddLocalServices\fP (\fBServiceFlags\fP services)"
.br
.ti -1c
.RI "void \fBRemoveLocalServices\fP (\fBServiceFlags\fP services)"
.br
.ti -1c
.RI "uint64_t \fBGetMaxOutboundTarget\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "std::chrono::seconds \fBGetMaxOutboundTimeframe\fP () const"
.br
.ti -1c
.RI "bool \fBOutboundTargetReached\fP (bool historicalBlockServingLimit) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "uint64_t \fBGetOutboundTargetBytesLeft\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "std::chrono::seconds \fBGetMaxOutboundTimeLeftInCycle\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "uint64_t \fBGetTotalBytesRecv\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetTotalBytesSent\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "\fBCSipHasher\fP \fBGetDeterministicRandomizer\fP (uint64_t id) const"
.br
.ti -1c
.RI "void \fBWakeMessageHandler\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!mutexMsgProc)"
.br
.ti -1c
.RI "bool \fBShouldRunInactivityChecks\fP (const \fBCNode\fP &\fBnode\fP, std::chrono::microseconds now) const"
.br
.ti -1c
.RI "bool \fBMultipleManualOrFullOutboundConns\fP (\fBNetwork\fP net) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(m_nodes_mutex)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "void \fB!m_total_bytes_sent_mutex\fP"
.br
.ti -1c
.RI "\fBm_local_services\fP = connOptions\&.m_local_services"
.br
.ti -1c
.RI "\fBm_max_automatic_connections\fP = connOptions\&.m_max_automatic_connections"
.br
.ti -1c
.RI "\fBm_max_outbound_full_relay\fP = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, \fBm_max_automatic_connections\fP)"
.br
.ti -1c
.RI "\fBm_max_outbound_block_relay\fP = std::min(MAX_BLOCK_RELAY_ONLY_CONNECTIONS, \fBm_max_automatic_connections\fP \- \fBm_max_outbound_full_relay\fP)"
.br
.ti -1c
.RI "\fBm_max_automatic_outbound\fP = \fBm_max_outbound_full_relay\fP + \fBm_max_outbound_block_relay\fP + m_max_feeler"
.br
.ti -1c
.RI "\fBm_max_inbound\fP = std::max(0, \fBm_max_automatic_connections\fP \- \fBm_max_automatic_outbound\fP)"
.br
.ti -1c
.RI "\fBm_use_addrman_outgoing\fP = connOptions\&.m_use_addrman_outgoing"
.br
.ti -1c
.RI "\fBm_client_interface\fP = connOptions\&.uiInterface"
.br
.ti -1c
.RI "\fBm_banman\fP = connOptions\&.m_banman"
.br
.ti -1c
.RI "\fBm_msgproc\fP = connOptions\&.m_msgproc"
.br
.ti -1c
.RI "\fBnSendBufferMaxSize\fP = connOptions\&.nSendBufferMaxSize"
.br
.ti -1c
.RI "\fBnReceiveFloodSize\fP = connOptions\&.nReceiveFloodSize"
.br
.ti -1c
.RI "\fBm_peer_connect_timeout\fP = std::chrono::seconds{connOptions\&.m_peer_connect_timeout}"
.br
.ti -1c
.RI "\fBnMaxOutboundLimit\fP = connOptions\&.nMaxOutboundLimit"
.br
.ti -1c
.RI "\fBvWhitelistedRangeIncoming\fP = connOptions\&.vWhitelistedRangeIncoming"
.br
.ti -1c
.RI "\fBvWhitelistedRangeOutgoing\fP = connOptions\&.vWhitelistedRangeOutgoing"
.br
.ti -1c
.RI "\fBm_onion_binds\fP = connOptions\&.onion_binds"
.br
.ti -1c
.RI "\fBwhitelist_forcerelay\fP = connOptions\&.whitelist_forcerelay"
.br
.ti -1c
.RI "\fBwhitelist_relay\fP = connOptions\&.whitelist_relay"
.br
.ti -1c
.RI "\fBm_capture_messages\fP = connOptions\&.m_capture_messages"
.br
.ti -1c
.RI "bool \fB!m_added_nodes_mutex\fP"
.br
.ti -1c
.RI "bool \fB!m_addr_fetches_mutex\fP"
.br
.ti -1c
.RI "bool \fB!mutexMsgProc\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "struct \fBConnmanTestMsg\fP"
.br
.in -1c
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBNodeFn\fP = std::function<void(\fBCNode\fP*)>"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCConnman\fP (uint64_t seed0, uint64_t seed1, \fBAddrMan\fP & addrman, const \fBNetGroupManager\fP & netgroupman, const \fBCChainParams\fP & params, bool network_active = \fRtrue\fP, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt_net = \fRstd::make_shared<\fBCThreadInterrupt\fP>()\fP)"

.SS "~\fBCConnman\fP ()"

.SH "Member Function Documentation"
.PP 
.SS "bool AddConnection (const std::string & address, \fBConnectionType\fP conn_type, bool use_v2transport = \fRfalse\fP)"
Attempts to open a connection\&. Currently only used from tests\&.

.PP
\fBParameters\fP
.RS 4
\fIaddress\fP Address of node to try connecting to 
.br
\fIconn_type\fP ConnectionType::OUTBOUND, \fBConnectionType::BLOCK_RELAY\fP, \fBConnectionType::ADDR_FETCH\fP or \fBConnectionType::FEELER\fP 
.br
\fIuse_v2transport\fP Set to true if node attempts to connect using BIP 324 v2 transport protocol\&. 
.RE
.PP
\fBReturns\fP
.RS 4
bool Returns false if there are no available slots for this connection:
.IP "\(bu" 2
conn_type not a supported \fBConnectionType\fP
.IP "\(bu" 2
Max total outbound connection capacity filled
.IP "\(bu" 2
Max connection capacity for type is filled 
.PP
.RE
.PP

.SS "bool AddedNodesContain (const \fBCAddress\fP & addr) const"

.SS "void AddLocalServices (\fBServiceFlags\fP services)\fR [inline]\fP"
Updates the local services that this node advertises to other peers during connection handshake\&. 
.SS "bool AddNode (const \fBAddedNodeParams\fP & add)"

.SS "void ASMapHealthCheck ()"

.SS "bool CheckIncomingNonce (uint64_t nonce)"

.SS "bool DisconnectNode (const \fBCNetAddr\fP & addr)"

.SS "bool DisconnectNode (const \fBCSubNet\fP & subnet)"

.SS "bool DisconnectNode (\fBNodeId\fP id)"

.SS "bool DisconnectNode (std::string_view node)"

.SS "for (const std::string &added_node :connOptions\&. m_added_nodes)\fR [inline]\fP"

.SS "void ForEachNode (const \fBNodeFn\fP & func)\fR [inline]\fP"

.SS "void ForEachNode (const \fBNodeFn\fP & func) const\fR [inline]\fP"

.SS "bool ForNode (\fBNodeId\fP id, std::function< bool(\fBCNode\fP *pnode)> func)"

.SS "std::vector< \fBAddedNodeInfo\fP > GetAddedNodeInfo (bool include_connected) const"

.SS "std::vector< \fBCAddress\fP > GetAddresses (\fBCNode\fP & requestor, size_t max_addresses, size_t max_pct)"
Return addresses from the per-requestor cache\&. If no cache entry exists, it is populated with randomly selected addresses\&. This function can be used in untrusted contexts\&.

.PP
A trusted caller (e\&.g\&. from RPC or a peer with addr permission) can use \fBGetAddressesUnsafe\fP to avoid using the cache\&.

.PP
\fBParameters\fP
.RS 4
\fIrequestor\fP The requesting peer\&. Used to key the cache to prevent privacy leaks\&. 
.br
\fImax_addresses\fP Maximum number of addresses to return (0 = all)\&. Ignored when cache already contains an entry for requestor\&. 
.br
\fImax_pct\fP Maximum percentage of addresses to return (0 = all)\&. Value must be from 0 to 100\&. Ignored when cache already contains an entry for requestor\&. 
.RE
.PP

.SS "std::vector< \fBCAddress\fP > GetAddressesUnsafe (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered = \fRtrue\fP) const"
Return randomly selected addresses\&. This function does not use the address response cache and should only be used in trusted contexts\&.

.PP
An untrusted caller (e\&.g\&. from p2p) should instead use \fBGetAddresses\fP to use the cache\&.

.PP
\fBParameters\fP
.RS 4
\fImax_addresses\fP Maximum number of addresses to return (0 = all)\&. 
.br
\fImax_pct\fP Maximum percentage of addresses to return (0 = all)\&. Value must be from 0 to 100\&. 
.br
\fInetwork\fP Select only addresses of this network (nullopt = all)\&. 
.br
\fIfiltered\fP Select only addresses that are considered high quality (false = all)\&. 
.RE
.PP

.SS "\fBCSipHasher\fP GetDeterministicRandomizer (uint64_t id) const"
Get a unique deterministic randomizer\&. 
.SS "int GetExtraBlockRelayCount () const"

.SS "int GetExtraFullOutboundCount () const"

.SS "int GetFullOutboundConnCount () const"

.SS "\fBServiceFlags\fP GetLocalServices () const"
Used to convey which local services we are offering peers during node connection\&.

.PP
The data returned by this is used in \fBCNode\fP construction, which is used to advertise which services we are offering that peer during \fR\fBnet_processing\&.cpp\fP:PushNodeVersion()\fP\&. 
.SS "uint32_t GetMappedAS (const \fBCNetAddr\fP & addr) const"

.SS "uint64_t GetMaxOutboundTarget () const"

.SS "std::chrono::seconds GetMaxOutboundTimeframe () const"

.SS "std::chrono::seconds GetMaxOutboundTimeLeftInCycle () const"

.SS "std::map< \fBCNetAddr\fP, \fBLocalServiceInfo\fP > getNetLocalAddresses () const"

.SS "bool GetNetworkActive () const\fR [inline]\fP"

.SS "size_t GetNodeCount (\fBConnectionDirection\fP flags) const"

.SS "\fBRecursiveMutex\fP & GetNodesMutex () const"

.SS "void GetNodeStats (std::vector< \fBCNodeStats\fP > & vstats) const"

.SS "uint64_t GetOutboundTargetBytesLeft () const"
response the bytes left in the current max outbound cycle in case of no limit, it will always response 0 
.SS "uint64_t GetTotalBytesRecv () const"

.SS "uint64_t GetTotalBytesSent () const"

.SS "bool GetTryNewOutboundPeer () const"

.SS "bool GetUseAddrmanOutgoing () const\fR [inline]\fP"

.SS "void \fBInit\fP (const \fBOptions\fP & connOptions)"

.SS "void Interrupt ()"

.SS "bool MultipleManualOrFullOutboundConns (\fBNetwork\fP net) const"

.SS "bool OpenNetworkConnection (const \fBCAddress\fP & addrConnect, bool fCountFailure, \fBCountingSemaphoreGrant\fP<> && grant_outbound, const char * pszDest, \fBConnectionType\fP conn_type, bool use_v2transport, const std::optional< \fBProxy\fP > & proxy_override = \fRstd::nullopt\fP)"
Open a new P2P connection and initialize it with the \fBPeerManager\fP at \fR\fBm_msgproc\fP\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddrConnect\fP Address to connect to, if \fRpszDest\fP is \fRnullptr\fP\&. 
.br
\fIfCountFailure\fP Increment the number of connection attempts to this address in Addrman\&. 
.br
\fIgrant_outbound\fP Take ownership of this grant, to be released later when the connection is closed\&. 
.br
\fIpszDest\fP Address to resolve and connect to\&. 
.br
\fIconn_type\fP Type of the connection to open, must not be \fR\fBConnectionType::INBOUND\fP\fP\&. 
.br
\fIuse_v2transport\fP Use P2P encryption, (aka V2 transport, BIP324)\&. 
.br
\fIproxy_override\fP Optional proxy to use and override normal proxy selection\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP The connection was opened successfully\&. 
.br
\fIfalse\fP The connection attempt failed\&. 
.RE
.PP

.SS "bool OutboundTargetReached (bool historicalBlockServingLimit) const"
check if the outbound target is reached if param historicalBlockServingLimit is set true, the function will response true if the limit for serving historical blocks has been reached 
.SS "void PushMessage (\fBCNode\fP * pnode, \fBCSerializedNetMsg\fP && msg)"

.SS "bool RemoveAddedNode (std::string_view node)"

.SS "void RemoveLocalServices (\fBServiceFlags\fP services)\fR [inline]\fP"

.SS "void SetCaptureMessages (bool cap)\fR [inline]\fP"

.SS "void SetNetworkActive (bool active)"

.SS "void SetTryNewOutboundPeer (bool flag)"

.SS "bool ShouldRunInactivityChecks (const \fBCNode\fP & node, std::chrono::microseconds now) const"
Return true if we should disconnect the peer for failing an inactivity check\&. 
.SS "bool Start (\fBCScheduler\fP & scheduler, const \fBOptions\fP & options)"

.SS "void StartExtraBlockRelayPeers ()"

.SS "void Stop ()\fR [inline]\fP"

.SS "void StopNodes ()"

.SS "void StopThreads ()"

.SS "const bool use_v2transport (\fBGetLocalServices\fP() & NODE_P2P_V2)"

.SS "void WakeMessageHandler ()"

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend struct \fBConnmanTestMsg\fP\fR [friend]\fP"

.SH "Field Documentation"
.PP 
.SS "bool !m_added_nodes_mutex"

.SS "bool !m_addr_fetches_mutex"

.SS "void !m_total_bytes_sent_mutex"
\fBInitial value:\fP
.nf
{
        AssertLockNotHeld(m_total_bytes_sent_mutex)
.PP
.fi

.SS "void !mutexMsgProc"

.SS "m_banman = connOptions\&.m_banman"

.SS "m_capture_messages = connOptions\&.m_capture_messages"

.SS "m_client_interface = connOptions\&.uiInterface"

.SS "m_local_services = connOptions\&.m_local_services"

.SS "m_max_automatic_connections = connOptions\&.m_max_automatic_connections"

.SS "m_max_automatic_outbound = \fBm_max_outbound_full_relay\fP + \fBm_max_outbound_block_relay\fP + m_max_feeler"

.SS "m_max_inbound = std::max(0, \fBm_max_automatic_connections\fP \- \fBm_max_automatic_outbound\fP)"

.SS "m_max_outbound_block_relay = std::min(MAX_BLOCK_RELAY_ONLY_CONNECTIONS, \fBm_max_automatic_connections\fP \- \fBm_max_outbound_full_relay\fP)"

.SS "m_max_outbound_full_relay = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, \fBm_max_automatic_connections\fP)"

.SS "m_msgproc = connOptions\&.m_msgproc"

.SS "m_onion_binds = connOptions\&.onion_binds"

.SS "m_peer_connect_timeout = std::chrono::seconds{connOptions\&.m_peer_connect_timeout}"

.SS "m_use_addrman_outgoing = connOptions\&.m_use_addrman_outgoing"

.SS "nMaxOutboundLimit = connOptions\&.nMaxOutboundLimit"

.SS "nReceiveFloodSize = connOptions\&.nReceiveFloodSize"

.SS "nSendBufferMaxSize = connOptions\&.nSendBufferMaxSize"

.SS "vWhitelistedRangeIncoming = connOptions\&.vWhitelistedRangeIncoming"

.SS "vWhitelistedRangeOutgoing = connOptions\&.vWhitelistedRangeOutgoing"

.SS "whitelist_forcerelay = connOptions\&.whitelist_forcerelay"

.SS "whitelist_relay = connOptions\&.whitelist_relay"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
