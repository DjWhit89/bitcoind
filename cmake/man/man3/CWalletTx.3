.TH "CWalletTx" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CWalletTx
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <transaction\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBAmountType\fP { \fBDEBIT\fP, \fBCREDIT\fP, \fBAMOUNTTYPE_ENUM_ELEMENTS\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCWalletTx\fP (\fBCTransactionRef\fP \fBtx\fP, const TxState &\fBstate\fP)"
.br
.ti -1c
.RI "void \fBInit\fP ()"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s) const"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s)"
.br
.ti -1c
.RI "void \fBSetTx\fP (\fBCTransactionRef\fP arg)"
.br
.ti -1c
.RI "void \fBMarkDirty\fP ()"
.br
.RI "make sure balances are recalculated "
.ti -1c
.RI "bool \fBIsEquivalentTo\fP (const \fBCWalletTx\fP &\fBtx\fP) const"
.br
.ti -1c
.RI "bool \fBInMempool\fP () const"
.br
.ti -1c
.RI "int64_t \fBGetTxTime\fP () const"
.br
.ti -1c
.RI "template<typename \fBT\fP> const \fBT\fP * \fBstate\fP () const"
.br
.ti -1c
.RI "template<typename \fBT\fP> \fBT\fP * \fBstate\fP ()"
.br
.ti -1c
.RI "void \fBupdateState\fP (\fBinterfaces::Chain\fP &chain)"
.br
.ti -1c
.RI "bool \fBisAbandoned\fP () const"
.br
.ti -1c
.RI "bool \fBisMempoolConflicted\fP () const"
.br
.ti -1c
.RI "bool \fBisBlockConflicted\fP () const"
.br
.ti -1c
.RI "bool \fBisInactive\fP () const"
.br
.ti -1c
.RI "bool \fBisUnconfirmed\fP () const"
.br
.ti -1c
.RI "bool \fBisConfirmed\fP () const"
.br
.ti -1c
.RI "const \fBTxid\fP & \fBGetHash\fP () const \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "const \fBWtxid\fP & \fBGetWitnessHash\fP () const \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "bool \fBIsCoinBase\fP () const"
.br
.ti -1c
.RI "void \fBCopyFrom\fP (const \fBCWalletTx\fP &)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "mapValue_t \fBmapValue\fP"
.br
.ti -1c
.RI "std::vector< std::pair< std::string, std::string > > \fBvOrderForm\fP"
.br
.ti -1c
.RI "unsigned int \fBnTimeReceived\fP"
.br
.RI "time received by this node "
.ti -1c
.RI "unsigned int \fBnTimeSmart\fP"
.br
.ti -1c
.RI "std::optional< bool > \fBm_cached_from_me\fP {std::nullopt}"
.br
.ti -1c
.RI "int64_t \fBnOrderPos\fP"
.br
.RI "position in ordered transaction list "
.ti -1c
.RI "std::multimap< int64_t, \fBCWalletTx\fP * >::const_iterator \fBm_it_wtxOrdered\fP"
.br
.ti -1c
.RI "CachableAmount \fBm_amounts\fP [\fBAMOUNTTYPE_ENUM_ELEMENTS\fP]"
.br
.ti -1c
.RI "bool \fBm_is_cache_empty\fP {true}"
.br
.ti -1c
.RI "bool \fBfChangeCached\fP"
.br
.ti -1c
.RI "\fBCAmount\fP \fBnChangeCached\fP"
.br
.ti -1c
.RI "\fBCTransactionRef\fP \fBtx\fP"
.br
.ti -1c
.RI "TxState \fBm_state\fP"
.br
.ti -1c
.RI "std::set< \fBTxid\fP > \fBmempool_conflicts\fP"
.br
.ti -1c
.RI "std::optional< \fBTxid\fP > \fBtruc_child_in_mempool\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A transaction with a bunch of additional info that only the owner cares about\&. It includes any unrecorded transactions needed to link it back to the block chain\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBAmountType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIDEBIT \fP
.TP
\f(BICREDIT \fP
.TP
\f(BIAMOUNTTYPE_ENUM_ELEMENTS \fP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCWalletTx\fP (\fBCTransactionRef\fP tx, const TxState & state)\fR [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void CopyFrom (const \fBCWalletTx\fP & _tx)"

.SS "const \fBTxid\fP & GetHash () const\fR [inline]\fP"

.SS "int64_t GetTxTime () const"

.SS "const \fBWtxid\fP & GetWitnessHash () const\fR [inline]\fP"

.SS "void \fBInit\fP ()\fR [inline]\fP"

.SS "bool InMempool () const"

.SS "bool isAbandoned () const\fR [inline]\fP"

.SS "bool isBlockConflicted () const\fR [inline]\fP"

.SS "bool IsCoinBase () const\fR [inline]\fP"

.SS "bool isConfirmed () const\fR [inline]\fP"

.SS "bool IsEquivalentTo (const \fBCWalletTx\fP & tx) const"
True if only scriptSigs are different 
.SS "bool isInactive () const\fR [inline]\fP"

.SS "bool isMempoolConflicted () const\fR [inline]\fP"

.SS "bool isUnconfirmed () const\fR [inline]\fP"

.SS "void MarkDirty ()\fR [inline]\fP"

.PP
make sure balances are recalculated 
.SS "template<typename Stream> void Serialize (Stream & s) const\fR [inline]\fP"
< Used to be vMerkleBranch

.PP
< Used to be vtxPrev

.PP
< Used to be fFromMe, and fSpent
.SS "void SetTx (\fBCTransactionRef\fP arg)\fR [inline]\fP"

.SS "template<typename \fBT\fP> \fBT\fP * state ()\fR [inline]\fP"

.SS "template<typename \fBT\fP> const \fBT\fP * state () const\fR [inline]\fP"

.SS "template<typename Stream> void Unserialize (Stream & s)\fR [inline]\fP"
< Used to be vMerkleBranch

.PP
< Used to be vtxPrev

.PP
Used to be fFromMe, and fSpent
.SS "void updateState (\fBinterfaces::Chain\fP & chain)"
Update transaction state when attaching to a chain, filling in heights of conflicted and confirmed blocks 
.SH "Field Documentation"
.PP 
.SS "bool fChangeCached\fR [mutable]\fP"

.SS "CachableAmount m_amounts[\fBAMOUNTTYPE_ENUM_ELEMENTS\fP]\fR [mutable]\fP"

.SS "std::optional<bool> m_cached_from_me {std::nullopt}\fR [mutable]\fP"

.SS "bool m_is_cache_empty {true}\fR [mutable]\fP"
This flag is true if all m_amounts caches are empty\&. This is particularly useful in places where MarkDirty is conditionally called and the condition can be expensive and thus can be skipped if the flag is true\&. See MarkDestinationsDirty\&. 
.SS "std::multimap<int64_t,\fBCWalletTx\fP*>::const_iterator m_it_wtxOrdered"

.SS "TxState m_state"

.SS "mapValue_t mapValue"
Key/value map with information about the transaction\&.

.PP
The following keys can be read and written through the map and are serialized in the wallet database: 
.PP
.nf
"comment", "to"   - comment strings provided to sendtoaddress,
                    and sendmany wallet RPCs
"replaces_txid"   - txid (as HexStr) of transaction replaced by
                    bumpfee on transaction created by bumpfee
"replaced_by_txid" - txid (as HexStr) of transaction created by
                    bumpfee on transaction replaced by bumpfee
"from", "message" - obsolete fields that could be set in UI prior to
                    2011 (removed in commit 4d9b223)

.fi
.PP

.PP
The following keys are serialized in the wallet database, but shouldn't be read or written through the map (they will be temporarily added and removed from the map during serialization): 
.PP
.nf
"fromaccount"     - serialized strFromAccount value
"n"               - serialized nOrderPos value
"timesmart"       - serialized nTimeSmart value
"spent"           - serialized vfSpent value that existed prior to
                    2014 (removed in commit 93a18a3)

.fi
.PP
 
.SS "std::set<\fBTxid\fP> mempool_conflicts"

.SS "\fBCAmount\fP nChangeCached\fR [mutable]\fP"

.SS "int64_t nOrderPos"

.PP
position in ordered transaction list 
.SS "unsigned int nTimeReceived"

.PP
time received by this node 
.SS "unsigned int nTimeSmart"
Stable timestamp that never changes, and reflects the order a transaction was added to the wallet\&. Timestamp is based on the block time for a transaction added as part of a block, or else the time when the transaction was received if it wasn't part of a block, with the timestamp adjusted in both cases so timestamp order matches the order transactions were added to the wallet\&. More details can be found in \fBCWallet::ComputeTimeSmart()\fP\&. 
.SS "std::optional<\fBTxid\fP> truc_child_in_mempool"

.SS "\fBCTransactionRef\fP tx"

.SS "std::vector<std::pair<std::string, std::string> > vOrderForm"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
