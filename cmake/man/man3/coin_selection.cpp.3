.TH "src/bench/coin_selection.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/bench/coin_selection.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <bench/bench\&.h>\fP
.br
\fR#include <consensus/amount\&.h>\fP
.br
\fR#include <interfaces/chain\&.h>\fP
.br
\fR#include <node/context\&.h>\fP
.br
\fR#include <outputtype\&.h>\fP
.br
\fR#include <policy/feerate\&.h>\fP
.br
\fR#include <policy/policy\&.h>\fP
.br
\fR#include <primitives/transaction\&.h>\fP
.br
\fR#include <random\&.h>\fP
.br
\fR#include <sync\&.h>\fP
.br
\fR#include <util/result\&.h>\fP
.br
\fR#include <wallet/coinselection\&.h>\fP
.br
\fR#include <wallet/spend\&.h>\fP
.br
\fR#include <wallet/test/util\&.h>\fP
.br
\fR#include <wallet/transaction\&.h>\fP
.br
\fR#include <wallet/wallet\&.h>\fP
.br
\fR#include <cassert>\fP
.br
\fR#include <map>\fP
.br
\fR#include <memory>\fP
.br
\fR#include <set>\fP
.br
\fR#include <utility>\fP
.br
\fR#include <vector>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBNodeContext\fP"
.br
.ti -1c
.RI "struct \fBCOutput\fP"
.br
.ti -1c
.RI "class \fBCWallet\fP"
.br
.ti -1c
.RI "class \fBCWalletTx\fP"
.br
.ti -1c
.RI "struct \fBCoinEligibilityFilter\fP"
.br
.ti -1c
.RI "struct \fBCoinSelectionParams\fP"
.br
.ti -1c
.RI "struct \fBOutputGroup\fP"
.br
.ti -1c
.RI "struct \fBTxStateInactive\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBBENCHMARK\fP (CoinSelection, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (BnBExhaustion, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fButil::Result\fP< SelectionResult > \fBAttemptSelection\fP (\fBinterfaces::Chain\fP &chain, const \fBCAmount\fP &nTargetValue, OutputGroupTypeMap &groups, const \fBCoinSelectionParams\fP &coin_selection_params, bool allow_mixed_output_types)"
.br
.ti -1c
.RI "std::unique_ptr< WalletDatabase > \fBCreateMockableWalletDatabase\fP (MockableData records)"
.br
.ti -1c
.RI "\fButil::Result\fP< SelectionResult > \fBSelectCoinsBnB\fP (std::vector< \fBOutputGroup\fP > &utxo_pool, const \fBCAmount\fP &selection_target, const \fBCAmount\fP &cost_of_change, int max_selection_weight)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fButil::Result\fP< SelectionResult > AttemptSelection (\fBinterfaces::Chain\fP & chain, const \fBCAmount\fP & nTargetValue, OutputGroupTypeMap & groups, const \fBCoinSelectionParams\fP & coin_selection_params, bool allow_mixed_output_types)"
Attempt to find a valid input set that preserves privacy by not mixing OutputTypes\&. \fRChooseSelectionResult()\fP will be called on each \fBOutputType\fP individually and the best the solution (according to the waste metric) will be chosen\&. If a valid input cannot be found from any single \fBOutputType\fP, fallback to running \fRChooseSelectionResult()\fP over all available coins\&.

.PP
\fBParameters\fP
.RS 4
\fIchain\fP The chain interface to get information on bump fees for unconfirmed UTXOs 
.br
\fInTargetValue\fP The target value 
.br
\fIgroups\fP The grouped outputs mapped by coin eligibility filters 
.br
\fIcoin_selection_params\fP Parameters for the coin selection 
.br
\fIallow_mixed_output_types\fP Relax restriction that SelectionResults must be of the same \fBOutputType\fP returns If successful, a SelectionResult containing the input set If failed, returns (1) an empty error message if the target was not reached (general "Insufficient funds") or (2) a specific error message if there was something particularly wrong (e\&.g\&. a selection result that surpassed the tx max weight size)\&. 
.RE
.PP

.SS "BENCHMARK (BnBExhaustion , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "BENCHMARK (CoinSelection , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "std::unique_ptr< WalletDatabase > CreateMockableWalletDatabase (MockableData records = \fR{}\fP)"

.SS "\fButil::Result\fP< SelectionResult > SelectCoinsBnB (std::vector< \fBOutputGroup\fP > & utxo_pool, const \fBCAmount\fP & selection_target, const \fBCAmount\fP & cost_of_change, int max_selection_weight)"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
