.TH "BIP324Cipher" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BIP324Cipher
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <bip324\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBIP324Cipher\fP ()=delete"
.br
.ti -1c
.RI "\fBBIP324Cipher\fP (const \fBCKey\fP &key, std::span< const std::byte > ent32) noexcept"
.br
.ti -1c
.RI "\fBBIP324Cipher\fP (const \fBCKey\fP &key, const \fBEllSwiftPubKey\fP &pubkey) noexcept"
.br
.ti -1c
.RI "const \fBEllSwiftPubKey\fP & \fBGetOurPubKey\fP () const noexcept"
.br
.ti -1c
.RI "void \fBInitialize\fP (const \fBEllSwiftPubKey\fP &their_pubkey, bool initiator, bool self_decrypt=false) noexcept"
.br
.ti -1c
.RI "\fBoperator bool\fP () const noexcept"
.br
.ti -1c
.RI "void \fBEncrypt\fP (std::span< const std::byte > contents, std::span< const std::byte > aad, bool ignore, std::span< std::byte > output) noexcept"
.br
.ti -1c
.RI "unsigned \fBDecryptLength\fP (std::span< const std::byte > input) noexcept"
.br
.ti -1c
.RI "bool \fBDecrypt\fP (std::span< const std::byte > input, std::span< const std::byte > aad, bool &ignore, std::span< std::byte > contents) noexcept"
.br
.ti -1c
.RI "std::span< const std::byte > \fBGetSessionID\fP () const noexcept"
.br
.ti -1c
.RI "std::span< const std::byte > \fBGetSendGarbageTerminator\fP () const noexcept"
.br
.ti -1c
.RI "std::span< const std::byte > \fBGetReceiveGarbageTerminator\fP () const noexcept"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr unsigned \fBSESSION_ID_LEN\fP {32}"
.br
.ti -1c
.RI "static constexpr unsigned \fBGARBAGE_TERMINATOR_LEN\fP {16}"
.br
.ti -1c
.RI "static constexpr unsigned \fBREKEY_INTERVAL\fP {224}"
.br
.ti -1c
.RI "static constexpr unsigned \fBLENGTH_LEN\fP {3}"
.br
.ti -1c
.RI "static constexpr unsigned \fBHEADER_LEN\fP {1}"
.br
.ti -1c
.RI "static constexpr unsigned \fBEXPANSION\fP = \fBLENGTH_LEN\fP + \fBHEADER_LEN\fP + \fBFSChaCha20Poly1305::EXPANSION\fP"
.br
.ti -1c
.RI "static constexpr std::byte \fBIGNORE_BIT\fP {0x80}"
.br
.in -1c
.SH "Detailed Description"
.PP 
The BIP324 packet cipher, encapsulating its key derivation, stream cipher, and AEAD\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBBIP324Cipher\fP ()\fR [delete]\fP"
No default constructor; keys must be provided to create a \fBBIP324Cipher\fP\&. 
.SS "\fBBIP324Cipher\fP (const \fBCKey\fP & key, std::span< const std::byte > ent32)\fR [noexcept]\fP"
Initialize a BIP324 cipher with specified key and encoding entropy (testing only)\&. 
.SS "\fBBIP324Cipher\fP (const \fBCKey\fP & key, const \fBEllSwiftPubKey\fP & pubkey)\fR [noexcept]\fP"
Initialize a BIP324 cipher with specified key (testing only)\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool Decrypt (std::span< const std::byte > input, std::span< const std::byte > aad, bool & ignore, std::span< std::byte > contents)\fR [noexcept]\fP"
Decrypt a packet\&. Only after \fBInitialize()\fP\&.

.PP
It must hold that input\&.size() + LENGTH_LEN == contents\&.size() + EXPANSION\&. Contents\&.size() must equal the length returned by DecryptLength\&. 
.SS "uint32_t DecryptLength (std::span< const std::byte > input)\fR [noexcept]\fP"
Decrypt the length of a packet\&. Only after \fBInitialize()\fP\&.

.PP
It must hold that input\&.size() == LENGTH_LEN\&. 
.SS "void Encrypt (std::span< const std::byte > contents, std::span< const std::byte > aad, bool ignore, std::span< std::byte > output)\fR [noexcept]\fP"
Encrypt a packet\&. Only after \fBInitialize()\fP\&.

.PP
It must hold that output\&.size() == contents\&.size() + EXPANSION\&. 
.SS "const \fBEllSwiftPubKey\fP & GetOurPubKey () const\fR [inline]\fP, \fR [noexcept]\fP"
Retrieve our public key\&. 
.SS "std::span< const std::byte > GetReceiveGarbageTerminator () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the expected Garbage Terminator to receive\&. Only after \fBInitialize()\fP\&. 
.SS "std::span< const std::byte > GetSendGarbageTerminator () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the Garbage Terminator to send\&. Only after \fBInitialize()\fP\&. 
.SS "std::span< const std::byte > GetSessionID () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the Session ID\&. Only after \fBInitialize()\fP\&. 
.SS "void Initialize (const \fBEllSwiftPubKey\fP & their_pubkey, bool initiator, bool self_decrypt = \fRfalse\fP)\fR [noexcept]\fP"
Initialize when the other side's public key is received\&. Can only be called once\&.

.PP
initiator is set to true if we are the initiator establishing the v2 P2P connection\&. self_decrypt is only for testing, and swaps encryption/decryption keys, so that encryption and decryption can be tested without knowing the other side's private key\&. 
.SS "operator bool () const\fR [inline]\fP, \fR [explicit]\fP, \fR [noexcept]\fP"
Determine whether this cipher is fully initialized\&. 
.SH "Field Documentation"
.PP 
.SS "unsigned EXPANSION = \fBLENGTH_LEN\fP + \fBHEADER_LEN\fP + \fBFSChaCha20Poly1305::EXPANSION\fP\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned GARBAGE_TERMINATOR_LEN {16}\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned HEADER_LEN {1}\fR [static]\fP, \fR [constexpr]\fP"

.SS "std::byte IGNORE_BIT {0x80}\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned LENGTH_LEN {3}\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned REKEY_INTERVAL {224}\fR [static]\fP, \fR [constexpr]\fP"

.SS "unsigned SESSION_ID_LEN {32}\fR [static]\fP, \fR [constexpr]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
