.TH "TestBlockManager" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TestBlockManager
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <validation\&.h>\fP
.PP
Inherits \fBBlockManager\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBCleanupForFuzzing\fP ()"
.br
.in -1c

Public Member Functions inherited from \fBBlockManager\fP
.in +1c
.ti -1c
.RI "\fBBlockManager\fP (const \fButil::SignalInterrupt\fP &interrupt, \fBOptions\fP\fBOptions\fP opts)"
.br
.ti -1c
.RI "\fBBlockMap\fP m_block_index \fBGUARDED_BY\fP (\fBcs_main\fP)"
.br
.ti -1c
.RI "std::unique_ptr< \fBBlockTreeDB\fP > m_block_tree_db \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBInsertBlockIndex\fP (const \fBuint256\fP &hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBPruneOneBlockFile\fP (const int fileNumber) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.RI "Mark one block file as pruned (modify associated database entries)\&. "
.ti -1c
.RI "\fBCBlockIndex\fP * \fBLookupBlockIndex\fP (const \fBuint256\fP &hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "const \fBCBlockIndex\fP * \fBLookupBlockIndex\fP (const \fBuint256\fP &hash) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCBlockFileInfo\fP * \fBGetBlockFileInfo\fP (size_t n)"
.br
.ti -1c
.RI "void \fBUpdateBlockInfo\fP (const \fBCBlock\fP &block, unsigned int \fBnHeight\fP, const \fBFlatFilePos\fP &pos)"
.br
.ti -1c
.RI "bool \fBIsPruneMode\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetPruneTarget\fP () const"
.br
.ti -1c
.RI "bool \fBLoadingBlocks\fP () const"
.br
.ti -1c
.RI "uint64_t \fBCalculateCurrentUsage\fP ()"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetBlockPosFilename\fP (const \fBFlatFilePos\fP &pos) const"
.br
.ti -1c
.RI "void \fBUnlinkPrunedFiles\fP (const std::set< int > &setFilesToPrune) const"
.br
.ti -1c
.RI "bool \fBReadBlock\fP (\fBCBlock\fP &block, const \fBFlatFilePos\fP &pos, const std::optional< \fBuint256\fP > &expected_hash) const"
.br
.ti -1c
.RI "bool \fBReadBlock\fP (\fBCBlock\fP &block, const \fBCBlockIndex\fP &index) const"
.br
.ti -1c
.RI "\fBReadRawBlockResult\fP \fBReadRawBlock\fP (const \fBFlatFilePos\fP &pos, std::optional< std::pair< size_t, size_t > > block_part=std::nullopt) const"
.br
.ti -1c
.RI "bool \fBReadBlockUndo\fP (\fBCBlockUndo\fP &blockundo, const \fBCBlockIndex\fP &index) const"
.br
.ti -1c
.RI "void \fBCleanupBlockRevFiles\fP () const"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBBlockManager\fP
.in +1c
.ti -1c
.RI "using \fBOptions\fP = \fBkernel::BlockManagerOpts\fP"
.br
.ti -1c
.RI "using \fBReadRawBlockResult\fP = \fButil::Expected\fP<std::vector<std::byte>, \fBReadRawError\fP>"
.br
.in -1c

Data Fields inherited from \fBBlockManager\fP
.in +1c
.ti -1c
.RI "const \fButil::SignalInterrupt\fP & \fBm_interrupt\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fBm_importing\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBm_blockfiles_indexed\fP {true}"
.br
.ti -1c
.RI "std::optional< int > \fBm_snapshot_height\fP"
.br
.ti -1c
.RI "std::vector< \fBCBlockIndex\fP * > GetAllBlockIndices() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::multimap< \fBCBlockIndex\fP *, \fBCBlockIndex\fP * > \fBm_blocks_unlinked\fP"
.br
.ti -1c
.RI "void WriteBlockIndexDB() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool LoadBlockIndexDB(const std::optional< \fBuint256\fP > &snapshot_blockhash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void ScanAndUnlinkAlreadyPrunedFiles() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCBlockIndex\fP \fBAddToBlockIndex\fP )(const \fBCBlockHeader\fP &block, \fBCBlockIndex\fP *&best_header) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool WriteBlockUndo(const \fBCBlockUndo\fP &blockundo, \fBBlockValidationState\fP &state, \fBCBlockIndex\fP &block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(FlatFilePo \fBWriteBlock\fP )(const \fBCBlock\fP &block, int \fBnHeight\fP)"
.br
.ti -1c
.RI "bool \fBCheckBlockDataAvailability\fP(const \fBCBlockIndex\fP &upper_block, const \fBCBlockIndex\fP &lower_block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP &GetFirstBlock(const \fBCBlockIndex\fP &upper_block \fBLIFETIMEBOUND\fP, uint32_t status_mask, const \fBCBlockIndex\fP *lower_block \fBLIFETIMEBOUND\fP=nullptr) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo \fBm_have_pruned\fP ) = false"
.br
.RI "Returns the earliest block with specified \fRstatus_mask\fP flags set after the latest block \fInot\fP having those flags\&. "
.ti -1c
.RI "bool IsBlockPruned(const \fBCBlockIndex\fP &block) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void UpdatePruneLock(const std::string &\fBname\fP, const \fBPruneLockInfo\fP &lock_info) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(AutoFil \fBOpenBlockFile\fP )(const \fBFlatFilePos\fP &pos, bool fReadOnly) const"
.br
.RI "Check whether the block associated with this index entry is pruned or not\&. "
.in -1c

Static Public Attributes inherited from \fBBlockManager\fP
.in +1c
.ti -1c
.RI "static constexpr auto \fBPRUNE_TARGET_MANUAL\fP {std::numeric_limits<uint64_t>::max()}"
.br
.in -1c

Protected Attributes inherited from \fBBlockManager\fP
.in +1c
.ti -1c
.RI "std::vector< \fBCBlockFileInfo\fP > \fBm_blockfile_info\fP"
.br
.ti -1c
.RI "std::set< \fBCBlockIndex\fP * > \fBm_dirty_blockindex\fP"
.br
.ti -1c
.RI "std::set< int > \fBm_dirty_fileinfo\fP"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void CleanupForFuzzing ()"
Test-only method to clear internal state for fuzzing 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
