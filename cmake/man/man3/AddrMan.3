.TH "AddrMan" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AddrMan
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <addrman\&.h>\fP
.PP
Inherited by \fBAddrManDeterministic\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAddrMan\fP (const \fBNetGroupManager\fP &netgroupman, bool deterministic, int32_t consistency_check_ratio)"
.br
.ti -1c
.RI "\fB~AddrMan\fP ()"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s_) const"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s_)"
.br
.ti -1c
.RI "size_t \fBSize\fP (std::optional< \fBNetwork\fP > net=std::nullopt, std::optional< bool > in_new=std::nullopt) const"
.br
.ti -1c
.RI "bool \fBAdd\fP (const std::vector< \fBCAddress\fP > &vAddr, const \fBCNetAddr\fP &source, std::chrono::seconds time_penalty=0s)"
.br
.ti -1c
.RI "bool \fBGood\fP (const \fBCService\fP &addr, \fBNodeSeconds\fP time=\fBNow\fP< \fBNodeSeconds\fP >())"
.br
.ti -1c
.RI "void \fBAttempt\fP (const \fBCService\fP &addr, bool fCountFailure, \fBNodeSeconds\fP time=\fBNow\fP< \fBNodeSeconds\fP >())"
.br
.RI "Mark an entry as connection attempted to\&. "
.ti -1c
.RI "void \fBResolveCollisions\fP ()"
.br
.RI "See if any to-be-evicted tried table entries have been tested and if so resolve the collisions\&. "
.ti -1c
.RI "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > \fBSelectTriedCollision\fP ()"
.br
.ti -1c
.RI "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > \fBSelect\fP (bool new_only=false, const std::unordered_set< \fBNetwork\fP > &networks={}) const"
.br
.ti -1c
.RI "std::vector< \fBCAddress\fP > \fBGetAddr\fP (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered=true) const"
.br
.ti -1c
.RI "std::vector< std::pair< \fBAddrInfo\fP, \fBAddressPosition\fP > > \fBGetEntries\fP (bool from_tried) const"
.br
.ti -1c
.RI "void \fBConnected\fP (const \fBCService\fP &addr, \fBNodeSeconds\fP time=\fBNow\fP< \fBNodeSeconds\fP >())"
.br
.ti -1c
.RI "void \fBSetServices\fP (const \fBCService\fP &addr, \fBServiceFlags\fP nServices)"
.br
.RI "Update an entry's service bits\&. "
.ti -1c
.RI "std::optional< \fBAddressPosition\fP > \fBFindAddressEntry\fP (const \fBCAddress\fP &addr)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "const std::unique_ptr< \fBAddrManImpl\fP > \fBm_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Stochastic address manager

.PP
Design goals:
.IP "\(bu" 2
Keep the address tables in-memory, and asynchronously dump the entire table to peers\&.dat\&.
.IP "\(bu" 2
Make sure no (localized) attacker can fill the entire table with his nodes/addresses\&.
.PP

.PP
To that end:
.IP "\(bu" 2
Addresses are organized into buckets that can each store up to 64 entries\&.
.IP "  \(bu" 4
Addresses to which our node has not successfully connected go into 1024 "new" buckets\&.
.IP "    \(bu" 6
Based on the address range (/16 for IPv4) of the source of information, or if an asmap is provided, the AS it belongs to (for IPv4/IPv6), 64 buckets are selected at random\&.
.IP "    \(bu" 6
The actual bucket is chosen from one of these, based on the range in which the address itself is located\&.
.IP "    \(bu" 6
The position in the bucket is chosen based on the full address\&.
.IP "    \(bu" 6
One single address can occur in up to 8 different buckets to increase selection chances for addresses that are seen frequently\&. The chance for increasing this multiplicity decreases exponentially\&.
.IP "    \(bu" 6
When adding a new address to an occupied position of a bucket, it will not replace the existing entry unless that address is also stored in another bucket or it doesn't meet one of several quality criteria (see IsTerrible for exact criteria)\&.
.PP

.IP "  \(bu" 4
Addresses of nodes that are known to be accessible go into 256 "tried" buckets\&.
.IP "    \(bu" 6
Each address range selects at random 8 of these buckets\&.
.IP "    \(bu" 6
The actual bucket is chosen from one of these, based on the full address\&.
.IP "    \(bu" 6
When adding a new good address to an occupied position of a bucket, a FEELER connection to the old address is attempted\&. The old entry is only replaced and moved back to the "new" buckets if this attempt was unsuccessful\&.
.PP

.IP "  \(bu" 4
Bucket selection is based on cryptographic hashing, using a randomly-generated 256-bit key, which should not be observable by adversaries\&.
.IP "  \(bu" 4
Several indexes are kept for high performance\&. Setting m_consistency_check_ratio with the -checkaddrman configuration option will introduce (expensive) consistency checks for the entire data structure\&. 
.PP

.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBAddrMan\fP (const \fBNetGroupManager\fP & netgroupman, bool deterministic, int32_t consistency_check_ratio)\fR [explicit]\fP"

.SS "~\fBAddrMan\fP ()\fR [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool Add (const std::vector< \fBCAddress\fP > & vAddr, const \fBCNetAddr\fP & source, std::chrono::seconds time_penalty = \fR0s\fP)"
Attempt to add one or more addresses to addrman's new table\&. If an address already exists in addrman, the existing entry may be updated (e\&.g\&. adding additional service flags)\&. If the existing entry is in the new table, it may be added to more buckets, improving the probability of selection\&.

.PP
\fBParameters\fP
.RS 4
\fIvAddr\fP Address records to attempt to add\&. 
.br
\fIsource\fP The address of the node that sent us these addr records\&. 
.br
\fItime_penalty\fP A "time penalty" to apply to the address record's nTime\&. If a peer sends us an address record with nTime=n, then we'll add it to our addrman with nTime=(n - time_penalty)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one address is successfully added, or added to an additional bucket\&. Unaffected by updates\&. 
.RE
.PP

.SS "void Attempt (const \fBCService\fP & addr, bool fCountFailure, \fBNodeSeconds\fP time = \fR\fBNow\fP<\fBNodeSeconds\fP>()\fP)"

.PP
Mark an entry as connection attempted to\&. 
.SS "void Connected (const \fBCService\fP & addr, \fBNodeSeconds\fP time = \fR\fBNow\fP<\fBNodeSeconds\fP>()\fP)"
We have successfully connected to this peer\&. Calling this function updates the \fBCAddress\fP's nTime, which is used in our IsTerrible() decisions and gossiped to peers\&. Callers should be careful that updating this information doesn't leak topology information to network spies\&.

.PP
net_processing calls this function when it \fIdisconnects\fP from a peer to not leak information about currently connected peers\&.

.PP
\fBParameters\fP
.RS 4
\fIaddr\fP The address of the peer we were connected to 
.br
\fItime\fP The time that we were last connected to this peer 
.RE
.PP

.SS "std::optional< \fBAddressPosition\fP > FindAddressEntry (const \fBCAddress\fP & addr)"
Test-only function Find the address record in \fBAddrMan\fP and return information about its position\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddr\fP The address record to look up\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Information about the address record in \fBAddrMan\fP or nullopt if address is not found\&. 
.RE
.PP

.SS "std::vector< \fBCAddress\fP > GetAddr (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered = \fRtrue\fP) const"
Return all or many randomly selected addresses, optionally by network\&.

.PP
\fBParameters\fP
.RS 4
\fImax_addresses\fP Maximum number of addresses to return (0 = all)\&. 
.br
\fImax_pct\fP Maximum percentage of addresses to return (0 = all)\&. Value must be from 0 to 100\&. 
.br
\fInetwork\fP Select only addresses of this network (nullopt = all)\&. 
.br
\fIfiltered\fP Select only addresses that are considered good quality (false = all)\&.
.RE
.PP
\fBReturns\fP
.RS 4
A vector of randomly selected addresses from vRandom\&. 
.RE
.PP

.SS "std::vector< std::pair< \fBAddrInfo\fP, \fBAddressPosition\fP > > GetEntries (bool from_tried) const"
Returns an information-location pair for all addresses in the selected addrman table\&. If an address appears multiple times in the new table, an information-location pair is returned for each occurrence\&. Addresses only ever appear once in the tried table\&.

.PP
\fBParameters\fP
.RS 4
\fIfrom_tried\fP Selects which table to return entries from\&.
.RE
.PP
\fBReturns\fP
.RS 4
A vector consisting of pairs of \fBAddrInfo\fP and \fBAddressPosition\fP\&. 
.RE
.PP

.SS "bool Good (const \fBCService\fP & addr, \fBNodeSeconds\fP time = \fR\fBNow\fP<\fBNodeSeconds\fP>()\fP)"
Mark an address record as accessible and attempt to move it to addrman's tried table\&.

.PP
\fBParameters\fP
.RS 4
\fIaddr\fP Address record to attempt to move to tried table\&. 
.br
\fItime\fP The time that we were last connected to this peer\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the address is successfully moved from the new table to the tried table\&. 
.RE
.PP

.SS "void ResolveCollisions ()"

.PP
See if any to-be-evicted tried table entries have been tested and if so resolve the collisions\&. 
.SS "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > Select (bool new_only = \fRfalse\fP, const std::unordered_set< \fBNetwork\fP > & networks = \fR{}\fP) const"
Choose an address to connect to\&.

.PP
\fBParameters\fP
.RS 4
\fInew_only\fP Whether to only select addresses from the new table\&. Passing \fRtrue\fP returns an address from the new table or an empty pair\&. Passing \fRfalse\fP will return an empty pair or an address from either the new or tried table (it does not guarantee a tried entry)\&. 
.br
\fInetworks\fP Select only addresses of these networks (empty = all)\&. Passing networks may slow down the search\&. 
.RE
.PP
\fBReturns\fP
.RS 4
\fBCAddress\fP The record for the selected peer\&. seconds The last time we attempted to connect to that peer\&. 
.RE
.PP

.SS "std::pair< \fBCAddress\fP, \fBNodeSeconds\fP > SelectTriedCollision ()"
Randomly select an address in the tried table that another address is attempting to evict\&.

.PP
\fBReturns\fP
.RS 4
\fBCAddress\fP The record for the selected tried peer\&. seconds The last time we attempted to connect to that peer\&. 
.RE
.PP

.SS "template<typename Stream> template void Serialize (Stream & s_) const"

.SS "void SetServices (const \fBCService\fP & addr, \fBServiceFlags\fP nServices)"

.PP
Update an entry's service bits\&. 
.SS "size_t Size (std::optional< \fBNetwork\fP > net = \fRstd::nullopt\fP, std::optional< bool > in_new = \fRstd::nullopt\fP) const"
Return size information about addrman\&.

.PP
\fBParameters\fP
.RS 4
\fInet\fP Select addresses only from specified network (nullopt = all) 
.br
\fIin_new\fP Select addresses only from one table (true = new, false = tried, nullopt = both) 
.RE
.PP
\fBReturns\fP
.RS 4
Number of unique addresses that match specified options\&. 
.RE
.PP

.SS "template<typename Stream> template void Unserialize (Stream & s_)"

.SH "Field Documentation"
.PP 
.SS "const std::unique_ptr<\fBAddrManImpl\fP> m_impl\fR [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
