.TH "md_src_2secp256k1_2doc_2musig" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_src_2secp256k1_2doc_2musig \- Notes on the musig module API 
.PP
The following sections contain additional notes on the API of the musig module (\fR\fBinclude/secp256k1_musig\&.h\fP\fP)\&. A usage example can be found in \fR\fBexamples/musig\&.c\fP\fP\&.
.SH "API misuse"
.PP
The musig API is designed with a focus on misuse resistance\&. However, due to the interactive nature of the MuSig protocol, there are additional failure modes that are not present in regular (single-party) Schnorr signature creation\&. While the results can be catastrophic (e\&.g\&. leaking of the secret key), it is unfortunately not possible for the musig implementation to prevent all such failure modes\&.

.PP
Therefore, users of the musig module must take great care to make sure of the following:

.PP
.IP "1." 4
A unique nonce per signing session is generated in \fR\fBsecp256k1_musig_nonce_gen\fP\fP\&. See the corresponding comment in \fR\fBinclude/secp256k1_musig\&.h\fP\fP for how to ensure that\&.
.IP "2." 4
The \fR\fBsecp256k1_musig_secnonce\fP\fP structure is never copied or serialized\&. See also the comment on \fR\fBsecp256k1_musig_secnonce\fP\fP in \fR\fBinclude/secp256k1_musig\&.h\fP\fP\&.
.IP "3." 4
Opaque data structures are never written to or read from directly\&. Instead, only the provided accessor functions are used\&.
.PP
.SH "Key Aggregation and (Taproot) Tweaking"
.PP
Given a set of public keys, the aggregate public key is computed with \fR\fBsecp256k1_musig_pubkey_agg\fP\fP\&. A plain tweak can be added to the resulting public key with \fR\fBsecp256k1_ec_pubkey_tweak_add\fP\fP by setting the \fRtweak32\fP argument to the hash defined in BIP 32\&. Similarly, a Taproot tweak can be added with \fR\fBsecp256k1_xonly_pubkey_tweak_add\fP\fP by setting the \fRtweak32\fP argument to the TapTweak hash defined in BIP 341\&. Both types of tweaking can be combined and invoked multiple times if the specific application requires it\&.
.SH "Signing"
.PP
This is covered by \fR\fBexamples/musig\&.c\fP\fP\&. Essentially, the protocol proceeds in the following steps:

.PP
.IP "1." 4
Generate a keypair with \fR\fBsecp256k1_keypair_create\fP\fP and obtain the public key with \fR\fBsecp256k1_keypair_pub\fP\fP\&.
.IP "2." 4
Call \fR\fBsecp256k1_musig_pubkey_agg\fP\fP with the pubkeys of all participants\&.
.IP "3." 4
Optionally add a (Taproot) tweak with \fR\fBsecp256k1_musig_pubkey_xonly_tweak_add\fP\fP and a plain tweak with \fR\fBsecp256k1_musig_pubkey_ec_tweak_add\fP\fP\&.
.IP "4." 4
Generate a pair of secret and public nonce with \fR\fBsecp256k1_musig_nonce_gen\fP\fP and send the public nonce to the other signers\&.
.IP "5." 4
Someone (not necessarily the signer) aggregates the public nonces with \fR\fBsecp256k1_musig_nonce_agg\fP\fP and sends it to the signers\&.
.IP "6." 4
Process the aggregate nonce with \fR\fBsecp256k1_musig_nonce_process\fP\fP\&.
.IP "7." 4
Create a partial signature with \fR\fBsecp256k1_musig_partial_sign\fP\fP\&.
.IP "8." 4
Verify the partial signatures (optional in some scenarios) with \fR\fBsecp256k1_musig_partial_sig_verify\fP\fP\&.
.IP "9." 4
Someone (not necessarily the signer) obtains all partial signatures and aggregates them into the final Schnorr signature using \fR\fBsecp256k1_musig_partial_sig_agg\fP\fP\&.
.PP

.PP
The aggregate signature can be verified with \fR\fBsecp256k1_schnorrsig_verify\fP\fP\&.

.PP
Steps 1 through 5 above can occur before or after the signers are aware of the message to be signed\&. Whenever possible, it is recommended to generate the nonces only after the message is known\&. This provides enhanced defense-in-depth measures, protecting against potential API misuse in certain scenarios\&. However, it does require two rounds of communication during the signing process\&. The alternative, generating the nonces in a pre-processing step before the message is known, eliminates these additional protective measures but allows for non-interactive signing\&. Similarly, the API supports an alternative protocol flow where generating the aggregate key (steps 1 to 3) is allowed to happen after exchanging nonces (steps 4 to 5)\&.
.SH "Verification"
.PP
A participant who wants to verify the partial signatures, but does not sign itself may do so using the above instructions except that the verifier skips steps 1, 4 and 7\&. 
