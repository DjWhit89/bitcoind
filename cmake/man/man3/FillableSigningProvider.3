.TH "FillableSigningProvider" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
FillableSigningProvider
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <signingprovider\&.h>\fP
.PP
Inherits \fBSigningProvider\fP\&.
.PP
Inherited by \fBLegacyDataSPKM\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual bool \fBAddKeyPubKey\fP (const \fBCKey\fP &key, const \fBCPubKey\fP &pubkey)"
.br
.ti -1c
.RI "virtual bool \fBAddKey\fP (const \fBCKey\fP &key)"
.br
.ti -1c
.RI "virtual bool \fBGetPubKey\fP (const \fBCKeyID\fP &address, \fBCPubKey\fP &vchPubKeyOut) const override"
.br
.ti -1c
.RI "virtual bool \fBHaveKey\fP (const \fBCKeyID\fP &address) const override"
.br
.ti -1c
.RI "virtual std::set< \fBCKeyID\fP > \fBGetKeys\fP () const"
.br
.ti -1c
.RI "virtual bool \fBGetKey\fP (const \fBCKeyID\fP &address, \fBCKey\fP &keyOut) const override"
.br
.ti -1c
.RI "virtual bool \fBAddCScript\fP (const \fBCScript\fP &redeemScript)"
.br
.ti -1c
.RI "virtual bool \fBHaveCScript\fP (const \fBCScriptID\fP &hash) const override"
.br
.ti -1c
.RI "virtual std::set< \fBCScriptID\fP > \fBGetCScripts\fP () const"
.br
.ti -1c
.RI "virtual bool \fBGetCScript\fP (const \fBCScriptID\fP &hash, \fBCScript\fP &redeemScriptOut) const override"
.br
.in -1c

Public Member Functions inherited from \fBSigningProvider\fP
.in +1c
.ti -1c
.RI "virtual \fB~SigningProvider\fP ()=default"
.br
.ti -1c
.RI "virtual bool \fBGetKeyOrigin\fP (const \fBCKeyID\fP &keyid, \fBKeyOriginInfo\fP &info) const"
.br
.ti -1c
.RI "virtual bool \fBGetTaprootSpendData\fP (const \fBXOnlyPubKey\fP &output_key, \fBTaprootSpendData\fP &spenddata) const"
.br
.ti -1c
.RI "virtual bool \fBGetTaprootBuilder\fP (const \fBXOnlyPubKey\fP &output_key, \fBTaprootBuilder\fP &builder) const"
.br
.ti -1c
.RI "virtual std::vector< \fBCPubKey\fP > \fBGetMuSig2ParticipantPubkeys\fP (const \fBCPubKey\fP &pubkey) const"
.br
.ti -1c
.RI "virtual std::map< \fBCPubKey\fP, std::vector< \fBCPubKey\fP > > \fBGetAllMuSig2ParticipantPubkeys\fP () const"
.br
.ti -1c
.RI "virtual void \fBSetMuSig2SecNonce\fP (const \fBuint256\fP &id, \fBMuSig2SecNonce\fP &&\fBnonce\fP) const"
.br
.ti -1c
.RI "virtual std::optional< std::reference_wrapper< \fBMuSig2SecNonce\fP > > \fBGetMuSig2SecNonce\fP (const \fBuint256\fP &session_id) const"
.br
.ti -1c
.RI "virtual void \fBDeleteMuSig2Session\fP (const \fBuint256\fP &session_id) const"
.br
.ti -1c
.RI "bool \fBGetKeyByXOnly\fP (const \fBXOnlyPubKey\fP &pubkey, \fBCKey\fP &key) const"
.br
.ti -1c
.RI "bool \fBGetPubKeyByXOnly\fP (const \fBXOnlyPubKey\fP &pubkey, \fBCPubKey\fP &out) const"
.br
.ti -1c
.RI "bool \fBGetKeyOriginByXOnly\fP (const \fBXOnlyPubKey\fP &pubkey, \fBKeyOriginInfo\fP &info) const"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBRecursiveMutex\fP \fBcs_KeyStore\fP"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "using \fBKeyMap\fP = std::map<\fBCKeyID\fP, \fBCKey\fP>"
.br
.ti -1c
.RI "using \fBScriptMap\fP = std::map<\fBCScriptID\fP, \fBCScript\fP>"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBKeyMap\fP mapKeys \fBGUARDED_BY\fP (\fBcs_KeyStore\fP)"
.br
.ti -1c
.RI "\fBScriptMap\fP mapScripts \fBGUARDED_BY\fP (\fBcs_KeyStore\fP)"
.br
.ti -1c
.RI "void \fBImplicitlyLearnRelatedKeyScripts\fP (const \fBCPubKey\fP &pubkey) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_KeyStore\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Fillable signing provider that keeps keys in an address->secret map 
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBKeyMap\fP = std::map<\fBCKeyID\fP, \fBCKey\fP>\fR [protected]\fP"

.SS "using \fBScriptMap\fP = std::map<\fBCScriptID\fP, \fBCScript\fP>\fR [protected]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool AddCScript (const \fBCScript\fP & redeemScript)\fR [virtual]\fP"

.SS "virtual bool AddKey (const \fBCKey\fP & key)\fR [inline]\fP, \fR [virtual]\fP"

.SS "bool AddKeyPubKey (const \fBCKey\fP & key, const \fBCPubKey\fP & pubkey)\fR [virtual]\fP"

.SS "bool GetCScript (const \fBCScriptID\fP & hash, \fBCScript\fP & redeemScriptOut) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBSigningProvider\fP\&.
.SS "std::set< \fBCScriptID\fP > GetCScripts () const\fR [virtual]\fP"

.SS "bool GetKey (const \fBCKeyID\fP & address, \fBCKey\fP & keyOut) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBSigningProvider\fP\&.
.PP
Reimplemented in \fBLegacyDataSPKM\fP\&.
.SS "std::set< \fBCKeyID\fP > GetKeys () const\fR [virtual]\fP"

.SS "bool GetPubKey (const \fBCKeyID\fP & address, \fBCPubKey\fP & vchPubKeyOut) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBSigningProvider\fP\&.
.PP
Reimplemented in \fBLegacyDataSPKM\fP\&.
.SS "\fBScriptMap\fP mapScripts GUARDED_BY (\fBcs_KeyStore\fP )\fR [protected]\fP"
Map of script id to scripts known by the signing provider\&.

.PP
This map originally just held P2SH redeemScripts, and was used by wallet code to look up script ids referenced in "OP_HASH160 <script id>OP_EQUAL" P2SH outputs\&. Later in 605e8473a7d it was extended to hold P2WSH witnessScripts as well, and used to look up nested scripts referenced in "OP_0 <script hash>" P2WSH outputs\&. Later in commits f4691ab3a9d and 248f3a76a82, it was extended once again to hold segwit "OP_0 <key or script hash>" scriptPubKeys, in order to give the wallet a way to distinguish between segwit outputs that it generated addresses for and wanted to receive payments from, and segwit outputs that it never generated addresses for, but it could spend just because of having keys\&. (Before segwit activation it was also important to not treat segwit outputs to arbitrary wallet keys as payments, because these could be spent by anyone without even needing to sign with the keys\&.)

.PP
Some of the scripts stored in mapScripts are memory-only and intentionally not saved to disk\&. Specifically, scripts added by ImplicitlyLearnRelatedKeyScripts(pubkey) calls are not written to disk so future wallet code can have flexibility to be more selective about what transaction outputs it recognizes as payments, instead of having to treat all outputs spending to keys it knows as payments\&. By contrast, mapScripts entries added by AddCScript(script), LearnRelatedScripts(pubkey, type), and LearnAllRelatedScripts(pubkey) calls are saved because they are all intentionally used to receive payments\&.

.PP
The FillableSigningProvider::mapScripts script map should not be confused with LegacyScriptPubKeyMan::setWatchOnly script set\&. The two collections can hold the same scripts, but they serve different purposes\&. The setWatchOnly script set is intended to expand the set of outputs the wallet considers payments\&. Every output with a script it contains is considered to belong to the wallet, regardless of whether the script is solvable or signable\&. By contrast, the scripts in mapScripts are only used for solving, and to restrict which outputs are considered payments by the wallet\&. An output with a script in mapScripts, unlike setWatchOnly, is not automatically considered to belong to the wallet if it can't be solved and signed for\&. 
.SS "\fBKeyMap\fP mapKeys GUARDED_BY (\fBcs_KeyStore\fP )\fR [protected]\fP"
Map of key id to unencrypted private keys known by the signing provider\&. Map may be empty if the provider has another source of keys, like an encrypted store\&. 
.SS "bool HaveCScript (const \fBCScriptID\fP & hash) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBSigningProvider\fP\&.
.SS "bool HaveKey (const \fBCKeyID\fP & address) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBSigningProvider\fP\&.
.PP
Reimplemented in \fBLegacyDataSPKM\fP\&.
.SS "void ImplicitlyLearnRelatedKeyScripts (const \fBCPubKey\fP & pubkey)\fR [protected]\fP"

.SH "Field Documentation"
.PP 
.SS "\fBRecursiveMutex\fP cs_KeyStore\fR [mutable]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
