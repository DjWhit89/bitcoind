.TH "node" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
node
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBImportingNow\fP"
.br
.ti -1c
.RI "struct \fBCBlockIndexWorkComparator\fP"
.br
.ti -1c
.RI "struct \fBCBlockIndexHeightOnlyComparator\fP"
.br
.ti -1c
.RI "struct \fBPruneLockInfo\fP"
.br
.ti -1c
.RI "struct \fBBlockfileCursor\fP"
.br
.ti -1c
.RI "class \fBBlockManager\fP"
.br
.ti -1c
.RI "struct \fBIndexCacheSizes\fP"
.br
.ti -1c
.RI "struct \fBCacheSizes\fP"
.br
.ti -1c
.RI "struct \fBChainstateLoadOptions\fP"
.br
.ti -1c
.RI "struct \fBNodeContext\fP"
.br
.ti -1c
.RI "class \fBKernelNotifications\fP"
.br
.ti -1c
.RI "struct \fBImportMempoolOptions\fP"
.br
.ti -1c
.RI "struct \fBCBlockTemplate\fP"
.br
.ti -1c
.RI "class \fBBlockAssembler\fP"
.br
.ti -1c
.RI "struct \fBAncestorFeerateComparator\fP"
.br
.ti -1c
.RI "class \fBMiniMinerMempoolEntry\fP"
.br
.ti -1c
.RI "struct \fBIteratorComparator\fP"
.br
.ti -1c
.RI "class \fBMiniMiner\fP"
.br
.ti -1c
.RI "struct \fBPSBTInputAnalysis\fP"
.br
.ti -1c
.RI "struct \fBPSBTAnalysis\fP"
.br
.ti -1c
.RI "struct \fBTxDownloadOptions\fP"
.br
.ti -1c
.RI "struct \fBTxDownloadConnectionInfo\fP"
.br
.ti -1c
.RI "struct \fBPackageToValidate\fP"
.br
.ti -1c
.RI "struct \fBRejectedTxTodo\fP"
.br
.ti -1c
.RI "class \fBTxDownloadManager\fP"
.br
.ti -1c
.RI "class \fBTxDownloadManagerImpl\fP"
.br
.ti -1c
.RI "class \fBTxOrphanageImpl\fP"
.br
.ti -1c
.RI "class \fBTxOrphanage\fP"
.br
.ti -1c
.RI "struct \fBBlockCreateOptions\fP"
.br
.ti -1c
.RI "struct \fBBlockWaitOptions\fP"
.br
.ti -1c
.RI "struct \fBBlockCheckOptions\fP"
.br
.ti -1c
.RI "class \fBSnapshotMetadata\fP"
.br
.ti -1c
.RI "class \fBWarnings\fP"
.br
.RI "Manages warning messages within a node\&. "
.ti -1c
.RI "class \fBCBlockFileInfo\fP"
.br
.ti -1c
.RI "class \fBBlockTreeDB\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBBlockMap\fP = std::unordered_map<\fBuint256\fP, \fBCBlockIndex\fP, \fBBlockHasher\fP>"
.br
.ti -1c
.RI "using \fBChainstateLoadResult\fP = std::tuple<\fBChainstateLoadStatus\fP, \fBbilingual_str\fP>"
.br
.RI "\fBChainstate\fP load status code and optional error string\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBBlockfileType\fP { \fBNORMAL\fP = 0, \fBASSUMED\fP = 1, \fBNUM_TYPES\fP = 2 }"
.br
.ti -1c
.RI "enum class \fBReadRawError\fP { \fBIO\fP, \fBBadPartRange\fP }"
.br
.ti -1c
.RI "enum class \fBChainstateLoadStatus\fP { \fBSUCCESS\fP, \fBFAILURE\fP, \fBFAILURE_FATAL\fP, \fBFAILURE_INCOMPATIBLE_DB\fP, \fBFAILURE_INSUFFICIENT_DBCACHE\fP, \fBINTERRUPTED\fP }"
.br
.ti -1c
.RI "enum class \fBTransactionError\fP { \fBOK\fP, \fBMISSING_INPUTS\fP, \fBALREADY_IN_UTXO_SET\fP, \fBMEMPOOL_REJECTED\fP, \fBMEMPOOL_ERROR\fP, \fBMAX_FEE_EXCEEDED\fP, \fBMAX_BURN_EXCEEDED\fP, \fBINVALID_PACKAGE\fP }"
.br
.ti -1c
.RI "enum class \fBTxBroadcast\fP : uint8_t { \fBMEMPOOL_AND_BROADCAST_TO_ALL\fP, \fBMEMPOOL_NO_BROADCAST\fP }"
.br
.ti -1c
.RI "enum class \fBWarning\fP { \fBCLOCK_OUT_OF_SYNC\fP, \fBPRE_RELEASE_TEST_BUILD\fP, \fBFATAL_INTERNAL_ERROR\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBAbortNode\fP (const std::function< bool()> &shutdown_request, std::atomic< int > &\fBexit_status\fP, const \fBbilingual_str\fP &message, \fBnode::Warnings\fP *warnings)"
.br
.ti -1c
.RI "\fButil::Result\fP< void > \fBApplyArgsManOptions\fP (const \fBArgsManager\fP &\fBargs\fP, \fBBlockManager::Options\fP &opts)"
.br
.ti -1c
.RI "void \fBImportBlocks\fP (\fBChainstateManager\fP &chainman, std::span< const \fBfs::path\fP > import_paths)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBBlockfileType\fP &type)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBBlockfileCursor\fP &cursor)"
.br
.ti -1c
.RI "size_t \fBCalculateDbCacheBytes\fP (const \fBArgsManager\fP &\fBargs\fP)"
.br
.ti -1c
.RI "\fBCacheSizes\fP \fBCalculateCacheSizes\fP (const \fBArgsManager\fP &\fBargs\fP, size_t n_indexes)"
.br
.ti -1c
.RI "void \fBLogOversizedDbCache\fP (const \fBArgsManager\fP &\fBargs\fP) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBShouldWarnOversizedDbCache\fP (size_t dbcache, size_t total_ram) noexcept"
.br
.ti -1c
.RI "\fBChainstateLoadResult\fP \fBLoadChainstate\fP (\fBChainstateManager\fP &chainman, const \fBCacheSizes\fP &cache_sizes, const \fBChainstateLoadOptions\fP &options)"
.br
.ti -1c
.RI "\fBChainstateLoadResult\fP \fBVerifyLoadedChainstate\fP (\fBChainstateManager\fP &chainman, const \fBChainstateLoadOptions\fP &options)"
.br
.ti -1c
.RI "\fBChainstateLoadResult\fP \fBLoadChainstate\fP (\fBChainstateManager\fP &chainman, const \fBkernel::CacheSizes\fP &cache_sizes, const \fBChainstateLoadOptions\fP &options)"
.br
.ti -1c
.RI "\fButil::Result\fP< void > \fBApplyArgsManOptions\fP (const \fBArgsManager\fP &\fBargs\fP, \fBChainstateManager::Options\fP &opts)"
.br
.ti -1c
.RI "void \fBFindCoins\fP (const \fBNodeContext\fP &\fBnode\fP, std::map< \fBCOutPoint\fP, \fBCoin\fP > &coins)"
.br
.ti -1c
.RI "void \fBReadCoinsViewArgs\fP (const \fBArgsManager\fP &\fBargs\fP, \fBCoinsViewOptions\fP &options)"
.br
.ti -1c
.RI "void \fBReadDatabaseArgs\fP (const \fBArgsManager\fP &\fBargs\fP, \fBDBOptions\fP &options)"
.br
.ti -1c
.RI "void \fBReadNotificationArgs\fP (const \fBArgsManager\fP &\fBargs\fP, \fBKernelNotifications\fP &notifications)"
.br
.ti -1c
.RI "bool \fBLoadMempool\fP (\fBCTxMemPool\fP &pool, const \fBfs::path\fP &load_path, \fBChainstate\fP &active_chainstate, \fBImportMempoolOptions\fP &&opts)"
.br
.ti -1c
.RI "bool \fBDumpMempool\fP (const \fBCTxMemPool\fP &pool, const \fBfs::path\fP &dump_path, \fBFopenFn\fP mockable_fopen_function, bool skip_file_commit)"
.br
.ti -1c
.RI "bool \fBShouldPersistMempool\fP (const \fBArgsManager\fP &argsman)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBMempoolPath\fP (const \fBArgsManager\fP &argsman)"
.br
.ti -1c
.RI "int64_t \fBGetMinimumTime\fP (const \fBCBlockIndex\fP *pindexPrev, const int64_t difficulty_adjustment_interval)"
.br
.ti -1c
.RI "int64_t \fBUpdateTime\fP (\fBCBlockHeader\fP *pblock, const \fBConsensus::Params\fP &consensusParams, const \fBCBlockIndex\fP *pindexPrev)"
.br
.ti -1c
.RI "void \fBRegenerateCommitments\fP (\fBCBlock\fP &block, \fBChainstateManager\fP &chainman)"
.br
.ti -1c
.RI "void \fBApplyArgsManOptions\fP (const \fBArgsManager\fP &\fBargs\fP, \fBBlockAssembler::Options\fP &options)"
.br
.ti -1c
.RI "void \fBAddMerkleRootAndCoinbase\fP (\fBCBlock\fP &block, \fBCTransactionRef\fP coinbase, uint32_t version, uint32_t timestamp, uint32_t \fBnonce\fP)"
.br
.ti -1c
.RI "void \fBInterruptWait\fP (\fBKernelNotifications\fP &kernel_notifications, bool &interrupt_wait)"
.br
.ti -1c
.RI "std::unique_ptr< \fBCBlockTemplate\fP > \fBWaitAndCreateNewBlock\fP (\fBChainstateManager\fP &chainman, \fBKernelNotifications\fP &kernel_notifications, \fBCTxMemPool\fP *mempool, const std::unique_ptr< \fBCBlockTemplate\fP > &block_template, const \fBBlockWaitOptions\fP &options, const \fBBlockAssembler::Options\fP &assemble_options, bool &interrupt_wait)"
.br
.ti -1c
.RI "std::optional< \fBBlockRef\fP > \fBGetTip\fP (\fBChainstateManager\fP &chainman)"
.br
.ti -1c
.RI "std::optional< \fBBlockRef\fP > \fBWaitTipChanged\fP (\fBChainstateManager\fP &chainman, \fBKernelNotifications\fP &kernel_notifications, const \fBuint256\fP &current_tip, \fBMillisecondsDouble\fP &timeout)"
.br
.ti -1c
.RI "Minisketch \fBMakeMinisketch32\fP (size_t capacity)"
.br
.ti -1c
.RI "Minisketch \fBMakeMinisketch32FP\fP (size_t max_elements, uint32_t fpbits)"
.br
.ti -1c
.RI "void \fBApplyArgsManOptions\fP (const \fBArgsManager\fP &argsman, \fBPeerManager::Options\fP &options)"
.br
.ti -1c
.RI "\fBPSBTAnalysis\fP \fBAnalyzePSBT\fP (\fBPartiallySignedTransaction\fP psbtx)"
.br
.ti -1c
.RI "\fBTransactionError\fP \fBBroadcastTransaction\fP (\fBNodeContext\fP &\fBnode\fP, const \fBCTransactionRef\fP tx, std::string &err_string, const \fBCAmount\fP &max_tx_fee, \fBTxBroadcast\fP broadcast_method, bool wait_callback)"
.br
.ti -1c
.RI "\fBCTransactionRef\fP \fBGetTransaction\fP (const \fBCBlockIndex\fP *const block_index, const \fBCTxMemPool\fP *const mempool, const \fBTxid\fP &hash, const \fBBlockManager\fP &blockman, \fBuint256\fP &hashBlock)"
.br
.ti -1c
.RI "std::unique_ptr< \fBTxOrphanage\fP > \fBMakeTxOrphanage\fP () noexcept"
.br
.ti -1c
.RI "std::unique_ptr< \fBTxOrphanage\fP > \fBMakeTxOrphanage\fP (\fBTxOrphanage::Count\fP max_global_latency_score, \fBTxOrphanage::Usage\fP reserved_peer_usage) noexcept"
.br
.ti -1c
.RI "bool \fBWriteSnapshotBaseBlockhash\fP (\fBChainstate\fP &snapshot_chainstate)"
.br
.ti -1c
.RI "std::optional< \fBuint256\fP > \fBReadSnapshotBaseBlockhash\fP (\fBfs::path\fP chaindir)"
.br
.ti -1c
.RI "std::optional< \fBfs::path\fP > \fBFindAssumeutxoChainstateDir\fP (const \fBfs::path\fP &data_dir)"
.br
.RI "Return a path to the snapshot-based chainstate dir, if one exists\&. "
.ti -1c
.RI "\fBUniValue\fP \fBGetWarningsForRpc\fP (const \fBWarnings\fP &warnings, bool use_deprecated)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBfs::path\fP \fBSNAPSHOT_BLOCKHASH_FILENAME\fP {'base_blockhash'}"
.br
.ti -1c
.RI "bool \fBWriteSnapshotBaseBlockhash\fP(\fBChainstate\fP &snapshot_chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::optional< \fBuint256\fP > \fBReadSnapshotBaseBlockhash\fP(\fBfs::path\fP chaindir) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(constexpr std::string_vie \fBSNAPSHOT_CHAINSTATE_SUFFIX\fP ) = '_snapshot'"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBBlockMap\fP = std::unordered_map<\fBuint256\fP, \fBCBlockIndex\fP, \fBBlockHasher\fP>"

.SS "using \fBChainstateLoadResult\fP = std::tuple<\fBChainstateLoadStatus\fP, \fBbilingual_str\fP>"

.PP
\fBChainstate\fP load status code and optional error string\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBBlockfileType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BINORMAL \fP
.TP
\f(BIASSUMED \fP
.TP
\f(BINUM_TYPES \fP
.SS "enum class \fBChainstateLoadStatus\fP\fR [strong]\fP"
\fBChainstate\fP load status\&. Simple applications can just check for the success case, and treat other cases as errors\&. More complex applications may want to try reindexing in the generic failure case, and pass an interrupt callback and exit cleanly in the interrupted case\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISUCCESS \fP
.TP
\f(BIFAILURE \fP
Generic failure which reindexing may fix\&. 
.TP
\f(BIFAILURE_FATAL \fP
Fatal error which should not prompt to reindex\&. 
.TP
\f(BIFAILURE_INCOMPATIBLE_DB \fP
.TP
\f(BIFAILURE_INSUFFICIENT_DBCACHE \fP
.TP
\f(BIINTERRUPTED \fP
.SS "enum class \fBReadRawError\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIIO \fP
.TP
\f(BIBadPartRange \fP
.SS "enum class \fBTransactionError\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIOK \fP
No error\&. 
.TP
\f(BIMISSING_INPUTS \fP
.TP
\f(BIALREADY_IN_UTXO_SET \fP
.TP
\f(BIMEMPOOL_REJECTED \fP
.TP
\f(BIMEMPOOL_ERROR \fP
.TP
\f(BIMAX_FEE_EXCEEDED \fP
.TP
\f(BIMAX_BURN_EXCEEDED \fP
.TP
\f(BIINVALID_PACKAGE \fP
.SS "enum class \fBTxBroadcast\fP : uint8_t\fR [strong]\fP"
How to broadcast a local transaction\&. Used to influence \fR\fBBroadcastTransaction()\fP\fP and its callers\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMEMPOOL_AND_BROADCAST_TO_ALL \fP
Add the transaction to the mempool and broadcast to all peers for which tx relay is enabled\&. 
.TP
\f(BIMEMPOOL_NO_BROADCAST \fP
Add the transaction to the mempool, but don't broadcast to anybody\&. 
.SS "enum class \fBWarning\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BICLOCK_OUT_OF_SYNC \fP
.TP
\f(BIPRE_RELEASE_TEST_BUILD \fP
.TP
\f(BIFATAL_INTERNAL_ERROR \fP
.SH "Function Documentation"
.PP 
.SS "void AbortNode (const std::function< bool()> & shutdown_request, std::atomic< int > & exit_status, const \fBbilingual_str\fP & message, \fBnode::Warnings\fP * warnings)"

.SS "void AddMerkleRootAndCoinbase (\fBCBlock\fP & block, \fBCTransactionRef\fP coinbase, uint32_t version, uint32_t timestamp, uint32_t nonce)"

.SS "\fBPSBTAnalysis\fP AnalyzePSBT (\fBPartiallySignedTransaction\fP psbtx)"
Provides helpful miscellaneous information about where a PSBT is in the signing workflow\&.

.PP
\fBParameters\fP
.RS 4
\fIpsbtx\fP the PSBT to analyze 
.RE
.PP
\fBReturns\fP
.RS 4
A \fBPSBTAnalysis\fP with information about the provided PSBT\&. 
.RE
.PP

.SS "void ApplyArgsManOptions (const \fBArgsManager\fP & gArgs, \fBBlockAssembler::Options\fP & options)"
Apply -blockmintxfee and -blockmaxweight options from \fBArgsManager\fP to \fBBlockAssembler\fP options\&. 
.SS "\fButil::Result\fP< void > ApplyArgsManOptions (const \fBArgsManager\fP & args, \fBBlockManager::Options\fP & opts)\fR [nodiscard]\fP"

.SS "\fButil::Result\fP< void > ApplyArgsManOptions (const \fBArgsManager\fP & args, \fBChainstateManager::Options\fP & opts)\fR [nodiscard]\fP"

.SS "void ApplyArgsManOptions (const \fBArgsManager\fP & argsman, \fBPeerManager::Options\fP & options)"

.SS "\fBTransactionError\fP BroadcastTransaction (\fBNodeContext\fP & node, \fBCTransactionRef\fP tx, std::string & err_string, const \fBCAmount\fP & max_tx_fee, \fBTxBroadcast\fP broadcast_method, bool wait_callback)\fR [nodiscard]\fP"
Submit a transaction to the mempool and (optionally) relay it to all P2P peers\&.

.PP
Mempool submission can be synchronous (will await mempool entry notification over the \fBCValidationInterface\fP) or asynchronous (will submit and not wait for notification), depending on the value of wait_callback\&. wait_callback MUST NOT be set while cs_main, cs_mempool or cs_wallet are held to avoid deadlock\&.

.PP
\fBParameters\fP
.RS 4
\fInode\fP reference to node context 
.br
\fItx\fP the transaction to broadcast 
.br
\fIerr_string\fP reference to std::string to fill with error string if available 
.br
\fImax_tx_fee\fP reject txs with fees higher than this (if 0, accept any fee) 
.br
\fIbroadcast_method\fP whether to add the transaction to the mempool and how to broadcast it 
.br
\fIwait_callback\fP wait until callbacks have been processed to avoid stale result due to a sequentially RPC\&. return error 
.RE
.PP

.SS "\fBCacheSizes\fP CalculateCacheSizes (const \fBArgsManager\fP & args, size_t n_indexes)"

.SS "size_t CalculateDbCacheBytes (const \fBArgsManager\fP & args)"

.SS "bool DumpMempool (const \fBCTxMemPool\fP & pool, const \fBfs::path\fP & dump_path, \fBfsbridge::FopenFn\fP mockable_fopen_function = \fR\fBfsbridge::fopen\fP\fP, bool skip_file_commit = \fRfalse\fP)"
Dump the mempool to a file\&. 
.SS "std::optional< \fBfs::path\fP > FindAssumeutxoChainstateDir (const \fBfs::path\fP & data_dir)"

.PP
Return a path to the snapshot-based chainstate dir, if one exists\&. 
.SS "void FindCoins (const \fBnode::NodeContext\fP & node, std::map< \fBCOutPoint\fP, \fBCoin\fP > & coins)"
Look up unspent output information\&. Returns coins in the mempool and in the current chain UTXO set\&. Iterates through all the keys in the map and populates the values\&.

.PP
\fBParameters\fP
.RS 4
\fInode\fP The node context to use for lookup 
.br
\fIcoins\fP map to fill 
.RE
.PP

.SS "int64_t GetMinimumTime (const \fBCBlockIndex\fP * pindexPrev, const int64_t difficulty_adjustment_interval)"
Get the minimum time a miner should use in the next block\&. This always accounts for the BIP94 timewarp rule, so does not necessarily reflect the consensus limit\&. 
.SS "std::optional< \fBBlockRef\fP > GetTip (\fBChainstateManager\fP & chainman)"

.SS "\fBCTransactionRef\fP GetTransaction (const \fBCBlockIndex\fP *const block_index, const \fBCTxMemPool\fP *const mempool, const \fBTxid\fP & hash, const \fBBlockManager\fP & blockman, \fBuint256\fP & hashBlock)"
Return transaction with a given hash\&. If mempool is provided and block_index is not provided, check it first for the tx\&. If -txindex is available, check it next for the tx\&. Finally, if block_index is provided, check for tx by reading entire block from disk\&.

.PP
\fBParameters\fP
.RS 4
\fIblock_index\fP The block to read from disk, or nullptr 
.br
\fImempool\fP If provided, check mempool for tx 
.br
\fIhash\fP The txid 
.br
\fIblockman\fP Used to access and read blocks from disk 
.br
\fIhashBlock\fP The block hash, if the tx was found via -txindex or block_index 
.RE
.PP
\fBReturns\fP
.RS 4
The tx if found, otherwise nullptr 
.RE
.PP

.SS "\fBUniValue\fP GetWarningsForRpc (const \fBWarnings\fP & warnings, bool use_deprecated)"
RPC helper function that wraps warnings\&.GetMessages()\&.

.PP
Returns a \fBUniValue::VSTR\fP with the latest warning if use_deprecated is set to true, or a \fBUniValue::VARR\fP with all warnings otherwise\&. 
.SS "void ImportBlocks (\fBChainstateManager\fP & chainman, std::span< const \fBfs::path\fP > import_paths)"

.SS "void InterruptWait (\fBKernelNotifications\fP & kernel_notifications, bool & interrupt_wait)"

.SS "\fBChainstateLoadResult\fP LoadChainstate (\fBChainstateManager\fP & chainman, const \fBCacheSizes\fP & cache_sizes, const \fBChainstateLoadOptions\fP & options)"

.SS "\fBChainstateLoadResult\fP LoadChainstate (\fBChainstateManager\fP & chainman, const \fBkernel::CacheSizes\fP & cache_sizes, const \fBChainstateLoadOptions\fP & options)"
This sequence can have 4 types of outcomes:

.PP
.IP "1." 4
Success
.IP "2." 4
Shutdown requested
.IP "  \(bu" 4
nothing failed but a shutdown was triggered in the middle of the sequence
.PP

.IP "3." 4
Soft failure
.IP "  \(bu" 4
a failure that might be recovered from with a reindex
.PP

.IP "4." 4
Hard failure
.IP "  \(bu" 4
a failure that definitively cannot be recovered from with a reindex
.PP

.PP

.PP
LoadChainstate returns a (status code, error string) tuple\&. 
.SS "bool LoadMempool (\fBCTxMemPool\fP & pool, const \fBfs::path\fP & load_path, \fBChainstate\fP & active_chainstate, \fBImportMempoolOptions\fP && opts)"
Import the file and attempt to add its contents to the mempool\&. 
.SS "void LogOversizedDbCache (const \fBArgsManager\fP & args)\fR [noexcept]\fP"

.SS "Minisketch MakeMinisketch32 (size_t capacity)"
\fBWrapper\fP around Minisketch::Minisketch(32, implementation, capacity)\&. 
.SS "Minisketch MakeMinisketch32FP (size_t max_elements, uint32_t fpbits)"
\fBWrapper\fP around Minisketch::CreateFP\&. 
.SS "std::unique_ptr< \fBTxOrphanage\fP > MakeTxOrphanage ()\fR [noexcept]\fP"
Create a new \fBTxOrphanage\fP instance 
.SS "std::unique_ptr< \fBTxOrphanage\fP > MakeTxOrphanage (\fBTxOrphanage::Count\fP max_global_latency_score, \fBTxOrphanage::Usage\fP reserved_peer_usage)\fR [noexcept]\fP"

.SS "\fBfs::path\fP MempoolPath (const \fBArgsManager\fP & argsman)"

.SS "std::ostream & operator<< (std::ostream & os, const \fBBlockfileCursor\fP & cursor)"

.SS "std::ostream & operator<< (std::ostream & os, const \fBBlockfileType\fP & type)"

.SS "void ReadCoinsViewArgs (const \fBArgsManager\fP & args, \fBCoinsViewOptions\fP & options)"

.SS "void ReadDatabaseArgs (const \fBArgsManager\fP & args, \fBDBOptions\fP & options)"

.SS "void ReadNotificationArgs (const \fBArgsManager\fP & args, \fBKernelNotifications\fP & notifications)"

.SS "std::optional< \fBuint256\fP > ReadSnapshotBaseBlockhash (\fBfs::path\fP chaindir)"

.SS "void RegenerateCommitments (\fBCBlock\fP & block, \fBChainstateManager\fP & chainman)"
Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed 
.SS "bool ShouldPersistMempool (const \fBArgsManager\fP & argsman)"

.SS "bool ShouldWarnOversizedDbCache (size_t dbcache, size_t total_ram)\fR [constexpr]\fP, \fR [noexcept]\fP"

.SS "int64_t UpdateTime (\fBCBlockHeader\fP * pblock, const \fBConsensus::Params\fP & consensusParams, const \fBCBlockIndex\fP * pindexPrev)"

.SS "\fBChainstateLoadResult\fP VerifyLoadedChainstate (\fBChainstateManager\fP & chainman, const \fBChainstateLoadOptions\fP & options)"

.SS "std::unique_ptr< \fBCBlockTemplate\fP > WaitAndCreateNewBlock (\fBChainstateManager\fP & chainman, \fBKernelNotifications\fP & kernel_notifications, \fBCTxMemPool\fP * mempool, const std::unique_ptr< \fBCBlockTemplate\fP > & block_template, const \fBBlockWaitOptions\fP & options, const \fBBlockAssembler::Options\fP & assemble_options, bool & interrupt_wait)"
Return a new block template when fees rise to a certain threshold or after a new tip; return nullopt if timeout is reached\&. We determine if fees increased compared to the previous template by generating a fresh template\&. There may be more efficient ways to determine how much (approximate) fees for the next block increased, perhaps more so after Cluster Mempool\&.

.PP
We'll also create a new template if the tip changed during this iteration\&.
.SS "std::optional< \fBBlockRef\fP > WaitTipChanged (\fBChainstateManager\fP & chainman, \fBKernelNotifications\fP & kernel_notifications, const \fBuint256\fP & current_tip, \fBMillisecondsDouble\fP & timeout)"

.SS "bool WriteSnapshotBaseBlockhash (\fBChainstate\fP & snapshot_chainstate)"

.SH "Variable Documentation"
.PP 
.SS "const \fBfs::path\fP SNAPSHOT_BLOCKHASH_FILENAME {'base_blockhash'}"
The file in the snapshot chainstate dir which stores the base blockhash\&. This is needed to reconstruct snapshot chainstates on init\&.

.PP
Because we only allow loading a single snapshot at a time, there will only be one chainstate directory with this filename present within it\&. 
.SS "bool \fBWriteSnapshotBaseBlockhash\fP (\fBChainstate\fP& snapshot_chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP( std::optional<\fBuint256\fP> \fBReadSnapshotBaseBlockhash\fP (\fBfs::path\fP chaindir) \fBEXCLUSIVE_LOCKS_REQUIRED\fP( constexpr std::string_vie SNAPSHOT_CHAINSTATE_SUFFIX)  = '_snapshot'\fR [constexpr]\fP"
Write out the blockhash of the snapshot base block that was used to construct this chainstate\&. This value is read in during subsequent initializations and used to reconstruct snapshot-based chainstates\&.

.PP
Read the blockhash of the snapshot base block that was used to construct the chainstate\&.

.PP
Suffix appended to the chainstate (leveldb) dir when created based upon a snapshot\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
