.TH "TxDownloadManagerImpl" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TxDownloadManagerImpl
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <txdownloadman_impl\&.h>\fP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBPeerInfo\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCRollingBloomFilter\fP & \fBRecentRejectsFilter\fP ()"
.br
.ti -1c
.RI "\fBCRollingBloomFilter\fP & \fBRecentRejectsReconsiderableFilter\fP ()"
.br
.ti -1c
.RI "\fBCRollingBloomFilter\fP & \fBRecentConfirmedTransactionsFilter\fP ()"
.br
.ti -1c
.RI "\fBTxDownloadManagerImpl\fP (const \fBTxDownloadOptions\fP &options)"
.br
.ti -1c
.RI "void \fBActiveTipChange\fP ()"
.br
.ti -1c
.RI "void \fBBlockConnected\fP (const std::shared_ptr< const \fBCBlock\fP > &pblock)"
.br
.ti -1c
.RI "void \fBBlockDisconnected\fP ()"
.br
.ti -1c
.RI "bool \fBAlreadyHaveTx\fP (const \fBGenTxid\fP &gtxid, bool include_reconsiderable)"
.br
.ti -1c
.RI "void \fBConnectedPeer\fP (\fBNodeId\fP nodeid, const \fBTxDownloadConnectionInfo\fP &info)"
.br
.ti -1c
.RI "void \fBDisconnectedPeer\fP (\fBNodeId\fP nodeid)"
.br
.ti -1c
.RI "bool \fBAddTxAnnouncement\fP (\fBNodeId\fP peer, const \fBGenTxid\fP &gtxid, std::chrono::microseconds now)"
.br
.ti -1c
.RI "std::vector< \fBGenTxid\fP > \fBGetRequestsToSend\fP (\fBNodeId\fP nodeid, std::chrono::microseconds current_time)"
.br
.ti -1c
.RI "void \fBReceivedNotFound\fP (\fBNodeId\fP nodeid, const std::vector< \fBGenTxid\fP > &gtxids)"
.br
.ti -1c
.RI "std::optional< \fBPackageToValidate\fP > \fBFind1P1CPackage\fP (const \fBCTransactionRef\fP &ptx, \fBNodeId\fP nodeid)"
.br
.ti -1c
.RI "void \fBMempoolAcceptedTx\fP (const \fBCTransactionRef\fP &tx)"
.br
.ti -1c
.RI "\fBRejectedTxTodo\fP \fBMempoolRejectedTx\fP (const \fBCTransactionRef\fP &ptx, const \fBTxValidationState\fP &state, \fBNodeId\fP nodeid, bool first_time_failure)"
.br
.ti -1c
.RI "void \fBMempoolRejectedPackage\fP (const \fBPackage\fP &package)"
.br
.ti -1c
.RI "std::pair< bool, std::optional< \fBPackageToValidate\fP > > \fBReceivedTx\fP (\fBNodeId\fP nodeid, const \fBCTransactionRef\fP &ptx)"
.br
.ti -1c
.RI "bool \fBHaveMoreWork\fP (\fBNodeId\fP nodeid)"
.br
.ti -1c
.RI "\fBCTransactionRef\fP \fBGetTxToReconsider\fP (\fBNodeId\fP nodeid)"
.br
.ti -1c
.RI "void \fBCheckIsEmpty\fP ()"
.br
.ti -1c
.RI "void \fBCheckIsEmpty\fP (\fBNodeId\fP nodeid)"
.br
.ti -1c
.RI "std::vector< \fBTxOrphanage::OrphanInfo\fP > \fBGetOrphanTransactions\fP () const"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBTxDownloadOptions\fP \fBm_opts\fP"
.br
.ti -1c
.RI "std::unique_ptr< \fBTxOrphanage\fP > \fBm_orphanage\fP"
.br
.ti -1c
.RI "\fBTxRequestTracker\fP \fBm_txrequest\fP"
.br
.ti -1c
.RI "std::unique_ptr< \fBCRollingBloomFilter\fP > \fBm_lazy_recent_rejects\fP {nullptr}"
.br
.ti -1c
.RI "std::unique_ptr< \fBCRollingBloomFilter\fP > \fBm_lazy_recent_rejects_reconsiderable\fP {nullptr}"
.br
.ti -1c
.RI "std::unique_ptr< \fBCRollingBloomFilter\fP > \fBm_lazy_recent_confirmed_transactions\fP {nullptr}"
.br
.ti -1c
.RI "std::map< \fBNodeId\fP, \fBPeerInfo\fP > \fBm_peer_info\fP"
.br
.ti -1c
.RI "uint32_t \fBm_num_wtxid_peers\fP {0}"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "std::vector< \fBTxid\fP > \fBGetUniqueParents\fP (const \fBCTransaction\fP &tx)"
.br
.ti -1c
.RI "bool \fBMaybeAddOrphanResolutionCandidate\fP (const std::vector< \fBTxid\fP > &unique_parents, const \fBWtxid\fP &wtxid, \fBNodeId\fP nodeid, std::chrono::microseconds now)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "TxDownloadManagerImpl (const \fBTxDownloadOptions\fP & options)\fR [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void ActiveTipChange ()"

.SS "bool AddTxAnnouncement (\fBNodeId\fP peer, const \fBGenTxid\fP & gtxid, std::chrono::microseconds now)"
Consider adding this tx hash to txrequest\&. Should be called whenever a new inv has been received\&. Also called internally when a transaction is missing parents so that we can request them\&. 
.SS "bool AlreadyHaveTx (const \fBGenTxid\fP & gtxid, bool include_reconsiderable)"
Check whether we already have this gtxid in:
.IP "\(bu" 2
mempool
.IP "\(bu" 2
orphanage
.IP "\(bu" 2
m_recent_rejects
.IP "\(bu" 2
m_recent_rejects_reconsiderable (if include_reconsiderable = true)
.IP "\(bu" 2
m_recent_confirmed_transactions 
.PP

.SS "void BlockConnected (const std::shared_ptr< const \fBCBlock\fP > & pblock)"

.SS "void BlockDisconnected ()"

.SS "void CheckIsEmpty ()"

.SS "void CheckIsEmpty (\fBNodeId\fP nodeid)"

.SS "void ConnectedPeer (\fBNodeId\fP nodeid, const \fBTxDownloadConnectionInfo\fP & info)"

.SS "void DisconnectedPeer (\fBNodeId\fP nodeid)"

.SS "std::optional< \fBPackageToValidate\fP > Find1P1CPackage (const \fBCTransactionRef\fP & ptx, \fBNodeId\fP nodeid)"
Look for a child of this transaction in the orphanage to form a 1-parent-1-child package, skipping any combinations that have already been tried\&. Return the resulting package along with the senders of its respective transactions, or std::nullopt if no package is found\&. 
.SS "std::vector< \fBTxOrphanage::OrphanInfo\fP > GetOrphanTransactions () const"

.SS "std::vector< \fBGenTxid\fP > GetRequestsToSend (\fBNodeId\fP nodeid, std::chrono::microseconds current_time)"
Get getdata requests to send\&. 
.SS "\fBCTransactionRef\fP GetTxToReconsider (\fBNodeId\fP nodeid)"

.SS "std::vector< \fBTxid\fP > GetUniqueParents (const \fBCTransaction\fP & tx)\fR [protected]\fP"
Helper for getting deduplicated vector of Txids in vin\&. 
.SS "bool HaveMoreWork (\fBNodeId\fP nodeid)"

.SS "bool MaybeAddOrphanResolutionCandidate (const std::vector< \fBTxid\fP > & unique_parents, const \fBWtxid\fP & wtxid, \fBNodeId\fP nodeid, std::chrono::microseconds now)\fR [protected]\fP"
If this peer is an orphan resolution candidate for this transaction, treat the unique_parents as announced by this peer; add them as new invs to m_txrequest\&. 
.PP
\fBReturns\fP
.RS 4
whether this transaction was a valid orphan resolution candidate\&. 
.RE
.PP

.SS "void MempoolAcceptedTx (const \fBCTransactionRef\fP & tx)"

.SS "void MempoolRejectedPackage (const \fBPackage\fP & package)"

.SS "\fBnode::RejectedTxTodo\fP MempoolRejectedTx (const \fBCTransactionRef\fP & ptx, const \fBTxValidationState\fP & state, \fBNodeId\fP nodeid, bool first_time_failure)"

.SS "void ReceivedNotFound (\fBNodeId\fP nodeid, const std::vector< \fBGenTxid\fP > & gtxids)"
Marks a tx as ReceivedResponse in txrequest\&. 
.SS "std::pair< bool, std::optional< \fBPackageToValidate\fP > > ReceivedTx (\fBNodeId\fP nodeid, const \fBCTransactionRef\fP & ptx)"

.SS "\fBCRollingBloomFilter\fP & RecentConfirmedTransactionsFilter ()\fR [inline]\fP"

.SS "\fBCRollingBloomFilter\fP & RecentRejectsFilter ()\fR [inline]\fP"

.SS "\fBCRollingBloomFilter\fP & RecentRejectsReconsiderableFilter ()\fR [inline]\fP"

.SH "Field Documentation"
.PP 
.SS "std::unique_ptr<\fBCRollingBloomFilter\fP> m_lazy_recent_confirmed_transactions {nullptr}"

.SS "std::unique_ptr<\fBCRollingBloomFilter\fP> m_lazy_recent_rejects {nullptr}"
Filter for transactions that were recently rejected by the mempool\&. These are not rerequested until the chain tip changes, at which point the entire filter is reset\&.

.PP
Without this filter we'd be re-requesting txs from each of our peers, increasing bandwidth consumption considerably\&. For instance, with 100 peers, half of which relay a tx we don't accept, that might be a 50x bandwidth increase\&. A flooding attacker attempting to roll-over the filter using minimum-sized, 60byte, transactions might manage to send 1000/sec if we have fast peers, so we pick 120,000 to give our peers a two minute window to send invs to us\&.

.PP
Decreasing the false positive rate is fairly cheap, so we pick one in a million to make it highly unlikely for users to have issues with this filter\&.

.PP
We typically only add wtxids to this filter\&. For non-segwit transactions, the txid == wtxid, so this only prevents us from re-downloading non-segwit transactions when communicating with non-wtxidrelay peers -- which is important for avoiding malleation attacks that could otherwise interfere with transaction relay from non-wtxidrelay peers\&. For communicating with wtxidrelay peers, having the reject filter store wtxids is exactly what we want to avoid redownload of a rejected transaction\&.

.PP
In cases where we can tell that a segwit transaction will fail validation no matter the witness, we may add the txid of such transaction to the filter as well\&. This can be helpful when communicating with txid-relay peers or if we were to otherwise fetch a transaction via txid (eg in our orphan handling)\&.

.PP
Memory used: 1\&.3 MB 
.SS "std::unique_ptr<\fBCRollingBloomFilter\fP> m_lazy_recent_rejects_reconsiderable {nullptr}"
Filter for: (1) wtxids of transactions that were recently rejected by the mempool but are eligible for reconsideration if submitted with other transactions\&. (2) packages (see GetPackageHash) we have already rejected before and should not retry\&.

.PP
Similar to m_lazy_recent_rejects, this filter is used to save bandwidth when e\&.g\&. all of our peers have larger mempools and thus lower minimum feerates than us\&.

.PP
When a transaction's error is \fBTxValidationResult::TX_RECONSIDERABLE\fP (in a package or by itself), add its wtxid to this filter\&. When a package fails for any reason, add the combined hash to this filter\&.

.PP
Upon receiving an announcement for a transaction, if it exists in this filter, do not download the txdata\&. When considering packages, if it exists in this filter, drop it\&.

.PP
Reset this filter when the chain tip changes\&.

.PP
Parameters are picked to be the same as m_lazy_recent_rejects, with the same rationale\&. 
.SS "uint32_t m_num_wtxid_peers {0}"
Number of wtxid relay peers we have in m_peer_info\&. 
.SS "\fBTxDownloadOptions\fP m_opts"

.SS "std::unique_ptr<\fBTxOrphanage\fP> m_orphanage"
Manages unvalidated tx data (orphan transactions for which we are downloading ancestors)\&. 
.SS "std::map<\fBNodeId\fP, \fBPeerInfo\fP> m_peer_info"
Information for all of the peers we may download transactions from\&. This is not necessarily all peers we are connected to (no block-relay-only and temporary connections)\&. 
.SS "\fBTxRequestTracker\fP m_txrequest"
Tracks candidates for requesting and downloading transaction data\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
