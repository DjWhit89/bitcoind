.TH "DepGraph< SetType >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DepGraph< SetType >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <cluster_linearize\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDepGraph\fP () noexcept=default"
.br
.ti -1c
.RI "\fBDepGraph\fP (const DepGraph &) noexcept=default"
.br
.ti -1c
.RI "\fBDepGraph\fP (DepGraph &&) noexcept=default"
.br
.ti -1c
.RI "\fBDepGraph\fP & \fBoperator=\fP (const \fBDepGraph\fP &) noexcept=default"
.br
.ti -1c
.RI "\fBDepGraph\fP & \fBoperator=\fP (\fBDepGraph\fP &&) noexcept=default"
.br
.ti -1c
.RI "\fBDepGraph\fP (const DepGraph< SetType > &depgraph, std::span< const \fBDepGraphIndex\fP > mapping, \fBDepGraphIndex\fP pos_range) noexcept"
.br
.ti -1c
.RI "const SetType & \fBPositions\fP () const noexcept"
.br
.ti -1c
.RI "\fBDepGraphIndex\fP \fBPositionRange\fP () const noexcept"
.br
.ti -1c
.RI "auto \fBTxCount\fP () const noexcept"
.br
.ti -1c
.RI "const \fBFeeFrac\fP & \fBFeeRate\fP (\fBDepGraphIndex\fP i) const noexcept"
.br
.ti -1c
.RI "\fBFeeFrac\fP & \fBFeeRate\fP (\fBDepGraphIndex\fP i) noexcept"
.br
.ti -1c
.RI "const SetType & \fBAncestors\fP (\fBDepGraphIndex\fP i) const noexcept"
.br
.ti -1c
.RI "const SetType & \fBDescendants\fP (\fBDepGraphIndex\fP i) const noexcept"
.br
.ti -1c
.RI "\fBDepGraphIndex\fP \fBAddTransaction\fP (const \fBFeeFrac\fP &feefrac) noexcept"
.br
.ti -1c
.RI "void \fBRemoveTransactions\fP (const SetType &del) noexcept"
.br
.ti -1c
.RI "void \fBAddDependencies\fP (const SetType &parents, \fBDepGraphIndex\fP child) noexcept"
.br
.ti -1c
.RI "SetType \fBGetReducedParents\fP (\fBDepGraphIndex\fP i) const noexcept"
.br
.ti -1c
.RI "SetType \fBGetReducedChildren\fP (\fBDepGraphIndex\fP i) const noexcept"
.br
.ti -1c
.RI "\fBFeeFrac\fP \fBFeeRate\fP (const SetType &elems) const noexcept"
.br
.ti -1c
.RI "SetType \fBGetConnectedComponent\fP (const SetType &todo, \fBDepGraphIndex\fP tx) const noexcept"
.br
.ti -1c
.RI "SetType \fBFindConnectedComponent\fP (const SetType &todo) const noexcept"
.br
.ti -1c
.RI "bool \fBIsConnected\fP (const SetType &subset) const noexcept"
.br
.ti -1c
.RI "bool \fBIsConnected\fP () const noexcept"
.br
.ti -1c
.RI "void \fBAppendTopo\fP (std::vector< \fBDepGraphIndex\fP > &list, const SetType &select) const noexcept"
.br
.ti -1c
.RI "bool \fBIsAcyclic\fP () const noexcept"
.br
.ti -1c
.RI "unsigned \fBCountDependencies\fP () const noexcept"
.br
.ti -1c
.RI "void \fBCompact\fP () noexcept"
.br
.ti -1c
.RI "size_t \fBDynamicMemoryUsage\fP () const noexcept"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "bool \fBoperator==\fP (const \fBDepGraph\fP &a, const \fBDepGraph\fP &b) noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename SetType>
.br
class cluster_linearize::DepGraph< SetType >"Data structure that holds a transaction graph's preprocessed data (fee, size, ancestors, descendants)\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename SetType> DepGraph ()\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> DepGraph (const DepGraph< SetType > & )\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> DepGraph (DepGraph< SetType > && )\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> DepGraph (const DepGraph< SetType > & depgraph, std::span< const \fBDepGraphIndex\fP > mapping, \fBDepGraphIndex\fP pos_range)\fR [inline]\fP, \fR [noexcept]\fP"
Construct a \fBDepGraph\fP object given another \fBDepGraph\fP and a mapping from old to new\&.

.PP
\fBParameters\fP
.RS 4
\fIdepgraph\fP The original \fBDepGraph\fP that is being remapped\&.
.br
\fImapping\fP A span such that mapping[i] gives the position in the new \fBDepGraph\fP for position i in the old depgraph\&. Its size must be equal to depgraph\&.PositionRange()\&. The value of mapping[i] is ignored if position i is a hole in depgraph (i\&.e\&., if !depgraph\&.\fBPositions()\fP[i])\&.
.br
\fIpos_range\fP The \fBPositionRange()\fP for the new \fBDepGraph\fP\&. It must equal the largest value in mapping for any used position in depgraph plus 1, or 0 if depgraph\&.TxCount() == 0\&.
.RE
.PP
Complexity: O(N^2) where N=depgraph\&.TxCount()\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename SetType> void AddDependencies (const SetType & parents, \fBDepGraphIndex\fP child)\fR [inline]\fP, \fR [noexcept]\fP"
Modify this transaction graph, adding multiple parents to a specified child\&.

.PP
Complexity: O(N) where N=\fBTxCount()\fP\&. 
.SS "template<typename SetType> \fBDepGraphIndex\fP AddTransaction (const \fBFeeFrac\fP & feefrac)\fR [inline]\fP, \fR [noexcept]\fP"
Add a new unconnected transaction to this transaction graph (in the first available position), and return its \fBDepGraphIndex\fP\&.

.PP
Complexity: O(1) (amortized, due to resizing of backing vector)\&. 
.SS "template<typename SetType> const SetType & Ancestors (\fBDepGraphIndex\fP i) const\fR [inline]\fP, \fR [noexcept]\fP"
Get the ancestors of a given transaction i\&. Complexity: O(1)\&. 
.SS "template<typename SetType> void AppendTopo (std::vector< \fBDepGraphIndex\fP > & list, const SetType & select) const\fR [inline]\fP, \fR [noexcept]\fP"
Append the entries of select to list in a topologically valid order\&.

.PP
Complexity: O(select\&.Count() * log(select\&.Count()))\&. 
.SS "template<typename SetType> void Compact ()\fR [inline]\fP, \fR [noexcept]\fP"
Reduce memory usage if possible\&. No observable effect\&. 
.SS "template<typename SetType> unsigned CountDependencies () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> const SetType & Descendants (\fBDepGraphIndex\fP i) const\fR [inline]\fP, \fR [noexcept]\fP"
Get the descendants of a given transaction i\&. Complexity: O(1)\&. 
.SS "template<typename SetType> size_t DynamicMemoryUsage () const\fR [inline]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> \fBFeeFrac\fP FeeRate (const SetType & elems) const\fR [inline]\fP, \fR [noexcept]\fP"
Compute the aggregate feerate of a set of nodes in this graph\&.

.PP
Complexity: O(N) where N=elems\&.Count()\&. 
.SS "template<typename SetType> const \fBFeeFrac\fP & FeeRate (\fBDepGraphIndex\fP i) const\fR [inline]\fP, \fR [noexcept]\fP"
Get the feerate of a given transaction i\&. Complexity: O(1)\&. 
.SS "template<typename SetType> \fBFeeFrac\fP & FeeRate (\fBDepGraphIndex\fP i)\fR [inline]\fP, \fR [noexcept]\fP"
Get the mutable feerate of a given transaction i\&. Complexity: O(1)\&. 
.SS "template<typename SetType> SetType FindConnectedComponent (const SetType & todo) const\fR [inline]\fP, \fR [noexcept]\fP"
Find some connected component within the subset "todo" of this graph\&.

.PP
Specifically, this finds the connected component which contains the first transaction of todo (if any)\&.

.PP
Complexity: O(ret\&.Count())\&. 
.SS "template<typename SetType> SetType GetConnectedComponent (const SetType & todo, \fBDepGraphIndex\fP tx) const\fR [inline]\fP, \fR [noexcept]\fP"
Get the connected component within the subset "todo" that contains tx (which must be in todo)\&.

.PP
Two transactions are considered connected if they are both in \fRtodo\fP, and one is an ancestor of the other in the entire graph (so not just within \fRtodo\fP), or transitively there is a path of transactions connecting them\&. This does mean that if \fRtodo\fP contains a transaction and a grandparent, but misses the parent, they will still be part of the same component\&.

.PP
Complexity: O(ret\&.Count())\&. 
.SS "template<typename SetType> SetType GetReducedChildren (\fBDepGraphIndex\fP i) const\fR [inline]\fP, \fR [noexcept]\fP"
Compute the (reduced) set of children of node i in this graph\&.

.PP
This returns the minimal subset of the children of i whose descendants together equal all of i's descendants (unless i is part of a cycle of dependencies)\&. Note that \fBDepGraph\fP does not store the set of children; this information is inferred from the descendant sets\&.

.PP
Complexity: O(N) where N=Descendants(i)\&.Count() (which is bounded by \fBTxCount()\fP)\&. 
.SS "template<typename SetType> SetType GetReducedParents (\fBDepGraphIndex\fP i) const\fR [inline]\fP, \fR [noexcept]\fP"
Compute the (reduced) set of parents of node i in this graph\&.

.PP
This returns the minimal subset of the parents of i whose ancestors together equal all of i's ancestors (unless i is part of a cycle of dependencies)\&. Note that \fBDepGraph\fP does not store the set of parents; this information is inferred from the ancestor sets\&.

.PP
Complexity: O(N) where N=Ancestors(i)\&.Count() (which is bounded by \fBTxCount()\fP)\&. 
.SS "template<typename SetType> bool IsAcyclic () const\fR [inline]\fP, \fR [noexcept]\fP"
Check if this graph is acyclic\&. 
.SS "template<typename SetType> bool IsConnected () const\fR [inline]\fP, \fR [noexcept]\fP"
Determine if this entire graph is connected\&.

.PP
Complexity: O(TxCount())\&. 
.SS "template<typename SetType> bool IsConnected (const SetType & subset) const\fR [inline]\fP, \fR [noexcept]\fP"
Determine if a subset is connected\&.

.PP
Complexity: O(subset\&.Count())\&. 
.SS "template<typename SetType> \fBDepGraph\fP & operator= (const \fBDepGraph\fP< SetType > & )\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> \fBDepGraph\fP & operator= (\fBDepGraph\fP< SetType > && )\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<typename SetType> \fBDepGraphIndex\fP PositionRange () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the range of positions in this \fBDepGraph\fP\&. All entries in \fBPositions()\fP are in [0, \fBPositionRange()\fP - 1]\&. 
.SS "template<typename SetType> const SetType & Positions () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the set of transactions positions in use\&. Complexity: O(1)\&. 
.SS "template<typename SetType> void RemoveTransactions (const SetType & del)\fR [inline]\fP, \fR [noexcept]\fP"
Remove the specified positions from this \fBDepGraph\fP\&.

.PP
The specified positions will no longer be part of \fBPositions()\fP, and dependencies with them are removed\&. Note that due to \fBDepGraph\fP only tracking ancestors/descendants (and not direct dependencies), if a parent is removed while a grandparent remains, the grandparent will remain an ancestor\&.

.PP
Complexity: O(N) where N=\fBTxCount()\fP\&. 
.SS "template<typename SetType> auto TxCount () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the number of transactions in the graph\&. Complexity: O(1)\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<typename SetType> bool operator== (const \fBDepGraph\fP< SetType > & a, const \fBDepGraph\fP< SetType > & b)\fR [friend]\fP"
Equality operator (primarily for testing purposes)\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
