.TH "CCoinsViewCache" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CCoinsViewCache
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <coins\&.h>\fP
.PP
Inherits \fBCCoinsViewBacked\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCCoinsViewCache\fP (\fBCCoinsView\fP *baseIn, bool deterministic=false)"
.br
.ti -1c
.RI "\fBCCoinsViewCache\fP (const \fBCCoinsViewCache\fP &)=delete"
.br
.ti -1c
.RI "std::optional< \fBCoin\fP > \fBGetCoin\fP (const \fBCOutPoint\fP &outpoint) const override"
.br
.RI "Retrieve the \fBCoin\fP (unspent transaction output) for a given outpoint\&. "
.ti -1c
.RI "bool \fBHaveCoin\fP (const \fBCOutPoint\fP &outpoint) const override"
.br
.RI "Just check whether a given outpoint is unspent\&. "
.ti -1c
.RI "\fBuint256\fP \fBGetBestBlock\fP () const override"
.br
.RI "Retrieve the block hash whose state this \fBCCoinsView\fP currently represents\&. "
.ti -1c
.RI "void \fBSetBestBlock\fP (const \fBuint256\fP &\fBhashBlock\fP)"
.br
.ti -1c
.RI "bool \fBBatchWrite\fP (\fBCoinsViewCacheCursor\fP &cursor, const \fBuint256\fP &\fBhashBlock\fP) override"
.br
.ti -1c
.RI "std::unique_ptr< \fBCCoinsViewCursor\fP > \fBCursor\fP () const override"
.br
.RI "Get a cursor to iterate over the whole state\&. "
.ti -1c
.RI "bool \fBHaveCoinInCache\fP (const \fBCOutPoint\fP &outpoint) const"
.br
.ti -1c
.RI "const \fBCoin\fP & \fBAccessCoin\fP (const \fBCOutPoint\fP &output) const"
.br
.ti -1c
.RI "void \fBAddCoin\fP (const \fBCOutPoint\fP &outpoint, \fBCoin\fP &&coin, bool possible_overwrite)"
.br
.ti -1c
.RI "void \fBEmplaceCoinInternalDANGER\fP (\fBCOutPoint\fP &&outpoint, \fBCoin\fP &&coin)"
.br
.ti -1c
.RI "bool \fBSpendCoin\fP (const \fBCOutPoint\fP &outpoint, \fBCoin\fP *moveto=nullptr)"
.br
.ti -1c
.RI "bool \fBFlush\fP (bool will_reuse_cache=true)"
.br
.ti -1c
.RI "bool \fBSync\fP ()"
.br
.ti -1c
.RI "void \fBUncache\fP (const \fBCOutPoint\fP &outpoint)"
.br
.ti -1c
.RI "unsigned int \fBGetCacheSize\fP () const"
.br
.RI "Calculate the size of the cache (in number of transaction outputs)\&. "
.ti -1c
.RI "size_t \fBDynamicMemoryUsage\fP () const"
.br
.RI "Calculate the size of the cache (in bytes)\&. "
.ti -1c
.RI "bool \fBHaveInputs\fP (const \fBCTransaction\fP &tx) const"
.br
.RI "Check whether all prevouts of the transaction are present in the UTXO set represented by this view\&. "
.ti -1c
.RI "void \fBReallocateCache\fP ()"
.br
.ti -1c
.RI "void \fBSanityCheck\fP () const"
.br
.RI "Run an internal sanity check on the cache data structure\&. */\&. "
.in -1c

Public Member Functions inherited from \fBCCoinsViewBacked\fP
.in +1c
.ti -1c
.RI "\fBCCoinsViewBacked\fP (\fBCCoinsView\fP *viewIn)"
.br
.ti -1c
.RI "std::vector< \fBuint256\fP > \fBGetHeadBlocks\fP () const override"
.br
.ti -1c
.RI "void \fBSetBackend\fP (\fBCCoinsView\fP &viewIn)"
.br
.ti -1c
.RI "size_t \fBEstimateSize\fP () const override"
.br
.RI "Estimate database size (0 if not implemented)\&. "
.in -1c

Public Member Functions inherited from \fBCCoinsView\fP
.in +1c
.ti -1c
.RI "virtual \fB~CCoinsView\fP ()=default"
.br
.RI "As we use CCoinsViews polymorphically, have a virtual destructor\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBuint256\fP \fBhashBlock\fP"
.br
.ti -1c
.RI "\fBCCoinsMapMemoryResource\fP \fBm_cache_coins_memory_resource\fP {}"
.br
.ti -1c
.RI "\fBCoinsCachePair\fP \fBm_sentinel\fP"
.br
.ti -1c
.RI "\fBCCoinsMap\fP \fBcacheCoins\fP"
.br
.ti -1c
.RI "size_t \fBcachedCoinsUsage\fP {0}"
.br
.in -1c

Protected Attributes inherited from \fBCCoinsViewBacked\fP
.in +1c
.ti -1c
.RI "\fBCCoinsView\fP * \fBbase\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBCCoinsView\fP that adds a memory cache for transactions to another \fBCCoinsView\fP 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCCoinsViewCache\fP (\fBCCoinsView\fP * baseIn, bool deterministic = \fRfalse\fP)"

.SS "\fBCCoinsViewCache\fP (const \fBCCoinsViewCache\fP & )\fR [delete]\fP"
By deleting the copy constructor, we prevent accidentally using it when one intends to create a cache on top of a base cache\&. 
.SH "Member Function Documentation"
.PP 
.SS "const \fBCoin\fP & AccessCoin (const \fBCOutPoint\fP & output) const"
Return a reference to \fBCoin\fP in the cache, or coinEmpty if not found\&. This is more efficient than GetCoin\&.

.PP
Generally, do not hold the reference returned for more than a short scope\&. While the current implementation allows for modifications to the contents of the cache while holding the reference, this behavior should not be relied on! To be safe, best to not hold the returned reference through any other calls to this cache\&. 
.SS "void AddCoin (const \fBCOutPoint\fP & outpoint, \fBCoin\fP && coin, bool possible_overwrite)"
Add a coin\&. Set possible_overwrite to true if an unspent version may already exist in the cache\&. 
.SS "bool BatchWrite (\fBCoinsViewCacheCursor\fP & cursor, const \fBuint256\fP & hashBlock)\fR [override]\fP, \fR [virtual]\fP"
Do a bulk modification (multiple \fBCoin\fP changes + BestBlock change)\&. The passed cursor is used to iterate through the coins\&. 
.PP
Reimplemented from \fBCCoinsViewBacked\fP\&.
.SS "std::unique_ptr< \fBCCoinsViewCursor\fP > Cursor () const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
Get a cursor to iterate over the whole state\&. 
.PP
Reimplemented from \fBCCoinsViewBacked\fP\&.
.SS "size_t DynamicMemoryUsage () const"

.PP
Calculate the size of the cache (in bytes)\&. 
.SS "void EmplaceCoinInternalDANGER (\fBCOutPoint\fP && outpoint, \fBCoin\fP && coin)"
Emplace a coin into cacheCoins without performing any checks, marking the emplaced coin as dirty\&.

.PP
NOT FOR GENERAL USE\&. Used only when loading coins from a UTXO snapshot\&. 
.PP
\fBSee also\fP
.RS 4
ChainstateManager::PopulateAndValidateSnapshot() 
.RE
.PP

.SS "bool Flush (bool will_reuse_cache = \fRtrue\fP)"
Push the modifications applied to this cache to its base and wipe local state\&. Failure to call this method or \fBSync()\fP before destruction will cause the changes to be forgotten\&. If will_reuse_cache is false, the cache will retain the same memory footprint after flushing and should be destroyed to deallocate\&. If false is returned, the state of this cache (and its backing view) will be undefined\&. 
.SS "\fBuint256\fP GetBestBlock () const\fR [override]\fP, \fR [virtual]\fP"

.PP
Retrieve the block hash whose state this \fBCCoinsView\fP currently represents\&. 
.PP
Reimplemented from \fBCCoinsViewBacked\fP\&.
.SS "unsigned int GetCacheSize () const"

.PP
Calculate the size of the cache (in number of transaction outputs)\&. 
.SS "std::optional< \fBCoin\fP > GetCoin (const \fBCOutPoint\fP & outpoint) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Retrieve the \fBCoin\fP (unspent transaction output) for a given outpoint\&. 
.PP
Reimplemented from \fBCCoinsViewBacked\fP\&.
.SS "bool HaveCoin (const \fBCOutPoint\fP & outpoint) const\fR [override]\fP, \fR [virtual]\fP"

.PP
Just check whether a given outpoint is unspent\&. 
.PP
Reimplemented from \fBCCoinsViewBacked\fP\&.
.SS "bool HaveCoinInCache (const \fBCOutPoint\fP & outpoint) const"
Check if we have the given utxo already loaded in this cache\&. The semantics are the same as \fBHaveCoin()\fP, but no calls to the backing \fBCCoinsView\fP are made\&. 
.SS "bool HaveInputs (const \fBCTransaction\fP & tx) const"

.PP
Check whether all prevouts of the transaction are present in the UTXO set represented by this view\&. 
.SS "void ReallocateCache ()"
Force a reallocation of the cache map\&. This is required when downsizing the cache because the map's allocator may be hanging onto a lot of memory despite having called \&.\fBclear()\fP\&.

.PP
See: https://stackoverflow.com/questions/42114044/how-to-release-unordered-map-memory 
.SS "void SanityCheck () const"

.PP
Run an internal sanity check on the cache data structure\&. */\&. 
.SS "void SetBestBlock (const \fBuint256\fP & hashBlock)"

.SS "bool SpendCoin (const \fBCOutPoint\fP & outpoint, \fBCoin\fP * moveto = \fRnullptr\fP)"
Spend a coin\&. Pass moveto in order to get the deleted data\&. If no unspent output exists for the passed outpoint, this call has no effect\&. 
.SS "bool Sync ()"
Push the modifications applied to this cache to its base while retaining the contents of this cache (except for spent coins, which we erase)\&. Failure to call this method or \fBFlush()\fP before destruction will cause the changes to be forgotten\&. If false is returned, the state of this cache (and its backing view) will be undefined\&. 
.SS "void Uncache (const \fBCOutPoint\fP & outpoint)"
Removes the UTXO with the given outpoint from the cache, if it is not modified\&. 
.SH "Field Documentation"
.PP 
.SS "\fBCCoinsMap\fP cacheCoins\fR [mutable]\fP, \fR [protected]\fP"

.SS "size_t cachedCoinsUsage {0}\fR [mutable]\fP, \fR [protected]\fP"

.SS "\fBuint256\fP hashBlock\fR [mutable]\fP, \fR [protected]\fP"
Make mutable so that we can "fill the cache" even from Get-methods declared as "const"\&. 
.SS "\fBCCoinsMapMemoryResource\fP m_cache_coins_memory_resource {}\fR [mutable]\fP, \fR [protected]\fP"

.SS "\fBCoinsCachePair\fP m_sentinel\fR [mutable]\fP, \fR [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
