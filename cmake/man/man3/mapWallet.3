.TH "mapWallet" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mapWallet \- MapWallet
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "const \fBCWalletTx\fP * \fBGetWalletTx\fP (const \fBTxid\fP &hash) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "void \fBUpgradeDescriptorCache\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.RI "Upgrade DescriptorCaches\&. "
.ti -1c
.RI "bool \fBUnlock\fP (const \fBSecureString\fP &strWalletPassphrase)"
.br
.ti -1c
.RI "bool \fBChangeWalletPassphrase\fP (const \fBSecureString\fP &strOldWalletPassphrase, const \fBSecureString\fP &strNewWalletPassphrase)"
.br
.ti -1c
.RI "void \fBSetLastBlockProcessed\fP (int block_height, \fBuint256\fP block_hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "std::set< \fBTxid\fP > \fBGetConflicts\fP (const \fBTxid\fP &txid) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.RI "Get wallet transactions that conflict with given transaction (spend same outputs)\&. "
.ti -1c
.RI "bool \fBHasWalletSpend\fP (const \fBCTransactionRef\fP &tx) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.RI "Check if a given transaction has any of its outputs spent by another transaction in the wallet\&. "
.ti -1c
.RI "void \fBClose\fP ()"
.br
.RI "Close wallet database\&. "
.ti -1c
.RI "bool \fBIsSpent\fP (const \fBCOutPoint\fP &outpoint) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBEncryptWallet\fP (const \fBSecureString\fP &strWalletPassphrase)"
.br
.ti -1c
.RI "\fBDBErrors\fP \fBReorderTransactions\fP ()"
.br
.ti -1c
.RI "int64_t \fBIncOrderPosNext\fP (\fBWalletBatch\fP *batch=nullptr) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "void \fBMarkDirty\fP ()"
.br
.ti -1c
.RI "bool \fBMarkReplaced\fP (const \fBTxid\fP &originalHash, const \fBTxid\fP &newHash)"
.br
.ti -1c
.RI "void \fBSetSpentKeyState\fP (\fBWalletBatch\fP &batch, const \fBTxid\fP &hash, unsigned int n, bool used, std::set< \fBCTxDestination\fP > &tx_destinations) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBIsSpentKey\fP (const \fBCScript\fP &scriptPubKey) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "\fBCWalletTx\fP * \fBAddToWallet\fP (\fBCTransactionRef\fP tx, const \fBTxState\fP &state, const \fBUpdateWalletTxFn\fP &update_wtx=nullptr, bool rescanning_old_block=false)"
.br
.ti -1c
.RI "bool \fBLoadToWallet\fP (const \fBTxid\fP &hash, const \fBUpdateWalletTxFn\fP &fill_wtx) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBTransactionCanBeAbandoned\fP (const \fBTxid\fP &hashTx) const"
.br
.ti -1c
.RI "bool \fBAbandonTransaction\fP (const \fBTxid\fP &hashTx)"
.br
.ti -1c
.RI "bool \fBAbandonTransaction\fP (\fBCWalletTx\fP &tx) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "void \fBtransactionAddedToMempool\fP (const \fBCTransactionRef\fP &tx) override"
.br
.ti -1c
.RI "void \fBtransactionRemovedFromMempool\fP (const \fBCTransactionRef\fP &tx, \fBMemPoolRemovalReason\fP reason) override"
.br
.ti -1c
.RI "void \fBblockConnected\fP (const \fBkernel::ChainstateRole\fP &role, const \fBinterfaces::BlockInfo\fP &block) override"
.br
.ti -1c
.RI "void \fBblockDisconnected\fP (const \fBinterfaces::BlockInfo\fP &block) override"
.br
.ti -1c
.RI "void \fBupdatedBlockTip\fP () override"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetDebit\fP (const \fBCTxIn\fP &txin) const"
.br
.ti -1c
.RI "bool \fBIsMine\fP (const \fBCTxOut\fP &txout) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBIsMine\fP (const \fBCTxDestination\fP &dest) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBIsMine\fP (const \fBCScript\fP &\fBscript\fP) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBIsMine\fP (const \fBCTransaction\fP &tx) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBIsMine\fP (const \fBCOutPoint\fP &outpoint) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBIsFromMe\fP (const \fBCTransaction\fP &tx) const"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetDebit\fP (const \fBCTransaction\fP &tx) const"
.br
.ti -1c
.RI "bool \fBIsHDEnabled\fP () const"
.br
.ti -1c
.RI "bool \fBCanGetAddresses\fP (bool internal=false) const"
.br
.ti -1c
.RI "void BlockUntilSyncedToCurrentChain() const \fBLOCKS_EXCLUDED\fP(void \fBSetWalletFlag\fP (uint64_t \fBflags\fP)"
.br
.ti -1c
.RI "void \fBUnsetWalletFlag\fP (uint64_t flag)"
.br
.ti -1c
.RI "bool \fBIsWalletFlagSet\fP (uint64_t flag) const override"
.br
.ti -1c
.RI "bool \fBLoadWalletFlags\fP (uint64_t \fBflags\fP)"
.br
.ti -1c
.RI "void \fBInitWalletFlags\fP (uint64_t \fBflags\fP)"
.br
.ti -1c
.RI "uint64_t \fBGetWalletFlags\fP () const"
.br
.RI "Retrieve all of the wallet's flags\&. "
.ti -1c
.RI "void \fBMaybeUpdateBirthTime\fP (int64_t time)"
.br
.ti -1c
.RI "int64_t \fBRescanFromTime\fP (int64_t startTime, const \fBWalletRescanReserver\fP &reserver, bool update)"
.br
.ti -1c
.RI "\fBScanResult\fP \fBScanForWalletTransactions\fP (const \fBuint256\fP &start_block, int start_height, std::optional< int > max_height, const \fBWalletRescanReserver\fP &reserver, bool fUpdate, const bool save_progress)"
.br
.ti -1c
.RI "bool \fBSubmitTxMemoryPoolAndRelay\fP (\fBCWalletTx\fP &wtx, std::string &err_string, \fBnode::TxBroadcast\fP broadcast_method) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "std::set< \fBTxid\fP > \fBGetTxConflicts\fP (const \fBCWalletTx\fP &wtx) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_wallet\fP)"
.br
.ti -1c
.RI "bool \fBShouldResend\fP () const"
.br
.ti -1c
.RI "void \fBResubmitWalletTransactions\fP (\fBnode::TxBroadcast\fP broadcast_method, bool force)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "Function Documentation"
.PP 
.SS "bool AbandonTransaction (const \fBTxid\fP & hashTx)"

.SS "bool AbandonTransaction (\fBCWalletTx\fP & tx)"

.SS "\fBCWalletTx\fP * AddToWallet (\fBCTransactionRef\fP tx, const \fBTxState\fP & state, const \fBUpdateWalletTxFn\fP & update_wtx = \fRnullptr\fP, bool rescanning_old_block = \fRfalse\fP)"
Add the transaction to the wallet, wrapping it up inside a \fBCWalletTx\fP 
.PP
\fBReturns\fP
.RS 4
the recently added wtx pointer or nullptr if there was a db write error\&. 
.RE
.PP

.SS "void blockConnected (const \fBkernel::ChainstateRole\fP & role, const \fBinterfaces::BlockInfo\fP & block)\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBChain::Notifications\fP\&.
.SS "void blockDisconnected (const \fBinterfaces::BlockInfo\fP & block)\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBChain::Notifications\fP\&.
.SS "bool CanGetAddresses (bool internal = \fRfalse\fP) const"

.SS "bool ChangeWalletPassphrase (const \fBSecureString\fP & strOldWalletPassphrase, const \fBSecureString\fP & strNewWalletPassphrase)"

.SS "void Close ()"

.PP
Close wallet database\&. 
.SS "bool EncryptWallet (const \fBSecureString\fP & strWalletPassphrase)"

.SS "std::set< \fBTxid\fP > GetConflicts (const \fBTxid\fP & txid) const"

.PP
Get wallet transactions that conflict with given transaction (spend same outputs)\&. 
.SS "\fBCAmount\fP GetDebit (const \fBCTransaction\fP & tx) const"

.SS "\fBCAmount\fP GetDebit (const \fBCTxIn\fP & txin) const"
Returns amount of debit, i\&.e\&. the amount leaving this wallet due to this input 
.SS "std::set< \fBTxid\fP > GetTxConflicts (const \fBCWalletTx\fP & wtx) const"

.SS "uint64_t GetWalletFlags () const"

.PP
Retrieve all of the wallet's flags\&. 
.SS "const \fBCWalletTx\fP * GetWalletTx (const \fBTxid\fP & hash) const"

.SS "bool HasWalletSpend (const \fBCTransactionRef\fP & tx) const"

.PP
Check if a given transaction has any of its outputs spent by another transaction in the wallet\&. 
.SS "int64_t IncOrderPosNext (\fBWalletBatch\fP * batch = \fRnullptr\fP)"
Increment the next transaction order id 
.PP
\fBReturns\fP
.RS 4
next transaction order id 
.RE
.PP

.SS "void InitWalletFlags (uint64_t flags)"
overwrite all flags by the given uint64_t flags must be uninitialised (or 0) only known flags may be present 
.SS "bool IsFromMe (const \fBCTransaction\fP & tx) const"
should probably be renamed to IsRelevantToMe 
.SS "bool IsHDEnabled () const"

.SS "bool IsMine (const \fBCOutPoint\fP & outpoint) const"

.SS "bool IsMine (const \fBCScript\fP & script) const"

.SS "bool IsMine (const \fBCTransaction\fP & tx) const"

.SS "bool IsMine (const \fBCTxDestination\fP & dest) const"

.SS "bool IsMine (const \fBCTxOut\fP & txout) const"

.SS "bool IsSpent (const \fBCOutPoint\fP & outpoint) const"
Outpoint is spent if any non-conflicted transaction spends it: 
.SS "bool IsSpentKey (const \fBCScript\fP & scriptPubKey) const"

.SS "bool IsWalletFlagSet (uint64_t flag) const\fR [override]\fP, \fR [virtual]\fP"
check if a certain wallet flag is set 
.PP
Implements \fBWalletStorage\fP\&.
.SS "bool LoadToWallet (const \fBTxid\fP & hash, const \fBUpdateWalletTxFn\fP & fill_wtx)"

.SS "bool LoadWalletFlags (uint64_t flags)"
Loads the flags into the wallet\&. (used by LoadWallet) 
.SS "void MarkDirty ()"

.SS "bool MarkReplaced (const \fBTxid\fP & originalHash, const \fBTxid\fP & newHash)"
Mark a transaction as replaced by another transaction\&. 
.SS "void MaybeUpdateBirthTime (int64_t time)"
Updates wallet birth time if 'time' is below it 
.SS "\fBDBErrors\fP ReorderTransactions ()"

.SS "int64_t RescanFromTime (int64_t startTime, const \fBWalletRescanReserver\fP & reserver, bool update)"
Scan active chain for relevant transactions after importing keys\&. This should be called whenever new keys are added to the wallet, with the oldest key creation time\&.

.PP
\fBReturns\fP
.RS 4
Earliest timestamp that could be successfully scanned from\&. Timestamp returned will be higher than startTime if relevant blocks could not be read\&. 
.RE
.PP

.SS "void ResubmitWalletTransactions (\fBnode::TxBroadcast\fP broadcast_method, bool force)"

.SS "\fBCWallet::ScanResult\fP ScanForWalletTransactions (const \fBuint256\fP & start_block, int start_height, std::optional< int > max_height, const \fBWalletRescanReserver\fP & reserver, bool fUpdate, const bool save_progress)"
Scan the block chain (starting in start_block) for transactions from or to us\&. If fUpdate is true, found transactions that already exist in the wallet will be updated\&. If max_height is not set, the mempool will be scanned as well\&.

.PP
\fBParameters\fP
.RS 4
\fIstart_block\fP Scan starting block\&. If block is not on the active chain, the scan will return SUCCESS immediately\&. 
.br
\fIstart_height\fP Height of start_block 
.br
\fImax_height\fP Optional max scanning height\&. If unset there is no maximum and scanning can continue to the tip
.RE
.PP
\fBReturns\fP
.RS 4
\fBScanResult\fP returning scan information and indicating success or failure\&. Return status will be set to SUCCESS if scan was successful\&. FAILURE if a complete rescan was not possible (due to pruning or corruption)\&. USER_ABORT if the rescan was aborted before it could complete\&.
.RE
.PP
\fBPrecondition\fP
.RS 4
Caller needs to make sure start_block (and the optional stop_block) are on the main chain after to the addition of any new keys you want to detect transactions for\&. 
.RE
.PP

.SS "void SetLastBlockProcessed (int block_height, \fBuint256\fP block_hash)"
Set last block processed height, and write to database 
.SS "void SetSpentKeyState (\fBWalletBatch\fP & batch, const \fBTxid\fP & hash, unsigned int n, bool used, std::set< \fBCTxDestination\fP > & tx_destinations)"

.SS "void SetWalletFlag (uint64_t flags)"
Blocks until the wallet state is up-to-date to /at least/ the current chain at the time this function is entered Obviously holding cs_main/cs_wallet when going into this call may cause deadlock set a single wallet flag 
.SS "bool ShouldResend () const"
Return true if all conditions for periodically resending transactions are met\&. 
.SS "bool SubmitTxMemoryPoolAndRelay (\fBCWalletTx\fP & wtx, std::string & err_string, \fBnode::TxBroadcast\fP broadcast_method) const"
Pass this transaction to node for optional mempool insertion and relay to peers\&. 
.SS "void transactionAddedToMempool (const \fBCTransactionRef\fP & tx)\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBChain::Notifications\fP\&.
.SS "bool TransactionCanBeAbandoned (const \fBTxid\fP & hashTx) const"
Return whether transaction can be abandoned 
.SS "void transactionRemovedFromMempool (const \fBCTransactionRef\fP & tx, \fBMemPoolRemovalReason\fP reason)\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBChain::Notifications\fP\&.
.SS "bool Unlock (const \fBSecureString\fP & strWalletPassphrase)"

.SS "void UnsetWalletFlag (uint64_t flag)"
Unsets a single wallet flag 
.SS "void updatedBlockTip ()\fR [override]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBChain::Notifications\fP\&.
.SS "void UpgradeDescriptorCache ()"

.PP
Upgrade DescriptorCaches\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
