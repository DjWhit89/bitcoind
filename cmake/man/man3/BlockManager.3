.TH "BlockManager" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BlockManager
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <blockstorage\&.h>\fP
.PP
Inherited by \fBTestBlockManager\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBOptions\fP = \fBkernel::BlockManagerOpts\fP"
.br
.ti -1c
.RI "using \fBReadRawBlockResult\fP = \fButil::Expected\fP<std::vector<std::byte>, ReadRawError>"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBlockMap\fP m_block_index \fBGUARDED_BY\fP (\fBcs_main\fP)"
.br
.ti -1c
.RI "std::unique_ptr< \fBBlockTreeDB\fP > m_block_tree_db \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "\fBBlockManager\fP (const \fButil::SignalInterrupt\fP &interrupt, \fBOptions\fP\fBOptions\fP opts)"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBInsertBlockIndex\fP (const \fBuint256\fP &hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBPruneOneBlockFile\fP (const int fileNumber) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.RI "Mark one block file as pruned (modify associated database entries)\&. "
.ti -1c
.RI "\fBCBlockIndex\fP * \fBLookupBlockIndex\fP (const \fBuint256\fP &hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "const \fBCBlockIndex\fP * \fBLookupBlockIndex\fP (const \fBuint256\fP &hash) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCBlockFileInfo\fP * \fBGetBlockFileInfo\fP (size_t n)"
.br
.ti -1c
.RI "void \fBUpdateBlockInfo\fP (const \fBCBlock\fP &block, unsigned int \fBnHeight\fP, const \fBFlatFilePos\fP &pos)"
.br
.ti -1c
.RI "bool \fBIsPruneMode\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetPruneTarget\fP () const"
.br
.ti -1c
.RI "bool \fBLoadingBlocks\fP () const"
.br
.ti -1c
.RI "uint64_t \fBCalculateCurrentUsage\fP ()"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetBlockPosFilename\fP (const \fBFlatFilePos\fP &pos) const"
.br
.ti -1c
.RI "void \fBUnlinkPrunedFiles\fP (const std::set< int > &setFilesToPrune) const"
.br
.ti -1c
.RI "bool \fBReadBlock\fP (\fBCBlock\fP &block, const \fBFlatFilePos\fP &pos, const std::optional< \fBuint256\fP > &expected_hash) const"
.br
.ti -1c
.RI "bool \fBReadBlock\fP (\fBCBlock\fP &block, const \fBCBlockIndex\fP &index) const"
.br
.ti -1c
.RI "\fBReadRawBlockResult\fP \fBReadRawBlock\fP (const \fBFlatFilePos\fP &pos, std::optional< std::pair< size_t, size_t > > block_part=std::nullopt) const"
.br
.ti -1c
.RI "bool \fBReadBlockUndo\fP (\fBCBlockUndo\fP &blockundo, const \fBCBlockIndex\fP &index) const"
.br
.ti -1c
.RI "void \fBCleanupBlockRevFiles\fP () const"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "const \fButil::SignalInterrupt\fP & \fBm_interrupt\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fBm_importing\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBm_blockfiles_indexed\fP {true}"
.br
.ti -1c
.RI "std::optional< int > \fBm_snapshot_height\fP"
.br
.ti -1c
.RI "std::vector< \fBCBlockIndex\fP * > GetAllBlockIndices() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::multimap< \fBCBlockIndex\fP *, \fBCBlockIndex\fP * > \fBm_blocks_unlinked\fP"
.br
.ti -1c
.RI "void WriteBlockIndexDB() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool LoadBlockIndexDB(const std::optional< \fBuint256\fP > &snapshot_blockhash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void ScanAndUnlinkAlreadyPrunedFiles() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCBlockIndex\fP \fBAddToBlockIndex\fP )(const \fBCBlockHeader\fP &block, \fBCBlockIndex\fP *&best_header) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool WriteBlockUndo(const \fBCBlockUndo\fP &blockundo, \fBBlockValidationState\fP &state, \fBCBlockIndex\fP &block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(FlatFilePo \fBWriteBlock\fP )(const \fBCBlock\fP &block, int \fBnHeight\fP)"
.br
.ti -1c
.RI "bool \fBCheckBlockDataAvailability\fP(const \fBCBlockIndex\fP &upper_block, const \fBCBlockIndex\fP &lower_block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP &GetFirstBlock(const \fBCBlockIndex\fP &upper_block \fBLIFETIMEBOUND\fP, uint32_t status_mask, const \fBCBlockIndex\fP *lower_block \fBLIFETIMEBOUND\fP=nullptr) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo \fBm_have_pruned\fP ) = false"
.br
.RI "Returns the earliest block with specified \fRstatus_mask\fP flags set after the latest block \fInot\fP having those flags\&. "
.ti -1c
.RI "bool IsBlockPruned(const \fBCBlockIndex\fP &block) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void UpdatePruneLock(const std::string &\fBname\fP, const PruneLockInfo &lock_info) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(AutoFil \fBOpenBlockFile\fP )(const \fBFlatFilePos\fP &pos, bool fReadOnly) const"
.br
.RI "Check whether the block associated with this index entry is pruned or not\&. "
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr auto \fBPRUNE_TARGET_MANUAL\fP {std::numeric_limits<uint64_t>::max()}"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::vector< \fBCBlockFileInfo\fP > \fBm_blockfile_info\fP"
.br
.ti -1c
.RI "std::set< \fBCBlockIndex\fP * > \fBm_dirty_blockindex\fP"
.br
.ti -1c
.RI "std::set< int > \fBm_dirty_fileinfo\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Maintains a tree of blocks (stored in \fRm_block_index\fP) which is consulted to determine where the most-work tip is\&.

.PP
This data is used mostly in \fR\fBChainstate\fP\fP - information about, e\&.g\&., candidate tips is not maintained here\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBOptions\fP\fBOptions\fP = \fBkernel::BlockManagerOpts\fP"

.SS "using \fBReadRawBlockResult\fP = \fButil::Expected\fP<std::vector<std::byte>, ReadRawError>"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBBlockManager\fP (const \fButil::SignalInterrupt\fP & interrupt, \fBOptions\fP\fBOptions\fP opts)\fR [explicit]\fP"

.SH "Member Function Documentation"
.PP 
.SS "uint64_t CalculateCurrentUsage ()"
Calculate the amount of disk space the block & undo files currently use 
.SS "void CleanupBlockRevFiles () const"

.SS "\fBCBlockFileInfo\fP * GetBlockFileInfo (size_t n)"
Get block file info entry for one block file 
.SS "\fBfs::path\fP GetBlockPosFilename (const \fBFlatFilePos\fP & pos) const"
Translation to a filesystem path 
.SS "uint64_t GetPruneTarget () const\fR [inline]\fP, \fR [nodiscard]\fP"
Attempt to stay below this number of bytes of block files\&. 
.SS "std::unique_ptr< \fBBlockTreeDB\fP > m_block_tree_db GUARDED_BY (\fB::cs_main\fP )"

.SS "\fBBlockMap\fP m_block_index GUARDED_BY (\fBcs_main\fP )"

.SS "\fBCBlockIndex\fP * InsertBlockIndex (const \fBuint256\fP & hash)"
Create a new block index entry for a given block hash 
.SS "bool IsPruneMode () const\fR [inline]\fP, \fR [nodiscard]\fP"
Whether running in -prune mode\&. 
.SS "bool LoadingBlocks () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "const \fBCBlockIndex\fP * LookupBlockIndex (const \fBuint256\fP & hash) const"

.SS "\fBCBlockIndex\fP * LookupBlockIndex (const \fBuint256\fP & hash)"

.SS "void PruneOneBlockFile (const int fileNumber)"

.PP
Mark one block file as pruned (modify associated database entries)\&. 
.SS "bool ReadBlock (\fBCBlock\fP & block, const \fBCBlockIndex\fP & index) const"

.SS "bool ReadBlock (\fBCBlock\fP & block, const \fBFlatFilePos\fP & pos, const std::optional< \fBuint256\fP > & expected_hash) const"
Functions for disk access for blocks 
.SS "bool ReadBlockUndo (\fBCBlockUndo\fP & blockundo, const \fBCBlockIndex\fP & index) const"

.SS "\fBBlockManager::ReadRawBlockResult\fP ReadRawBlock (const \fBFlatFilePos\fP & pos, std::optional< std::pair< size_t, size_t > > block_part = \fRstd::nullopt\fP) const"

.SS "void UnlinkPrunedFiles (const std::set< int > & setFilesToPrune) const"
Actually unlink the specified files 
.SS "void UpdateBlockInfo (const \fBCBlock\fP & block, unsigned int nHeight, const \fBFlatFilePos\fP & pos)"
Update blockfile info while processing a block during reindex\&. The block must be available on disk\&.

.PP
\fBParameters\fP
.RS 4
\fIblock\fP the block being processed 
.br
\fInHeight\fP the height of the block 
.br
\fIpos\fP the position of the serialized \fBCBlock\fP on disk 
.RE
.PP

.SH "Field Documentation"
.PP 
.SS "\fBCBlockIndex\fP * AddToBlockIndex"
Remove any pruned block & undo files that are still on disk\&. This could happen on some systems if the file was still being read while unlinked, or if we crash before unlinking\&. 
.SS "std::vector<\fBCBlockFileInfo\fP> m_blockfile_info\fR [protected]\fP"

.SS "std::atomic_bool m_blockfiles_indexed {true}"
Whether all blockfiles have been added to the block tree database\&. Normally true, but set to false when a reindex is requested and the database is wiped\&. The value is persisted in the database across restarts and will be false until reindexing completes\&. 
.SS "std::vector<\fBCBlockIndex\fP*> GetAllBlockIndices () \fBEXCLUSIVE_LOCKS_REQUIRED\fP( std::multimap<\fBCBlockIndex\fP*, \fBCBlockIndex\fP*> m_blocks_unlinked"
All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions\&. Pruned nodes may have entries where B is missing data\&. 
.SS "std::set<\fBCBlockIndex\fP*> m_dirty_blockindex\fR [protected]\fP"
Dirty block index entries\&. 
.SS "std::set<int> m_dirty_fileinfo\fR [protected]\fP"
Dirty block file entries\&. 
.SS "bool \fBCheckBlockDataAvailability\fP (const \fBCBlockIndex\fP& upper_block, const \fBCBlockIndex\fP& lower_block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP( const \fBCBlockIndex\fP& GetFirstBlock ( const \fBCBlockIndex\fP& upper_block \fBLIFETIMEBOUND\fP, uint32_t status_mask, const \fBCBlockIndex\fP* lower_block \fBLIFETIMEBOUND\fP = nullptr ) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP( boo m_have_pruned)  = false"

.PP
Returns the earliest block with specified \fRstatus_mask\fP flags set after the latest block \fInot\fP having those flags\&. Check if all blocks in the [upper_block, lower_block] range have data available\&. The caller is responsible for ensuring that lower_block is an ancestor of upper_block (part of the same chain)\&. 

.PP
This function starts from \fRupper_block\fP, which must have all \fRstatus_mask\fP flags set, and iterates backwards through its ancestors\&. It continues as long as each block has all \fRstatus_mask\fP flags set, until reaching the oldest ancestor or \fRlower_block\fP\&.

.PP
\fBPrecondition\fP
.RS 4
\fRupper_block\fP must have all \fRstatus_mask\fP flags set\&. 

.PP
\fRlower_block\fP must be null or an ancestor of \fRupper_block\fP
.RE
.PP
\fBParameters\fP
.RS 4
\fIupper_block\fP The starting block for the search, which must have all \fRstatus_mask\fP flags set\&. 
.br
\fIstatus_mask\fP Bitmask specifying required status flags\&. 
.br
\fIlower_block\fP The earliest possible block to return\&. If null, the search can extend to the genesis block\&.
.RE
.PP
\fBReturns\fP
.RS 4
A reference to the earliest block between \fRupper_block\fP and \fRlower_block\fP, inclusive, such that every block between the returned block and \fRupper_block\fP has \fRstatus_mask\fP flags set\&. True if any block files have ever been pruned\&. 
.RE
.PP

.SS "std::atomic<bool> m_importing {false}"

.SS "const \fButil::SignalInterrupt\fP& m_interrupt"

.SS "std::optional<int> m_snapshot_height"
The height of the base block of an assumeutxo snapshot, if one is in use\&.

.PP
This controls how blockfiles are segmented by chainstate type to avoid comingling different height regions of the chain when an assumedvalid chainstate is in use\&. If heights are drastically different in the same blockfile, pruning suffers\&.

.PP
This is set during ActivateSnapshot() or upon LoadBlockIndex() if a snapshot had been previously loaded\&. After the snapshot is validated, this is unset to restore normal LoadBlockIndex behavior\&. 
.SS "\fBAutoFile\fP OpenBlockFile"

.PP
Check whether the block associated with this index entry is pruned or not\&. Create or update a prune lock identified by its name Open a block file (blk?????\&.dat) 
.SS "auto PRUNE_TARGET_MANUAL {std::numeric_limits<uint64_t>::max()}\fR [static]\fP, \fR [constexpr]\fP"

.SS "\fBFlatFilePos\fP WriteBlock"
Store block on disk and update block file statistics\&.

.PP
\fBParameters\fP
.RS 4
\fIblock\fP the block to be stored 
.br
\fInHeight\fP the height of the block
.RE
.PP
\fBReturns\fP
.RS 4
in case of success, the position to which the block was written to in case of an error, an empty \fBFlatFilePos\fP 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
