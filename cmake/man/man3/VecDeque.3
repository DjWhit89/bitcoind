.TH "VecDeque< T >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
VecDeque< T >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <vecdeque\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBVecDeque\fP () noexcept=default"
.br
.ti -1c
.RI "void \fBresize\fP (size_t \fBsize\fP)"
.br
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.ti -1c
.RI "\fB~VecDeque\fP ()"
.br
.ti -1c
.RI "\fBVecDeque\fP & \fBoperator=\fP (const \fBVecDeque\fP &other)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBVecDeque\fP &other) noexcept"
.br
.ti -1c
.RI "\fBVecDeque\fP & \fBoperator=\fP (\fBVecDeque\fP &&other) noexcept"
.br
.ti -1c
.RI "\fBVecDeque\fP (const \fBVecDeque\fP &other)"
.br
.ti -1c
.RI "\fBVecDeque\fP (\fBVecDeque\fP &&other) noexcept"
.br
.ti -1c
.RI "bool friend \fBoperator==\fP (const \fBVecDeque\fP &a, const \fBVecDeque\fP &b)"
.br
.ti -1c
.RI "std::strong_ordering friend \fBoperator<=>\fP (const \fBVecDeque\fP &a, const \fBVecDeque\fP &b)"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t \fBcapacity\fP)"
.br
.ti -1c
.RI "void \fBshrink_to_fit\fP ()"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBemplace_back\fP (Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "void \fBpush_back\fP (\fBT\fP &&elem)"
.br
.ti -1c
.RI "void \fBpush_back\fP (const \fBT\fP &elem)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBemplace_front\fP (Args &&\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "void \fBpush_front\fP (const \fBT\fP &elem)"
.br
.ti -1c
.RI "void \fBpush_front\fP (\fBT\fP &&elem)"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "\fBT\fP & \fBfront\fP () noexcept"
.br
.ti -1c
.RI "const \fBT\fP & \fBfront\fP () const noexcept"
.br
.ti -1c
.RI "\fBT\fP & \fBback\fP () noexcept"
.br
.ti -1c
.RI "const \fBT\fP & \fBback\fP () const noexcept"
.br
.ti -1c
.RI "\fBT\fP & \fBoperator[]\fP (size_t idx) noexcept"
.br
.ti -1c
.RI "const \fBT\fP & \fBoperator[]\fP (size_t idx) const noexcept"
.br
.ti -1c
.RI "bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "size_t \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "size_t \fBcapacity\fP () const noexcept"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "void \fBswap\fP (\fBVecDeque\fP &a, \fBVecDeque\fP &b) noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename \fBT\fP>
.br
class VecDeque< T >"Data structure largely mimicking std::deque, but using single preallocated ring buffer\&.

.PP
.IP "\(bu" 2
More efficient and better memory locality than std::deque\&.
.IP "\(bu" 2
Most operations ({push_,pop_,emplace_,}{front,back}(), operator[], \&.\&.\&.) are O(1), unless reallocation is needed (in which case they are O(n))\&.
.IP "\(bu" 2
Supports \fBreserve()\fP, \fBcapacity()\fP, \fBshrink_to_fit()\fP like vectors\&.
.IP "\(bu" 2
No iterator support\&.
.IP "\(bu" 2
Data is not stored in a single contiguous block, so no data()\&. 
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename \fBT\fP> \fBVecDeque\fP ()\fR [default]\fP, \fR [noexcept]\fP"

.SS "template<typename \fBT\fP> ~\fBVecDeque\fP ()\fR [inline]\fP"
Destroy a deque\&. 
.SS "template<typename \fBT\fP> \fBVecDeque\fP (const \fBVecDeque\fP< \fBT\fP > & other)\fR [inline]\fP"
Copy-construct a deque\&. 
.SS "template<typename \fBT\fP> \fBVecDeque\fP (\fBVecDeque\fP< \fBT\fP > && other)\fR [inline]\fP, \fR [noexcept]\fP"
Move-construct a deque\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename \fBT\fP> const \fBT\fP & back () const\fR [inline]\fP, \fR [noexcept]\fP"
Get a const reference to the last element of the deque\&. Requires !empty()\&. 
.SS "template<typename \fBT\fP> \fBT\fP & back ()\fR [inline]\fP, \fR [noexcept]\fP"
Get a mutable reference to the last element of the deque\&. Requires !empty()\&. 
.SS "template<typename \fBT\fP> size_t capacity () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the capacity of this deque (maximum size it can have without reallocating)\&. 
.SS "template<typename \fBT\fP> void clear ()\fR [inline]\fP, \fR [noexcept]\fP"
Resize the deque to be size 0\&. The capacity will remain unchanged\&. 
.SS "template<typename \fBT\fP> template<typename\&.\&.\&. Args> void emplace_back (Args &&\&.\&.\&. args)\fR [inline]\fP"
Construct a new element at the end of the deque\&. 
.SS "template<typename \fBT\fP> template<typename\&.\&.\&. Args> void emplace_front (Args &&\&.\&.\&. args)\fR [inline]\fP"
Construct a new element at the beginning of the deque\&. 
.SS "template<typename \fBT\fP> bool empty () const\fR [inline]\fP, \fR [noexcept]\fP"
Test whether the contents of this deque is empty\&. 
.SS "template<typename \fBT\fP> const \fBT\fP & front () const\fR [inline]\fP, \fR [noexcept]\fP"
Get a const reference to the first element of the deque\&. Requires !empty()\&. 
.SS "template<typename \fBT\fP> \fBT\fP & front ()\fR [inline]\fP, \fR [noexcept]\fP"
Get a mutable reference to the first element of the deque\&. Requires !empty()\&. 
.SS "template<typename \fBT\fP> std::strong_ordering friend operator<=> (const \fBVecDeque\fP< \fBT\fP > & a, const \fBVecDeque\fP< \fBT\fP > & b)\fR [inline]\fP"
Comparison between two deques, implementing lexicographic ordering on the contents\&. 
.SS "template<typename \fBT\fP> \fBVecDeque\fP & operator= (const \fBVecDeque\fP< \fBT\fP > & other)\fR [inline]\fP"
Copy-assign a deque\&. 
.SS "template<typename \fBT\fP> \fBVecDeque\fP & operator= (\fBVecDeque\fP< \fBT\fP > && other)\fR [inline]\fP, \fR [noexcept]\fP"
Move-assign a deque\&. 
.SS "template<typename \fBT\fP> bool friend operator== (const \fBVecDeque\fP< \fBT\fP > & a, const \fBVecDeque\fP< \fBT\fP > & b)\fR [inline]\fP"
Equality comparison between two deques (only compares size+contents, not capacity)\&. 
.SS "template<typename \fBT\fP> const \fBT\fP & operator[] (size_t idx) const\fR [inline]\fP, \fR [noexcept]\fP"
Get a const reference to the element in the deque at the given index\&. Requires idx < \fBsize()\fP\&. 
.SS "template<typename \fBT\fP> \fBT\fP & operator[] (size_t idx)\fR [inline]\fP, \fR [noexcept]\fP"
Get a mutable reference to the element in the deque at the given index\&. Requires idx < \fBsize()\fP\&. 
.SS "template<typename \fBT\fP> void pop_back ()\fR [inline]\fP"
Remove the last element of the deque\&. Requires !empty()\&. 
.SS "template<typename \fBT\fP> void pop_front ()\fR [inline]\fP"
Remove the first element of the deque\&. Requires !empty()\&. 
.SS "template<typename \fBT\fP> void push_back (const \fBT\fP & elem)\fR [inline]\fP"
Copy-construct a new element at the end of the deque\&. 
.SS "template<typename \fBT\fP> void push_back (\fBT\fP && elem)\fR [inline]\fP"
Move-construct a new element at the end of the deque\&. 
.SS "template<typename \fBT\fP> void push_front (const \fBT\fP & elem)\fR [inline]\fP"
Copy-construct a new element at the beginning of the deque\&. 
.SS "template<typename \fBT\fP> void push_front (\fBT\fP && elem)\fR [inline]\fP"
Move-construct a new element at the beginning of the deque\&. 
.SS "template<typename \fBT\fP> void reserve (size_t capacity)\fR [inline]\fP"
Increase the capacity to capacity\&. Capacity will not shrink\&. 
.SS "template<typename \fBT\fP> void resize (size_t size)\fR [inline]\fP"
Resize the deque to be exactly size size (adding default-constructed elements if needed)\&. 
.SS "template<typename \fBT\fP> void shrink_to_fit ()\fR [inline]\fP"
Make the capacity equal to the size\&. The contents does not change\&. 
.SS "template<typename \fBT\fP> size_t size () const\fR [inline]\fP, \fR [noexcept]\fP"
Get the number of elements in this deque\&. 
.SS "template<typename \fBT\fP> void swap (\fBVecDeque\fP< \fBT\fP > & other)\fR [inline]\fP, \fR [noexcept]\fP"
Swap two deques\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<typename \fBT\fP> void swap (\fBVecDeque\fP< \fBT\fP > & a, \fBVecDeque\fP< \fBT\fP > & b)\fR [friend]\fP"
Non-member version of swap\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
