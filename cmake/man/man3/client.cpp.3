.TH "src/rpc/client.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/rpc/client.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <common/args\&.h>\fP
.br
\fR#include <rpc/client\&.h>\fP
.br
\fR#include <tinyformat\&.h>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <set>\fP
.br
\fR#include <string>\fP
.br
\fR#include <string_view>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBCRPCConvertParam\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBrpc_convert\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBParamFormat\fP { \fBJSON\fP, \fBSTRING\fP, \fBJSON_OR_STRING\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const \fBCRPCConvertParam\fP * \fBFromPosition\fP (std::string_view method, size_t pos)"
.br
.ti -1c
.RI "const \fBCRPCConvertParam\fP * \fBFromName\fP (std::string_view method, std::string_view \fBname\fP)"
.br
.ti -1c
.RI "\fBUniValue\fP \fBRPCConvertValues\fP (const std::string &strMethod, const std::vector< std::string > &strParams)"
.br
.ti -1c
.RI "\fBUniValue\fP \fBRPCConvertNamedValues\fP (const std::string &strMethod, const std::vector< std::string > &strParams)"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBParamFormat\fP"
Specify whether parameter should be parsed by bitcoin-cli as a JSON value, or passed unchanged as a string, or a combination of both\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIJSON \fP
.TP
\f(BISTRING \fP
.TP
\f(BIJSON_OR_STRING \fP
.SH "Function Documentation"
.PP 
.SS "\fBUniValue\fP RPCConvertNamedValues (const std::string & strMethod, const std::vector< std::string > & strParams)"
Convert command line arguments to params object when -named is enabled\&.

.PP
The -named syntax accepts named arguments in NAME=VALUE format, as well as positional arguments without names\&. The syntax is inherently ambiguous if names are omitted and values contain '=', so a heuristic is used to disambiguate:

.PP
.IP "\(bu" 2
Arguments that do not contain '=' are treated as positional parameters\&.
.IP "\(bu" 2
Arguments that do contain '=' are assumed to be named parameters in NAME=VALUE format except for two special cases:
.IP "  1." 6
The case where NAME is not a known parameter name, and the next positional parameter requires a JSON value, and the argument parses as JSON\&. E\&.g\&. ["list", "with", "="]\&.
.IP "  2." 6
The case where NAME is not a known parameter name and the next positional parameter requires a string value\&. E\&.g\&. "my=wallet"\&.
.PP

.PP

.PP
For example, the command \fRbitcoin-cli -named createwallet "my=\fBwallet\fP"\fP, the parser initially sees "my=wallet" and attempts to process it as a parameter named "my"\&. When it finds that "my" is not a valid named parameter parameter for this method, it falls back to checking the rule for the next available positional parameter (index 0)\&. Because it finds the rule that this parameter is a ParamFormat::STRING, it correctly treats the entire "my=wallet" as a single positional string, successfully creating a wallet with that literal name\&. 
.SS "\fBUniValue\fP RPCConvertValues (const std::string & strMethod, const std::vector< std::string > & strParams)"
Convert command lines arguments to params object when -named is disabled\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
