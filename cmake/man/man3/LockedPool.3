.TH "LockedPool" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
LockedPool
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <lockedpool\&.h>\fP
.PP
Inherited by \fBLockedPoolManager\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBStats\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef bool(* \fBLockingFailed_Callback\fP) ()"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLockedPool\fP (std::unique_ptr< \fBLockedPageAllocator\fP > allocator, \fBLockingFailed_Callback\fP lf_cb_in=nullptr)"
.br
.ti -1c
.RI "\fB~LockedPool\fP ()"
.br
.ti -1c
.RI "\fBLockedPool\fP (const \fBLockedPool\fP &other)=delete"
.br
.ti -1c
.RI "\fBLockedPool\fP & \fBoperator=\fP (const \fBLockedPool\fP &)=delete"
.br
.ti -1c
.RI "void * \fBalloc\fP (size_t size)"
.br
.ti -1c
.RI "void \fBfree\fP (void *ptr)"
.br
.ti -1c
.RI "\fBStats\fP \fBstats\fP () const"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const size_t \fBARENA_SIZE\fP = 256*1024"
.br
.ti -1c
.RI "static const size_t \fBARENA_ALIGN\fP = 16"
.br
.in -1c
.SH "Detailed Description"
.PP 
Pool for locked memory chunks\&.

.PP
To avoid sensitive key data from being swapped to disk, the memory in this pool is locked/pinned\&.

.PP
An arena manages a contiguous region of memory\&. The pool starts out with one arena but can grow to multiple arenas if the need arises\&.

.PP
Unlike a normal C heap, the administrative structures are separate from the managed memory\&. This has been done as the sizes and bases of objects are not in themselves sensitive information, as to conserve precious locked memory\&. In some operating systems the amount of memory that can be locked is small\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "typedef bool(* LockingFailed_Callback) ()"
Callback when allocation succeeds but locking fails\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBLockedPool\fP (std::unique_ptr< \fBLockedPageAllocator\fP > allocator, \fBLockingFailed_Callback\fP lf_cb_in = \fRnullptr\fP)\fR [explicit]\fP"
Create a new \fBLockedPool\fP\&. This takes ownership of the MemoryPageLocker, you can only instantiate this with \fBLockedPool(std::move(\&.\&.\&.))\fP\&.

.PP
The second argument is an optional callback when locking a newly allocated arena failed\&. If this callback is provided and returns false, the allocation fails (hard fail), if it returns true the allocation proceeds, but it could warn\&. 
.SS "~\fBLockedPool\fP ()\fR [default]\fP"

.SS "\fBLockedPool\fP (const \fBLockedPool\fP & other)\fR [delete]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void * alloc (size_t size)"
Allocate size bytes from this arena\&. Returns pointer on success, or 0 if memory is full or the application tried to allocate 0 bytes\&. 
.SS "void free (void * ptr)"
Free a previously allocated chunk of memory\&. Freeing the zero pointer has no effect\&. Raises std::runtime_error in case of error\&. 
.SS "\fBLockedPool\fP & operator= (const \fBLockedPool\fP & )\fR [delete]\fP"

.SS "\fBLockedPool::Stats\fP stats () const"
Get pool usage statistics 
.SH "Field Documentation"
.PP 
.SS "const size_t ARENA_ALIGN = 16\fR [static]\fP"
Chunk alignment\&. Another compromise\&. Setting this too high will waste memory, setting it too low will facilitate fragmentation\&. 
.SS "const size_t ARENA_SIZE = 256*1024\fR [static]\fP"
Size of one arena of locked memory\&. This is a compromise\&. Do not set this too low, as managing many arenas will increase allocation and deallocation overhead\&. Setting it too high allocates more locked memory from the OS than strictly necessary\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
