.TH "src/test/serialize_tests.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/test/serialize_tests.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <hash\&.h>\fP
.br
\fR#include <serialize\&.h>\fP
.br
\fR#include <streams\&.h>\fP
.br
\fR#include <test/util/setup_common\&.h>\fP
.br
\fR#include <util/strencodings\&.h>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <string>\fP
.br
\fR#include <boost/test/unit_test\&.hpp>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBUncopyableStream\fP"
.br
.ti -1c
.RI "class \fBCSerializeMethodsTestSingle\fP"
.br
.ti -1c
.RI "class \fBCSerializeMethodsTestMany\fP"
.br
.ti -1c
.RI "struct \fBBaseFormat\fP"
.br
.ti -1c
.RI "class \fBBase\fP"
.br
.RI "(Un)serialize a number as raw byte or 2 hexadecimal chars\&. "
.ti -1c
.RI "class \fBDerivedAndBaseFormat\fP"
.br
.ti -1c
.RI "class \fBDerived\fP"
.br
.ti -1c
.RI "struct \fBOtherParam\fP"
.br
.ti -1c
.RI "class \fBOtherParamChecker\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (sizes)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (varints)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (varints_bitpatterns)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (compactsize)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (vector_bool)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (array)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (noncanonical)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (class_methods)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (with_params_multi)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (with_params_move)"
.br
.RI "Test creating a \fBParamsStream\fP that moves from a stream argument\&. "
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (with_params_base)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (with_params_vector_of_base)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (with_params_derived)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "constexpr \fBBaseFormat\fP \fBRAW\fP {\fBBaseFormat::RAW\fP}"
.br
.ti -1c
.RI "constexpr \fBBaseFormat\fP \fBHEX\fP {\fBBaseFormat::HEX\fP}"
.br
.ti -1c
.RI "constexpr \fBDerivedAndBaseFormat\fP \fBRAW_LOWER\fP {{\fBBaseFormat::RAW\fP}, \fBDerivedAndBaseFormat::DerivedFormat::LOWER\fP}"
.br
.ti -1c
.RI "constexpr \fBDerivedAndBaseFormat\fP \fBHEX_UPPER\fP {{\fBBaseFormat::HEX\fP}, \fBDerivedAndBaseFormat::DerivedFormat::UPPER\fP}"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "BOOST_AUTO_TEST_CASE (array )"

.SS "BOOST_AUTO_TEST_CASE (class_methods )"

.SS "BOOST_AUTO_TEST_CASE (compactsize )"

.SS "BOOST_AUTO_TEST_CASE (noncanonical )"

.SS "BOOST_AUTO_TEST_CASE (sizes )"

.SS "BOOST_AUTO_TEST_CASE (varints )"

.SS "BOOST_AUTO_TEST_CASE (varints_bitpatterns )"

.SS "BOOST_AUTO_TEST_CASE (vector_bool )"

.SS "BOOST_AUTO_TEST_CASE (with_params_base )"

.SS "BOOST_AUTO_TEST_CASE (with_params_derived )"

.SS "BOOST_AUTO_TEST_CASE (with_params_move )"

.PP
Test creating a \fBParamsStream\fP that moves from a stream argument\&. 
.SS "BOOST_AUTO_TEST_CASE (with_params_multi )"
Test creating a stream with multiple parameters and making sure serialization code requiring different parameters can retrieve them\&. Also test that earlier parameters take precedence if the same parameter type is specified twice\&. (Choice of whether earlier or later values take precedence or multiple values of the same type are allowed was arbitrary, and just decided based on what would require smallest amount of ugly C++ template code\&. Intent of the test is to just ensure there is no unexpected behavior\&.) 
.SS "BOOST_AUTO_TEST_CASE (with_params_vector_of_base )"

.SH "Variable Documentation"
.PP 
.SS "\fBBaseFormat\fP HEX {\fBBaseFormat::HEX\fP}\fR [constexpr]\fP"

.SS "\fBDerivedAndBaseFormat\fP HEX_UPPER {{\fBBaseFormat::HEX\fP}, \fBDerivedAndBaseFormat::DerivedFormat::UPPER\fP}\fR [constexpr]\fP"

.SS "\fBBaseFormat\fP RAW {\fBBaseFormat::RAW\fP}\fR [constexpr]\fP"

.SS "\fBDerivedAndBaseFormat\fP RAW_LOWER {{\fBBaseFormat::RAW\fP}, \fBDerivedAndBaseFormat::DerivedFormat::LOWER\fP}\fR [constexpr]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
