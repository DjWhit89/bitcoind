.TH "Session" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Session
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <i2p\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSession\fP (const \fBfs::path\fP &private_key_file, const \fBProxy\fP &control_host, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt)"
.br
.ti -1c
.RI "\fBSession\fP (const \fBProxy\fP &control_host, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt)"
.br
.ti -1c
.RI "\fB~Session\fP ()"
.br
.ti -1c
.RI "bool \fBListen\fP (\fBConnection\fP &conn) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_mutex)"
.br
.ti -1c
.RI "bool \fBAccept\fP (\fBConnection\fP &conn) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_mutex)"
.br
.ti -1c
.RI "bool \fBConnect\fP (const \fBCService\fP &to, \fBConnection\fP &conn, bool &proxy_error) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_mutex)"
.br
.in -1c
.SH "Detailed Description"
.PP 
I2P SAM session\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Session (const \fBfs::path\fP & private_key_file, const \fBProxy\fP & control_host, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt)"
Construct a session\&. This will not initiate any IO, the session will be lazily created later when first used\&. 
.PP
\fBParameters\fP
.RS 4
\fIprivate_key_file\fP Path to a private key file\&. If the file does not exist then the private key will be generated and saved into the file\&. 
.br
\fIcontrol_host\fP Location of the SAM proxy\&. 
.br
\fIinterrupt\fP If this is signaled then all operations are canceled as soon as possible and executing methods throw an exception\&. 
.RE
.PP

.SS "Session (const \fBProxy\fP & control_host, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt)"
Construct a transient session which will generate its own I2P private key rather than read the one from disk (it will not be saved on disk either and will be lost once this object is destroyed)\&. This will not initiate any IO, the session will be lazily created later when first used\&. 
.PP
\fBParameters\fP
.RS 4
\fIcontrol_host\fP Location of the SAM proxy\&. 
.br
\fIinterrupt\fP If this is signaled then all operations are canceled as soon as possible and executing methods throw an exception\&. 
.RE
.PP

.SS "~\fBSession\fP ()"
Destroy the session, closing the internally used sockets\&. The sockets that have been returned by \fR\fBAccept()\fP\fP or \fR\fBConnect()\fP\fP will not be closed, but they will be closed by the SAM proxy because the session is destroyed\&. So they will return an error next time we try to read or write to them\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool Accept (\fBConnection\fP & conn)"
Wait for and accept a new incoming connection\&. 
.PP
\fBParameters\fP
.RS 4
\fIconn\fP The \fRsock\fP member is used for waiting and accepting\&. Upon successful completion the \fRpeer\fP member will be set to the address of the incoming peer\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true on success 
.RE
.PP

.SS "bool Connect (const \fBCService\fP & to, \fBConnection\fP & conn, bool & proxy_error)"
Connect to an I2P peer\&. 
.PP
\fBParameters\fP
.RS 4
\fIto\fP Peer to connect to\&. 
.br
\fIconn\fP Established connection\&. Only set if \fRtrue\fP is returned\&. 
.br
\fIproxy_error\fP If an error occurs due to proxy or general network failure, then this is set to \fRtrue\fP\&. If an error occurs due to unreachable peer (likely peer is down), then it is set to \fRfalse\fP\&. Only set if \fRfalse\fP is returned\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true on success 
.RE
.PP

.SS "bool Listen (\fBConnection\fP & conn)"
Start listening for an incoming connection\&. 
.PP
\fBParameters\fP
.RS 4
\fIconn\fP Upon successful completion the \fRsock\fP and \fRme\fP members will be set to the listening socket and address\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true on success 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
