.TH "src/core_write.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/core_write.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <core_io\&.h>\fP
.br
\fR#include <common/system\&.h>\fP
.br
\fR#include <consensus/amount\&.h>\fP
.br
\fR#include <consensus/consensus\&.h>\fP
.br
\fR#include <consensus/validation\&.h>\fP
.br
\fR#include <key_io\&.h>\fP
.br
\fR#include <script/descriptor\&.h>\fP
.br
\fR#include <script/script\&.h>\fP
.br
\fR#include <script/solver\&.h>\fP
.br
\fR#include <serialize\&.h>\fP
.br
\fR#include <streams\&.h>\fP
.br
\fR#include <undo\&.h>\fP
.br
\fR#include <univalue\&.h>\fP
.br
\fR#include <util/check\&.h>\fP
.br
\fR#include <util/strencodings\&.h>\fP
.br
\fR#include <map>\fP
.br
\fR#include <string>\fP
.br
\fR#include <vector>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBUniValue\fP \fBValueFromAmount\fP (const \fBCAmount\fP amount)"
.br
.ti -1c
.RI "std::string \fBFormatScript\fP (const \fBCScript\fP &\fBscript\fP)"
.br
.ti -1c
.RI "std::string \fBSighashToStr\fP (unsigned char sighash_type)"
.br
.ti -1c
.RI "std::string \fBScriptToAsmStr\fP (const \fBCScript\fP &\fBscript\fP, const bool fAttemptSighashDecode)"
.br
.ti -1c
.RI "std::string \fBEncodeHexTx\fP (const \fBCTransaction\fP &tx)"
.br
.ti -1c
.RI "void \fBScriptToUniv\fP (const \fBCScript\fP &\fBscript\fP, \fBUniValue\fP &out, bool include_hex, bool include_address, const \fBSigningProvider\fP *provider)"
.br
.ti -1c
.RI "void \fBTxToUniv\fP (const \fBCTransaction\fP &tx, const \fBuint256\fP &block_hash, \fBUniValue\fP &entry, bool include_hex, const \fBCTxUndo\fP *txundo, \fBTxVerbosity\fP verbosity, std::function< bool(const \fBCTxOut\fP &)> is_change_func)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const std::map< unsigned char, std::string > \fBmapSigHashTypes\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "std::string EncodeHexTx (const \fBCTransaction\fP & tx)"

.SS "std::string FormatScript (const \fBCScript\fP & script)"

.SS "std::string ScriptToAsmStr (const \fBCScript\fP & script, const bool fAttemptSighashDecode)"
Create the assembly string representation of a \fBCScript\fP object\&. 
.PP
\fBParameters\fP
.RS 4
\fIscript\fP \fBCScript\fP object to convert into the asm string representation\&. 
.br
\fIfAttemptSighashDecode\fP Whether to attempt to decode sighash types on data within the script that matches the format of a signature\&. Only pass true for scripts you believe could contain signatures\&. For example, pass false, or omit the this argument (defaults to false), for scriptPubKeys\&. 
.RE
.PP

.SS "void ScriptToUniv (const \fBCScript\fP & script, \fBUniValue\fP & out, bool include_hex, bool include_address, const \fBSigningProvider\fP * provider)"

.SS "std::string SighashToStr (unsigned char sighash_type)"

.SS "void TxToUniv (const \fBCTransaction\fP & tx, const \fBuint256\fP & block_hash, \fBUniValue\fP & entry, bool include_hex, const \fBCTxUndo\fP * txundo, \fBTxVerbosity\fP verbosity, std::function< bool(const \fBCTxOut\fP &)> is_change_func)"

.SS "\fBUniValue\fP ValueFromAmount (const \fBCAmount\fP amount)"

.SH "Variable Documentation"
.PP 
.SS "const std::map<unsigned char, std::string> mapSigHashTypes"
\fBInitial value:\fP
.nf
= {
    {static_cast<unsigned char>(SIGHASH_ALL), std::string("ALL")},
    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string("ALL|ANYONECANPAY")},
    {static_cast<unsigned char>(SIGHASH_NONE), std::string("NONE")},
    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string("NONE|ANYONECANPAY")},
    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string("SINGLE")},
    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string("SINGLE|ANYONECANPAY")},
}
.PP
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
