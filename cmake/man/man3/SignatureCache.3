.TH "SignatureCache" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SignatureCache
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <sigcache\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSignatureCache\fP (size_t max_size_bytes)"
.br
.ti -1c
.RI "\fBSignatureCache\fP (const \fBSignatureCache\fP &)=delete"
.br
.ti -1c
.RI "\fBSignatureCache\fP & \fBoperator=\fP (const \fBSignatureCache\fP &)=delete"
.br
.ti -1c
.RI "void \fBComputeEntryECDSA\fP (\fBuint256\fP &entry, const \fBuint256\fP &hash, const std::vector< unsigned char > &vchSig, const \fBCPubKey\fP &pubkey) const"
.br
.ti -1c
.RI "void \fBComputeEntrySchnorr\fP (\fBuint256\fP &entry, const \fBuint256\fP &hash, std::span< const unsigned char > sig, const \fBXOnlyPubKey\fP &pubkey) const"
.br
.ti -1c
.RI "bool \fBGet\fP (const \fBuint256\fP &entry, const bool erase)"
.br
.ti -1c
.RI "void \fBSet\fP (const \fBuint256\fP &entry)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Valid signature cache, to avoid doing expensive ECDSA signature checking twice for every transaction (once when accepted into memory pool, and again when accepted into the block chain) 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBSignatureCache\fP (size_t max_size_bytes)"

.SS "\fBSignatureCache\fP (const \fBSignatureCache\fP & )\fR [delete]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void ComputeEntryECDSA (\fBuint256\fP & entry, const \fBuint256\fP & hash, const std::vector< unsigned char > & vchSig, const \fBCPubKey\fP & pubkey) const"

.SS "void ComputeEntrySchnorr (\fBuint256\fP & entry, const \fBuint256\fP & hash, std::span< const unsigned char > sig, const \fBXOnlyPubKey\fP & pubkey) const"

.SS "bool Get (const \fBuint256\fP & entry, const bool erase)"

.SS "\fBSignatureCache\fP & operator= (const \fBSignatureCache\fP & )\fR [delete]\fP"

.SS "void Set (const \fBuint256\fP & entry)"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
