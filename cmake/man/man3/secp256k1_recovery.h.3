.TH "src/secp256k1/include/secp256k1_recovery.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/secp256k1/include/secp256k1_recovery.h
.SH SYNOPSIS
.br
.PP
\fR#include 'secp256k1\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsecp256k1_ecdsa_recoverable_signature\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct secp256k1_ecdsa_recoverable_signature \fBsecp256k1_ecdsa_recoverable_signature\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_recoverable_signature_parse_compact\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP *sig, const unsigned char *input64, int recid) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_recoverable_signature_convert\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_ecdsa_signature\fP *sig, const \fBsecp256k1_ecdsa_recoverable_signature\fP *sigin) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_recoverable_signature_serialize_compact\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *output64, int *recid, const \fBsecp256k1_ecdsa_recoverable_signature\fP *sig) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_sign_recoverable\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP *sig, const unsigned char *msghash32, const unsigned char *seckey, \fBsecp256k1_nonce_function\fP noncefp, const void *ndata) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_ecdsa_recover\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_pubkey\fP *pubkey, const \fBsecp256k1_ecdsa_recoverable_signature\fP *sig, const unsigned char *msghash32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct secp256k1_ecdsa_recoverable_signature secp256k1_ecdsa_recoverable_signature"
Opaque data structure that holds a parsed ECDSA signature, supporting pubkey recovery\&.

.PP
The exact representation of data inside is implementation defined and not guaranteed to be portable between different platforms or versions\&. It is however guaranteed to be 65 bytes in size, and can be safely copied/moved\&. If you need to convert to a format suitable for storage or transmission, use the secp256k1_ecdsa_signature_serialize_* and secp256k1_ecdsa_signature_parse_* functions\&.

.PP
Furthermore, it is guaranteed that identical signatures (including their recoverability) will have identical representation, so they can be memcmp'ed\&. 
.SH "Function Documentation"
.PP 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_ecdsa_recover (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_pubkey\fP * pubkey, const \fBsecp256k1_ecdsa_recoverable_signature\fP * sig, const unsigned char * msghash32)"
Recover an ECDSA public key from a signature\&.

.PP
Successful public key recovery guarantees that the signature, after normalization, passes \fR\fBsecp256k1_ecdsa_verify\fP\fP\&. Thus, explicit verification is not necessary\&.

.PP
However, a recoverable signature that successfully passes \fR\fBsecp256k1_ecdsa_recover\fP\fP, when converted to a non-recoverable signature (using \fR\fBsecp256k1_ecdsa_recoverable_signature_convert\fP\fP), is not guaranteed to be normalized and thus not guaranteed to pass \fR\fBsecp256k1_ecdsa_verify\fP\fP\&. If a normalized signature is required, call \fR\fBsecp256k1_ecdsa_signature_normalize\fP\fP after \fR\fBsecp256k1_ecdsa_recoverable_signature_convert\fP\fP\&.

.PP
Returns: 1: public key successfully recovered 0: otherwise\&. Args: ctx: pointer to a context object\&. Out: pubkey: pointer to the recovered public key\&. In: sig: pointer to initialized signature that supports pubkey recovery\&. msghash32: the 32-byte message hash assumed to be signed\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_recoverable_signature_convert (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_ecdsa_signature\fP * sig, const \fBsecp256k1_ecdsa_recoverable_signature\fP * sigin)"
Convert a recoverable signature into a normal signature\&.

.PP
Returns: 1 Args: ctx: pointer to a context object\&. Out: sig: pointer to a normal signature\&. In: sigin: pointer to a recoverable signature\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_recoverable_signature_parse_compact (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP * sig, const unsigned char * input64, int recid)"
Parse a compact ECDSA signature (64 bytes + recovery id)\&.

.PP
Returns: 1 when the signature could be parsed, 0 otherwise Args: ctx: pointer to a context object Out: sig: pointer to a signature object In: input64: pointer to a 64-byte compact signature recid: the recovery id (0, 1, 2 or 3) 
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_recoverable_signature_serialize_compact (const \fBsecp256k1_context\fP * ctx, unsigned char * output64, int * recid, const \fBsecp256k1_ecdsa_recoverable_signature\fP * sig)"
Serialize an ECDSA signature in compact format (64 bytes + recovery id)\&.

.PP
Returns: 1 Args: ctx: pointer to a context object\&. Out: output64: pointer to a 64-byte array of the compact signature\&. recid: pointer to an integer to hold the recovery id\&. In: sig: pointer to an initialized signature object\&. 
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_sign_recoverable (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP * sig, const unsigned char * msghash32, const unsigned char * seckey, \fBsecp256k1_nonce_function\fP noncefp, const void * ndata)"
Create a recoverable ECDSA signature\&.

.PP
Returns: 1: signature created 0: the nonce generation function failed, or the secret key was invalid\&. Args: ctx: pointer to a context object (not secp256k1_context_static)\&. Out: sig: pointer to an array where the signature will be placed\&. In: msghash32: the 32-byte message hash being signed\&. seckey: pointer to a 32-byte secret key\&. noncefp: pointer to a nonce generation function\&. If NULL, secp256k1_nonce_function_default is used\&. ndata: pointer to arbitrary data used by the nonce generation function (can be NULL for secp256k1_nonce_function_default)\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
