.TH "Result< M >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Result< M >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <result\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBResult\fP ()"
.br
.ti -1c
.RI "\fBResult\fP (T obj)"
.br
.ti -1c
.RI "\fBResult\fP (\fBError\fP error)"
.br
.ti -1c
.RI "\fBResult\fP (Result &&)=default"
.br
.ti -1c
.RI "\fB~Result\fP ()=default"
.br
.ti -1c
.RI "bool \fBhas_value\fP () const noexcept"
.br
.ti -1c
.RI "const T & \fBvalue\fP () const \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "T & \fBvalue\fP () \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "template<class U> T \fBvalue_or\fP (U &&default_value) const &"
.br
.ti -1c
.RI "template<class U> T \fBvalue_or\fP (U &&default_value) &&"
.br
.ti -1c
.RI "\fBoperator bool\fP () const noexcept"
.br
.ti -1c
.RI "const T * \fBoperator\->\fP () const \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "const T & \fBoperator*\fP () const \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "T * \fBoperator\->\fP () \fBLIFETIMEBOUND\fP"
.br
.ti -1c
.RI "T & \fBoperator*\fP () \fBLIFETIMEBOUND\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename FT> \fBbilingual_str\fP \fBErrorString\fP (const Result< FT > &result)"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class M> Result ()\fR [inline]\fP"

.SS "template<class M> Result (T obj)\fR [inline]\fP"

.SS "template<class M> Result (\fBError\fP error)\fR [inline]\fP"

.SS "template<class M> Result (Result< M > && )\fR [default]\fP"

.SS "template<class M> ~Result ()\fR [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<class M> bool has_value () const\fR [inline]\fP, \fR [noexcept]\fP"
std::optional methods, so functions returning optional<T> can change to return Result<T> with minimal changes to existing code, and vice versa\&. 
.SS "template<class M> operator bool () const\fR [inline]\fP, \fR [explicit]\fP, \fR [noexcept]\fP"

.SS "template<class M> const T & operator* () const\fR [inline]\fP"

.SS "template<class M> T & operator* ()\fR [inline]\fP"

.SS "template<class M> const T * operator\-> () const\fR [inline]\fP"

.SS "template<class M> T * operator\-> ()\fR [inline]\fP"

.SS "template<class M> const T & value () const\fR [inline]\fP"

.SS "template<class M> T & value ()\fR [inline]\fP"

.SS "template<class M> template<class U> T value_or (U && default_value) &&\fR [inline]\fP"

.SS "template<class M> template<class U> T value_or (U && default_value) const &\fR [inline]\fP"

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<class M> template<typename FT> \fBbilingual_str\fP ErrorString (const Result< FT > & result)\fR [friend]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
