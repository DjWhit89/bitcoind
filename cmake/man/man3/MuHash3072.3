.TH "MuHash3072" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MuHash3072
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <muhash\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBMuHash3072\fP () noexcept=default"
.br
.ti -1c
.RI "\fBMuHash3072\fP (std::span< const unsigned char > in) noexcept"
.br
.ti -1c
.RI "\fBMuHash3072\fP & \fBInsert\fP (std::span< const unsigned char > in) noexcept"
.br
.ti -1c
.RI "\fBMuHash3072\fP & \fBRemove\fP (std::span< const unsigned char > in) noexcept"
.br
.ti -1c
.RI "\fBMuHash3072\fP & \fBoperator*=\fP (const \fBMuHash3072\fP &mul) noexcept"
.br
.ti -1c
.RI "\fBMuHash3072\fP & \fBoperator/=\fP (const \fBMuHash3072\fP &div) noexcept"
.br
.ti -1c
.RI "void \fBFinalize\fP (\fBuint256\fP &out) noexcept"
.br
.ti -1c
.RI "\fBSERIALIZE_METHODS\fP (\fBMuHash3072\fP, obj)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A class representing MuHash sets

.PP
MuHash is a hashing algorithm that supports adding set elements in any order but also deleting in any order\&. As a result, it can maintain a running sum for a set of data as a whole, and add/remove when data is added to or removed from it\&. A downside of MuHash is that computing an inverse is relatively expensive\&. This is solved by representing the running value as a fraction, and multiplying added elements into the numerator and removed elements into the denominator\&. Only when the final hash is desired, a single modular inverse and multiplication is needed to combine the two\&. The combination is also run on serialization to allow for space-efficient storage on disk\&.

.PP
As the update operations are also associative, H(a)+H(b)+H(c)+H(d) can in fact be computed as (H(a)+H(b)) + (H(c)+H(d))\&. This implies that all of this is perfectly parallellizable: each thread can process an arbitrary subset of the update operations, allowing them to be efficiently combined later\&.

.PP
MuHash does not support checking if an element is already part of the set\&. That is why this class does not enforce the use of a set as the data it represents because there is no efficient way to do so\&. It is possible to add elements more than once and also to remove elements that have not been added before\&. However, this implementation is intended to represent a set of elements\&.

.PP
See also https://cseweb.ucsd.edu/~mihir/papers/inchash.pdf and https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014337.html\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBMuHash3072\fP ()\fR [default]\fP, \fR [noexcept]\fP"

.SS "\fBMuHash3072\fP (std::span< const unsigned char > in)\fR [explicit]\fP, \fR [noexcept]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void Finalize (\fBuint256\fP & out)\fR [noexcept]\fP"

.SS "\fBMuHash3072\fP & Insert (std::span< const unsigned char > in)\fR [noexcept]\fP"

.SS "\fBMuHash3072\fP & operator*= (const \fBMuHash3072\fP & mul)\fR [noexcept]\fP"

.SS "\fBMuHash3072\fP & operator/= (const \fBMuHash3072\fP & div)\fR [noexcept]\fP"

.SS "\fBMuHash3072\fP & Remove (std::span< const unsigned char > in)\fR [noexcept]\fP"

.SS "SERIALIZE_METHODS (\fBMuHash3072\fP , obj )\fR [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
