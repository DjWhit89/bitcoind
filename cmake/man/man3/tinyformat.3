.TH "tinyformat" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tinyformat
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBdetail\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBRuntimeFormat\fP"
.br
.ti -1c
.RI "struct \fBFormatStringCheck\fP"
.br
.ti -1c
.RI "class \fBformat_error\fP"
.br
.ti -1c
.RI "class \fBFormatList\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef const \fBFormatList\fP & \fBFormatListRef\fP"
.br
.RI "Reference to type-opaque format list for passing to \fBvformat()\fP\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename \fBT\fP> void \fBformatValue\fP (std::ostream &out, const char *, const char *fmtEnd, int ntrunc, const \fBT\fP &value)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> \fBdetail::FormatListN\fP< sizeof\&.\&.\&.(Args)> \fBmakeFormatList\fP (const Args &\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "void \fBvformat\fP (std::ostream &out, const char *fmt, \fBFormatListRef\fP list)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBformat\fP (std::ostream &out, \fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. \fBargs\fP)"
.br
.RI "\fBFormat\fP list of arguments to the stream according to given format string\&. "
.ti -1c
.RI "template<typename\&.\&.\&. Args> std::string \fBformat\fP (\fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBprintf\fP (\fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. \fBargs\fP)"
.br
.RI "\fBFormat\fP list of arguments to std::cout, according to the given format string\&. "
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBprintfln\fP (\fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. \fBargs\fP)"
.br
.ti -1c
.RI "template<> void \fBformatValue\fP (std::ostream &, const char *, const char *, int, const std::filesystem::path &)=delete"
.br
.ti -1c
.RI "template<> void \fBformatValue\fP (std::ostream &, const char *, const char *, int, const \fBfs::path\fP &)=delete"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> \fBbilingual_str\fP \fBformat\fP (\fButil::BilingualFmt\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. \fBargs\fP)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef const \fBFormatList\fP& \fBFormatListRef\fP"

.PP
Reference to type-opaque format list for passing to \fBvformat()\fP\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename\&.\&.\&. Args> std::string format (\fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. args)"
\fBFormat\fP list of arguments according to the given format string and return the result as a string\&. 
.SS "template<typename\&.\&.\&. Args> void format (std::ostream & out, \fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. args)"

.PP
\fBFormat\fP list of arguments to the stream according to given format string\&. 
.SS "template<typename\&.\&.\&. Args> \fBbilingual_str\fP format (\fButil::BilingualFmt\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. args)"

.SS "template<> void formatValue (std::ostream & , const char * , const char * , int , const \fBfs::path\fP & )\fR [inline]\fP, \fR [delete]\fP"

.SS "template<> void formatValue (std::ostream & , const char * , const char * , int , const std::filesystem::path & )\fR [inline]\fP, \fR [delete]\fP"

.SS "template<typename \fBT\fP> void formatValue (std::ostream & out, const char * , const char * fmtEnd, int ntrunc, const \fBT\fP & value)\fR [inline]\fP"
\fBFormat\fP a value into a stream, delegating to operator<< by default\&.

.PP
Users may override this for their own types\&. When this function is called, the stream flags will have been modified according to the format string\&. The format specification is provided in the range [fmtBegin, fmtEnd)\&. For truncating conversions, ntrunc is set to the desired maximum number of characters, for example "%\&.7s" calls formatValue with ntrunc = 7\&.

.PP
By default, \fBformatValue()\fP uses the usual stream insertion operator operator<< to format the type T, with special cases for the c and p conversions\&. 
.SS "template<typename\&.\&.\&. Args> \fBdetail::FormatListN\fP< sizeof\&.\&.\&.(Args)> makeFormatList (const Args &\&.\&.\&. args)"
Make type-agnostic format list from list of template arguments\&.

.PP
The exact return type of this function is an implementation detail and shouldn't be relied upon\&. Instead it should be stored as a \fBFormatListRef\fP:

.PP
\fBFormatListRef\fP formatList = makeFormatList( /*\&.\&.\&.*/ ); 
.SS "template<typename\&.\&.\&. Args> void printf (\fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. args)"

.PP
\fBFormat\fP list of arguments to std::cout, according to the given format string\&. 
.SS "template<typename\&.\&.\&. Args> void printfln (\fBFormatStringCheck\fP< sizeof\&.\&.\&.(Args)> fmt, const Args &\&.\&.\&. args)"

.SS "void vformat (std::ostream & out, const char * fmt, \fBFormatListRef\fP list)\fR [inline]\fP"
\fBFormat\fP list of arguments to the stream according to the given format string\&.

.PP
The name \fBvformat()\fP is chosen for the semantic similarity to vprintf(): the list of format arguments is held in a single function argument\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
