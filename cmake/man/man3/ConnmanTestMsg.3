.TH "ConnmanTestMsg" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ConnmanTestMsg
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <net\&.h>\fP
.PP
Inherits \fBCConnman\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBSetMsgProc\fP (\fBNetEventsInterface\fP *msgproc)"
.br
.ti -1c
.RI "void \fBSetPeerConnectTimeout\fP (std::chrono::seconds timeout)"
.br
.ti -1c
.RI "void \fBResetAddrCache\fP ()"
.br
.ti -1c
.RI "void \fBResetMaxOutboundCycle\fP ()"
.br
.ti -1c
.RI "std::vector< \fBCNode\fP * > \fBTestNodes\fP ()"
.br
.ti -1c
.RI "void \fBAddTestNode\fP (\fBCNode\fP &\fBnode\fP)"
.br
.ti -1c
.RI "void \fBClearTestNodes\fP ()"
.br
.ti -1c
.RI "void \fBCreateNodeFromAcceptedSocketPublic\fP (std::unique_ptr< \fBSock\fP > sock, \fBNetPermissionFlags\fP permissions, const \fBCAddress\fP &addr_bind, const \fBCAddress\fP &addr_peer)"
.br
.ti -1c
.RI "bool \fBInitBindsPublic\fP (const \fBCConnman::Options\fP &options)"
.br
.ti -1c
.RI "void \fBSocketHandlerPublic\fP ()"
.br
.ti -1c
.RI "void \fBNodeReceiveMsgBytes\fP (\fBCNode\fP &\fBnode\fP, std::span< const uint8_t > msg_bytes, bool &complete) const"
.br
.ti -1c
.RI "bool \fBReceiveMsgFrom\fP (\fBCNode\fP &\fBnode\fP, \fBCSerializedNetMsg\fP &&ser_msg) const"
.br
.ti -1c
.RI "void \fBFlushSendBuffer\fP (\fBCNode\fP &\fBnode\fP) const"
.br
.ti -1c
.RI "bool \fBAlreadyConnectedToAddressPublic\fP (const \fBCNetAddr\fP &addr)"
.br
.ti -1c
.RI "\fBCNode\fP * \fBConnectNodePublic\fP (\fBPeerManager\fP &peerman, const char *pszDest, \fBConnectionType\fP conn_type) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_unused_i2p_sessions_mutex)"
.br
.ti -1c
.RI "\fBCConnman\fP (uint64_t seed0, uint64_t seed1, \fBAddrMan\fP &addrman, const \fBNetGroupManager\fP &netgroupman, const \fBCChainParams\fP &params, bool network_active=true, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt_net=std::make_shared< \fBCThreadInterrupt\fP >())"
.br
.in -1c

Public Member Functions inherited from \fBCConnman\fP
.in +1c
.ti -1c
.RI "void \fBInit\fP (const \fBOptions\fP &connOptions) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex"
.br
.ti -1c
.RI "const bool \fBuse_v2transport\fP (\fBGetLocalServices\fP() &\fBNODE_P2P_V2\fP)"
.br
.ti -1c
.RI "\fBfor\fP (const std::string &added_node :connOptions\&.m_added_nodes)"
.br
.ti -1c
.RI "void \fBSetCaptureMessages\fP (bool cap)"
.br
.ti -1c
.RI "\fBCConnman\fP (uint64_t seed0, uint64_t seed1, \fBAddrMan\fP &addrman, const \fBNetGroupManager\fP &netgroupman, const \fBCChainParams\fP &params, bool network_active=true, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt_net=std::make_shared< \fBCThreadInterrupt\fP >())"
.br
.ti -1c
.RI "\fB~CConnman\fP ()"
.br
.ti -1c
.RI "bool \fBStart\fP (\fBCScheduler\fP &scheduler, const \fBOptions\fP &options) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex"
.br
.ti -1c
.RI "void \fBStopThreads\fP ()"
.br
.ti -1c
.RI "void \fBStopNodes\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_reconnections_mutex)"
.br
.ti -1c
.RI "void \fBStop\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_reconnections_mutex)"
.br
.ti -1c
.RI "void \fBInterrupt\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!mutexMsgProc)"
.br
.ti -1c
.RI "bool \fBGetNetworkActive\fP () const"
.br
.ti -1c
.RI "bool \fBGetUseAddrmanOutgoing\fP () const"
.br
.ti -1c
.RI "void \fBSetNetworkActive\fP (bool active)"
.br
.ti -1c
.RI "bool \fBOpenNetworkConnection\fP (const \fBCAddress\fP &addrConnect, bool fCountFailure, \fBCountingSemaphoreGrant\fP<> &&grant_outbound, const char *pszDest, \fBConnectionType\fP conn_type, bool \fBuse_v2transport\fP, const std::optional< \fBProxy\fP > &proxy_override=std::nullopt) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_unused_i2p_sessions_mutex)"
.br
.ti -1c
.RI "bool \fBCheckIncomingNonce\fP (uint64_t \fBnonce\fP)"
.br
.ti -1c
.RI "void \fBASMapHealthCheck\fP ()"
.br
.ti -1c
.RI "\fBRecursiveMutex\fP & \fBGetNodesMutex\fP () const \fBLOCK_RETURNED\fP(m_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBForNode\fP (\fBNodeId\fP id, std::function< bool(\fBCNode\fP *pnode)> func)"
.br
.ti -1c
.RI "void \fBPushMessage\fP (\fBCNode\fP *pnode, \fBCSerializedNetMsg\fP &&msg) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "void \fBForEachNode\fP (const \fBNodeFn\fP &func)"
.br
.ti -1c
.RI "void \fBForEachNode\fP (const \fBNodeFn\fP &func) const"
.br
.ti -1c
.RI "std::vector< \fBCAddress\fP > \fBGetAddressesUnsafe\fP (size_t max_addresses, size_t max_pct, std::optional< \fBNetwork\fP > network, const bool filtered=true) const"
.br
.ti -1c
.RI "std::vector< \fBCAddress\fP > \fBGetAddresses\fP (\fBCNode\fP &requestor, size_t max_addresses, size_t max_pct)"
.br
.ti -1c
.RI "void \fBSetTryNewOutboundPeer\fP (bool flag)"
.br
.ti -1c
.RI "bool \fBGetTryNewOutboundPeer\fP () const"
.br
.ti -1c
.RI "void \fBStartExtraBlockRelayPeers\fP ()"
.br
.ti -1c
.RI "int \fBGetFullOutboundConnCount\fP () const"
.br
.ti -1c
.RI "int \fBGetExtraFullOutboundCount\fP () const"
.br
.ti -1c
.RI "int \fBGetExtraBlockRelayCount\fP () const"
.br
.ti -1c
.RI "bool \fBAddNode\fP (const \fBAddedNodeParams\fP &add) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBRemoveAddedNode\fP (std::string_view \fBnode\fP) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBAddedNodesContain\fP (const \fBCAddress\fP &addr) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "std::vector< \fBAddedNodeInfo\fP > \fBGetAddedNodeInfo\fP (bool include_connected) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_added_nodes_mutex)"
.br
.ti -1c
.RI "bool \fBAddConnection\fP (const std::string &address, \fBConnectionType\fP conn_type, bool \fBuse_v2transport\fP) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_unused_i2p_sessions_mutex)"
.br
.ti -1c
.RI "size_t \fBGetNodeCount\fP (\fBConnectionDirection\fP) const"
.br
.ti -1c
.RI "std::map< \fBCNetAddr\fP, \fBLocalServiceInfo\fP > \fBgetNetLocalAddresses\fP () const"
.br
.ti -1c
.RI "uint32_t \fBGetMappedAS\fP (const \fBCNetAddr\fP &addr) const"
.br
.ti -1c
.RI "void \fBGetNodeStats\fP (std::vector< \fBCNodeStats\fP > &vstats) const"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (std::string_view \fBnode\fP)"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (const \fBCSubNet\fP &subnet)"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (const \fBCNetAddr\fP &addr)"
.br
.ti -1c
.RI "bool \fBDisconnectNode\fP (\fBNodeId\fP id)"
.br
.ti -1c
.RI "\fBServiceFlags\fP \fBGetLocalServices\fP () const"
.br
.ti -1c
.RI "void \fBAddLocalServices\fP (\fBServiceFlags\fP services)"
.br
.ti -1c
.RI "void \fBRemoveLocalServices\fP (\fBServiceFlags\fP services)"
.br
.ti -1c
.RI "uint64_t \fBGetMaxOutboundTarget\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "std::chrono::seconds \fBGetMaxOutboundTimeframe\fP () const"
.br
.ti -1c
.RI "bool \fBOutboundTargetReached\fP (bool historicalBlockServingLimit) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "uint64_t \fBGetOutboundTargetBytesLeft\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "std::chrono::seconds \fBGetMaxOutboundTimeLeftInCycle\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "uint64_t \fBGetTotalBytesRecv\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetTotalBytesSent\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_total_bytes_sent_mutex)"
.br
.ti -1c
.RI "\fBCSipHasher\fP \fBGetDeterministicRandomizer\fP (uint64_t id) const"
.br
.ti -1c
.RI "void \fBWakeMessageHandler\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!mutexMsgProc)"
.br
.ti -1c
.RI "bool \fBShouldRunInactivityChecks\fP (const \fBCNode\fP &\fBnode\fP, std::chrono::microseconds now) const"
.br
.ti -1c
.RI "bool \fBMultipleManualOrFullOutboundConns\fP (\fBNetwork\fP net) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(m_nodes_mutex)"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "void Handshake(\fBCNode\fP &\fBnode\fP, bool successfully_connected, \fBServiceFlags\fP remote_services, \fBServiceFlags\fP local_services, int32_t version, bool relay_txs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBNetEventsInterface\fP boo \fBProcessMessagesOnce\fP )(\fBCNode\fP &\fBnode\fP) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBNetEventsInterface\fP"
.br
.in -1c

Data Fields inherited from \fBCConnman\fP
.in +1c
.ti -1c
.RI "void \fB!m_total_bytes_sent_mutex\fP"
.br
.ti -1c
.RI "\fBm_local_services\fP = connOptions\&.m_local_services"
.br
.ti -1c
.RI "\fBm_max_automatic_connections\fP = connOptions\&.m_max_automatic_connections"
.br
.ti -1c
.RI "\fBm_max_outbound_full_relay\fP = std::min(MAX_OUTBOUND_FULL_RELAY_CONNECTIONS, \fBm_max_automatic_connections\fP)"
.br
.ti -1c
.RI "\fBm_max_outbound_block_relay\fP = std::min(MAX_BLOCK_RELAY_ONLY_CONNECTIONS, \fBm_max_automatic_connections\fP \- \fBm_max_outbound_full_relay\fP)"
.br
.ti -1c
.RI "\fBm_max_automatic_outbound\fP = \fBm_max_outbound_full_relay\fP + \fBm_max_outbound_block_relay\fP + m_max_feeler"
.br
.ti -1c
.RI "\fBm_max_inbound\fP = std::max(0, \fBm_max_automatic_connections\fP \- \fBm_max_automatic_outbound\fP)"
.br
.ti -1c
.RI "\fBm_use_addrman_outgoing\fP = connOptions\&.m_use_addrman_outgoing"
.br
.ti -1c
.RI "\fBm_client_interface\fP = connOptions\&.uiInterface"
.br
.ti -1c
.RI "\fBm_banman\fP = connOptions\&.m_banman"
.br
.ti -1c
.RI "\fBm_msgproc\fP = connOptions\&.m_msgproc"
.br
.ti -1c
.RI "\fBnSendBufferMaxSize\fP = connOptions\&.nSendBufferMaxSize"
.br
.ti -1c
.RI "\fBnReceiveFloodSize\fP = connOptions\&.nReceiveFloodSize"
.br
.ti -1c
.RI "\fBm_peer_connect_timeout\fP = std::chrono::seconds{connOptions\&.m_peer_connect_timeout}"
.br
.ti -1c
.RI "\fBnMaxOutboundLimit\fP = connOptions\&.nMaxOutboundLimit"
.br
.ti -1c
.RI "\fBvWhitelistedRangeIncoming\fP = connOptions\&.vWhitelistedRangeIncoming"
.br
.ti -1c
.RI "\fBvWhitelistedRangeOutgoing\fP = connOptions\&.vWhitelistedRangeOutgoing"
.br
.ti -1c
.RI "\fBm_onion_binds\fP = connOptions\&.onion_binds"
.br
.ti -1c
.RI "\fBwhitelist_forcerelay\fP = connOptions\&.whitelist_forcerelay"
.br
.ti -1c
.RI "\fBwhitelist_relay\fP = connOptions\&.whitelist_relay"
.br
.ti -1c
.RI "\fBm_capture_messages\fP = connOptions\&.m_capture_messages"
.br
.ti -1c
.RI "bool \fB!m_added_nodes_mutex\fP"
.br
.ti -1c
.RI "bool \fB!m_addr_fetches_mutex\fP"
.br
.ti -1c
.RI "bool \fB!mutexMsgProc\fP"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBCConnman\fP
.in +1c
.ti -1c
.RI "using \fBNodeFn\fP = std::function<void(\fBCNode\fP*)>"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void AddTestNode (\fBCNode\fP & node)\fR [inline]\fP"

.SS "bool AlreadyConnectedToAddressPublic (const \fBCNetAddr\fP & addr)\fR [inline]\fP"

.SS "\fBCConnman\fP (uint64_t seed0, uint64_t seed1, \fBAddrMan\fP & addrman, const \fBNetGroupManager\fP & netgroupman, const \fBCChainParams\fP & params, bool network_active = \fRtrue\fP, std::shared_ptr< \fBCThreadInterrupt\fP > interrupt_net = \fRstd::make_shared<\fBCThreadInterrupt\fP>()\fP)"

.SS "void ClearTestNodes ()\fR [inline]\fP"

.SS "\fBCNode\fP * ConnectNodePublic (\fBPeerManager\fP & peerman, const char * pszDest, \fBConnectionType\fP conn_type)"

.SS "void CreateNodeFromAcceptedSocketPublic (std::unique_ptr< \fBSock\fP > sock, \fBNetPermissionFlags\fP permissions, const \fBCAddress\fP & addr_bind, const \fBCAddress\fP & addr_peer)\fR [inline]\fP"

.SS "void FlushSendBuffer (\fBCNode\fP & node) const"

.SS "bool InitBindsPublic (const \fBCConnman::Options\fP & options)\fR [inline]\fP"

.SS "void NodeReceiveMsgBytes (\fBCNode\fP & node, std::span< const uint8_t > msg_bytes, bool & complete) const"

.SS "bool ReceiveMsgFrom (\fBCNode\fP & node, \fBCSerializedNetMsg\fP && ser_msg) const"

.SS "void ResetAddrCache ()"

.SS "void ResetMaxOutboundCycle ()"

.SS "void SetMsgProc (\fBNetEventsInterface\fP * msgproc)\fR [inline]\fP"

.SS "void SetPeerConnectTimeout (std::chrono::seconds timeout)\fR [inline]\fP"

.SS "void SocketHandlerPublic ()\fR [inline]\fP"

.SS "std::vector< \fBCNode\fP * > TestNodes ()\fR [inline]\fP"

.SH "Field Documentation"
.PP 
.SS "void Handshake(\fBCNode\fP &\fBnode\fP, bool successfully_connected, \fBServiceFlags\fP remote_services, \fBServiceFlags\fP local_services, int32_t version, bool relay_txs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBNetEventsInterface\fP boo ProcessMessagesOnce) (\fBCNode\fP &\fBnode\fP) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBNetEventsInterface\fP\fR [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
