.TH "ArgsManager" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ArgsManager
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <args\&.h>\fP
.PP
Inherited by \fBTestArgsManager\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBArg\fP"
.br
.ti -1c
.RI "struct \fBCommand\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBFlags\fP : uint32_t { \fBALLOW_ANY\fP = 0x01, \fBDISALLOW_NEGATION\fP = 0x20, \fBDISALLOW_ELISION\fP = 0x40, \fBDEBUG_ONLY\fP = 0x100, \fBNETWORK_ONLY\fP = 0x200, \fBSENSITIVE\fP = 0x400, \fBCOMMAND\fP = 0x800 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBcommon::SettingsValue\fP \fBGetSetting\fP (const std::string &arg) const"
.br
.ti -1c
.RI "std::vector< \fBcommon::SettingsValue\fP > \fBGetSettingsList\fP (const std::string &arg) const"
.br
.ti -1c
.RI "\fBArgsManager\fP ()"
.br
.ti -1c
.RI "\fB~ArgsManager\fP ()"
.br
.ti -1c
.RI "void \fBSelectConfigNetwork\fP (const std::string &network)"
.br
.ti -1c
.RI "bool \fBParseParameters\fP (int argc, const char *const argv[], std::string &error)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetConfigFilePath\fP () const"
.br
.ti -1c
.RI "void \fBSetConfigFilePath\fP (\fBfs::path\fP)"
.br
.ti -1c
.RI "bool \fBReadConfigFiles\fP (std::string &error, bool ignore_invalid_keys=false)"
.br
.ti -1c
.RI "std::set< std::string > \fBGetUnsuitableSectionOnlyArgs\fP () const"
.br
.ti -1c
.RI "std::list< \fBSectionInfo\fP > \fBGetUnrecognizedSections\fP () const"
.br
.ti -1c
.RI "std::optional< const \fBCommand\fP > \fBGetCommand\fP () const"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetBlocksDirPath\fP () const"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetDataDirBase\fP () const"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetDataDirNet\fP () const"
.br
.ti -1c
.RI "void \fBClearPathCache\fP ()"
.br
.ti -1c
.RI "std::vector< std::string > \fBGetArgs\fP (const std::string &strArg) const"
.br
.ti -1c
.RI "bool \fBIsArgSet\fP (const std::string &strArg) const"
.br
.ti -1c
.RI "bool \fBIsArgNegated\fP (const std::string &strArg) const"
.br
.ti -1c
.RI "std::string \fBGetArg\fP (const std::string &strArg, const std::string &strDefault) const"
.br
.ti -1c
.RI "std::optional< std::string > \fBGetArg\fP (const std::string &strArg) const"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetPathArg\fP (std::string arg, const \fBfs::path\fP &default_value={}) const"
.br
.ti -1c
.RI "int64_t \fBGetIntArg\fP (const std::string &strArg, int64_t nDefault) const"
.br
.ti -1c
.RI "std::optional< int64_t > \fBGetIntArg\fP (const std::string &strArg) const"
.br
.ti -1c
.RI "bool \fBGetBoolArg\fP (const std::string &strArg, bool fDefault) const"
.br
.ti -1c
.RI "std::optional< bool > \fBGetBoolArg\fP (const std::string &strArg) const"
.br
.ti -1c
.RI "bool \fBSoftSetArg\fP (const std::string &strArg, const std::string &strValue)"
.br
.ti -1c
.RI "bool \fBSoftSetBoolArg\fP (const std::string &strArg, bool fValue)"
.br
.ti -1c
.RI "void \fBForceSetArg\fP (const std::string &strArg, const std::string &strValue)"
.br
.ti -1c
.RI "\fBChainType\fP \fBGetChainType\fP () const"
.br
.ti -1c
.RI "std::string \fBGetChainTypeString\fP () const"
.br
.ti -1c
.RI "void \fBAddArg\fP (const std::string &\fBname\fP, const std::string &help, unsigned int \fBflags\fP, const \fBOptionsCategory\fP &cat)"
.br
.ti -1c
.RI "void \fBAddCommand\fP (const std::string &\fBcmd\fP, const std::string &help)"
.br
.ti -1c
.RI "void \fBAddHiddenArgs\fP (const std::vector< std::string > &\fBargs\fP)"
.br
.ti -1c
.RI "void \fBClearArgs\fP ()"
.br
.ti -1c
.RI "void \fBCheckMultipleCLIArgs\fP () const"
.br
.ti -1c
.RI "std::string \fBGetHelpMessage\fP () const"
.br
.ti -1c
.RI "std::optional< unsigned int > \fBGetArgFlags\fP (const std::string &\fBname\fP) const"
.br
.ti -1c
.RI "void \fBSetDefaultFlags\fP (std::optional< unsigned int >)"
.br
.ti -1c
.RI "bool \fBGetSettingsPath\fP (\fBfs::path\fP *filepath=nullptr, bool temp=false, bool backup=false) const"
.br
.ti -1c
.RI "bool \fBReadSettingsFile\fP (std::vector< std::string > *errors=nullptr)"
.br
.ti -1c
.RI "bool \fBWriteSettingsFile\fP (std::vector< std::string > *errors=nullptr, bool backup=false) const"
.br
.ti -1c
.RI "\fBcommon::SettingsValue\fP \fBGetPersistentSetting\fP (const std::string &\fBname\fP) const"
.br
.ti -1c
.RI "template<typename Fn> void \fBLockSettings\fP (Fn &&fn)"
.br
.ti -1c
.RI "void \fBLogArgs\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBcommon::Settings\fP m_settings \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::vector< std::string > m_command \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::string m_network \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::set< std::string > m_network_only_args \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::map< \fBOptionsCategory\fP, std::map< std::string, \fBArg\fP > > m_available_args \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::optional< unsigned int > m_default_flags \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "bool m_accept_any_command \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::list< \fBSectionInfo\fP > m_config_sections \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "std::optional< \fBfs::path\fP > m_config_path \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "\fBfs::path\fP m_cached_blocks_path \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "\fBfs::path\fP m_cached_datadir_path \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "\fBfs::path\fP m_cached_network_datadir_path \fBGUARDED_BY\fP (\fBcs_args\fP)"
.br
.ti -1c
.RI "bool \fBReadConfigStream\fP (std::istream &stream, const std::string &filepath, std::string &error, bool ignore_invalid_keys=false)"
.br
.ti -1c
.RI "bool \fBUseDefaultSection\fP (const std::string &arg) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_args\fP)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBRecursiveMutex\fP \fBcs_args\fP"
.br
.in -1c
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBFlags\fP : uint32_t"
\fBFlags\fP controlling how config and command line arguments are validated and interpreted\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIALLOW_ANY \fP
disable validation 
.TP
\f(BIDISALLOW_NEGATION \fP
disallow -nofoo syntax 
.TP
\f(BIDISALLOW_ELISION \fP
disallow -foo syntax that doesn't assign any value 
.TP
\f(BIDEBUG_ONLY \fP
.TP
\f(BINETWORK_ONLY \fP
.TP
\f(BISENSITIVE \fP
.TP
\f(BICOMMAND \fP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBArgsManager\fP ()\fR [default]\fP"

.SS "~\fBArgsManager\fP ()\fR [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void AddArg (const std::string & name, const std::string & help, unsigned int flags, const \fBOptionsCategory\fP & cat)"
Add argument 
.SS "void AddCommand (const std::string & cmd, const std::string & help)"
Add subcommand 
.SS "void AddHiddenArgs (const std::vector< std::string > & args)"
Add many hidden arguments 
.SS "void CheckMultipleCLIArgs () const"
Check CLI command args

.PP
\fBExceptions\fP
.RS 4
\fIstd::runtime_error\fP when multiple CLI_COMMAND arguments are specified 
.RE
.PP

.SS "void ClearArgs ()"
Clear available arguments 
.SS "void ClearPathCache ()"
Clear cached directory paths 
.SS "void ForceSetArg (const std::string & strArg, const std::string & strValue)"

.SS "std::optional< std::string > GetArg (const std::string & strArg) const"

.SS "std::string GetArg (const std::string & strArg, const std::string & strDefault) const"
Return string argument or default value

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to get (e\&.g\&. "-foo") 
.br
\fIstrDefault\fP (e\&.g\&. "1") 
.RE
.PP
\fBReturns\fP
.RS 4
command-line argument or default value 
.RE
.PP

.SS "std::optional< unsigned int > GetArgFlags (const std::string & name) const"
Return \fBFlags\fP for known arg\&. Return default flags for unknown arg\&. 
.SS "std::vector< std::string > GetArgs (const std::string & strArg) const"
Return a vector of strings of the given argument

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to get (e\&.g\&. "-foo") 
.RE
.PP
\fBReturns\fP
.RS 4
command-line arguments 
.RE
.PP

.SS "\fBfs::path\fP GetBlocksDirPath () const"
Get blocks directory path

.PP
\fBReturns\fP
.RS 4
Blocks path which is network specific 
.RE
.PP

.SS "std::optional< bool > GetBoolArg (const std::string & strArg) const"

.SS "bool GetBoolArg (const std::string & strArg, bool fDefault) const"
Return boolean argument or default value

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to get (e\&.g\&. "-foo") 
.br
\fIfDefault\fP (true or false) 
.RE
.PP
\fBReturns\fP
.RS 4
command-line argument or default value 
.RE
.PP

.SS "\fBChainType\fP GetChainType () const"
Returns the appropriate chain type from the program arguments\&. 
.PP
\fBReturns\fP
.RS 4
\fBChainType::MAIN\fP by default; raises runtime error if an invalid combination, or unknown chain is given\&. 
.RE
.PP

.SS "std::string GetChainTypeString () const"
Returns the appropriate chain type string from the program arguments\&. 
.PP
\fBReturns\fP
.RS 4
\fBChainType::MAIN\fP string by default; raises runtime error if an invalid combination is given\&. 
.RE
.PP

.SS "std::optional< const \fBArgsManager::Command\fP > GetCommand () const"
Get the command and command args (returns std::nullopt if no command provided) 
.SS "\fBfs::path\fP GetConfigFilePath () const"
Return config file path (read-only) 
.SS "\fBfs::path\fP GetDataDirBase () const\fR [inline]\fP"
Get data directory path

.PP
\fBReturns\fP
.RS 4
Absolute path on success, otherwise an empty path when a non-directory path would be returned 
.RE
.PP

.SS "\fBfs::path\fP GetDataDirNet () const\fR [inline]\fP"
Get data directory path with appended network identifier

.PP
\fBReturns\fP
.RS 4
Absolute path on success, otherwise an empty path when a non-directory path would be returned 
.RE
.PP

.SS "std::string GetHelpMessage () const"
Get the help string 
.SS "std::optional< int64_t > GetIntArg (const std::string & strArg) const"

.SS "int64_t GetIntArg (const std::string & strArg, int64_t nDefault) const"
Return integer argument or default value

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to get (e\&.g\&. "-foo") 
.br
\fInDefault\fP (e\&.g\&. 1) 
.RE
.PP
\fBReturns\fP
.RS 4
command-line argument (0 if invalid number) or default value 
.RE
.PP

.SS "\fBfs::path\fP GetPathArg (std::string arg, const \fBfs::path\fP & default_value = \fR{}\fP) const"
Return path argument or default value

.PP
\fBParameters\fP
.RS 4
\fIarg\fP Argument to get a path from (e\&.g\&., "-datadir", "-blocksdir" or "-walletdir") 
.br
\fIdefault_value\fP Optional default value to return instead of the empty path\&. 
.RE
.PP
\fBReturns\fP
.RS 4
normalized path if argument is set, with redundant "\&." and "\&.\&." path components and trailing separators removed (see patharg unit test for examples or implementation for details)\&. If argument is empty or not set, default_value is returned unchanged\&. 
.RE
.PP

.SS "\fBcommon::SettingsValue\fP GetPersistentSetting (const std::string & name) const"
Get current setting from config file or read/write settings file, ignoring nonpersistent command line or forced settings values\&. 
.SS "\fBcommon::SettingsValue\fP GetSetting (const std::string & arg) const"
Get setting value\&.

.PP
Result will be null if setting was unset, true if "-setting" argument was passed false if "-nosetting" argument was passed, and a string if a "-setting=value" argument was passed\&. 
.SS "std::vector< \fBcommon::SettingsValue\fP > GetSettingsList (const std::string & arg) const"
Get list of setting values\&. 
.SS "bool GetSettingsPath (\fBfs::path\fP * filepath = \fRnullptr\fP, bool temp = \fRfalse\fP, bool backup = \fRfalse\fP) const"
Get settings file path, or return false if read-write settings were disabled with -nosettings\&. 
.SS "std::list< \fBSectionInfo\fP > GetUnrecognizedSections () const"
Log warnings for unrecognized section names in the config file\&. 
.SS "std::set< std::string > GetUnsuitableSectionOnlyArgs () const"
Log warnings for options in m_section_only_args when they are specified in the default section but not overridden on the command line or in a network-specific section in the config file\&. 
.SS "\fBfs::path\fP m_cached_network_datadir_path GUARDED_BY (\fBcs_args\fP )\fR [mutable]\fP, \fR [protected]\fP"

.SS "\fBfs::path\fP m_cached_datadir_path GUARDED_BY (\fBcs_args\fP )\fR [mutable]\fP, \fR [protected]\fP"

.SS "\fBfs::path\fP m_cached_blocks_path GUARDED_BY (\fBcs_args\fP )\fR [mutable]\fP, \fR [protected]\fP"

.SS "std::optional< \fBfs::path\fP > m_config_path GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "std::list< \fBSectionInfo\fP > m_config_sections GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "bool m_accept_any_command GUARDED_BY (\fBcs_args\fP )\fR [inline]\fP, \fR [protected]\fP"

.SS "std::optional< unsigned int > m_default_flags GUARDED_BY (\fBcs_args\fP )\fR [inline]\fP, \fR [protected]\fP"

.SS "std::map< \fBOptionsCategory\fP, std::map< std::string, \fBArg\fP > > m_available_args GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "std::set< std::string > m_network_only_args GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "std::string m_network GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "std::vector< std::string > m_command GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "\fBcommon::Settings\fP m_settings GUARDED_BY (\fBcs_args\fP )\fR [protected]\fP"

.SS "bool IsArgNegated (const std::string & strArg) const"
Return true if the argument was originally passed as a negated option, i\&.e\&. -nofoo\&.

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to get (e\&.g\&. "-foo") 
.RE
.PP
\fBReturns\fP
.RS 4
true if the argument was passed negated 
.RE
.PP

.SS "bool IsArgSet (const std::string & strArg) const"
Return true if the given argument has been manually set

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to get (e\&.g\&. "-foo") 
.RE
.PP
\fBReturns\fP
.RS 4
true if the argument has been set 
.RE
.PP

.SS "template<typename Fn> void LockSettings (Fn && fn)\fR [inline]\fP"
Access settings with lock held\&. 
.SS "void LogArgs () const"
Log the config file options and the command line arguments, useful for troubleshooting\&. 
.SS "bool ParseParameters (int argc, const char *const argv[], std::string & error)\fR [nodiscard]\fP"

.SS "bool ReadConfigFiles (std::string & error, bool ignore_invalid_keys = \fRfalse\fP)\fR [nodiscard]\fP"

.SS "bool ReadConfigStream (std::istream & stream, const std::string & filepath, std::string & error, bool ignore_invalid_keys = \fRfalse\fP)\fR [nodiscard]\fP, \fR [protected]\fP"

.SS "bool ReadSettingsFile (std::vector< std::string > * errors = \fRnullptr\fP)"
Read settings file\&. Push errors to vector, or log them if null\&. 
.SS "void SelectConfigNetwork (const std::string & network)"
Select the network in use 
.SS "void SetConfigFilePath (\fBfs::path\fP path)"

.SS "void SetDefaultFlags (std::optional< unsigned int > flags)"
Set default flags to return for an unknown arg\&. 
.SS "bool SoftSetArg (const std::string & strArg, const std::string & strValue)"
Set an argument if it doesn't already have a value

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to set (e\&.g\&. "-foo") 
.br
\fIstrValue\fP Value (e\&.g\&. "1") 
.RE
.PP
\fBReturns\fP
.RS 4
true if argument gets set, false if it already had a value 
.RE
.PP

.SS "bool SoftSetBoolArg (const std::string & strArg, bool fValue)"
Set a boolean argument if it doesn't already have a value

.PP
\fBParameters\fP
.RS 4
\fIstrArg\fP Argument to set (e\&.g\&. "-foo") 
.br
\fIfValue\fP Value (e\&.g\&. false) 
.RE
.PP
\fBReturns\fP
.RS 4
true if argument gets set, false if it already had a value 
.RE
.PP

.SS "bool UseDefaultSection (const std::string & arg) const\fR [protected]\fP"
Returns true if settings values from the default section should be used, depending on the current network and whether the setting is network-specific\&. 
.SS "bool WriteSettingsFile (std::vector< std::string > * errors = \fRnullptr\fP, bool backup = \fRfalse\fP) const"
Write settings file or backup settings file\&. Push errors to vector, or log them if null\&. 
.SH "Field Documentation"
.PP 
.SS "\fBRecursiveMutex\fP cs_args\fR [mutable]\fP, \fR [protected]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
