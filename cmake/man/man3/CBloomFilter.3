.TH "CBloomFilter" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CBloomFilter
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <bloom\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCBloomFilter\fP (const unsigned int nElements, const double nFPRate, const unsigned int nTweak, unsigned char nFlagsIn)"
.br
.ti -1c
.RI "\fBCBloomFilter\fP ()"
.br
.ti -1c
.RI "\fBSERIALIZE_METHODS\fP (\fBCBloomFilter\fP, obj)"
.br
.ti -1c
.RI "void \fBinsert\fP (std::span< const unsigned char > vKey)"
.br
.ti -1c
.RI "void \fBinsert\fP (const \fBCOutPoint\fP &outpoint)"
.br
.ti -1c
.RI "bool \fBcontains\fP (std::span< const unsigned char > vKey) const"
.br
.ti -1c
.RI "bool \fBcontains\fP (const \fBCOutPoint\fP &outpoint) const"
.br
.ti -1c
.RI "bool \fBIsWithinSizeConstraints\fP () const"
.br
.ti -1c
.RI "bool \fBIsRelevantAndUpdate\fP (const \fBCTransaction\fP &tx)"
.br
.RI "Also adds any outputs which match the filter to the filter (to match their spending txes)\&. "
.in -1c
.SH "Detailed Description"
.PP 
BloomFilter is a probabilistic filter which SPV clients provide so that we can filter the transactions we send them\&.

.PP
This allows for significantly more efficient transaction and block downloads\&.

.PP
Because bloom filters are probabilistic, a SPV node can increase the false- positive rate, making us send it transactions which aren't actually its, allowing clients to trade more bandwidth for more privacy by obfuscating which keys are controlled by them\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCBloomFilter\fP (const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn, unsigned char nFlagsIn)"
Creates a new bloom filter which will provide the given fp rate when filled with the given number of elements Note that if the given parameters will result in a filter outside the bounds of the protocol limits, the filter created will be as close to the given parameters as possible within the protocol limits\&. This will apply if nFPRate is very low or nElements is unreasonably high\&. nTweak is a constant which is added to the seed value passed to the hash function It should generally always be a random value (and is largely only exposed for unit testing) nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)

.PP
The ideal size for a bloom filter with a given number of elements and false positive rate is:
.IP "\(bu" 2
nElements * log(fp rate) / ln(2)^2 We ignore filter parameters which will create a bloom filter larger than the protocol limits The ideal number of hash functions is filter size * ln(2) / number of elements Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits See https://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas 
.PP

.SS "\fBCBloomFilter\fP ()\fR [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "bool contains (const \fBCOutPoint\fP & outpoint) const"

.SS "bool contains (std::span< const unsigned char > vKey) const"

.SS "void insert (const \fBCOutPoint\fP & outpoint)"

.SS "void insert (std::span< const unsigned char > vKey)"

.SS "bool IsRelevantAndUpdate (const \fBCTransaction\fP & tx)"

.PP
Also adds any outputs which match the filter to the filter (to match their spending txes)\&. 
.SS "bool IsWithinSizeConstraints () const"
True if the size is <= MAX_BLOOM_FILTER_SIZE and the number of hash functions is <= MAX_HASH_FUNCS (catch a filter which was just deserialized which was too big) 
.SS "SERIALIZE_METHODS (\fBCBloomFilter\fP , obj )\fR [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
