.TH "V2Transport" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
V2Transport
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <net\&.h>\fP
.PP
Inherits \fBTransport\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBV2Transport\fP (\fBNodeId\fP nodeid, bool initiating) noexcept"
.br
.ti -1c
.RI "\fBV2Transport\fP (\fBNodeId\fP nodeid, bool initiating, const \fBCKey\fP &key, std::span< const std::byte > ent32, std::vector< uint8_t > garbage) noexcept"
.br
.ti -1c
.RI "bool \fBReceivedMessageComplete\fP () const noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_recv_mutex)"
.br
.ti -1c
.RI "bool \fBReceivedBytes\fP (std::span< const uint8_t > &msg_bytes) noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_recv_mutex"
.br
.ti -1c
.RI "\fBCNetMessage\fP \fBGetReceivedMessage\fP (std::chrono::microseconds time, bool &reject_message) noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_recv_mutex)"
.br
.ti -1c
.RI "bool \fBSetMessageToSend\fP (\fBCSerializedNetMsg\fP &msg) noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_send_mutex)"
.br
.ti -1c
.RI "\fBBytesToSend\fP \fBGetBytesToSend\fP (bool have_next_message) const noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_send_mutex)"
.br
.ti -1c
.RI "void \fBMarkBytesSent\fP (size_t bytes_sent) noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_send_mutex)"
.br
.ti -1c
.RI "size_t \fBGetSendMemoryUsage\fP () const noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_send_mutex)"
.br
.ti -1c
.RI "bool \fBShouldReconnectV1\fP () const noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_recv_mutex"
.br
.ti -1c
.RI "\fBInfo\fP \fBGetInfo\fP () const noexcept override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_recv_mutex)"
.br
.in -1c

Public Member Functions inherited from \fBTransport\fP
.in +1c
.ti -1c
.RI "virtual \fB~Transport\fP ()=default"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr uint32_t \fBMAX_GARBAGE_LEN\fP = 4095"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBTransport\fP
.in +1c
.ti -1c
.RI "using \fBBytesToSend\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBV2Transport\fP (\fBNodeId\fP nodeid, bool initiating)\fR [noexcept]\fP"
Construct a V2 transport with securely generated random keys\&.

.PP
\fBParameters\fP
.RS 4
\fInodeid\fP the node's \fBNodeId\fP (only for debug log output)\&. 
.br
\fIinitiating\fP whether we are the initiator side\&. 
.RE
.PP

.SS "\fBV2Transport\fP (\fBNodeId\fP nodeid, bool initiating, const \fBCKey\fP & key, std::span< const std::byte > ent32, std::vector< uint8_t > garbage)\fR [noexcept]\fP"
Construct a V2 transport with specified keys and garbage (test use only)\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBTransport::BytesToSend\fP GetBytesToSend (bool have_next_message) const\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Get bytes to send on the wire, if any, along with other information about it\&.

.PP
As a const function, it does not modify the transport's observable state, and is thus safe to be called multiple times\&.

.PP
\fBParameters\fP
.RS 4
\fIhave_next_message\fP If true, the "more" return value reports whether more will be sendable after a SetMessageToSend call\&. It is set by the caller when they know they have another message ready to send, and only care about what happens after that\&. The have_next_message argument only affects this "more" return value and nothing else\&.
.RE
.PP
Effectively, there are three possible outcomes about whether there are more bytes to send:
.IP "\(bu" 2
Yes: the transport itself has more bytes to send later\&. For example, for \fBV1Transport\fP this happens during the sending of the header of a message, when there is a non-empty payload that follows\&.
.IP "\(bu" 2
No: the transport itself has no more bytes to send, but will have bytes to send if handed a message through SetMessageToSend\&. In \fBV1Transport\fP this happens when sending the payload of a message\&.
.IP "\(bu" 2
Blocked: the transport itself has no more bytes to send, and is also incapable of sending anything more at all now, if it were handed another message to send\&. This occurs in \fBV2Transport\fP before the handshake is complete, as the encryption ciphers are not set up for sending messages before that point\&.
.PP

.PP
The boolean 'more' is true for Yes, false for Blocked, and have_next_message controls what is returned for No\&.

.PP
\fBReturns\fP
.RS 4
a \fBBytesToSend\fP object\&. The to_send member returned acts as a stream which is only ever appended to\&. This means that with the exception of MarkBytesSent (which pops bytes off the front of later to_sends), operations on the transport can only append to what is being returned\&. Also note that m_type and to_send refer to data that is internal to the transport, and calling any non-const function on this object may invalidate them\&. 
.RE
.PP

.PP
Implements \fBTransport\fP\&.
.SS "\fBTransport::Info\fP GetInfo () const\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Retrieve information about this transport\&. 
.PP
Implements \fBTransport\fP\&.
.SS "\fBCNetMessage\fP GetReceivedMessage (std::chrono::microseconds time, bool & reject_message)\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Retrieve a completed message from transport\&.

.PP
This can only be called when \fBReceivedMessageComplete()\fP is true\&.

.PP
If reject_message=true is returned the message itself is invalid, but (other than false returned by ReceivedBytes) the transport is not in an inconsistent state\&. 
.PP
Implements \fBTransport\fP\&.
.SS "size_t GetSendMemoryUsage () const\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Return the memory usage of this transport attributable to buffered data to send\&. 
.PP
Implements \fBTransport\fP\&.
.SS "void MarkBytesSent (size_t bytes_sent)\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Report how many bytes returned by the last \fBGetBytesToSend()\fP have been sent\&.

.PP
bytes_sent cannot exceed to_send\&.size() of the last \fBGetBytesToSend()\fP result\&.

.PP
If bytes_sent=0, this call has no effect\&. 
.PP
Implements \fBTransport\fP\&.
.SS "bool ReceivedBytes (std::span< const uint8_t > & msg_bytes)\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Feed wire bytes to the transport\&.

.PP
\fBReturns\fP
.RS 4
false if some bytes were invalid, in which case the transport can't be used anymore\&.
.RE
.PP
Consumed bytes are chopped off the front of msg_bytes\&. How many bytes to allocate in the receive buffer at most above what is received so far\&.
.PP
Implements \fBTransport\fP\&.
.SS "bool ReceivedMessageComplete () const\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Returns true if the current message is complete (so GetReceivedMessage can be called)\&. 
.PP
Implements \fBTransport\fP\&.
.SS "bool SetMessageToSend (\fBCSerializedNetMsg\fP & msg)\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Set the next message to send\&.

.PP
If no message can currently be set (perhaps because the previous one is not yet done being sent), returns false, and msg will be unmodified\&. Otherwise msg is enqueued (and possibly moved-from) and true is returned\&. 
.PP
Implements \fBTransport\fP\&.
.SS "bool ShouldReconnectV1 () const\fR [override]\fP, \fR [virtual]\fP, \fR [noexcept]\fP"
Whether upon disconnections, a reconnect with V1 is warranted\&. 
.PP
Implements \fBTransport\fP\&.
.SH "Field Documentation"
.PP 
.SS "uint32_t MAX_GARBAGE_LEN = 4095\fR [static]\fP, \fR [constexpr]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
