.TH "DisconnectedBlockTransactions" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DisconnectedBlockTransactions
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <disconnected_transactions\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDisconnectedBlockTransactions\fP (size_t max_mem_usage)"
.br
.ti -1c
.RI "\fB~DisconnectedBlockTransactions\fP ()"
.br
.ti -1c
.RI "size_t \fBDynamicMemoryUsage\fP () const"
.br
.ti -1c
.RI "std::vector< \fBCTransactionRef\fP > \fBAddTransactionsFromBlock\fP (const std::vector< \fBCTransactionRef\fP > &vtx)"
.br
.ti -1c
.RI "void \fBremoveForBlock\fP (const std::vector< \fBCTransactionRef\fP > &vtx)"
.br
.ti -1c
.RI "size_t \fBsize\fP () const"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "std::list< \fBCTransactionRef\fP > \fBtake\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBDisconnectedBlockTransactions\fP

.PP
During the reorg, it's desirable to re-add previously confirmed transactions to the mempool, so that anything not re-confirmed in the new chain is available to be mined\&. However, it's more efficient to wait until the reorg is complete and process all still-unconfirmed transactions at that time, since we expect most confirmed transactions to (typically) still be confirmed in the new chain, and re-accepting to the memory pool is expensive (and therefore better to not do in the middle of reorg-processing)\&. Instead, store the disconnected transactions (in order!) as we go, remove any that are included in blocks in the new chain, and then process the remaining still-unconfirmed transactions at the end\&.

.PP
Order of queuedTx: The front of the list should be the most recently-confirmed transactions (transactions at the end of vtx of blocks closer to the tip)\&. If memory usage grows too large, we trim from the front of the list\&. After trimming, transactions can be re-added to the mempool from the back of the list to the front without running into missing inputs\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBDisconnectedBlockTransactions\fP (size_t max_mem_usage)\fR [inline]\fP"

.SS "~\fBDisconnectedBlockTransactions\fP ()"

.SH "Member Function Documentation"
.PP 
.SS "std::vector< \fBCTransactionRef\fP > AddTransactionsFromBlock (const std::vector< \fBCTransactionRef\fP > & vtx)\fR [nodiscard]\fP"
Add transactions from the block, iterating through vtx in reverse order\&. Callers should call this function for blocks in descending order by block height\&. We assume that callers never pass multiple transactions with the same txid, otherwise things can go very wrong in removeForBlock due to queuedTx containing an item without a corresponding entry in iters_by_txid\&. 
.PP
\fBReturns\fP
.RS 4
vector of transactions that were evicted for size-limiting\&. 
.RE
.PP

.SS "void clear ()"

.SS "size_t DynamicMemoryUsage () const"

.SS "void removeForBlock (const std::vector< \fBCTransactionRef\fP > & vtx)"
Remove any entries that are in this block\&. 
.SS "size_t size () const\fR [inline]\fP"

.SS "std::list< \fBCTransactionRef\fP > take ()"
Clear all data structures and return the list of transactions\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
