.TH "DummyChainState" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DummyChainState
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <mempool\&.h>\fP
.PP
Inherits \fBChainstate\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBSetMempool\fP (\fBCTxMemPool\fP *mempool)"
.br
.in -1c

Public Member Functions inherited from \fBChainstate\fP
.in +1c
.ti -1c
.RI "\fBChainstate\fP (\fBCTxMemPool\fP *mempool, \fBnode::BlockManager\fP &blockman, \fBChainstateManager\fP &chainman, std::optional< \fBuint256\fP > from_snapshot_blockhash=std::nullopt)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBStoragePath\fP () const"
.br
.RI "Return path to chainstate leveldb directory\&. "
.ti -1c
.RI "\fBkernel::ChainstateRole\fP GetRole() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void \fBInitCoinsDB\fP (size_t cache_size_bytes, bool in_memory, bool should_wipe)"
.br
.ti -1c
.RI "void InitCoinsCache(size_t cache_size_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool \fBCanFlushToDisk\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBAssumeutxo\fP m_assumeutxo \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "std::optional< \fBuint256\fP > m_target_blockhash \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "std::optional< \fBAssumeutxoHash\fP > m_target_utxohash \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "\fBCCoinsViewCache\fP & \fBCoinsTip\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBCCoinsViewDB\fP & \fBCoinsDB\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBCTxMemPool\fP * \fBGetMempool\fP ()"
.br
.ti -1c
.RI "\fBCCoinsViewErrorCatcher\fP & \fBCoinsErrorCatcher\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "void \fBResetCoinsViews\fP ()"
.br
.RI "Destructs all objects related to accessing the UTXO set\&. "
.ti -1c
.RI "bool ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool \fBFlushStateToDisk\fP (\fBBlockValidationState\fP &state, \fBFlushStateMode\fP mode, int nManualPruneHeight=0)"
.br
.ti -1c
.RI "void \fBForceFlushStateToDisk\fP ()"
.br
.RI "Unconditionally flush all changes to disk\&. "
.ti -1c
.RI "void \fBPruneAndFlush\fP ()"
.br
.ti -1c
.RI "bool \fBDisconnectTip\fP (\fBBlockValidationState\fP &state, \fBDisconnectedBlockTransactions\fP *disconnectpool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.ti -1c
.RI "bool \fBReplayBlocks\fP ()"
.br
.ti -1c
.RI "bool \fBNeedsRedownload\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBLoadGenesisBlock\fP ()"
.br
.ti -1c
.RI "void \fBTryAddBlockIndexCandidate\fP (\fBCBlockIndex\fP *pindex) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBPruneBlockIndexCandidates\fP ()"
.br
.ti -1c
.RI "void ClearBlockIndexCandidates() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP * \fBFindForkInGlobalIndex\fP (const \fBCBlockLocator\fP &locator) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBLoadChainTip\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCoinsCacheSizeState\fP GetCoinsCacheSizeState() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCoinsCacheSizeState\fP GetCoinsCacheSizeState(size_t max_coins_cache_size_bytes, size_t max_mempool_size_bytes) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::string \fBToString\fP() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBRecursiveMutex\fP * \fBMempoolMutex\fP () const \fBLOCK_RETURNED\fP(\fBm_mempool\fP \-> \fBcs\fP)"
.br
.RI "Indirection necessary to make lock annotations work with an optional mempool\&. "
.in -1c
.SS "Additional Inherited Members"


Data Fields inherited from \fBChainstate\fP
.in +1c
.ti -1c
.RI "\fBnode::BlockManager\fP & \fBm_blockman\fP"
.br
.ti -1c
.RI "\fBChainstateManager\fP & \fBm_chainman\fP"
.br
.ti -1c
.RI "\fBCChain\fP \fBm_chain\fP"
.br
.ti -1c
.RI "const std::optional< \fBuint256\fP > \fBm_from_snapshot_blockhash\fP"
.br
.ti -1c
.RI "const \fBCBlockIndex\fP *SnapshotBase() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(const \fBCBlockIndex\fP *TargetBlock() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void SetTargetBlock(\fBCBlockIndex\fP *block) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void SetTargetBlockHash(\fBuint256\fP block_hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo \fBReachedTarget\fP )() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.RI "Return true if chainstate reached target block\&. "
.ti -1c
.RI "std::set< \fBCBlockIndex\fP *, \fBnode::CBlockIndexWorkComparator\fP > \fBsetBlockIndexCandidates\fP"
.br
.ti -1c
.RI "size_t \fBm_coinsdb_cache_size_bytes\fP {0}"
.br
.RI "The cache size of the on-disk coins view\&. "
.ti -1c
.RI "size_t \fBm_coinstip_cache_size_bytes\fP {0}"
.br
.RI "The cache size of the in-memory coins view\&. "
.ti -1c
.RI "bool ActivateBestChain(\fBBlockValidationState\fP &state, std::shared_ptr< const \fBCBlock\fP > pblock=nullptr) \fBLOCKS_EXCLUDED\fP(\fBDisconnectResult\fP DisconnectBlock(const \fBCBlock\fP &block, const \fBCBlockIndex\fP *pindex, \fBCCoinsViewCache\fP &view) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(boo \fBConnectBlock\fP )(const \fBCBlock\fP &block, \fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindex, \fBCCoinsViewCache\fP &view, bool fJustCheck=false) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBm_mempool\fP \fBcs\fP"
.br
.ti -1c
.RI "bool PreciousBlock(\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindex) \fBLOCKS_EXCLUDED\fP(bool \fBInvalidateBlock\fP(\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindex) \fBLOCKS_EXCLUDED\fP(void SetBlockFailureFlags(\fBCBlockIndex\fP *pindex) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(voi \fBResetBlockFailureFlags\fP )(\fBCBlockIndex\fP *pindex) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.in -1c

Protected Member Functions inherited from \fBChainstate\fP
.in +1c
.ti -1c
.RI "const \fBCBlockIndex\fP *m_cached_snapshot_base \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.RI "Cached result of LookupBlockIndex(*m_from_snapshot_blockhash)\&. "
.ti -1c
.RI "const \fBCBlockIndex\fP *m_cached_target_block \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.RI "Cached result of LookupBlockIndex(*m_target_blockhash)\&. "
.ti -1c
.RI "std::optional< const char * > m_last_script_check_reason_logged \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "bool \fBActivateBestChainStep\fP (\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindexMostWork, const std::shared_ptr< const \fBCBlock\fP > &pblock, bool &fInvalidFound, \fBConnectTrace\fP &connectTrace) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.ti -1c
.RI "bool \fBConnectTip\fP (\fBBlockValidationState\fP &state, \fBCBlockIndex\fP *pindexNew, std::shared_ptr< const \fBCBlock\fP > block_to_connect, \fBConnectTrace\fP &connectTrace, \fBDisconnectedBlockTransactions\fP &disconnectpool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.ti -1c
.RI "void \fBInvalidBlockFound\fP (\fBCBlockIndex\fP *pindex, const \fBBlockValidationState\fP &state) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBFindMostWorkChain\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBRollforwardBlock\fP (const \fBCBlockIndex\fP *pindex, \fBCCoinsViewCache\fP &inputs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBCheckForkWarningConditions\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBInvalidChainFound\fP (\fBCBlockIndex\fP *pindexNew) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBMaybeUpdateMempoolForReorg\fP (\fBDisconnectedBlockTransactions\fP &disconnectpool, bool fAddToMempool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP"
.br
.in -1c

Protected Attributes inherited from \fBChainstate\fP
.in +1c
.ti -1c
.RI "\fBMutex\fP \fBm_chainstate_mutex\fP"
.br
.ti -1c
.RI "\fBCTxMemPool\fP * \fBm_mempool\fP"
.br
.ti -1c
.RI "std::unique_ptr< \fBCoinsViews\fP > \fBm_coins_views\fP"
.br
.RI "Manages the UTXO set, which is a reflection of the contents of \fR\fBm_chain\fP\fP\&. "
.ti -1c
.RI "void \fBm_mempool\fP \fBcs\fP"
.br
.ti -1c
.RI "void UpdateTip(const \fBCBlockIndex\fP *pindexNew) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(NodeClock::time_poin \fBm_next_write\fP ) {NodeClock::time_point::max()}"
.br
.ti -1c
.RI "\fButil::Result\fP< void > InvalidateCoinsDBOnDisk() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(friend \fBChainstateManager\fP"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void SetMempool (\fBCTxMemPool\fP * mempool)\fR [inline]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
