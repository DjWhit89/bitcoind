.TH "src/common/args.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/common/args.h
.SH SYNOPSIS
.br
.PP
\fR#include <common/settings\&.h>\fP
.br
\fR#include <compat/compat\&.h>\fP
.br
\fR#include <sync\&.h>\fP
.br
\fR#include <util/chaintype\&.h>\fP
.br
\fR#include <util/fs\&.h>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <iosfwd>\fP
.br
\fR#include <list>\fP
.br
\fR#include <map>\fP
.br
\fR#include <optional>\fP
.br
\fR#include <set>\fP
.br
\fR#include <string>\fP
.br
\fR#include <variant>\fP
.br
\fR#include <vector>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBKeyInfo\fP"
.br
.ti -1c
.RI "struct \fBSectionInfo\fP"
.br
.ti -1c
.RI "class \fBArgsManager\fP"
.br
.ti -1c
.RI "struct \fBArgsManager::Arg\fP"
.br
.ti -1c
.RI "struct \fBArgsManager::Command\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBOptionsCategory\fP { \fBOPTIONS\fP, \fBCONNECTION\fP, \fBWALLET\fP, \fBWALLET_DEBUG_TEST\fP, \fBZMQ\fP, \fBDEBUG_TEST\fP, \fBCHAINPARAMS\fP, \fBNODE_RELAY\fP, \fBBLOCK_CREATION\fP, \fBRPC\fP, \fBGUI\fP, \fBCOMMANDS\fP, \fBREGISTER_COMMANDS\fP, \fBCLI_COMMANDS\fP, \fBIPC\fP, \fBHIDDEN\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBCheckDataDirOption\fP (const \fBArgsManager\fP &\fBargs\fP)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBAbsPathForConfigVal\fP (const \fBArgsManager\fP &\fBargs\fP, const \fBfs::path\fP &path, bool net_specific=true)"
.br
.ti -1c
.RI "bool \fBIsSwitchChar\fP (char c)"
.br
.ti -1c
.RI "\fBKeyInfo\fP \fBInterpretKey\fP (std::string key)"
.br
.ti -1c
.RI "std::optional< \fBcommon::SettingsValue\fP > \fBInterpretValue\fP (const \fBKeyInfo\fP &key, const std::string *value, unsigned int \fBflags\fP, std::string &error)"
.br
.ti -1c
.RI "std::string \fBSettingToString\fP (const \fBcommon::SettingsValue\fP &, const std::string &)"
.br
.ti -1c
.RI "std::optional< std::string > \fBSettingToString\fP (const \fBcommon::SettingsValue\fP &)"
.br
.ti -1c
.RI "int64_t \fBSettingToInt\fP (const \fBcommon::SettingsValue\fP &, int64_t)"
.br
.ti -1c
.RI "std::optional< int64_t > \fBSettingToInt\fP (const \fBcommon::SettingsValue\fP &)"
.br
.ti -1c
.RI "bool \fBSettingToBool\fP (const \fBcommon::SettingsValue\fP &, bool)"
.br
.ti -1c
.RI "std::optional< bool > \fBSettingToBool\fP (const \fBcommon::SettingsValue\fP &)"
.br
.ti -1c
.RI "bool \fBHelpRequested\fP (const \fBArgsManager\fP &\fBargs\fP)"
.br
.ti -1c
.RI "void \fBSetupHelpOptions\fP (\fBArgsManager\fP &\fBargs\fP)"
.br
.ti -1c
.RI "bool \fBHasTestOption\fP (const \fBArgsManager\fP &\fBargs\fP, const std::string &test_option)"
.br
.ti -1c
.RI "std::string \fBHelpMessageGroup\fP (const std::string &message)"
.br
.ti -1c
.RI "std::string \fBHelpMessageOpt\fP (const std::string &option, const std::string &message)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const char *const \fBBITCOIN_CONF_FILENAME\fP"
.br
.ti -1c
.RI "const char *const \fBBITCOIN_SETTINGS_FILENAME\fP"
.br
.ti -1c
.RI "\fBArgsManager\fP \fBgArgs\fP"
.br
.ti -1c
.RI "const std::vector< std::string > \fBTEST_OPTIONS_DOC\fP"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBOptionsCategory\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIOPTIONS \fP
.TP
\f(BICONNECTION \fP
.TP
\f(BIWALLET \fP
.TP
\f(BIWALLET_DEBUG_TEST \fP
.TP
\f(BIZMQ \fP
.TP
\f(BIDEBUG_TEST \fP
.TP
\f(BICHAINPARAMS \fP
.TP
\f(BINODE_RELAY \fP
.TP
\f(BIBLOCK_CREATION \fP
.TP
\f(BIRPC \fP
.TP
\f(BIGUI \fP
.TP
\f(BICOMMANDS \fP
.TP
\f(BIREGISTER_COMMANDS \fP
.TP
\f(BICLI_COMMANDS \fP
.TP
\f(BIIPC \fP
.TP
\f(BIHIDDEN \fP
.SH "Function Documentation"
.PP 
.SS "\fBfs::path\fP AbsPathForConfigVal (const \fBArgsManager\fP & args, const \fBfs::path\fP & path, bool net_specific = \fRtrue\fP)"
Most paths passed as configuration arguments are treated as relative to the datadir if they are not absolute\&.

.PP
\fBParameters\fP
.RS 4
\fIargs\fP Parsed arguments and settings\&. 
.br
\fIpath\fP The path to be conditionally prefixed with datadir\&. 
.br
\fInet_specific\fP Use network specific datadir variant 
.RE
.PP
\fBReturns\fP
.RS 4
The normalized path\&. 
.RE
.PP

.SS "bool CheckDataDirOption (const \fBArgsManager\fP & args)"

.SS "bool HasTestOption (const \fBArgsManager\fP & args, const std::string & test_option)"
Checks if a particular test option is present in -test command-line arg options 
.SS "std::string HelpMessageGroup (const std::string & message)"
\fBFormat\fP a string to be used as group of options in help messages

.PP
\fBParameters\fP
.RS 4
\fImessage\fP Group name (e\&.g\&. "RPC server options:") 
.RE
.PP
\fBReturns\fP
.RS 4
the formatted string 
.RE
.PP

.SS "std::string HelpMessageOpt (const std::string & option, const std::string & message)"
\fBFormat\fP a string to be used as option description in help messages

.PP
\fBParameters\fP
.RS 4
\fIoption\fP Option message (e\&.g\&. "-rpcuser=<user>") 
.br
\fImessage\fP Option description (e\&.g\&. "Username for JSON-RPC connections") 
.RE
.PP
\fBReturns\fP
.RS 4
the formatted string 
.RE
.PP

.SS "bool HelpRequested (const \fBArgsManager\fP & args)"

.PP
\fBReturns\fP
.RS 4
true if help has been requested via a command-line arg 
.RE
.PP

.SS "\fBKeyInfo\fP InterpretKey (std::string key)"
Parse "name", "section\&.name", "noname", "section\&.noname" settings keys\&.

.PP
\fBNote\fP
.RS 4
Where an option was negated can be later checked using the IsArgNegated() method\&. One use case for this is to have a way to disable options that are not normally boolean (e\&.g\&. using -nodebuglogfile to request that debug log output is not sent to any file at all)\&. 
.RE
.PP

.SS "std::optional< \fBcommon::SettingsValue\fP > InterpretValue (const \fBKeyInfo\fP & key, const std::string * value, unsigned int flags, std::string & error)"
Interpret settings value based on registered flags\&.

.PP
\fBParameters\fP
.RS 4
\fIkey\fP key information to know if key was negated 
.br
\fIvalue\fP string value of setting to be parsed 
.br
\fIflags\fP \fBArgsManager\fP registered argument flags 
.br
\fIerror\fP Error description if settings value is not valid
.RE
.PP
\fBReturns\fP
.RS 4
parsed settings value if it is valid, otherwise nullopt accompanied by a descriptive error string 
.RE
.PP

.SS "bool IsSwitchChar (char c)\fR [inline]\fP"

.SS "std::optional< bool > SettingToBool (const \fBcommon::SettingsValue\fP & value)"

.SS "bool SettingToBool (const \fBcommon::SettingsValue\fP & value, bool fDefault)"

.SS "std::optional< int64_t > SettingToInt (const \fBcommon::SettingsValue\fP & value)"

.SS "int64_t SettingToInt (const \fBcommon::SettingsValue\fP & value, int64_t nDefault)"

.SS "std::optional< std::string > SettingToString (const \fBcommon::SettingsValue\fP & value)"

.SS "std::string SettingToString (const \fBcommon::SettingsValue\fP & value, const std::string & strDefault)"

.SS "void SetupHelpOptions (\fBArgsManager\fP & args)"
Add help options to the args manager 
.SH "Variable Documentation"
.PP 
.SS "const char* const BITCOIN_CONF_FILENAME\fR [extern]\fP"

.SS "const char* const BITCOIN_SETTINGS_FILENAME\fR [extern]\fP"

.SS "\fBArgsManager\fP gArgs\fR [extern]\fP"

.SS "const std::vector<std::string> TEST_OPTIONS_DOC\fR [extern]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
