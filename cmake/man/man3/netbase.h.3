.TH "src/netbase.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/netbase.h
.SH SYNOPSIS
.br
.PP
\fR#include <compat/compat\&.h>\fP
.br
\fR#include <netaddress\&.h>\fP
.br
\fR#include <serialize\&.h>\fP
.br
\fR#include <util/sock\&.h>\fP
.br
\fR#include <util/threadinterrupt\&.h>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <functional>\fP
.br
\fR#include <memory>\fP
.br
\fR#include <string>\fP
.br
\fR#include <type_traits>\fP
.br
\fR#include <unordered_set>\fP
.br
\fR#include <vector>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBProxy\fP"
.br
.ti -1c
.RI "struct \fBProxyCredentials\fP"
.br
.ti -1c
.RI "class \fBReachableNets\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBDNSLookupFn\fP = std::function<std::vector<\fBCNetAddr\fP>(const std::string&, bool)>"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBConnectionDirection\fP { \fBNone\fP = 0, \fBIn\fP = (1U << 0), \fBOut\fP = (1U << 1), \fBBoth\fP = (In | Out) }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBIsUnixSocketPath\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "std::vector< \fBCNetAddr\fP > \fBWrappedGetAddrInfo\fP (const std::string &\fBname\fP, bool allow_lookup)"
.br
.ti -1c
.RI "enum \fBNetwork\fP \fBParseNetwork\fP (const std::string &net)"
.br
.ti -1c
.RI "std::string \fBGetNetworkName\fP (enum \fBNetwork\fP net)"
.br
.ti -1c
.RI "std::vector< std::string > \fBGetNetworkNames\fP (bool append_unroutable=false)"
.br
.ti -1c
.RI "bool \fBSetProxy\fP (enum \fBNetwork\fP net, const \fBProxy\fP &addrProxy)"
.br
.ti -1c
.RI "bool \fBGetProxy\fP (enum \fBNetwork\fP net, \fBProxy\fP &proxyInfoOut)"
.br
.ti -1c
.RI "bool \fBIsProxy\fP (const \fBCNetAddr\fP &addr)"
.br
.ti -1c
.RI "bool \fBSetNameProxy\fP (const \fBProxy\fP &addrProxy)"
.br
.ti -1c
.RI "bool \fBHaveNameProxy\fP ()"
.br
.ti -1c
.RI "bool \fBGetNameProxy\fP (\fBProxy\fP &nameProxyOut)"
.br
.ti -1c
.RI "std::vector< \fBCNetAddr\fP > \fBLookupHost\fP (const std::string &\fBname\fP, unsigned int nMaxSolutions, bool fAllowLookup, \fBDNSLookupFn\fP dns_lookup_function=\fBg_dns_lookup\fP)"
.br
.ti -1c
.RI "std::optional< \fBCNetAddr\fP > \fBLookupHost\fP (const std::string &\fBname\fP, bool fAllowLookup, \fBDNSLookupFn\fP dns_lookup_function=\fBg_dns_lookup\fP)"
.br
.ti -1c
.RI "std::vector< \fBCService\fP > \fBLookup\fP (const std::string &\fBname\fP, uint16_t portDefault, bool fAllowLookup, unsigned int nMaxSolutions, \fBDNSLookupFn\fP dns_lookup_function=\fBg_dns_lookup\fP)"
.br
.ti -1c
.RI "std::optional< \fBCService\fP > \fBLookup\fP (const std::string &\fBname\fP, uint16_t portDefault, bool fAllowLookup, \fBDNSLookupFn\fP dns_lookup_function=\fBg_dns_lookup\fP)"
.br
.ti -1c
.RI "\fBCService\fP \fBLookupNumeric\fP (const std::string &\fBname\fP, uint16_t portDefault=0, \fBDNSLookupFn\fP dns_lookup_function=\fBg_dns_lookup\fP)"
.br
.ti -1c
.RI "\fBCSubNet\fP \fBLookupSubNet\fP (const std::string &subnet_str)"
.br
.ti -1c
.RI "std::unique_ptr< \fBSock\fP > \fBCreateSockOS\fP (int domain, int type, int protocol)"
.br
.ti -1c
.RI "std::unique_ptr< \fBSock\fP > \fBConnectDirectly\fP (const \fBCService\fP &dest, bool manual_connection)"
.br
.ti -1c
.RI "std::unique_ptr< \fBSock\fP > \fBConnectThroughProxy\fP (const \fBProxy\fP &proxy, const std::string &dest, uint16_t port, bool &proxy_connection_failed)"
.br
.ti -1c
.RI "bool \fBSocks5\fP (const std::string &strDest, uint16_t port, const \fBProxyCredentials\fP *auth, const \fBSock\fP &socket)"
.br
.ti -1c
.RI "bool \fBIsBadPort\fP (uint16_t port)"
.br
.ti -1c
.RI "\fBCService\fP \fBMaybeFlipIPv6toCJDNS\fP (const \fBCService\fP &service)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "int \fBnConnectTimeout\fP"
.br
.ti -1c
.RI "bool \fBfNameLookup\fP"
.br
.ti -1c
.RI "const std::string \fBADDR_PREFIX_UNIX\fP = 'unix:'"
.br
.ti -1c
.RI "\fBReachableNets\fP \fBg_reachable_nets\fP"
.br
.ti -1c
.RI "\fBDNSLookupFn\fP \fBg_dns_lookup\fP"
.br
.ti -1c
.RI "std::function< std::unique_ptr< \fBSock\fP >(int, int, int)> \fBCreateSock\fP"
.br
.ti -1c
.RI "\fBCThreadInterrupt\fP \fBg_socks5_interrupt\fP"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBDNSLookupFn\fP = std::function<std::vector<\fBCNetAddr\fP>(const std::string&, bool)>"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBConnectionDirection\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BINone \fP
.TP
\f(BIIn \fP
.TP
\f(BIOut \fP
.TP
\f(BIBoth \fP
.SH "Function Documentation"
.PP 
.SS "std::unique_ptr< \fBSock\fP > ConnectDirectly (const \fBCService\fP & dest, bool manual_connection)"
Create a socket and try to connect to the specified service\&.

.PP
\fBParameters\fP
.RS 4
\fIdest\fP The service to which to connect\&. 
.br
\fImanual_connection\fP Whether or not the connection was manually requested (e\&.g\&. through the addnode RPC)
.RE
.PP
\fBReturns\fP
.RS 4
the connected socket if the operation succeeded, empty unique_ptr otherwise 
.RE
.PP

.SS "std::unique_ptr< \fBSock\fP > ConnectThroughProxy (const \fBProxy\fP & proxy, const std::string & dest, uint16_t port, bool & proxy_connection_failed)"
Connect to a specified destination service through a SOCKS5 proxy by first connecting to the SOCKS5 proxy\&.

.PP
\fBParameters\fP
.RS 4
\fIproxy\fP The SOCKS5 proxy\&. 
.br
\fIdest\fP The destination service to which to connect\&. 
.br
\fIport\fP The destination port\&. 
.br
\fIproxy_connection_failed\fP Whether or not the connection to the SOCKS5 proxy failed\&.
.RE
.PP
\fBReturns\fP
.RS 4
the connected socket if the operation succeeded\&. Otherwise an empty unique_ptr\&. 
.RE
.PP

.SS "std::unique_ptr< \fBSock\fP > CreateSockOS (int domain, int type, int protocol)"
Create a real socket from the operating system\&. 
.PP
\fBParameters\fP
.RS 4
\fIdomain\fP Communications domain, first argument to the socket(2) syscall\&. 
.br
\fItype\fP Type of the socket, second argument to the socket(2) syscall\&. 
.br
\fIprotocol\fP The particular protocol to be used with the socket, third argument to the socket(2) syscall\&. 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the created \fBSock\fP object or unique_ptr that owns nothing in case of failure 
.RE
.PP

.SS "bool GetNameProxy (\fBProxy\fP & nameProxyOut)"

.SS "std::string GetNetworkName (enum \fBNetwork\fP net)"

.SS "std::vector< std::string > GetNetworkNames (bool append_unroutable = \fRfalse\fP)"
Return a vector of publicly routable \fBNetwork\fP names; optionally append NET_UNROUTABLE\&. 
.SS "bool GetProxy (enum \fBNetwork\fP net, \fBProxy\fP & proxyInfoOut)"

.SS "bool HaveNameProxy ()"

.SS "bool IsBadPort (uint16_t port)"
Determine if a port is "bad" from the perspective of attempting to connect to a node on that port\&. 
.PP
\fBSee also\fP
.RS 4
doc/p2p-bad-ports\&.md 
.RE
.PP
\fBParameters\fP
.RS 4
\fIport\fP Port to check\&. 
.RE
.PP
\fBReturns\fP
.RS 4
whether the port is bad 
.RE
.PP

.SS "bool IsProxy (const \fBCNetAddr\fP & addr)"

.SS "bool IsUnixSocketPath (const std::string & name)"
Check if a string is a valid UNIX domain socket path

.PP
\fBParameters\fP
.RS 4
\fIname\fP The string provided by the user representing a local path
.RE
.PP
\fBReturns\fP
.RS 4
Whether the string has proper format, length, and points to an existing file path 
.RE
.PP

.SS "std::optional< \fBCService\fP > Lookup (const std::string & name, uint16_t portDefault, bool fAllowLookup, \fBDNSLookupFn\fP dns_lookup_function = \fR\fBg_dns_lookup\fP\fP)"
Resolve a service string to its first corresponding service\&.

.PP
\fBSee also\fP
.RS 4
\fBLookup(const std::string&, uint16_t, bool, unsigned int, DNSLookupFn)\fP \fBfor\fP additional parameter descriptions\&. 
.RE
.PP

.SS "std::vector< \fBCService\fP > Lookup (const std::string & name, uint16_t portDefault, bool fAllowLookup, unsigned int nMaxSolutions, \fBDNSLookupFn\fP dns_lookup_function = \fR\fBg_dns_lookup\fP\fP)"
Resolve a service string to its corresponding service\&.

.PP
\fBParameters\fP
.RS 4
\fIname\fP The string representing a service\&. Could be a name or a numerical IP address (IPv6 addresses should be in their disambiguated bracketed form), optionally followed by a uint16_t port number\&. (e\&.g\&. example\&.com:8333 or
.br
\fIportDefault\fP The default port for resulting services if not specified by the service string\&. 
.br
\fIfAllowLookup\fP Whether or not hostname lookups are permitted\&. If yes, external queries may be performed\&. 
.br
\fInMaxSolutions\fP The maximum number of results we want, specifying 0 means "as many solutions as we get\&."
.RE
.PP
\fBReturns\fP
.RS 4
The resulting services to which the specified service string resolved\&. 
.RE
.PP

.SS "std::optional< \fBCNetAddr\fP > LookupHost (const std::string & name, bool fAllowLookup, \fBDNSLookupFn\fP dns_lookup_function = \fR\fBg_dns_lookup\fP\fP)"
Resolve a host string to its first corresponding network address\&.

.PP
\fBReturns\fP
.RS 4
The resulting network address to which the specified host string resolved or std::nullopt if host does not resolve to an address\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBLookupHost(const std::string&, unsigned int, bool, DNSLookupFn)\fP \fBfor\fP additional parameter descriptions\&. 
.RE
.PP

.SS "std::vector< \fBCNetAddr\fP > LookupHost (const std::string & name, unsigned int nMaxSolutions, bool fAllowLookup, \fBDNSLookupFn\fP dns_lookup_function = \fR\fBg_dns_lookup\fP\fP)"
Resolve a host string to its corresponding network addresses\&.

.PP
\fBParameters\fP
.RS 4
\fIname\fP The string representing a host\&. Could be a name or a numerical IP address (IPv6 addresses in their bracketed form are allowed)\&.
.RE
.PP
\fBReturns\fP
.RS 4
The resulting network addresses to which the specified host string resolved\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBLookup(const std::string&, uint16_t, bool, unsigned int, DNSLookupFn)\fP \fBfor\fP additional parameter descriptions\&. 
.RE
.PP

.SS "\fBCService\fP LookupNumeric (const std::string & name, uint16_t portDefault = \fR0\fP, \fBDNSLookupFn\fP dns_lookup_function = \fR\fBg_dns_lookup\fP\fP)"
Resolve a service string with a numeric IP to its first corresponding service\&.

.PP
\fBReturns\fP
.RS 4
The resulting \fBCService\fP if the resolution was successful, [::]:0 otherwise\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBLookup(const std::string&, uint16_t, bool, unsigned int, DNSLookupFn)\fP \fBfor\fP additional parameter descriptions\&. 
.RE
.PP

.SS "\fBCSubNet\fP LookupSubNet (const std::string & subnet_str)"
Parse and resolve a specified subnet string into the appropriate internal representation\&.

.PP
\fBParameters\fP
.RS 4
\fIsubnet_str\fP A string representation of a subnet of the form \fRnetwork address [ "/", ( CIDR-style suffix | netmask ) ]\fP e\&.g\&. "2001:db8::/32", "192\&.0\&.2\&.0/255\&.255\&.255\&.0" or "8\&.8\&.8\&.8"\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a \fBCSubNet\fP object (that may or may not be valid)\&. 
.RE
.PP

.SS "\fBCService\fP MaybeFlipIPv6toCJDNS (const \fBCService\fP & service)"
If an IPv6 address belongs to the address range used by the CJDNS network and the CJDNS network is reachable (-cjdnsreachable config is set), then change the type from NET_IPV6 to NET_CJDNS\&. 
.PP
\fBParameters\fP
.RS 4
\fIservice\fP Address to potentially convert\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a copy of \fRservice\fP either unmodified or changed to CJDNS\&. 
.RE
.PP

.SS "enum \fBNetwork\fP ParseNetwork (const std::string & net)"

.SS "bool SetNameProxy (const \fBProxy\fP & addrProxy)"
Set the name proxy to use for all connections to nodes specified by a hostname\&. After setting this proxy, connecting to a node specified by a hostname won't result in a local lookup of said hostname, rather, connect to the node by asking the name proxy for a proxy connection to the hostname, effectively delegating the hostname lookup to the specified proxy\&.

.PP
This delegation increases privacy for those who set the name proxy as they no longer leak their external hostname queries to their DNS servers\&.

.PP
\fBReturns\fP
.RS 4
Whether or not the operation succeeded\&.
.RE
.PP
\fBNote\fP
.RS 4
SOCKS5's support for UDP-over-SOCKS5 has been considered, but no SOCK5 server in common use (most notably Tor) actually implements UDP support, and a DNS resolver is beyond the scope of this project\&. 
.RE
.PP

.SS "bool SetProxy (enum \fBNetwork\fP net, const \fBProxy\fP & addrProxy)"

.SS "bool Socks5 (const std::string & strDest, uint16_t port, const \fBProxyCredentials\fP * auth, const \fBSock\fP & socket)"
Connect to a specified destination service through an already connected SOCKS5 proxy\&.

.PP
\fBParameters\fP
.RS 4
\fIstrDest\fP The destination fully-qualified domain name\&. 
.br
\fIport\fP The destination port\&. 
.br
\fIauth\fP The credentials with which to authenticate with the specified SOCKS5 proxy\&. 
.br
\fIsocket\fP The SOCKS5 proxy socket\&.
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not the operation succeeded\&.
.RE
.PP
\fBNote\fP
.RS 4
The specified SOCKS5 proxy socket must already be connected to the SOCKS5 proxy\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fRRFC1928: SOCKS Protocol Version 5\fP 
.RE
.PP

.SS "std::vector< \fBCNetAddr\fP > WrappedGetAddrInfo (const std::string & name, bool allow_lookup)"
\fBWrapper\fP for getaddrinfo(3)\&. Do not use directly: call Lookup/LookupHost/LookupNumeric/LookupSubNet\&. 
.SH "Variable Documentation"
.PP 
.SS "const std::string ADDR_PREFIX_UNIX = 'unix:'"
Prefix for unix domain socket addresses (which are local filesystem paths) 
.SS "std::function<std::unique_ptr<\fBSock\fP>(int, int, int)> CreateSock\fR [extern]\fP"
Socket factory\&. Defaults to \fR\fBCreateSockOS()\fP\fP, but can be overridden by unit tests\&. 
.SS "bool fNameLookup\fR [extern]\fP"

.SS "\fBDNSLookupFn\fP g_dns_lookup\fR [extern]\fP"

.SS "\fBReachableNets\fP g_reachable_nets\fR [extern]\fP"

.SS "\fBCThreadInterrupt\fP g_socks5_interrupt\fR [extern]\fP"
Interrupt SOCKS5 reads or writes\&. 
.SS "int nConnectTimeout\fR [extern]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
