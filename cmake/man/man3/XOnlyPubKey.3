.TH "XOnlyPubKey" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
XOnlyPubKey
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <pubkey\&.h>\fP
.PP
Inherited by \fBWitnessV1Taproot\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBXOnlyPubKey\fP ()=default"
.br
.ti -1c
.RI "\fBXOnlyPubKey\fP (const \fBXOnlyPubKey\fP &)=default"
.br
.ti -1c
.RI "\fBXOnlyPubKey\fP & \fBoperator=\fP (const \fBXOnlyPubKey\fP &)=default"
.br
.ti -1c
.RI "bool \fBIsFullyValid\fP () const"
.br
.ti -1c
.RI "bool \fBIsNull\fP () const"
.br
.ti -1c
.RI "constexpr \fBXOnlyPubKey\fP (std::span< const unsigned char > bytes)"
.br
.ti -1c
.RI "\fBXOnlyPubKey\fP (const \fBCPubKey\fP &pubkey)"
.br
.ti -1c
.RI "bool \fBVerifySchnorr\fP (const \fBuint256\fP &msg, std::span< const unsigned char > sigbytes) const"
.br
.ti -1c
.RI "\fBuint256\fP \fBComputeTapTweakHash\fP (const \fBuint256\fP *merkle_root) const"
.br
.ti -1c
.RI "bool \fBCheckTapTweak\fP (const \fBXOnlyPubKey\fP &internal, const \fBuint256\fP &merkle_root, bool parity) const"
.br
.ti -1c
.RI "std::optional< std::pair< \fBXOnlyPubKey\fP, bool > > \fBCreateTapTweak\fP (const \fBuint256\fP *merkle_root) const"
.br
.ti -1c
.RI "std::vector< \fBCKeyID\fP > \fBGetKeyIDs\fP () const"
.br
.ti -1c
.RI "std::vector< \fBCPubKey\fP > \fBGetCPubKeys\fP () const"
.br
.ti -1c
.RI "\fBCPubKey\fP \fBGetEvenCorrespondingCPubKey\fP () const"
.br
.ti -1c
.RI "const unsigned char & \fBoperator[]\fP (int pos) const"
.br
.ti -1c
.RI "const unsigned char * \fBdata\fP () const"
.br
.ti -1c
.RI "const unsigned char * \fBbegin\fP () const"
.br
.ti -1c
.RI "const unsigned char * \fBend\fP () const"
.br
.ti -1c
.RI "unsigned char * \fBdata\fP ()"
.br
.ti -1c
.RI "unsigned char * \fBbegin\fP ()"
.br
.ti -1c
.RI "unsigned char * \fBend\fP ()"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBXOnlyPubKey\fP &other) const"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBXOnlyPubKey\fP &other) const"
.br
.ti -1c
.RI "\fBSERIALIZE_METHODS\fP (\fBXOnlyPubKey\fP, obj)"
.br
.RI "Implement serialization without length prefixes since it is a fixed length\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static constexpr size_t \fBsize\fP ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const \fBXOnlyPubKey\fP \fBNUMS_H\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBXOnlyPubKey\fP ()\fR [default]\fP"
Construct an empty x-only pubkey\&. 
.SS "\fBXOnlyPubKey\fP (const \fBXOnlyPubKey\fP & )\fR [default]\fP"

.SS "\fBXOnlyPubKey\fP (std::span< const unsigned char > bytes)\fR [inline]\fP, \fR [explicit]\fP, \fR [constexpr]\fP"
Construct an x-only pubkey from exactly 32 bytes\&. 
.SS "\fBXOnlyPubKey\fP (const \fBCPubKey\fP & pubkey)\fR [inline]\fP, \fR [explicit]\fP"
Construct an x-only pubkey from a normal pubkey\&. 
.SH "Member Function Documentation"
.PP 
.SS "unsigned char * begin ()\fR [inline]\fP"

.SS "const unsigned char * begin () const\fR [inline]\fP"

.SS "bool CheckTapTweak (const \fBXOnlyPubKey\fP & internal, const \fBuint256\fP & merkle_root, bool parity) const"
Verify that this is a Taproot tweaked output point, against a specified internal key, Merkle root, and parity\&. 
.SS "\fBuint256\fP ComputeTapTweakHash (const \fBuint256\fP * merkle_root) const"
Compute the Taproot tweak as specified in BIP341, with *this as internal key:
.IP "\(bu" 2
if merkle_root == nullptr: H_TapTweak(xonly_pubkey)
.IP "\(bu" 2
otherwise: H_TapTweak(xonly_pubkey || *merkle_root)
.PP

.PP
Note that the behavior of this function with merkle_root != nullptr is consensus critical\&. 
.SS "std::optional< std::pair< \fBXOnlyPubKey\fP, bool > > CreateTapTweak (const \fBuint256\fP * merkle_root) const"
Construct a Taproot tweaked output point with this point as internal key\&. 
.SS "unsigned char * data ()\fR [inline]\fP"

.SS "const unsigned char * data () const\fR [inline]\fP"

.SS "unsigned char * end ()\fR [inline]\fP"

.SS "const unsigned char * end () const\fR [inline]\fP"

.SS "std::vector< \fBCPubKey\fP > GetCPubKeys () const"
Returns this \fBXOnlyPubKey\fP with 0x02 and 0x03 prefixes 
.SS "\fBCPubKey\fP GetEvenCorrespondingCPubKey () const"

.SS "std::vector< \fBCKeyID\fP > GetKeyIDs () const"
Returns a list of CKeyIDs for the CPubKeys that could have been used to create this \fBXOnlyPubKey\fP\&. As the \fBCKeyID\fP is the Hash160(full pubkey), the produced CKeyIDs are for the versions of this \fBXOnlyPubKey\fP with 0x02 and 0x03 prefixes\&. This is needed for key lookups since keys are indexed by \fBCKeyID\fP\&. 
.SS "bool IsFullyValid () const"
Determine if this pubkey is fully valid\&. This is true for approximately 50% of all possible 32-byte arrays\&. If false, VerifySchnorr, CheckTapTweak and CreateTapTweak will always fail\&. 
.SS "bool IsNull () const\fR [inline]\fP"
Test whether this is the 0 key (the result of default construction)\&. This implies !IsFullyValid()\&. 
.SS "bool operator< (const \fBXOnlyPubKey\fP & other) const\fR [inline]\fP"

.SS "\fBXOnlyPubKey\fP & operator= (const \fBXOnlyPubKey\fP & )\fR [default]\fP"

.SS "bool operator== (const \fBXOnlyPubKey\fP & other) const\fR [inline]\fP"

.SS "const unsigned char & operator[] (int pos) const\fR [inline]\fP"

.SS "SERIALIZE_METHODS (\fBXOnlyPubKey\fP , obj )\fR [inline]\fP"

.PP
Implement serialization without length prefixes since it is a fixed length\&. 
.SS "constexpr size_t size ()\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP"

.SS "bool VerifySchnorr (const \fBuint256\fP & msg, std::span< const unsigned char > sigbytes) const"
Verify a Schnorr signature against this public key\&.

.PP
sigbytes must be exactly 64 bytes\&. 
.SH "Field Documentation"
.PP 
.SS "\fBXOnlyPubKey\fP NUMS_H\fR [static]\fP, \fR [constexpr]\fP"
\fBInitial value:\fP
.nf
{
    
    []() consteval { return XOnlyPubKey{"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0"_hex_u8}; }(),
}
.PP
.fi
Nothing Up My Sleeve point H Used as an internal key for provably disabling the key path spend see BIP341 for more details

.PP
Nothing Up My Sleeve (NUMS) point

.PP
NUMS_H is a point with an unknown discrete logarithm, constructed by taking the \fBsha256\fP of 'g' (uncompressed encoding), which happens to be a point on the curve\&.

.PP
For an example script for calculating H, refer to the unit tests in \&./test/functional/test_framework/crypto/secp256k1\&.py 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
