.TH "common" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
common
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBConfigError\fP"
.br
.ti -1c
.RI "struct \fBSettings\fP"
.br
.ti -1c
.RI "struct \fBSettingsSpan\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBSettingsAbortFn\fP = std::function<bool(const \fBbilingual_str\fP& message, const std::vector<std::string>& details)>"
.br
.ti -1c
.RI "using \fBSettingsValue\fP = \fBUniValue\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBConfigStatus\fP { \fBFAILED\fP, \fBFAILED_WRITE\fP, \fBABORTED\fP }"
.br
.ti -1c
.RI "enum class \fBPSBTError\fP { \fBMISSING_INPUTS\fP, \fBSIGHASH_MISMATCH\fP, \fBEXTERNAL_SIGNER_NOT_FOUND\fP, \fBEXTERNAL_SIGNER_FAILED\fP, \fBUNSUPPORTED\fP, \fBINCOMPLETE\fP, \fBOK\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "std::optional< \fBConfigError\fP > \fBInitConfig\fP (\fBArgsManager\fP &\fBargs\fP, \fBSettingsAbortFn\fP settings_abort_fn)"
.br
.ti -1c
.RI "std::string \fBStringForFeeReason\fP (\fBFeeReason\fP reason)"
.br
.ti -1c
.RI "const std::vector< std::pair< std::string, \fBFeeEstimateMode\fP > > & \fBFeeModeMap\fP ()"
.br
.ti -1c
.RI "std::string \fBFeeModeInfo\fP (const std::pair< std::string, \fBFeeEstimateMode\fP > &mode, std::string &default_info)"
.br
.ti -1c
.RI "std::string \fBFeeModesDetail\fP (std::string default_info)"
.br
.ti -1c
.RI "std::string \fBFeeModes\fP (const std::string &delimiter)"
.br
.ti -1c
.RI "std::string \fBInvalidEstimateModeErrorMessage\fP ()"
.br
.ti -1c
.RI "bool \fBFeeModeFromString\fP (std::string_view mode_string, \fBFeeEstimateMode\fP &fee_estimate_mode)"
.br
.ti -1c
.RI "\fBbilingual_str\fP \fBPSBTErrorString\fP (\fBPSBTError\fP err)"
.br
.ti -1c
.RI "\fBbilingual_str\fP \fBTransactionErrorString\fP (const \fBTransactionError\fP err)"
.br
.ti -1c
.RI "\fBbilingual_str\fP \fBResolveErrMsg\fP (const std::string &optname, const std::string &strBind)"
.br
.ti -1c
.RI "\fBbilingual_str\fP \fBInvalidPortErrMsg\fP (const std::string &optname, const std::string &invalid_value)"
.br
.ti -1c
.RI "\fBbilingual_str\fP \fBAmountHighWarn\fP (const std::string &optname)"
.br
.ti -1c
.RI "\fBbilingual_str\fP \fBAmountErrMsg\fP (const std::string &optname, const std::string &strValue)"
.br
.ti -1c
.RI "std::string \fBFeeModeInfo\fP (std::pair< std::string, \fBFeeEstimateMode\fP > &mode)"
.br
.ti -1c
.RI "bool \fBReadSettings\fP (const \fBfs::path\fP &path, std::map< std::string, \fBSettingsValue\fP > &values, std::vector< std::string > &errors)"
.br
.RI "Read settings file\&. "
.ti -1c
.RI "bool \fBWriteSettings\fP (const \fBfs::path\fP &path, const std::map< std::string, \fBSettingsValue\fP > &values, std::vector< std::string > &errors)"
.br
.RI "Write settings file\&. "
.ti -1c
.RI "\fBSettingsValue\fP \fBGetSetting\fP (const \fBSettings\fP &settings, const std::string &section, const std::string &\fBname\fP, bool ignore_default_section_config, bool ignore_nonpersistent, bool get_chain_type)"
.br
.ti -1c
.RI "std::vector< \fBSettingsValue\fP > \fBGetSettingsList\fP (const \fBSettings\fP &settings, const std::string &section, const std::string &\fBname\fP, bool ignore_default_section_config)"
.br
.ti -1c
.RI "bool \fBOnlyHasDefaultSectionSetting\fP (const \fBSettings\fP &settings, const std::string &section, const std::string &\fBname\fP)"
.br
.ti -1c
.RI "template<typename Map, typename Key> auto \fBFindKey\fP (Map &&map, Key &&key) \-> decltype(&map\&.at(key))"
.br
.RI "Map lookup helper\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBSettingsAbortFn\fP = std::function<bool(const \fBbilingual_str\fP& message, const std::vector<std::string>& details)>"
Callback function to let the user decide whether to abort loading if settings\&.json file exists and can't be parsed, or to ignore the error and overwrite the file\&. 
.SS "using \fBSettingsValue\fP = \fBUniValue\fP"
\fBSettings\fP value type (string/integer/boolean/null variant)\&.

.PP
\fBNote\fP
.RS 4
\fBUniValue\fP is used here for convenience and because it can be easily serialized in a readable format\&. But any other variant type that can be assigned strings, int64_t, and bool values and has get_str(), getInt<int64_t>(), get_bool(), isNum(), isBool(), isFalse(), isTrue() and isNull() methods can be substituted if there's a need to move away from \fBUniValue\fP\&. (An implementation with boost::variant was posted at https://github.com/bitcoin/bitcoin/pull/15934/files#r337691812) 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBConfigStatus\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIFAILED \fP
Failed generically\&. 
.TP
\f(BIFAILED_WRITE \fP
Failed to write settings\&.json\&. 
.TP
\f(BIABORTED \fP
Aborted by user\&. 
.SS "enum class \fBPSBTError\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIMISSING_INPUTS \fP
.TP
\f(BISIGHASH_MISMATCH \fP
.TP
\f(BIEXTERNAL_SIGNER_NOT_FOUND \fP
.TP
\f(BIEXTERNAL_SIGNER_FAILED \fP
.TP
\f(BIUNSUPPORTED \fP
.TP
\f(BIINCOMPLETE \fP
.TP
\f(BIOK \fP
.SH "Function Documentation"
.PP 
.SS "\fBbilingual_str\fP AmountErrMsg (const std::string & optname, const std::string & strValue)"

.SS "\fBbilingual_str\fP AmountHighWarn (const std::string & optname)"

.SS "bool FeeModeFromString (std::string_view mode_string, \fBFeeEstimateMode\fP & fee_estimate_mode)"

.SS "std::string FeeModeInfo (const std::pair< std::string, \fBFeeEstimateMode\fP > & mode, std::string & default_info)"

.SS "std::string FeeModeInfo (std::pair< std::string, \fBFeeEstimateMode\fP > & mode)"

.SS "const std::vector< std::pair< std::string, \fBFeeEstimateMode\fP > > & FeeModeMap ()"

.SS "std::string FeeModes (const std::string & delimiter)"

.SS "std::string FeeModesDetail (std::string default_info)"

.SS "template<typename Map, typename Key> auto FindKey (Map && map, Key && key)\->decltype(&map\&.at(key))"

.PP
Map lookup helper\&. 
.SS "\fBSettingsValue\fP GetSetting (const \fBSettings\fP & settings, const std::string & section, const std::string & name, bool ignore_default_section_config, bool ignore_nonpersistent, bool get_chain_type)"
Get settings value from combined sources: forced settings, command line arguments, runtime read-write settings, and the read-only config file\&.

.PP
\fBParameters\fP
.RS 4
\fIignore_default_section_config\fP - ignore values in the default section of the config file (part before any [section] keywords) 
.br
\fIignore_nonpersistent\fP - ignore non-persistent settings values (forced settings values and values specified on the command line)\&. Only return settings in the read-only config and read-write settings files\&. 
.br
\fIget_chain_type\fP - enable special backwards compatible behavior for GetChainType 
.RE
.PP

.SS "std::vector< \fBSettingsValue\fP > GetSettingsList (const \fBSettings\fP & settings, const std::string & section, const std::string & name, bool ignore_default_section_config)"
Get combined setting value similar to \fBGetSetting()\fP, except if setting was specified multiple times, return a list of all the values specified\&. 
.SS "std::optional< \fBConfigError\fP > InitConfig (\fBArgsManager\fP & args, \fBSettingsAbortFn\fP settings_abort_fn)"

.SS "std::string InvalidEstimateModeErrorMessage ()"

.SS "\fBbilingual_str\fP InvalidPortErrMsg (const std::string & optname, const std::string & invalid_value)"

.SS "bool OnlyHasDefaultSectionSetting (const \fBSettings\fP & settings, const std::string & section, const std::string & name)"
Return true if a setting is set in the default config file section, and not overridden by a higher priority command-line or network section value\&.

.PP
This is used to provide user warnings about values that might be getting ignored unintentionally\&. 
.SS "\fBbilingual_str\fP PSBTErrorString (\fBPSBTError\fP err)"

.SS "bool ReadSettings (const \fBfs::path\fP & path, std::map< std::string, \fBSettingsValue\fP > & values, std::vector< std::string > & errors)"

.PP
Read settings file\&. 
.SS "\fBbilingual_str\fP ResolveErrMsg (const std::string & optname, const std::string & strBind)"

.SS "std::string StringForFeeReason (\fBFeeReason\fP reason)"

.SS "\fBbilingual_str\fP TransactionErrorString (const \fBTransactionError\fP err)"

.SS "bool WriteSettings (const \fBfs::path\fP & path, const std::map< std::string, \fBSettingsValue\fP > & values, std::vector< std::string > & errors)"

.PP
Write settings file\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
