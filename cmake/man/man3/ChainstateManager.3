.TH "ChainstateManager" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ChainstateManager
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <validation\&.h>\fP
.PP
Inherited by \fBTestChainstateManager\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBOptions\fP = \fBkernel::ChainstateManagerOpts\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBChainstateManager\fP (const \fButil::SignalInterrupt\fP &interrupt, \fBOptions\fP\fBOptions\fP options, \fBnode::BlockManager::Options\fP blockman_options)"
.br
.ti -1c
.RI "const \fBCChainParams\fP & \fBGetParams\fP () const"
.br
.ti -1c
.RI "const \fBConsensus::Params\fP & \fBGetConsensus\fP () const"
.br
.ti -1c
.RI "bool \fBShouldCheckBlockIndex\fP () const"
.br
.ti -1c
.RI "const \fBarith_uint256\fP & \fBMinimumChainWork\fP () const"
.br
.ti -1c
.RI "const \fBuint256\fP & \fBAssumedValidBlock\fP () const"
.br
.ti -1c
.RI "\fBkernel::Notifications\fP & \fBGetNotifications\fP () const"
.br
.ti -1c
.RI "void \fBCheckBlockIndex\fP () const"
.br
.ti -1c
.RI "\fBRecursiveMutex\fP & \fBGetMutex\fP () const \fBLOCK_RETURNED\fP("
.br
.ti -1c
.RI "int32_t nBlockSequenceId \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "void \fBResetBlockSequenceCounters\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBCBlockIndex\fP *m_best_header \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "\fBChainstate\fP * \fBHistoricalChainstate\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.RI "Return historical chainstate targeting a specific block, if any\&. "
.ti -1c
.RI "\fBChainstate\fP & \fBValidatedChainstate\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "std::unique_ptr< \fBChainstate\fP > \fBRemoveChainstate\fP (\fBChainstate\fP &chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.RI "Remove a chainstate\&. "
.ti -1c
.RI "\fBnode::BlockMap\fP & \fBBlockIndex\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "bool \fBIsInitialBlockDownload\fP () const"
.br
.ti -1c
.RI "double \fBGuessVerificationProgress\fP (const \fBCBlockIndex\fP *pindex) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "void \fBLoadExternalBlockFile\fP (\fBAutoFile\fP &file_in, \fBFlatFilePos\fP *dbp=nullptr, std::multimap< \fBuint256\fP, \fBFlatFilePos\fP > *blocks_with_unknown_parent=nullptr)"
.br
.ti -1c
.RI "bool \fBProcessNewBlock\fP (const std::shared_ptr< const \fBCBlock\fP > &block, bool force_processing, bool min_pow_checked, bool *new_block) \fBLOCKS_EXCLUDED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBProcessNewBlockHeaders\fP (std::span< const \fBCBlockHeader\fP > headers, bool min_pow_checked, \fBBlockValidationState\fP &state, const \fBCBlockIndex\fP **ppindex=nullptr) \fBLOCKS_EXCLUDED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBAcceptBlock\fP (const std::shared_ptr< const \fBCBlock\fP > &pblock, \fBBlockValidationState\fP &state, \fBCBlockIndex\fP **ppindex, bool fRequested, const \fBFlatFilePos\fP *dbp, bool *fNewBlock, bool min_pow_checked) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBReceivedBlockTransactions\fP (const \fBCBlock\fP &block, \fBCBlockIndex\fP *pindexNew, const \fBFlatFilePos\fP &pos) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBMempoolAcceptResult\fP \fBProcessTransaction\fP (const \fBCTransactionRef\fP &tx, bool test_accept=false) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBLoadBlockIndex\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.RI "Load the block tree and coins database from disk, initializing state if we're running with -reindex\&. "
.ti -1c
.RI "void MaybeRebalanceCaches() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void \fBUpdateUncommittedBlockStructures\fP (\fBCBlock\fP &block, const \fBCBlockIndex\fP *pindexPrev) const"
.br
.ti -1c
.RI "std::vector< unsigned char > \fBGenerateCoinbaseCommitment\fP (\fBCBlock\fP &block, const \fBCBlockIndex\fP *pindexPrev) const"
.br
.ti -1c
.RI "void \fBReportHeadersPresync\fP (const \fBarith_uint256\fP &work, int64_t height, int64_t timestamp)"
.br
.ti -1c
.RI "\fB~ChainstateManager\fP ()"
.br
.ti -1c
.RI "std::vector< std::unique_ptr< \fBChainstate\fP > > m_chainstates \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBChainstate\fP & \fBActiveChainstate\fP () const"
.br
.ti -1c
.RI "\fBCChain\fP & \fBActiveChain\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "int \fBActiveHeight\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBActiveTip\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.in -1c
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "std::function< void()> \fBsnapshot_download_completed\fP = std::function<void()>()"
.br
.ti -1c
.RI "const \fButil::SignalInterrupt\fP & \fBm_interrupt\fP"
.br
.ti -1c
.RI "const \fBOptions\fP\fBOptions\fP \fBm_options\fP"
.br
.ti -1c
.RI "\fBnode::BlockManager\fP \fBm_blockman\fP"
.br
.ti -1c
.RI "\fBValidationCache\fP \fBm_validation_cache\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fBm_cached_finished_ibd\fP {false}"
.br
.ti -1c
.RI "int32_t \fBnBlockReverseSequenceId\fP = \-1"
.br
.ti -1c
.RI "\fBarith_uint256\fP \fBnLastPreciousChainwork\fP = 0"
.br
.ti -1c
.RI "size_t \fBm_total_coinstip_cache\fP {0}"
.br
.ti -1c
.RI "size_t \fBm_total_coinsdb_cache\fP {0}"
.br
.ti -1c
.RI "\fBChainstate\fP &InitializeChainstate(\fBCTxMemPool\fP *mempool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fButil::Result\fP< \fBCBlockIndex\fP * \fBActivateSnapshot\fP )(\fBAutoFile\fP &coins_file, const \fBnode::SnapshotMetadata\fP &metadata, bool in_memory)"
.br
.ti -1c
.RI "\fBSnapshotCompletionResult\fP MaybeValidateSnapshot(\fBChainstate\fP &validated_cs, \fBChainstate\fP &unvalidated_cs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBChainstate\fP \fBCurrentChainstate\fP )() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.RI "Return current chainstate targeting the most-work, network tip\&. "
.ti -1c
.RI "\fBVersionBitsCache\fP \fBm_versionbitscache\fP"
.br
.ti -1c
.RI "\fBChainstate\fP *LoadAssumeutxoChainstate() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBChainstate\fP &AddChainstate(std::unique_ptr< \fBChainstate\fP > chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void ResetChainstates() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool DeleteChainstate(\fBChainstate\fP &chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool ValidatedSnapshotCleanup(\fBChainstate\fP &validated_cs, \fBChainstate\fP &unvalidated_cs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::optional< std::pair< const \fBCBlockIndex\fP *, const \fBCBlockIndex\fP * > > GetHistoricalBlockRange() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fButil::Result\fP< void > ActivateBestChains() \fBLOCKS_EXCLUDED\fP(void RecalculateBestHeader() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCCheckQueue\fP< \fBCScriptCheck\fP > \fBGetCheckQueue\fP )()"
.br
.RI "Add new chainstate\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBCBlockIndex\fP *m_best_invalid \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Interface for managing multiple \fBChainstate\fP objects, where each chainstate is associated with chainstate* subdirectory in the data directory and contains a database of UTXOs existing at a different point in history\&. (See \fBChainstate\fP class for more information\&.)

.PP
Normally there is exactly one \fBChainstate\fP, which contains the UTXO set of chain tip if syncing is completed, or the UTXO set the most recent validated block if the initial sync is still in progress\&.

.PP
However, if an assumeutxo snapshot is loaded before syncing is completed, there will be two chainstates\&. The original fully validated chainstate will continue to exist and download new blocks in the background\&. But the new snapshot which is loaded will become a second chainstate\&. The second chainstate will be used as the chain tip for the wallet and RPCs even though it is only assumed to be valid\&. When the initial chainstate catches up to the snapshot height and confirms that the assumeutxo snapshot is actually valid, the second chainstate will be marked validated and become the only chainstate again\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBOptions\fP\fBOptions\fP = \fBkernel::ChainstateManagerOpts\fP"

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBChainstateManager\fP (const \fButil::SignalInterrupt\fP & interrupt, \fBOptions\fP\fBOptions\fP options, \fBnode::BlockManager::Options\fP blockman_options)\fR [explicit]\fP"

.SS "~\fBChainstateManager\fP ()"

.SH "Member Function Documentation"
.PP 
.SS "bool AcceptBlock (const std::shared_ptr< const \fBCBlock\fP > & pblock, \fBBlockValidationState\fP & state, \fBCBlockIndex\fP ** ppindex, bool fRequested, const \fBFlatFilePos\fP * dbp, bool * fNewBlock, bool min_pow_checked)"
Sufficiently validate a block for disk storage (and store on disk)\&.

.PP
\fBParameters\fP
.RS 4
\fIpblock\fP The block we want to process\&. 
.br
\fIfRequested\fP Whether we requested this block from a peer\&. 
.br
\fIdbp\fP The location on disk, if we are importing this block from prior storage\&. 
.br
\fImin_pow_checked\fP True if proof-of-work anti-DoS checks have been done by caller for headers chain
.br
\fIstate\fP The state of the block validation\&. 
.br
\fIppindex\fP Optional return parameter to get the \fBCBlockIndex\fP pointer for this block\&. 
.br
\fIfNewBlock\fP Optional return parameter to indicate if the block is new to our storage\&.
.RE
.PP
\fBReturns\fP
.RS 4
False if the block or header is invalid, or if saving to disk fails (likely a fatal error); true otherwise\&.
.RE
.PP
Store block on disk\&. If dbp is non-nullptr, the file is known to already reside on disk 
.SS "\fBCChain\fP & ActiveChain () const\fR [inline]\fP"

.SS "\fBChainstate\fP & ActiveChainstate () const"
Alternatives to \fBCurrentChainstate()\fP used by older code to query latest chainstate information without locking cs_main\&. Newer code should avoid querying \fBChainstateManager\fP and use \fBChainstate\fP objects directly, or should use \fBCurrentChainstate()\fP instead\&. 
.SS "int ActiveHeight () const\fR [inline]\fP"

.SS "\fBCBlockIndex\fP * ActiveTip () const\fR [inline]\fP"

.SS "const \fBuint256\fP & AssumedValidBlock () const\fR [inline]\fP"

.SS "\fBnode::BlockMap\fP & BlockIndex ()\fR [inline]\fP"

.SS "void CheckBlockIndex () const"
Make various assertions about the state of the block index\&.

.PP
By default this only executes fully when using the Regtest chain; see: m_options\&.check_block_index\&. 
.SS "std::vector< unsigned char > GenerateCoinbaseCommitment (\fBCBlock\fP & block, const \fBCBlockIndex\fP * pindexPrev) const"
Produce the necessary coinbase commitment for a block (modifies the hash, don't call for mined blocks)\&. 
.SS "const \fBConsensus::Params\fP & GetConsensus () const\fR [inline]\fP"

.SS "\fBRecursiveMutex\fP & GetMutex () const\fR [inline]\fP"
Alias for \fBcs_main\fP\&. Should be used in new code to make it easier to make \fBcs_main\fP a member of this class\&. Generally, methods of this class should be annotated to require this mutex\&. This will make calling code more verbose, but also help to:
.IP "\(bu" 2
Clarify that the method will acquire a mutex that heavily affects overall performance\&.
.IP "\(bu" 2
Force call sites to think how long they need to acquire the mutex to get consistent results\&. 
.PP

.SS "\fBkernel::Notifications\fP & GetNotifications () const\fR [inline]\fP"

.SS "const \fBCChainParams\fP & GetParams () const\fR [inline]\fP"

.SS "std::vector< std::unique_ptr< \fBChainstate\fP > > m_chainstates GUARDED_BY (\fB::cs_main\fP )"
List of chainstates\&. Note: in general, it is not safe to delete \fBChainstate\fP objects once they are added to this list because there is no mutex that can be locked to prevent \fBChainstate\fP pointers from being used while they are deleted\&. (cs_main doesn't work because it is too narrow and is released in the middle of Chainstate::ActivateBestChain to let notifications be processed\&. m_chainstate_mutex doesn't work because it is not locked at other times when the chainstate is in use\&.) 
.SS "\fBCBlockIndex\fP *m_best_header GUARDED_BY (\fB::cs_main\fP )\fR [inline]\fP"
Best header we've seen so far for which the block is not known to be invalid (used, among others, for getheaders queries' starting points)\&. In case of multiple best headers with the same work, it could point to any because \fBCBlockIndexWorkComparator\fP tiebreaker rules are not applied\&. 
.SS "int32_t nBlockSequenceId GUARDED_BY (\fB::cs_main\fP )"
Every received block is assigned a unique and increasing identifier, so we know which one to give priority in case of a fork\&. Blocks loaded from disk are assigned id SEQ_ID_INIT_FROM_DISK{1} (SEQ_ID_BEST_CHAIN_FROM_DISK{0} if they belong to the best chain loaded from disk), so start the counter after that\&. 
.SS "\fBCBlockIndex\fP *m_best_invalid GUARDED_BY (\fB::cs_main\fP )\fR [inline]\fP, \fR [protected]\fP"

.SS "double GuessVerificationProgress (const \fBCBlockIndex\fP * pindex) const"
Guess verification progress (as a fraction between 0\&.0=genesis and 1\&.0=current tip)\&. 
.SS "\fBChainstate\fP * HistoricalChainstate () const\fR [inline]\fP"

.PP
Return historical chainstate targeting a specific block, if any\&. 
.SS "bool IsInitialBlockDownload () const"
Check whether we are doing an initial block download (synchronizing from disk or network) 
.SS "bool LoadBlockIndex ()"

.PP
Load the block tree and coins database from disk, initializing state if we're running with -reindex\&. 
.SS "void LoadExternalBlockFile (\fBAutoFile\fP & file_in, \fBFlatFilePos\fP * dbp = \fRnullptr\fP, std::multimap< \fBuint256\fP, \fBFlatFilePos\fP > * blocks_with_unknown_parent = \fRnullptr\fP)"
Import blocks from an external file

.PP
During reindexing, this function is called for each block file (datadir/blocks/blk?????\&.dat)\&. It reads all blocks contained in the given file and attempts to process them (add them to the block index)\&. The blocks may be out of order within each file and across files\&. Often this function reads a block but finds that its parent hasn't been read yet, so the block can't be processed yet\&. The function will add an entry to the blocks_with_unknown_parent map (which is passed as an argument), so that when the block's parent is later read and processed, this function can re-read the child block from disk and process it\&.

.PP
Because a block's parent may be in a later file, not just later in the same file, the blocks_with_unknown_parent map must be passed in and out with each call\&. It's a multimap, rather than just a map, because multiple blocks may have the same parent (when chain splits or stale blocks exist)\&. It maps from parent-hash to child-disk-position\&.

.PP
This function can also be used to read blocks from user-specified block files using the -loadblock= option\&. There's no unknown-parent tracking, so the last two arguments are omitted\&.

.PP
\fBParameters\fP
.RS 4
\fIfile_in\fP File containing blocks to read 
.br
\fIdbp\fP (optional) Disk block position (only for reindex) 
.br
\fIblocks_with_unknown_parent\fP (optional) Map of disk positions for blocks with unknown parent, key is parent block hash (only used for reindex) 
.RE
.PP

.SS "const \fBarith_uint256\fP & MinimumChainWork () const\fR [inline]\fP"

.SS "bool ProcessNewBlock (const std::shared_ptr< const \fBCBlock\fP > & block, bool force_processing, bool min_pow_checked, bool * new_block)"
Process an incoming block\&. This only returns after the best known valid block is made active\&. Note that it does not, however, guarantee that the specific block passed to it has been checked for validity!

.PP
If you want to \fIpossibly\fP get feedback on whether block is valid, you must install a \fBCValidationInterface\fP (see \fBvalidationinterface\&.h\fP) - this will have its BlockChecked method called whenever \fIany\fP block completes validation\&.

.PP
Note that we guarantee that either the proof-of-work is valid on block, or (and possibly also) BlockChecked will have been called\&.

.PP
May not be called in a validationinterface callback\&.

.PP
\fBParameters\fP
.RS 4
\fIblock\fP The block we want to process\&. 
.br
\fIforce_processing\fP Process this block even if unrequested; used for non-network block sources\&. 
.br
\fImin_pow_checked\fP True if proof-of-work anti-DoS checks have been done by caller for headers chain (note: only affects headers acceptance; if block header is already present in block index then this parameter has no effect) 
.br
\fInew_block\fP A boolean which is set to indicate if the block was first received via this call 
.RE
.PP
\fBReturns\fP
.RS 4
If the block was processed, independently of block validity 
.RE
.PP

.SS "bool ProcessNewBlockHeaders (std::span< const \fBCBlockHeader\fP > headers, bool min_pow_checked, \fBBlockValidationState\fP & state, const \fBCBlockIndex\fP ** ppindex = \fRnullptr\fP)"
Process incoming block headers\&.

.PP
May not be called in a validationinterface callback\&.

.PP
\fBParameters\fP
.RS 4
\fIheaders\fP The block headers themselves 
.br
\fImin_pow_checked\fP True if proof-of-work anti-DoS checks have been done by caller for headers chain 
.br
\fIstate\fP This may be set to an Error state if any error occurred processing them 
.br
\fIppindex\fP If set, the pointer will be set to point to the last new block index object for the given headers 
.RE
.PP
\fBReturns\fP
.RS 4
false if AcceptBlockHeader fails on any of the headers, true otherwise (including if headers were already known) 
.RE
.PP

.SS "\fBMempoolAcceptResult\fP ProcessTransaction (const \fBCTransactionRef\fP & tx, bool test_accept = \fRfalse\fP)\fR [nodiscard]\fP"
Try to add a transaction to the memory pool\&.

.PP
\fBParameters\fP
.RS 4
\fItx\fP The transaction to submit for mempool acceptance\&. 
.br
\fItest_accept\fP When true, run validation checks but don't submit to mempool\&. 
.RE
.PP

.SS "void ReceivedBlockTransactions (const \fBCBlock\fP & block, \fBCBlockIndex\fP * pindexNew, const \fBFlatFilePos\fP & pos)"
Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS)\&. 
.SS "std::unique_ptr< \fBChainstate\fP > RemoveChainstate (\fBChainstate\fP & chainstate)\fR [inline]\fP"

.PP
Remove a chainstate\&. 
.SS "void ReportHeadersPresync (const \fBarith_uint256\fP & work, int64_t height, int64_t timestamp)"
This is used by net_processing to report pre-synchronization progress of headers, as headers are not yet fed to validation during that time, but validation is (for now) responsible for logging and signalling through NotifyHeaderTip, so it needs this information\&. 
.SS "void ResetBlockSequenceCounters ()\fR [inline]\fP"

.SS "bool ShouldCheckBlockIndex () const"

.SS "void UpdateUncommittedBlockStructures (\fBCBlock\fP & block, const \fBCBlockIndex\fP * pindexPrev) const"
Check to see if caches are out of balance and if so, call ResizeCoinsCaches() as needed\&. Update uncommitted block structures (currently: only the witness reserved value)\&. This is safe for submitted blocks as long as they honor default_witness_commitment from the template\&. 
.SS "\fBChainstate\fP & ValidatedChainstate () const\fR [inline]\fP"
Return fully validated chainstate that should be used for indexing, to support indexes that need to index blocks in order and can't start from the snapshot block\&. 
.SH "Field Documentation"
.PP 
.SS "\fButil::Result\fP< \fBCBlockIndex\fP * > ActivateSnapshot\fR [nodiscard]\fP"
Instantiate a new chainstate\&.

.PP
\fBParameters\fP
.RS 4
\fImempool\fP The mempool to pass to the chainstate
.RE
.PP
Construct and activate a \fBChainstate\fP on the basis of UTXO snapshot data\&.

.PP
Steps:

.PP
.IP "\(bu" 2
Initialize an unused \fBChainstate\fP\&.
.IP "\(bu" 2
Load its \fR\fBCoinsViews\fP\fP contents from \fRcoins_file\fP\&.
.IP "\(bu" 2
Verify that the hash of the resulting coinsdb matches the expected hash per assumeutxo chain parameters\&.
.IP "\(bu" 2
Wait for our headers chain to include the base block of the snapshot\&.
.IP "\(bu" 2
"Fast forward" the tip of the new chainstate to the base of the snapshot\&.
.IP "\(bu" 2
Construct the new \fBChainstate\fP and add it to m_chainstates\&. 
.PP

.SS "\fBSnapshotCompletionResult\fP MaybeValidateSnapshot(\fBChainstate\fP &validated_cs, \fBChainstate\fP &unvalidated_cs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBChainstate\fP CurrentChainstate) () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())\fR [inline]\fP"

.PP
Return current chainstate targeting the most-work, network tip\&. Try to validate an assumeutxo snapshot by using a validated historical chainstate targeted at the snapshot block\&. When the target block is reached, the UTXO hash is computed and saved to \fRvalidated_cs\&.m_target_utxohash\fP, and \fRunvalidated_cs\&.m_assumeutxo\fP will be updated from UNVALIDATED to either VALIDATED or INVALID depending on whether the hash matches\&. The INVALID case should not happen in practice because the software should refuse to load unrecognized snapshots, but if it does happen, it is a fatal error\&. 
.SS "\fBChainstate\fP *LoadAssumeutxoChainstate() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBChainstate\fP &AddChainstate(std::unique_ptr< \fBChainstate\fP > chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void ResetChainstates() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool DeleteChainstate(\fBChainstate\fP &chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool ValidatedSnapshotCleanup(\fBChainstate\fP &validated_cs, \fBChainstate\fP &unvalidated_cs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::optional< std::pair< const \fBCBlockIndex\fP *, const \fBCBlockIndex\fP * > > GetHistoricalBlockRange() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fButil::Result\fP< void > ActivateBestChains() \fBLOCKS_EXCLUDED\fP(void RecalculateBestHeader() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCCheckQueue\fP< \fBCScriptCheck\fP > GetCheckQueue) ()\fR [inline]\fP, \fR [nodiscard]\fP"

.PP
Add new chainstate\&. When starting up, search the datadir for a chainstate based on a UTXO snapshot that is in the process of being validated and load it if found\&. Return pointer to the \fBChainstate\fP if it is loaded\&.

.PP
Remove the chainstate and all on-disk artifacts\&. Used when reindex{-chainstate} is called during snapshot use\&.

.PP
If we have validated a snapshot chain during this runtime, copy its chainstate directory over to the main \fRchainstate\fP location, completing validation of the snapshot\&.

.PP
If the cleanup succeeds, the caller will need to ensure chainstates are reinitialized, since ResetChainstates() will be called before leveldb directories are moved or deleted\&.

.PP
\fBSee also\fP
.RS 4
node/chainstate:\fBLoadChainstate()\fP Get range of historical blocks to download\&. Call ActivateBestChain() on every chainstate\&.
.RE
.PP
If, due to invalidation / reconsideration of blocks, the previous best header is no longer valid / guaranteed to be the most-work header in our block-index not known to be invalid, recalculate it\&. 
.SS "\fBnode::BlockManager\fP m_blockman"
A single \fBBlockManager\fP instance is shared across each constructed chainstate to avoid duplicating block metadata\&. 
.SS "std::atomic<bool> m_cached_finished_ibd {false}\fR [mutable]\fP"
Whether initial block download has ended and IsInitialBlockDownload should return false from now on\&.

.PP
Mutable because we need to be able to mark \fBIsInitialBlockDownload()\fP const, which latches this for caching purposes\&. 
.SS "const \fButil::SignalInterrupt\fP& m_interrupt"

.SS "const \fBOptions\fP\fBOptions\fP m_options"

.SS "size_t m_total_coinsdb_cache {0}"
The total number of bytes available for us to use across all leveldb coins databases\&. This will be split somehow across chainstates\&. 
.SS "size_t m_total_coinstip_cache {0}"
The total number of bytes available for us to use across all in-memory coins caches\&. This will be split somehow across chainstates\&. 
.SS "\fBValidationCache\fP m_validation_cache"

.SS "\fBVersionBitsCache\fP m_versionbitscache\fR [mutable]\fP"
Track versionbit status 
.SS "int32_t nBlockReverseSequenceId = \-1"
Decreasing counter (used by subsequent preciousblock calls)\&. 
.SS "\fBarith_uint256\fP nLastPreciousChainwork = 0"
chainwork for the last block that preciousblock has been applied to\&. 
.SS "std::function<void()> snapshot_download_completed = std::function<void()>()"
Function to restart active indexes; set dynamically to avoid a circular dependency on \fRbase/index\&.cpp\fP\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
