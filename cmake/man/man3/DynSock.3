.TH "DynSock" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
DynSock
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <net\&.h>\fP
.PP
Inherits \fBZeroSock\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBPipe\fP"
.br
.ti -1c
.RI "struct \fBPipes\fP"
.br
.ti -1c
.RI "class \fBQueue\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBDynSock\fP (std::shared_ptr< \fBPipes\fP > pipes, std::shared_ptr< \fBQueue\fP > accept_sockets)"
.br
.ti -1c
.RI "\fB~DynSock\fP ()"
.br
.ti -1c
.RI "ssize_t \fBRecv\fP (void *buf, size_t len, int \fBflags\fP) const override"
.br
.ti -1c
.RI "ssize_t \fBSend\fP (const void *buf, size_t len, int) const override"
.br
.ti -1c
.RI "std::unique_ptr< \fBSock\fP > \fBAccept\fP (sockaddr *addr, socklen_t *addr_len) const override"
.br
.ti -1c
.RI "bool \fBWait\fP (std::chrono::milliseconds timeout, \fBEvent\fP requested, \fBEvent\fP *occurred=nullptr) const override"
.br
.ti -1c
.RI "bool \fBWaitMany\fP (std::chrono::milliseconds timeout, \fBEventsPerSock\fP &events_per_sock) const override"
.br
.in -1c

Public Member Functions inherited from \fBZeroSock\fP
.in +1c
.ti -1c
.RI "\fBZeroSock\fP ()"
.br
.ti -1c
.RI "\fB~ZeroSock\fP () override"
.br
.ti -1c
.RI "ssize_t \fBSend\fP (const void *, size_t len, int) const override"
.br
.ti -1c
.RI "ssize_t \fBRecv\fP (void *buf, size_t len, int \fBflags\fP) const override"
.br
.ti -1c
.RI "int \fBConnect\fP (const sockaddr *, socklen_t) const override"
.br
.ti -1c
.RI "int \fBBind\fP (const sockaddr *, socklen_t) const override"
.br
.ti -1c
.RI "int \fBListen\fP (int) const override"
.br
.ti -1c
.RI "std::unique_ptr< \fBSock\fP > \fBAccept\fP (sockaddr *addr, socklen_t *addr_len) const override"
.br
.ti -1c
.RI "int \fBGetSockOpt\fP (int level, int opt_name, void *opt_val, socklen_t *opt_len) const override"
.br
.ti -1c
.RI "int \fBSetSockOpt\fP (int, int, const void *, socklen_t) const override"
.br
.ti -1c
.RI "int \fBGetSockName\fP (sockaddr *\fBname\fP, socklen_t *name_len) const override"
.br
.ti -1c
.RI "bool \fBSetNonBlocking\fP () const override"
.br
.ti -1c
.RI "bool \fBIsSelectable\fP () const override"
.br
.ti -1c
.RI "bool \fBWait\fP (std::chrono::milliseconds timeout, \fBEvent\fP requested, \fBEvent\fP *occurred=nullptr) const override"
.br
.ti -1c
.RI "bool \fBWaitMany\fP (std::chrono::milliseconds timeout, \fBEventsPerSock\fP &events_per_sock) const override"
.br
.in -1c

Public Member Functions inherited from \fBSock\fP
.in +1c
.ti -1c
.RI "\fBSock\fP ()=delete"
.br
.ti -1c
.RI "\fBSock\fP (\fBSOCKET\fP s)"
.br
.ti -1c
.RI "\fBSock\fP (const \fBSock\fP &)=delete"
.br
.ti -1c
.RI "\fBSock\fP (\fBSock\fP &&other)"
.br
.ti -1c
.RI "virtual \fB~Sock\fP ()"
.br
.ti -1c
.RI "\fBSock\fP & \fBoperator=\fP (const \fBSock\fP &)=delete"
.br
.ti -1c
.RI "virtual void \fBSendComplete\fP (std::span< const unsigned char > data, std::chrono::milliseconds timeout, \fBCThreadInterrupt\fP &interrupt) const"
.br
.ti -1c
.RI "virtual void \fBSendComplete\fP (std::span< const char > data, std::chrono::milliseconds timeout, \fBCThreadInterrupt\fP &interrupt) const"
.br
.ti -1c
.RI "virtual std::string \fBRecvUntilTerminator\fP (uint8_t terminator, std::chrono::milliseconds timeout, \fBCThreadInterrupt\fP &interrupt, size_t max_data) const"
.br
.ti -1c
.RI "virtual bool \fBIsConnected\fP (std::string &errmsg) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (\fBSOCKET\fP s) const"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBSock\fP
.in +1c
.ti -1c
.RI "using \fBEvent\fP = uint8_t"
.br
.ti -1c
.RI "using \fBEventsPerSock\fP = std::unordered_map<std::shared_ptr<const \fBSock\fP>, \fBEvents\fP, \fBHashSharedPtrSock\fP, \fBEqualSharedPtrSock\fP>"
.br
.in -1c

Static Public Attributes inherited from \fBSock\fP
.in +1c
.ti -1c
.RI "static constexpr \fBEvent\fP \fBRECV\fP = 0b001"
.br
.ti -1c
.RI "static constexpr \fBEvent\fP \fBSEND\fP = 0b010"
.br
.ti -1c
.RI "static constexpr \fBEvent\fP \fBERR\fP = 0b100"
.br
.in -1c

Protected Attributes inherited from \fBSock\fP
.in +1c
.ti -1c
.RI "\fBSOCKET\fP \fBm_socket\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A mocked \fBSock\fP alternative that allows providing the data to be returned by \fBRecv()\fP and inspecting the data that has been supplied to \fBSend()\fP\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBDynSock\fP (std::shared_ptr< \fBPipes\fP > pipes, std::shared_ptr< \fBQueue\fP > accept_sockets)\fR [explicit]\fP"
Create a new mocked sock\&. 
.PP
\fBParameters\fP
.RS 4
\fIpipes\fP Send/recv pipes used by the \fBSend()\fP and \fBRecv()\fP methods\&. 
.br
\fIaccept_sockets\fP Sockets to return by the \fBAccept()\fP method\&. 
.RE
.PP

.SS "~\fBDynSock\fP ()"

.SH "Member Function Documentation"
.PP 
.SS "std::unique_ptr< \fBSock\fP > Accept (sockaddr * addr, socklen_t * addr_len) const\fR [override]\fP, \fR [virtual]\fP"
accept(2) wrapper\&. Equivalent to \fRstd::make_unique<\fBSock\fP>(accept(m_socket, addr, addr_len))\fP\&. Code that uses this wrapper can be unit tested if this method is overridden by a mock \fBSock\fP implementation\&. The returned unique_ptr is empty if \fRaccept()\fP failed in which case errno will be set\&. 
.PP
Reimplemented from \fBSock\fP\&.
.SS "ssize_t Recv (void * buf, size_t len, int flags) const\fR [override]\fP, \fR [virtual]\fP"
recv(2) wrapper\&. Equivalent to \fRrecv(m_socket, buf, len, flags);\fP\&. Code that uses this wrapper can be unit tested if this method is overridden by a mock \fBSock\fP implementation\&. 
.PP
Reimplemented from \fBSock\fP\&.
.SS "ssize_t Send (const void * data, size_t len, int flags) const\fR [override]\fP, \fR [virtual]\fP"
send(2) wrapper\&. Equivalent to \fRsend(m_socket, data, len, flags);\fP\&. Code that uses this wrapper can be unit tested if this method is overridden by a mock \fBSock\fP implementation\&. 
.PP
Reimplemented from \fBSock\fP\&.
.SS "bool Wait (std::chrono::milliseconds timeout, \fBEvent\fP requested, \fBEvent\fP * occurred = \fRnullptr\fP) const\fR [override]\fP, \fR [virtual]\fP"
Wait for readiness for input (recv) or output (send)\&. 
.PP
\fBParameters\fP
.RS 4
\fItimeout\fP Wait this much for at least one of the requested events to occur\&. 
.br
\fIrequested\fP Wait for those events, bitwise-or of \fR\fBRECV\fP\fP and \fR\fBSEND\fP\fP\&. 
.br
\fIoccurred\fP If not nullptr and the function returns \fRtrue\fP, then this indicates which of the requested events occurred (\fR\fBERR\fP\fP will be added, even if not requested, if an exceptional event occurs on the socket)\&. A timeout is indicated by return value of \fRtrue\fP and \fRoccurred\fP being set to 0\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true on success (or timeout, if \fRoccurred\fP of 0 is returned), false otherwise 
.RE
.PP

.PP
Reimplemented from \fBSock\fP\&.
.SS "bool WaitMany (std::chrono::milliseconds timeout, \fBEventsPerSock\fP & events_per_sock) const\fR [override]\fP, \fR [virtual]\fP"
Same as \fR\fBWait()\fP\fP, but wait on many sockets within the same timeout\&. 
.PP
\fBParameters\fP
.RS 4
\fItimeout\fP Wait this long for at least one of the requested events to occur\&. 
.br
\fIevents_per_sock\fP Wait for the requested events on these sockets and set \fRoccurred\fP for the events that actually occurred\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true on success (or timeout, if all \fRwhat[]\&.occurred\fP are returned as 0), false otherwise 
.RE
.PP

.PP
Reimplemented from \fBSock\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
