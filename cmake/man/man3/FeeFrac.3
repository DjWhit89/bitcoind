.TH "FeeFrac" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
FeeFrac
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <feefrac\&.h>\fP
.PP
Inherited by \fBFeePerUnit< VSizeTag >\fP, \fBFeePerUnit< WeightTag >\fP, and \fBFeePerUnit< Tag >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "constexpr \fBFeeFrac\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBFeeFrac\fP (int64_t f, int32_t s) noexcept"
.br
.ti -1c
.RI "constexpr \fBFeeFrac\fP (const \fBFeeFrac\fP &) noexcept=default"
.br
.ti -1c
.RI "constexpr \fBFeeFrac\fP & \fBoperator=\fP (const \fBFeeFrac\fP &) noexcept=default"
.br
.ti -1c
.RI "bool \fBIsEmpty\fP () const noexcept"
.br
.ti -1c
.RI "void \fBoperator+=\fP (const \fBFeeFrac\fP &other) noexcept"
.br
.ti -1c
.RI "void \fBoperator\-=\fP (const \fBFeeFrac\fP &other) noexcept"
.br
.ti -1c
.RI "template<bool RoundDown> int64_t \fBEvaluateFee\fP (int32_t at_size) const noexcept"
.br
.ti -1c
.RI "int64_t \fBEvaluateFeeDown\fP (int32_t at_size) const noexcept"
.br
.ti -1c
.RI "int64_t \fBEvaluateFeeUp\fP (int32_t at_size) const noexcept"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static std::pair< int64_t, uint32_t > \fBMulFallback\fP (int64_t a, int32_t b) noexcept"
.br
.ti -1c
.RI "static int64_t \fBDivFallback\fP (std::pair< int64_t, uint32_t > n, int32_t d, bool round_down) noexcept"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "int64_t \fBfee\fP"
.br
.ti -1c
.RI "int32_t \fBsize\fP"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr auto \fBMul\fP = \fBMulFallback\fP"
.br
.ti -1c
.RI "static constexpr auto \fBDiv\fP = \fBDivFallback\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBFeeFrac\fP \fBoperator+\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "\fBFeeFrac\fP \fBoperator\-\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "std::weak_ordering \fBFeeRateCompare\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "bool \fBoperator<<\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "bool \fBoperator>>\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "std::strong_ordering \fBoperator<=>\fP (const \fBFeeFrac\fP &a, const \fBFeeFrac\fP &b) noexcept"
.br
.ti -1c
.RI "void \fBswap\fP (\fBFeeFrac\fP &a, \fBFeeFrac\fP &b) noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 
Data structure storing a fee and size, ordered by increasing fee/size\&.

.PP
The size of a \fBFeeFrac\fP cannot be zero unless the fee is also zero\&.

.PP
FeeFracs have a total ordering, first by increasing feerate (ratio of fee over size), and then by decreasing size\&. The empty \fBFeeFrac\fP (fee and size both 0) sorts last\&. So for example, the following FeeFracs are in sorted order:

.PP
.IP "\(bu" 2
fee=0 size=1 (feerate 0)
.IP "\(bu" 2
fee=1 size=2 (feerate 0\&.5)
.IP "\(bu" 2
fee=2 size=3 (feerate 0\&.667\&.\&.\&.)
.IP "\(bu" 2
fee=2 size=2 (feerate 1)
.IP "\(bu" 2
fee=1 size=1 (feerate 1)
.IP "\(bu" 2
fee=3 size=2 (feerate 1\&.5)
.IP "\(bu" 2
fee=2 size=1 (feerate 2)
.IP "\(bu" 2
fee=0 size=0 (undefined feerate)
.PP

.PP
A \fBFeeFrac\fP is considered "better" if it sorts after another, by this ordering\&. All standard comparison operators (<=>, ==, !=, >, <, >=, <=) respect this ordering\&.

.PP
The FeeRateCompare, and >> and << operators only compare feerate and treat equal feerate but different size as equivalent\&. The empty \fBFeeFrac\fP is neither lower or higher in feerate than any other\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBFeeFrac\fP ()\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Construct an \fBIsEmpty()\fP \fBFeeFrac\fP\&. 
.SS "\fBFeeFrac\fP (int64_t f, int32_t s)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Construct a \fBFeeFrac\fP with specified fee and size\&. 
.SS "\fBFeeFrac\fP (const \fBFeeFrac\fP & )\fR [inline]\fP, \fR [constexpr]\fP, \fR [default]\fP, \fR [noexcept]\fP"

.SH "Member Function Documentation"
.PP 
.SS "int64_t DivFallback (std::pair< int64_t, uint32_t > n, int32_t d, bool round_down)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"
Helper function for 96/32 signed division, rounding towards negative infinity (if round_down) or positive infinity (if !round_down)\&. This is a fallback version, separate so that it can be tested on platforms where it isn't actually needed\&.

.PP
The exact behavior with negative n does not really matter, but this implementation chooses to be consistent for testability reasons\&.

.PP
The result must fit in an int64_t, and d must be strictly positive\&. 
.SS "template<bool RoundDown> int64_t EvaluateFee (int32_t at_size) const\fR [inline]\fP, \fR [noexcept]\fP"
Compute the fee for a given size \fRat_size\fP using this object's feerate\&.

.PP
This effectively corresponds to evaluating (this->fee * at_size) / this->size, with the result rounded towards negative infinity (if RoundDown) or towards positive infinity (if !RoundDown)\&.

.PP
Requires this->size > 0, at_size >= 0, and that the correct result fits in a int64_t\&. This is guaranteed to be the case when 0 <= at_size <= this->size\&. 
.SS "int64_t EvaluateFeeDown (int32_t at_size) const\fR [inline]\fP, \fR [noexcept]\fP"
Compute the fee for a given size \fRat_size\fP using this object's feerate, rounding down\&. 
.SS "int64_t EvaluateFeeUp (int32_t at_size) const\fR [inline]\fP, \fR [noexcept]\fP"
Compute the fee for a given size \fRat_size\fP using this object's feerate, rounding up\&. 
.SS "bool IsEmpty () const\fR [inline]\fP, \fR [noexcept]\fP"
Check if this is empty (size and fee are 0)\&. 
.SS "std::pair< int64_t, uint32_t > MulFallback (int64_t a, int32_t b)\fR [inline]\fP, \fR [static]\fP, \fR [noexcept]\fP"
Helper function for 32*64 signed multiplication, returning an unspecified but totally ordered type\&. This is a fallback version, separate so it can be tested on platforms where it isn't actually needed\&. 
.SS "void operator+= (const \fBFeeFrac\fP & other)\fR [inline]\fP, \fR [noexcept]\fP"
Add fee and size of another \fBFeeFrac\fP to this one\&. 
.SS "void operator\-= (const \fBFeeFrac\fP & other)\fR [inline]\fP, \fR [noexcept]\fP"
Subtract fee and size of another \fBFeeFrac\fP from this one\&. 
.SS "\fBFeeFrac\fP & operator= (const \fBFeeFrac\fP & )\fR [inline]\fP, \fR [constexpr]\fP, \fR [default]\fP, \fR [noexcept]\fP"

.SH "Friends And Related Symbol Documentation"
.PP 
.SS "std::weak_ordering FeeRateCompare (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Compare two FeeFracs just by feerate\&. 
.SS "\fBFeeFrac\fP operator+ (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Sum fee and size\&. 
.SS "\fBFeeFrac\fP operator\- (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Subtract both fee and size\&. 
.SS "bool operator<< (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Check if a \fBFeeFrac\fP object has strictly lower feerate than another\&. 
.SS "std::strong_ordering operator<=> (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Compare two FeeFracs\&. <, >, <=, and >= are auto-generated from this\&. 
.SS "bool operator== (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Check if two \fBFeeFrac\fP objects are equal (both same fee and same size)\&. 
.SS "bool operator>> (const \fBFeeFrac\fP & a, const \fBFeeFrac\fP & b)\fR [friend]\fP"
Check if a \fBFeeFrac\fP object has strictly higher feerate than another\&. 
.SS "void swap (\fBFeeFrac\fP & a, \fBFeeFrac\fP & b)\fR [friend]\fP"
Swap two FeeFracs\&. 
.SH "Field Documentation"
.PP 
.SS "auto Div = \fBDivFallback\fP\fR [static]\fP, \fR [constexpr]\fP"

.SS "int64_t fee"

.SS "auto Mul = \fBMulFallback\fP\fR [static]\fP, \fR [constexpr]\fP"

.SS "int32_t size"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
