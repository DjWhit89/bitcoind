.TH "CPartialMerkleTree" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CPartialMerkleTree
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <merkleblock\&.h>\fP
.PP
Inherited by \fBCPartialMerkleTreeTester\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSERIALIZE_METHODS\fP (\fBCPartialMerkleTree\fP, obj)"
.br
.ti -1c
.RI "\fBCPartialMerkleTree\fP (const std::vector< \fBTxid\fP > &vTxid, const std::vector< bool > &vMatch)"
.br
.ti -1c
.RI "\fBCPartialMerkleTree\fP ()"
.br
.ti -1c
.RI "\fBuint256\fP \fBExtractMatches\fP (std::vector< \fBTxid\fP > &vMatch, std::vector< unsigned int > &vnIndex)"
.br
.ti -1c
.RI "unsigned int \fBGetNumTransactions\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "unsigned int \fBCalcTreeWidth\fP (int height) const"
.br
.ti -1c
.RI "\fBuint256\fP \fBCalcHash\fP (int height, unsigned int pos, const std::vector< \fBTxid\fP > &vTxid)"
.br
.ti -1c
.RI "void \fBTraverseAndBuild\fP (int height, unsigned int pos, const std::vector< \fBTxid\fP > &vTxid, const std::vector< bool > &vMatch)"
.br
.ti -1c
.RI "\fBuint256\fP \fBTraverseAndExtract\fP (int height, unsigned int pos, unsigned int &nBitsUsed, unsigned int &nHashUsed, std::vector< \fBTxid\fP > &vMatch, std::vector< unsigned int > &vnIndex)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "unsigned int \fBnTransactions\fP"
.br
.ti -1c
.RI "std::vector< bool > \fBvBits\fP"
.br
.ti -1c
.RI "std::vector< \fBuint256\fP > \fBvHash\fP"
.br
.ti -1c
.RI "bool \fBfBad\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Data structure that represents a partial merkle tree\&.

.PP
It represents a subset of the txid's of a known block, in a way that allows recovery of the list of txid's and the merkle root, in an authenticated way\&.

.PP
The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node, signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself)\&. In case we are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further\&. Otherwise, no hash is stored, but we recurse into both (or the only) child branch\&. During decoding, the same depth-first traversal is performed, consuming bits and hashes as they written during encoding\&.

.PP
The serialization is fixed and provides a hard guarantee about the encoded size:

.PP
SIZE <= 10 + ceil(32\&.25*N)

.PP
Where N represents the number of leaf nodes of the partial tree\&. N itself is bounded by:

.PP
N <= total_transactions N <= 1 + matched_transactions*tree_height

.PP
The serialization format:
.IP "\(bu" 2
uint32 total_transactions (4 bytes)
.IP "\(bu" 2
varint number of hashes (1-3 bytes)
.IP "\(bu" 2
\fBuint256\fP[] hashes in depth-first order (<= 32*N bytes)
.IP "\(bu" 2
varint number of bytes of flag bits (1-3 bytes)
.IP "\(bu" 2
byte[] flag bits, packed per 8 in a byte, least significant bit first (<= 2*N-1 bits) The size constraints follow from this\&. 
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCPartialMerkleTree\fP (const std::vector< \fBTxid\fP > & vTxid, const std::vector< bool > & vMatch)"
Construct a partial merkle tree from a list of transaction ids, and a mask that selects a subset of them 
.SS "\fBCPartialMerkleTree\fP ()"

.SH "Member Function Documentation"
.PP 
.SS "\fBuint256\fP CalcHash (int height, unsigned int pos, const std::vector< \fBTxid\fP > & vTxid)\fR [protected]\fP"
calculate the hash of a node in the merkle tree (at leaf level: the txid's themselves) 
.SS "unsigned int CalcTreeWidth (int height) const\fR [inline]\fP, \fR [protected]\fP"
helper function to efficiently calculate the number of nodes at given height in the merkle tree 
.SS "\fBuint256\fP ExtractMatches (std::vector< \fBTxid\fP > & vMatch, std::vector< unsigned int > & vnIndex)"
extract the matching txid's represented by this partial merkle tree and their respective indices within the partial tree\&. returns the merkle root, or 0 in case of failure 
.SS "unsigned int GetNumTransactions () const\fR [inline]\fP"
Get number of transactions the merkle proof is indicating for cross-reference with local blockchain knowledge\&. 
.SS "SERIALIZE_METHODS (\fBCPartialMerkleTree\fP , obj )\fR [inline]\fP"

.SS "void TraverseAndBuild (int height, unsigned int pos, const std::vector< \fBTxid\fP > & vTxid, const std::vector< bool > & vMatch)\fR [protected]\fP"
recursive function that traverses tree nodes, storing the data as bits and hashes 
.SS "\fBuint256\fP TraverseAndExtract (int height, unsigned int pos, unsigned int & nBitsUsed, unsigned int & nHashUsed, std::vector< \fBTxid\fP > & vMatch, std::vector< unsigned int > & vnIndex)\fR [protected]\fP"
recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild\&. it returns the hash of the respective node and its respective index\&. 
.SH "Field Documentation"
.PP 
.SS "bool fBad\fR [protected]\fP"
flag set when encountering invalid data 
.SS "unsigned int nTransactions\fR [protected]\fP"
the total number of transactions in the block 
.SS "std::vector<bool> vBits\fR [protected]\fP"
node-is-parent-of-matched-txid bits 
.SS "std::vector<\fBuint256\fP> vHash\fR [protected]\fP"
txids and internal hashes 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
