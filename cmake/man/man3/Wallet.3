.TH "wallet" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
wallet
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBwallet_crypto_tests\fP"
.br
.ti -1c
.RI "namespace \fBfeebumper\fP"
.br
.ti -1c
.RI "namespace \fBDBKeys\fP"
.br
.ti -1c
.RI "namespace \fBWalletTool\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBFuzzedWallet\fP"
.br
.ti -1c
.RI "class \fBPreselectedInput\fP"
.br
.ti -1c
.RI "class \fBCCoinControl\fP"
.br
.ti -1c
.RI "class \fBMinOutputGroupComparator\fP"
.br
.ti -1c
.RI "struct \fBCOutput\fP"
.br
.ti -1c
.RI "struct \fBCoinSelectionParams\fP"
.br
.ti -1c
.RI "struct \fBCoinEligibilityFilter\fP"
.br
.ti -1c
.RI "struct \fBOutputGroup\fP"
.br
.ti -1c
.RI "struct \fBGroups\fP"
.br
.ti -1c
.RI "struct \fBOutputGroupTypeMap\fP"
.br
.ti -1c
.RI "struct \fBSelectionResult\fP"
.br
.ti -1c
.RI "struct \fBWalletContext\fP"
.br
.ti -1c
.RI "class \fBCMasterKey\fP"
.br
.ti -1c
.RI "class \fBCCrypter\fP"
.br
.ti -1c
.RI "struct \fBBytePrefix\fP"
.br
.ti -1c
.RI "class \fBDatabaseCursor\fP"
.br
.ti -1c
.RI "class \fBDatabaseBatch\fP"
.br
.ti -1c
.RI "class \fBWalletDatabase\fP"
.br
.ti -1c
.RI "struct \fBDatabaseOptions\fP"
.br
.ti -1c
.RI "class \fBExternalSignerScriptPubKeyMan\fP"
.br
.ti -1c
.RI "class \fBWalletInit\fP"
.br
.ti -1c
.RI "class \fBMetaPage\fP"
.br
.ti -1c
.RI "class \fBRecordHeader\fP"
.br
.ti -1c
.RI "class \fBDataRecord\fP"
.br
.ti -1c
.RI "class \fBInternalRecord\fP"
.br
.ti -1c
.RI "class \fBOverflowRecord\fP"
.br
.ti -1c
.RI "class \fBPageHeader\fP"
.br
.ti -1c
.RI "class \fBRecordsPage\fP"
.br
.ti -1c
.RI "class \fBOverflowPage\fP"
.br
.ti -1c
.RI "class \fBInternalPage\fP"
.br
.ti -1c
.RI "class \fBBerkeleyRODatabase\fP"
.br
.ti -1c
.RI "class \fBBerkeleyROCursor\fP"
.br
.ti -1c
.RI "class \fBBerkeleyROBatch\fP"
.br
.ti -1c
.RI "struct \fBCOutputEntry\fP"
.br
.ti -1c
.RI "struct \fBBalance\fP"
.br
.ti -1c
.RI "class \fBDescribeWalletAddressVisitor\fP"
.br
.ti -1c
.RI "struct \fBtallyitem\fP"
.br
.ti -1c
.RI "class \fBWalletStorage\fP"
.br
.ti -1c
.RI "struct \fBWalletDestination\fP"
.br
.ti -1c
.RI "class \fBScriptPubKeyMan\fP"
.br
.ti -1c
.RI "class \fBLegacyDataSPKM\fP"
.br
.ti -1c
.RI "class \fBLegacySigningProvider\fP"
.br
.ti -1c
.RI "class \fBDescriptorScriptPubKeyMan\fP"
.br
.ti -1c
.RI "struct \fBMigrationData\fP"
.br
.ti -1c
.RI "struct \fBTxSize\fP"
.br
.ti -1c
.RI "struct \fBCoinsResult\fP"
.br
.ti -1c
.RI "struct \fBCoinFilterParams\fP"
.br
.ti -1c
.RI "struct \fBSelectionFilter\fP"
.br
.ti -1c
.RI "struct \fBPreSelectedInputs\fP"
.br
.ti -1c
.RI "struct \fBCreatedTransactionResult\fP"
.br
.ti -1c
.RI "class \fBSQLiteCursor\fP"
.br
.ti -1c
.RI "class \fBSQliteExecHandler\fP"
.br
.ti -1c
.RI "class \fBSQLiteBatch\fP"
.br
.ti -1c
.RI "class \fBSQLiteDatabase\fP"
.br
.ti -1c
.RI "class \fBDbExecBlocker\fP"
.br
.ti -1c
.RI "class \fBGroupVerifier\fP"
.br
.ti -1c
.RI "struct \fBInitWalletDirTestingSetup\fP"
.br
.ti -1c
.RI "class \fBMockableCursor\fP"
.br
.ti -1c
.RI "class \fBMockableBatch\fP"
.br
.ti -1c
.RI "class \fBMockableDatabase\fP"
.br
.ti -1c
.RI "class \fBTestCrypter\fP"
.br
.ti -1c
.RI "struct \fBWalletTestingSetup\fP"
.br
.ti -1c
.RI "class \fBListCoinsTestingSetup\fP"
.br
.ti -1c
.RI "class \fBDummyDescriptor\fP"
.br
.ti -1c
.RI "struct \fBTxStateConfirmed\fP"
.br
.RI "\fBState\fP of transaction confirmed in a block\&. "
.ti -1c
.RI "struct \fBTxStateInMempool\fP"
.br
.RI "\fBState\fP of transaction added to mempool\&. "
.ti -1c
.RI "struct \fBTxStateBlockConflicted\fP"
.br
.RI "\fBState\fP of rejected transaction that conflicts with a confirmed block\&. "
.ti -1c
.RI "struct \fBTxStateInactive\fP"
.br
.ti -1c
.RI "struct \fBTxStateUnrecognized\fP"
.br
.ti -1c
.RI "struct \fBCachableAmount\fP"
.br
.ti -1c
.RI "class \fBCMerkleTx\fP"
.br
.ti -1c
.RI "class \fBCWalletTx\fP"
.br
.ti -1c
.RI "struct \fBWalletTxOrderComparator\fP"
.br
.ti -1c
.RI "class \fBWalletTXO\fP"
.br
.ti -1c
.RI "class \fBReserveDestination\fP"
.br
.ti -1c
.RI "struct \fBCAddressBookData\fP"
.br
.ti -1c
.RI "struct \fBCRecipient\fP"
.br
.ti -1c
.RI "class \fBCWallet\fP"
.br
.ti -1c
.RI "class \fBWalletRescanReserver\fP"
.br
.ti -1c
.RI "struct \fBMigrationResult\fP"
.br
.ti -1c
.RI "struct \fBLoadResult\fP"
.br
.ti -1c
.RI "class \fBCHDChain\fP"
.br
.ti -1c
.RI "class \fBCKeyMetadata\fP"
.br
.ti -1c
.RI "struct \fBDbTxnListener\fP"
.br
.ti -1c
.RI "class \fBWalletBatch\fP"
.br
.ti -1c
.RI "class \fBWalletDescriptor\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef std::map< \fBCoinEligibilityFilter\fP, \fBOutputGroupTypeMap\fP > \fBFilteredOutputGroups\fP"
.br
.ti -1c
.RI "using \fBLoadWalletFn\fP = std::function<void(std::unique_ptr<\fBinterfaces::Wallet\fP> \fBwallet\fP)>"
.br
.ti -1c
.RI "typedef std::vector< unsigned char, \fBsecure_allocator\fP< unsigned char > > \fBCKeyingMaterial\fP"
.br
.ti -1c
.RI "using \fBBerkeleyROData\fP = std::map<\fBSerializeData\fP, \fBSerializeData\fP, std::less<>>"
.br
.ti -1c
.RI "typedef std::vector< unsigned char > \fBvaltype\fP"
.br
.ti -1c
.RI "typedef std::set< std::shared_ptr< \fBCOutput\fP > > \fBCoinSet\fP"
.br
.ti -1c
.RI "using \fBMockableData\fP = std::map<\fBSerializeData\fP, \fBSerializeData\fP, std::less<>>"
.br
.ti -1c
.RI "using \fBTxState\fP = std::variant<\fBTxStateConfirmed\fP, \fBTxStateInMempool\fP, \fBTxStateBlockConflicted\fP, \fBTxStateInactive\fP, \fBTxStateUnrecognized\fP>"
.br
.RI "All possible \fBCWalletTx\fP states\&. "
.ti -1c
.RI "using \fBSyncTxState\fP = std::variant<\fBTxStateConfirmed\fP, \fBTxStateInMempool\fP, \fBTxStateInactive\fP>"
.br
.RI "Subset of states transaction sync logic is implemented to handle\&. "
.ti -1c
.RI "typedef std::map< std::string, std::string > \fBmapValue_t\fP"
.br
.ti -1c
.RI "using \fBLoadFunc\fP = std::function<\fBDBErrors\fP(\fBCWallet\fP* pwallet, \fBDataStream\fP& key, \fBDataStream\fP& value, std::string& err)>"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBSelectionAlgorithm\fP : uint8_t { \fBBNB\fP = 0, \fBKNAPSACK\fP = 1, \fBSRD\fP = 2, \fBCG\fP = 3, \fBMANUAL\fP = 4 }"
.br
.ti -1c
.RI "enum class \fBDatabaseFormat\fP { \fBSQLITE\fP, \fBBERKELEY_RO\fP }"
.br
.ti -1c
.RI "enum class \fBDatabaseStatus\fP { \fBSUCCESS\fP, \fBFAILED_BAD_PATH\fP, \fBFAILED_BAD_FORMAT\fP, \fBFAILED_LEGACY_DISABLED\fP, \fBFAILED_ALREADY_LOADED\fP, \fBFAILED_ALREADY_EXISTS\fP, \fBFAILED_NOT_FOUND\fP, \fBFAILED_CREATE\fP, \fBFAILED_LOAD\fP, \fBFAILED_VERIFY\fP, \fBFAILED_ENCRYPT\fP, \fBFAILED_INVALID_BACKUP_FILE\fP }"
.br
.ti -1c
.RI "enum class \fBPageType\fP : uint8_t { \fBBTREE_INTERNAL\fP = 3, \fBBTREE_LEAF\fP = 5, \fBOVERFLOW_DATA\fP = 7, \fBBTREE_META\fP = 9 }"
.br
.ti -1c
.RI "enum class \fBRecordType\fP : uint8_t { \fBKEYDATA\fP = 1, \fBOVERFLOW_DATA\fP = 3, \fBDELETE\fP = 0x80 }"
.br
.ti -1c
.RI "enum class \fBBTreeFlags\fP : uint32_t { \fBSUBDB\fP = 0x20 }"
.br
.ti -1c
.RI "enum class \fBCoinSelectionAlgorithm\fP { \fBBNB\fP, \fBSRD\fP, \fBKNAPSACK\fP }"
.br
.ti -1c
.RI "enum class \fBAddressPurpose\fP { \fBRECEIVE\fP, \fBSEND\fP, \fBREFUND\fP }"
.br
.ti -1c
.RI "enum class \fBDBErrors\fP : int { \fBLOAD_OK\fP = 0, \fBNEED_RESCAN\fP = 1, \fBNEED_REWRITE\fP = 2, \fBEXTERNAL_SIGNER_SUPPORT_REQUIRED\fP = 3, \fBNONCRITICAL_ERROR\fP = 4, \fBTOO_NEW\fP = 5, \fBUNKNOWN_DESCRIPTOR\fP = 6, \fBLOAD_FAIL\fP = 7, \fBUNEXPECTED_LEGACY_ENTRY\fP = 8, \fBLEGACY_WALLET\fP = 9, \fBCORRUPT\fP = 10 }"
.br
.ti -1c
.RI "enum \fBWalletFlags\fP : uint64_t { \fBWALLET_FLAG_AVOID_REUSE\fP = (1ULL << 0), \fBWALLET_FLAG_KEY_ORIGIN_METADATA\fP = (1ULL << 1), \fBWALLET_FLAG_LAST_HARDENED_XPUB_CACHED\fP = (1ULL << 2), \fBWALLET_FLAG_DISABLE_PRIVATE_KEYS\fP = (1ULL << 32), \fBWALLET_FLAG_BLANK_WALLET\fP = (1ULL << 33), \fBWALLET_FLAG_DESCRIPTORS\fP = (1ULL << 34), \fBWALLET_FLAG_EXTERNAL_SIGNER\fP = (1ULL << 35) }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBBENCHMARK\fP (WalletBalanceDirty, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletBalanceClean, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletBalanceMine, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletBalanceWatch, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletCreatePlain, \fBbenchmark::PriorityLevel::LOW\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletCreateEncrypted, \fBbenchmark::PriorityLevel::LOW\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletIsMineDescriptors, \fBbenchmark::PriorityLevel::LOW\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletIsMineMigratedDescriptors, \fBbenchmark::PriorityLevel::LOW\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletLoadingDescriptors, \fBbenchmark::PriorityLevel::HIGH\fP)"
.br
.ti -1c
.RI "\fBBENCHMARK\fP (WalletMigration, \fBbenchmark::PriorityLevel::LOW\fP)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBSelectCoinsBnB\fP (std::vector< \fBOutputGroup\fP > &utxo_pool, const \fBCAmount\fP &selection_target, const \fBCAmount\fP &cost_of_change, int max_selection_weight)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBCoinGrinder\fP (std::vector< \fBOutputGroup\fP > &utxo_pool, const \fBCAmount\fP &selection_target, \fBCAmount\fP change_target, int max_selection_weight)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBSelectCoinsSRD\fP (const std::vector< \fBOutputGroup\fP > &utxo_pool, \fBCAmount\fP target_value, \fBCAmount\fP change_fee, \fBFastRandomContext\fP &rng, int max_selection_weight)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBKnapsackSolver\fP (std::vector< \fBOutputGroup\fP > &groups, const \fBCAmount\fP &nTargetValue, \fBCAmount\fP change_target, \fBFastRandomContext\fP &rng, int max_selection_weight)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGenerateChangeTarget\fP (const \fBCAmount\fP payment_value, const \fBCAmount\fP change_fee, \fBFastRandomContext\fP &rng)"
.br
.ti -1c
.RI "std::string \fBGetAlgorithmName\fP (const \fBSelectionAlgorithm\fP algo)"
.br
.ti -1c
.RI "bool \fBEncryptSecret\fP (const \fBCKeyingMaterial\fP &vMasterKey, const \fBCKeyingMaterial\fP &vchPlaintext, const \fBuint256\fP &nIV, std::vector< unsigned char > &vchCiphertext)"
.br
.ti -1c
.RI "bool \fBDecryptSecret\fP (const \fBCKeyingMaterial\fP &master_key, const std::span< const unsigned char > ciphertext, const \fBuint256\fP &iv, \fBCKeyingMaterial\fP &plaintext)"
.br
.ti -1c
.RI "bool \fBDecryptKey\fP (const \fBCKeyingMaterial\fP &master_key, const std::span< const unsigned char > crypted_secret, const \fBCPubKey\fP &pub_key, \fBCKey\fP &key)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (\fBBytePrefix\fP a, std::span< const std::byte > b)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (std::span< const std::byte > a, \fBBytePrefix\fP b)"
.br
.ti -1c
.RI "std::vector< std::pair< \fBfs::path\fP, std::string > > \fBListDatabases\fP (const \fBfs::path\fP &wallet_dir)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBBDBDataFile\fP (const \fBfs::path\fP &wallet_path)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBSQLiteDataFile\fP (const \fBfs::path\fP &path)"
.br
.ti -1c
.RI "bool \fBIsBDBFile\fP (const \fBfs::path\fP &path)"
.br
.ti -1c
.RI "bool \fBIsSQLiteFile\fP (const \fBfs::path\fP &path)"
.br
.ti -1c
.RI "void \fBReadDatabaseArgs\fP (const \fBArgsManager\fP &\fBargs\fP, \fBDatabaseOptions\fP &options)"
.br
.ti -1c
.RI "std::unique_ptr< \fBWalletDatabase\fP > \fBMakeDatabase\fP (const \fBfs::path\fP &path, const \fBDatabaseOptions\fP &options, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error)"
.br
.ti -1c
.RI "bool \fBDumpWallet\fP (const \fBArgsManager\fP &\fBargs\fP, \fBWalletDatabase\fP &db, \fBbilingual_str\fP &error)"
.br
.ti -1c
.RI "bool \fBCreateFromDump\fP (const \fBArgsManager\fP &\fBargs\fP, const std::string &\fBname\fP, const \fBfs::path\fP &wallet_path, \fBbilingual_str\fP &error, std::vector< \fBbilingual_str\fP > &warnings)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetRequiredFee\fP (const \fBCWallet\fP &\fBwallet\fP, unsigned int nTxBytes)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBGetMinimumFee\fP (const \fBCWallet\fP &\fBwallet\fP, unsigned int nTxBytes, const \fBCCoinControl\fP &coin_control, \fBFeeCalculation\fP *feeCalc)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBGetRequiredFeeRate\fP (const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBGetMinimumFeeRate\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCCoinControl\fP &coin_control, \fBFeeCalculation\fP *feeCalc)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBGetDiscardRate\fP (const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "bool \fBVerifyWallets\fP (\fBWalletContext\fP &context)"
.br
.RI "Responsible for reading and validating the -wallet arguments and verifying the wallet database\&. "
.ti -1c
.RI "bool \fBLoadWallets\fP (\fBWalletContext\fP &context)"
.br
.RI "Load wallet databases\&. "
.ti -1c
.RI "void \fBStartWallets\fP (\fBWalletContext\fP &context)"
.br
.RI "Complete startup of wallets\&. "
.ti -1c
.RI "void \fBUnloadWallets\fP (\fBWalletContext\fP &context)"
.br
.ti -1c
.RI "std::unique_ptr< \fBBerkeleyRODatabase\fP > \fBMakeBerkeleyRODatabase\fP (const \fBfs::path\fP &path, const \fBDatabaseOptions\fP &options, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error)"
.br
.RI "Return object giving access to Berkeley Read Only database at specified path\&. "
.ti -1c
.RI "bool \fBInputIsMine\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTxIn\fP &txin)"
.br
.ti -1c
.RI "bool \fBAllInputsMine\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTransaction\fP &tx)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBOutputGetCredit\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTxOut\fP &txout)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBTxGetCredit\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTransaction\fP &tx)"
.br
.ti -1c
.RI "bool \fBScriptIsChange\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCScript\fP &\fBscript\fP)"
.br
.ti -1c
.RI "bool \fBOutputIsChange\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTxOut\fP &txout)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBOutputGetChange\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTxOut\fP &txout)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBTxGetChange\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCTransaction\fP &tx)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBCachedTxGetCredit\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx, bool avoid_reuse)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBCachedTxGetDebit\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx, bool avoid_reuse)"
.br
.ti -1c
.RI "\fBCAmount\fP \fBCachedTxGetChange\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx)"
.br
.ti -1c
.RI "void \fBCachedTxGetAmounts\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx, std::list< \fBCOutputEntry\fP > &listReceived, std::list< \fBCOutputEntry\fP > &listSent, \fBCAmount\fP &nFee, bool include_change)"
.br
.ti -1c
.RI "bool \fBCachedTxIsFromMe\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx)"
.br
.ti -1c
.RI "bool \fBCachedTxIsTrusted\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx, std::set< \fBTxid\fP > &trusted_parents)"
.br
.ti -1c
.RI "bool \fBCachedTxIsTrusted\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCWalletTx\fP &wtx)"
.br
.ti -1c
.RI "\fBBalance\fP \fBGetBalance\fP (const \fBCWallet\fP &\fBwallet\fP, const int min_depth, bool avoid_reuse)"
.br
.ti -1c
.RI "std::map< \fBCTxDestination\fP, \fBCAmount\fP > \fBGetAddressBalances\fP (const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "std::set< std::set< \fBCTxDestination\fP > > \fBGetAddressGroupings\fP (const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetnewaddress\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetrawchangeaddress\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsetlabel\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistaddressgroupings\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBkeypoolrefill\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetaddressinfo\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetaddressesbylabel\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistlabels\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBimportprunedfunds\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBremoveprunedfunds\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBimportdescriptors\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistdescriptors\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBbackupwallet\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBrestorewallet\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetreceivedbyaddress\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetreceivedbylabel\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetbalance\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlockunspent\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistlockunspent\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgetbalances\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistunspent\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBwalletpassphrase\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBwalletpassphrasechange\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBwalletlock\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBencryptwallet\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsignmessage\fP ()"
.br
.ti -1c
.RI "std::vector< \fBCRecipient\fP > \fBCreateRecipients\fP (const std::vector< std::pair< \fBCTxDestination\fP, \fBCAmount\fP > > &outputs, const std::set< int > &subtract_fee_outputs)"
.br
.ti -1c
.RI "std::set< int > \fBInterpretSubtractFeeFromOutputInstructions\fP (const \fBUniValue\fP &sffo_instructions, const std::vector< std::string > &destinations)"
.br
.ti -1c
.RI "\fBUniValue\fP \fBSendMoney\fP (\fBCWallet\fP &\fBwallet\fP, const \fBCCoinControl\fP &coin_control, std::vector< \fBCRecipient\fP > &recipients, \fBmapValue_t\fP map_value, bool verbose)"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsendtoaddress\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsendmany\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsettxfee\fP ()"
.br
.ti -1c
.RI "\fBCreatedTransactionResult\fP \fBFundTransaction\fP (\fBCWallet\fP &\fBwallet\fP, const \fBCMutableTransaction\fP &tx, const std::vector< \fBCRecipient\fP > &recipients, const \fBUniValue\fP &options, \fBCCoinControl\fP &coinControl, bool override_min_fee)"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBfundrawtransaction\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsignrawtransactionwithwallet\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBbumpfee\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBpsbtbumpfee\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsend\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsendall\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBwalletprocesspsbt\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBwalletcreatefundedpsbt\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistreceivedbyaddress\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistreceivedbylabel\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlisttransactions\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBlistsinceblock\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgettransaction\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBabandontransaction\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBrescanblockchain\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBabortrescan\fP ()"
.br
.ti -1c
.RI "bool \fBGetAvoidReuseFlag\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBUniValue\fP &param)"
.br
.ti -1c
.RI "std::string \fBEnsureUniqueWalletName\fP (const \fBJSONRPCRequest\fP &request, std::optional< std::string_view > wallet_name)"
.br
.ti -1c
.RI "bool \fBGetWalletNameFromJSONRPCRequest\fP (const \fBJSONRPCRequest\fP &request, std::string &wallet_name)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBGetWalletForJSONRPCRequest\fP (const \fBJSONRPCRequest\fP &request)"
.br
.ti -1c
.RI "void \fBEnsureWalletIsUnlocked\fP (const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "\fBWalletContext\fP & \fBEnsureWalletContext\fP (const std::any &context)"
.br
.ti -1c
.RI "std::string \fBLabelFromValue\fP (const \fBUniValue\fP &value)"
.br
.ti -1c
.RI "void \fBPushParentDescriptors\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCScript\fP &script_pubkey, \fBUniValue\fP &entry)"
.br
.RI "Fetch parent descriptors of this scriptPubKey\&. "
.ti -1c
.RI "void \fBHandleWalletError\fP (const std::shared_ptr< \fBCWallet\fP > \fBwallet\fP, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error)"
.br
.ti -1c
.RI "void \fBAppendLastProcessedBlock\fP (\fBUniValue\fP &entry, const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBsimulaterawtransaction\fP ()"
.br
.ti -1c
.RI "\fBRPCHelpMan\fP \fBgethdkeys\fP ()"
.br
.ti -1c
.RI "std::span< const \fBCRPCCommand\fP > \fBGetWalletRPCCommands\fP ()"
.br
.ti -1c
.RI "std::vector< \fBCKeyID\fP > \fBGetAffectedKeys\fP (const \fBCScript\fP &spk, const \fBSigningProvider\fP &provider)"
.br
.ti -1c
.RI "int \fBCalculateMaximumSignedInputSize\fP (const \fBCTxOut\fP &txout, const \fBCOutPoint\fP outpoint, const \fBSigningProvider\fP *provider, bool can_grind_r, const \fBCCoinControl\fP *coin_control)"
.br
.ti -1c
.RI "int \fBCalculateMaximumSignedInputSize\fP (const \fBCTxOut\fP &txout, const \fBCWallet\fP *\fBwallet\fP, const \fBCCoinControl\fP *coin_control)"
.br
.ti -1c
.RI "\fBTxSize\fP \fBCalculateMaximumSignedTxSize\fP (const \fBCTransaction\fP &tx, const \fBCWallet\fP *\fBwallet\fP, const std::vector< \fBCTxOut\fP > &txouts, const \fBCCoinControl\fP *coin_control)"
.br
.ti -1c
.RI "\fBTxSize\fP \fBCalculateMaximumSignedTxSize\fP (const \fBCTransaction\fP &tx, const \fBCWallet\fP *\fBwallet\fP, const \fBCCoinControl\fP *coin_control)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBPreSelectedInputs\fP > \fBFetchSelectedInputs\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCCoinControl\fP &coin_control, const \fBCoinSelectionParams\fP &coin_selection_params)"
.br
.ti -1c
.RI "\fBCoinsResult\fP \fBAvailableCoins\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCCoinControl\fP *coinControl, std::optional< \fBCFeeRate\fP > feerate, const \fBCoinFilterParams\fP &params)"
.br
.ti -1c
.RI "const \fBCTxOut\fP & \fBFindNonChangeParentOutput\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCOutPoint\fP &outpoint)"
.br
.ti -1c
.RI "std::map< \fBCTxDestination\fP, std::vector< \fBCOutput\fP > > \fBListCoins\fP (const \fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "\fBFilteredOutputGroups\fP \fBGroupOutputs\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCoinsResult\fP &coins, const \fBCoinSelectionParams\fP &coin_sel_params, const std::vector< \fBSelectionFilter\fP > &filters, std::vector< \fBOutputGroup\fP > &ret_discarded_groups)"
.br
.ti -1c
.RI "\fBFilteredOutputGroups\fP \fBGroupOutputs\fP (const \fBCWallet\fP &\fBwallet\fP, const \fBCoinsResult\fP &coins, const \fBCoinSelectionParams\fP &params, const std::vector< \fBSelectionFilter\fP > &filters)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBAttemptSelection\fP (\fBinterfaces::Chain\fP &chain, const \fBCAmount\fP &nTargetValue, \fBOutputGroupTypeMap\fP &groups, const \fBCoinSelectionParams\fP &coin_selection_params, bool allow_mixed_output_types)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBChooseSelectionResult\fP (\fBinterfaces::Chain\fP &chain, const \fBCAmount\fP &nTargetValue, \fBGroups\fP &groups, const \fBCoinSelectionParams\fP &coin_selection_params)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBSelectCoins\fP (const \fBCWallet\fP &\fBwallet\fP, \fBCoinsResult\fP &available_coins, const \fBPreSelectedInputs\fP &pre_set_inputs, const \fBCAmount\fP &nTargetValue, const \fBCCoinControl\fP &coin_control, const \fBCoinSelectionParams\fP &coin_selection_params)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBSelectionResult\fP > \fBAutomaticCoinSelection\fP (const \fBCWallet\fP &\fBwallet\fP, \fBCoinsResult\fP &available_coins, const \fBCAmount\fP &value_to_select, const \fBCoinSelectionParams\fP &coin_selection_params)"
.br
.ti -1c
.RI "void \fBDiscourageFeeSniping\fP (\fBCMutableTransaction\fP &tx, \fBFastRandomContext\fP &rng_fast, \fBinterfaces::Chain\fP &chain, const \fBuint256\fP &block_hash, int block_height)"
.br
.ti -1c
.RI "uint64_t \fBGetSerializeSizeForRecipient\fP (const \fBCRecipient\fP &recipient)"
.br
.ti -1c
.RI "bool \fBIsDust\fP (const \fBCRecipient\fP &recipient, const \fBCFeeRate\fP &dustRelayFee)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBCreatedTransactionResult\fP > \fBCreateTransaction\fP (\fBCWallet\fP &\fBwallet\fP, const std::vector< \fBCRecipient\fP > &vecSend, std::optional< unsigned int > change_pos, const \fBCCoinControl\fP &coin_control, bool sign)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBCreatedTransactionResult\fP > \fBFundTransaction\fP (\fBCWallet\fP &\fBwallet\fP, const \fBCMutableTransaction\fP &tx, const std::vector< \fBCRecipient\fP > &vecSend, std::optional< unsigned int > change_pos, bool lockUnspents, \fBCCoinControl\fP coinControl)"
.br
.ti -1c
.RI "\fBTxSize\fP \fBCalculateMaximumSignedTxSize\fP (const \fBCTransaction\fP &tx, const \fBCWallet\fP *\fBwallet\fP, const \fBCCoinControl\fP *coin_control=nullptr) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBwallet\fP \-> cs_wallet)"
.br
.ti -1c
.RI "std::unique_ptr< \fBSQLiteDatabase\fP > \fBMakeSQLiteDatabase\fP (const \fBfs::path\fP &path, const \fBDatabaseOptions\fP &options, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error)"
.br
.ti -1c
.RI "std::string \fBSQLiteDatabaseVersion\fP ()"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (bnb_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (bnb_feerate_sensitivity_test)"
.br
.ti -1c
.RI "std::optional< \fBSelectionResult\fP > \fBKnapsackSolver\fP (std::vector< \fBOutputGroup\fP > &groups, const \fBCAmount\fP &nTargetValue, \fBCAmount\fP change_target, \fBFastRandomContext\fP &rng)"
.br
.ti -1c
.RI "std::optional< \fBSelectionResult\fP > \fBSelectCoinsBnB\fP (std::vector< \fBOutputGroup\fP > &utxo_pool, const \fBCAmount\fP &selection_target, const \fBCAmount\fP &cost_of_change)"
.br
.ti -1c
.RI "std::vector< \fBOutputGroup\fP > & \fBGroupCoins\fP (const std::vector< \fBCOutput\fP > &available_coins, bool subtract_fee_outputs=false)"
.br
.ti -1c
.RI "std::vector< \fBOutputGroup\fP > & \fBKnapsackGroupOutputs\fP (const \fBCoinsResult\fP &available_coins, \fBCWallet\fP &\fBwallet\fP, const \fBCoinEligibilityFilter\fP &filter)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (bnb_search_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (bnb_sffo_restriction)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (knapsack_solver_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (ApproximateBestSubset)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (SelectCoins_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (waste_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (bump_fee_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (effective_value_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (coin_grinder_tests)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (srd_tests)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (check_max_selection_weight)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (SelectCoins_effective_value_test)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (wallet_coinsresult_test, \fBBasicTestingSetup\fP)"
.br
.ti -1c
.RI "std::span< const std::byte > \fBStringBytes\fP (std::string_view str)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (db_cursor_prefix_range_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (db_cursor_prefix_byte_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (db_availability_after_write_error)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (erase_prefix)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (txn_close_failure_dangling_txn)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (concurrent_txn_dont_interfere)"
.br
.ti -1c
.RI "\fBFUZZ_TARGET\fP (coin_grinder)"
.br
.ti -1c
.RI "\fBFUZZ_TARGET\fP (coin_grinder_is_optimal)"
.br
.ti -1c
.RI "template<\fBCoinSelectionAlgorithm\fP Algorithm> void \fBFuzzCoinSelectionAlgorithm\fP (std::span< const uint8_t > buffer)"
.br
.ti -1c
.RI "\fBFUZZ_TARGET\fP (coinselection_bnb)"
.br
.ti -1c
.RI "\fBFUZZ_TARGET\fP (coinselection_srd)"
.br
.ti -1c
.RI "\fBFUZZ_TARGET\fP (coinselection_knapsack)"
.br
.ti -1c
.RI "\fBCoinSelectionParams\fP \fBmakeSelectionParams\fP (\fBFastRandomContext\fP &rand, bool avoid_partial_spends)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (outputs_grouping_tests)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_default)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_custom)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_does_not_exist)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_is_not_directory)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_is_not_relative)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_no_trailing)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletinit_verify_walletdir_no_trailing2)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (ismine_standard)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (psbt_updater_test)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (parse_hd_keypath)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (DescriptorScriptPubKeyManTests)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (SubtractFee, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (wallet_duplicated_preset_inputs_test, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "std::unique_ptr< \fBCWallet\fP > \fBCreateSyncedWallet\fP (\fBinterfaces::Chain\fP &chain, \fBCChain\fP &cchain, const \fBCKey\fP &key)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBTestLoadWallet\fP (std::unique_ptr< \fBWalletDatabase\fP > database, \fBWalletContext\fP &context, uint64_t create_flags)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBTestLoadWallet\fP (\fBWalletContext\fP &context)"
.br
.ti -1c
.RI "void \fBTestUnloadWallet\fP (std::shared_ptr< \fBCWallet\fP > &&\fBwallet\fP)"
.br
.ti -1c
.RI "std::unique_ptr< \fBWalletDatabase\fP > \fBDuplicateMockDatabase\fP (\fBWalletDatabase\fP &database)"
.br
.ti -1c
.RI "std::string \fBgetnewaddress\fP (\fBCWallet\fP &w)"
.br
.ti -1c
.RI "\fBCTxDestination\fP \fBgetNewDestination\fP (\fBCWallet\fP &w, \fBOutputType\fP output_type)"
.br
.ti -1c
.RI "std::unique_ptr< \fBWalletDatabase\fP > \fBCreateMockableWalletDatabase\fP (\fBMockableData\fP records)"
.br
.ti -1c
.RI "\fBMockableDatabase\fP & \fBGetMockableDatabase\fP (\fBCWallet\fP &\fBwallet\fP)"
.br
.ti -1c
.RI "\fBwallet::DescriptorScriptPubKeyMan\fP * \fBCreateDescriptor\fP (\fBCWallet\fP &keystore, const std::string &desc_str, const bool success)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (passphrase)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (encrypt)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (decrypt)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (ensure_unique_wallet_name)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (update_non_range_descriptor, \fBTestingSetup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (scan_for_wallet_transactions, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (write_wallet_settings_concurrently, \fBTestingSetup\fP)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (ComputeTimeSmart)"
.br
.ti -1c
.RI "void \fBTestLoadWallet\fP (const std::string &\fBname\fP, \fBDatabaseFormat\fP format, std::function< void(std::shared_ptr< \fBCWallet\fP >)> f)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (LoadReceiveRequests, \fBTestingSetup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (ListCoinsTest, \fBListCoinsTestingSetup\fP)"
.br
.ti -1c
.RI "void \fBTestCoinsResult\fP (ListCoinsTest &context, \fBOutputType\fP out_type, \fBCAmount\fP amount, std::map< \fBOutputType\fP, size_t > &expected_coins_sizes)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (BasicOutputTypesTest, ListCoinsTest)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (wallet_disableprivkeys, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (dummy_input_size_test, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "bool \fBmalformed_descriptor\fP (std::ios_base::failure e)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (wallet_descriptor_test, \fBBasicTestingSetup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (\fBCreateWallet\fP, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (CreateWalletWithoutChain, \fBBasicTestingSetup\fP)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (RemoveTxs, \fBTestChain100Setup\fP)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (roundtrip)"
.br
.ti -1c
.RI "\fBBOOST_AUTO_TEST_CASE\fP (walletdb_readkeyvalue)"
.br
.ti -1c
.RI "\fBBOOST_FIXTURE_TEST_CASE\fP (wallet_load_descriptors, \fBTestingSetup\fP)"
.br
.ti -1c
.RI "template<typename \fBT\fP> std::string \fBTxStateString\fP (const \fBT\fP &state)"
.br
.RI "Return \fBTxState\fP or \fBSyncTxState\fP as a string for logging or debugging\&. "
.ti -1c
.RI "bool \fBAddWalletSetting\fP (\fBinterfaces::Chain\fP &chain, const std::string &wallet_name)"
.br
.RI "Add wallet name to persistent configuration so it will be loaded on startup\&. "
.ti -1c
.RI "bool \fBRemoveWalletSetting\fP (\fBinterfaces::Chain\fP &chain, const std::string &wallet_name)"
.br
.RI "Remove wallet name from persistent configuration so it will not be loaded on startup\&. "
.ti -1c
.RI "bool \fBAddWallet\fP (\fBWalletContext\fP &context, const std::shared_ptr< \fBCWallet\fP > &\fBwallet\fP)"
.br
.ti -1c
.RI "bool \fBRemoveWallet\fP (\fBWalletContext\fP &context, const std::shared_ptr< \fBCWallet\fP > &\fBwallet\fP, std::optional< bool > load_on_start, std::vector< \fBbilingual_str\fP > &warnings)"
.br
.ti -1c
.RI "bool \fBRemoveWallet\fP (\fBWalletContext\fP &context, const std::shared_ptr< \fBCWallet\fP > &\fBwallet\fP, std::optional< bool > load_on_start)"
.br
.ti -1c
.RI "std::vector< std::shared_ptr< \fBCWallet\fP > > \fBGetWallets\fP (\fBWalletContext\fP &context)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBGetDefaultWallet\fP (\fBWalletContext\fP &context, size_t &count)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBGetWallet\fP (\fBWalletContext\fP &context, const std::string &\fBname\fP)"
.br
.ti -1c
.RI "std::unique_ptr< \fBinterfaces::Handler\fP > \fBHandleLoadWallet\fP (\fBWalletContext\fP &context, \fBLoadWalletFn\fP load_wallet)"
.br
.ti -1c
.RI "void \fBNotifyWalletLoaded\fP (\fBWalletContext\fP &context, const std::shared_ptr< \fBCWallet\fP > &\fBwallet\fP)"
.br
.ti -1c
.RI "void \fBWaitForDeleteWallet\fP (std::shared_ptr< \fBCWallet\fP > &&\fBwallet\fP)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBLoadWallet\fP (\fBWalletContext\fP &context, const std::string &\fBname\fP, std::optional< bool > load_on_start, const \fBDatabaseOptions\fP &options, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error, std::vector< \fBbilingual_str\fP > &warnings)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBCreateWallet\fP (\fBWalletContext\fP &context, const std::string &\fBname\fP, std::optional< bool > load_on_start, \fBDatabaseOptions\fP &options, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error, std::vector< \fBbilingual_str\fP > &warnings)"
.br
.ti -1c
.RI "std::shared_ptr< \fBCWallet\fP > \fBRestoreWallet\fP (\fBWalletContext\fP &context, const \fBfs::path\fP &backup_file, const std::string &wallet_name, std::optional< bool > load_on_start, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error, std::vector< \fBbilingual_str\fP > &warnings, bool load_after_restore)"
.br
.ti -1c
.RI "void \fBMaybeResendWalletTxs\fP (\fBWalletContext\fP &context)"
.br
.ti -1c
.RI "std::unique_ptr< \fBWalletDatabase\fP > \fBMakeWalletDatabase\fP (const std::string &\fBname\fP, const \fBDatabaseOptions\fP &options, \fBDatabaseStatus\fP &status, \fBbilingual_str\fP &error_string)"
.br
.ti -1c
.RI "bool \fBDoMigration\fP (\fBCWallet\fP &\fBwallet\fP, \fBWalletContext\fP &context, \fBbilingual_str\fP &error, \fBMigrationResult\fP &res) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(wallet\&.cs_wallet)"
.br
.ti -1c
.RI "\fButil::Result\fP< \fBMigrationResult\fP > \fBMigrateLegacyToDescriptor\fP (const std::string &wallet_name, const \fBSecureString\fP &passphrase, \fBWalletContext\fP &context)"
.br
.RI "Do all steps to migrate a legacy wallet to a descriptor wallet\&. "
.ti -1c
.RI "\fButil::Result\fP< \fBMigrationResult\fP > \fBMigrateLegacyToDescriptor\fP (std::shared_ptr< \fBCWallet\fP > local_wallet, const \fBSecureString\fP &passphrase, \fBWalletContext\fP &context)"
.br
.RI "Requirement: The wallet provided to this function must be isolated, with no attachment to the node's context\&. "
.ti -1c
.RI "std::string \fBPurposeToString\fP (\fBAddressPurpose\fP p)"
.br
.ti -1c
.RI "std::optional< \fBAddressPurpose\fP > \fBPurposeFromString\fP (std::string_view s)"
.br
.ti -1c
.RI "void \fBLogDBInfo\fP ()"
.br
.ti -1c
.RI "bool \fBLoadKey\fP (\fBCWallet\fP *pwallet, \fBDataStream\fP &ssKey, \fBDataStream\fP &ssValue, std::string &strErr)"
.br
.ti -1c
.RI "bool \fBLoadCryptedKey\fP (\fBCWallet\fP *pwallet, \fBDataStream\fP &ssKey, \fBDataStream\fP &ssValue, std::string &strErr)"
.br
.ti -1c
.RI "bool \fBLoadEncryptionKey\fP (\fBCWallet\fP *pwallet, \fBDataStream\fP &ssKey, \fBDataStream\fP &ssValue, std::string &strErr)"
.br
.ti -1c
.RI "bool \fBLoadHDChain\fP (\fBCWallet\fP *pwallet, \fBDataStream\fP &ssValue, std::string &strErr)"
.br
.ti -1c
.RI "bool \fBHasLegacyRecords\fP (\fBCWallet\fP &\fBwallet\fP)"
.br
.RI "Returns true if there are any \fBDBKeys::LEGACY_TYPES\fP record in the wallet db\&. "
.ti -1c
.RI "bool \fBHasLegacyRecords\fP (\fBCWallet\fP &\fBwallet\fP, \fBDatabaseBatch\fP &batch)"
.br
.ti -1c
.RI "bool \fBRunWithinTxn\fP (\fBWalletDatabase\fP &database, std::string_view process_desc, const std::function< bool(\fBWalletBatch\fP &)> &func)"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetWalletDir\fP ()"
.br
.RI "Get the path of the wallet directory\&. "
.ti -1c
.RI "\fBWalletDescriptor\fP \fBGenerateWalletDescriptor\fP (const \fBCExtPubKey\fP &master_key, const \fBOutputType\fP &addr_type, bool internal)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const int \fBDEFAULT_MIN_DEPTH\fP = 0"
.br
.ti -1c
.RI "const int \fBDEFAULT_MAX_DEPTH\fP = 9999999"
.br
.ti -1c
.RI "const int \fBDEFAULT_WALLET_TX_VERSION\fP = \fBCTransaction::CURRENT_VERSION\fP"
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "} \fBdescending\fP"
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "} \fBdescending_effval_weight\fP"
.br
.ti -1c
.RI "const unsigned int \fBWALLET_CRYPTO_KEY_SIZE\fP = 32"
.br
.ti -1c
.RI "const unsigned int \fBWALLET_CRYPTO_SALT_SIZE\fP = 8"
.br
.ti -1c
.RI "const unsigned int \fBWALLET_CRYPTO_IV_SIZE\fP = 16"
.br
.ti -1c
.RI "uint32_t \fBDUMP_VERSION\fP = 1"
.br
.ti -1c
.RI "constexpr uint32_t \fBBTREE_MAGIC\fP = 0x00053162"
.br
.ti -1c
.RI "constexpr uint32_t \fBBTREE_MAGIC_OE\fP = 0x62310500"
.br
.ti -1c
.RI "const std::string \fBHELP_REQUIRING_PASSPHRASE\fP {'\\nRequires \fBwallet\fP passphrase to be set with \fBwalletpassphrase\fP call \fBif\fP \fBwallet\fP is encrypted\&.\\n'}"
.br
.ti -1c
.RI "constexpr int \fBTEST_SQLITE_ERROR\fP = \-999"
.br
.ti -1c
.RI "const std::string \fBADDRESS_BCRT1_UNSPENDABLE\fP = 'bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj'"
.br
.ti -1c
.RI "constexpr \fBCAmount\fP \fBDEFAULT_PAY_TX_FEE\fP = 0"
.br
.RI "-paytxfee default "
.ti -1c
.RI "constexpr \fBCAmount\fP \fBHIGH_APS_FEE\fP {COIN / 10000}"
.br
.RI "discourage APS fee higher than this amount "
.ti -1c
.RI "constexpr \fBCAmount\fP \fBDEFAULT_TRANSACTION_MAXFEE\fP {COIN / 10}"
.br
.RI "-maxtxfee default "
.ti -1c
.RI "constexpr \fBCAmount\fP \fBHIGH_TX_FEE_PER_KB\fP {COIN / 100}"
.br
.RI "Discourage users to set fees higher than this amount (in satoshis) per kB\&. "
.ti -1c
.RI "constexpr \fBCAmount\fP \fBHIGH_MAX_TX_FEE\fP {100 * \fBHIGH_TX_FEE_PER_KB\fP}"
.br
.RI "-maxtxfee will warn if called with a higher fee than this amount (in satoshis) "
.ti -1c
.RI "constexpr \fBOutputType\fP \fBDEFAULT_ADDRESS_TYPE\fP {\fBOutputType::BECH32\fP}"
.br
.RI "Default for -addresstype\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBBerkeleyROData\fP = std::map<\fBSerializeData\fP, \fBSerializeData\fP, std::less<>>"

.SS "typedef std::vector<unsigned char, \fBsecure_allocator\fP<unsigned char> > \fBCKeyingMaterial\fP"

.SS "typedef std::set<std::shared_ptr<\fBCOutput\fP> > \fBCoinSet\fP"

.SS "typedef std::map<\fBCoinEligibilityFilter\fP, \fBOutputGroupTypeMap\fP> \fBFilteredOutputGroups\fP"

.SS "using \fBLoadFunc\fP = std::function<\fBDBErrors\fP(\fBCWallet\fP* pwallet, \fBDataStream\fP& key, \fBDataStream\fP& value, std::string& err)>"

.SS "using \fBLoadWalletFn\fP = std::function<void(std::unique_ptr<\fBinterfaces::Wallet\fP> \fBwallet\fP)>"

.SS "typedef std::map<std::string, std::string> \fBmapValue_t\fP"

.SS "using \fBMockableData\fP = std::map<\fBSerializeData\fP, \fBSerializeData\fP, std::less<>>"

.SS "using \fBSyncTxState\fP = std::variant<\fBTxStateConfirmed\fP, \fBTxStateInMempool\fP, \fBTxStateInactive\fP>"

.PP
Subset of states transaction sync logic is implemented to handle\&. 
.SS "using \fBTxState\fP = std::variant<\fBTxStateConfirmed\fP, \fBTxStateInMempool\fP, \fBTxStateBlockConflicted\fP, \fBTxStateInactive\fP, \fBTxStateUnrecognized\fP>"

.PP
All possible \fBCWalletTx\fP states\&. 
.SS "typedef std::vector<unsigned char> \fBvaltype\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBAddressPurpose\fP\fR [strong]\fP"
Address purpose field that has been been stored with wallet sending and receiving addresses since BIP70 payment protocol support was added in https://github.com/bitcoin/bitcoin/pull/2539\&. This field is not currently used for any logic inside the wallet, but it is still shown in RPC and GUI interfaces and saved for new addresses\&. It is basically redundant with an address's IsMine() result\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIRECEIVE \fP
.TP
\f(BISEND \fP
.TP
\f(BIREFUND \fP
Never set in current code may be present in older wallet databases\&. 
.SS "enum class \fBBTreeFlags\fP : uint32_t\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISUBDB \fP
.SS "enum class \fBCoinSelectionAlgorithm\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBNB \fP
.TP
\f(BISRD \fP
.TP
\f(BIKNAPSACK \fP
.SS "enum class \fBDatabaseFormat\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISQLITE \fP
.TP
\f(BIBERKELEY_RO \fP
.SS "enum class \fBDatabaseStatus\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISUCCESS \fP
.TP
\f(BIFAILED_BAD_PATH \fP
.TP
\f(BIFAILED_BAD_FORMAT \fP
.TP
\f(BIFAILED_LEGACY_DISABLED \fP
.TP
\f(BIFAILED_ALREADY_LOADED \fP
.TP
\f(BIFAILED_ALREADY_EXISTS \fP
.TP
\f(BIFAILED_NOT_FOUND \fP
.TP
\f(BIFAILED_CREATE \fP
.TP
\f(BIFAILED_LOAD \fP
.TP
\f(BIFAILED_VERIFY \fP
.TP
\f(BIFAILED_ENCRYPT \fP
.TP
\f(BIFAILED_INVALID_BACKUP_FILE \fP
.SS "enum class \fBDBErrors\fP : int\fR [strong]\fP"
Overview of wallet database classes:

.PP
.IP "\(bu" 2
\fBWalletBatch\fP is an abstract modifier object for the wallet database, and encapsulates a database batch update as well as methods to act on the database\&. It should be agnostic to the database implementation\&. Error statuses for the wallet database\&. Values are in order of severity\&. When multiple errors occur, the most severe (highest value) will be returned\&. 
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILOAD_OK \fP
.TP
\f(BINEED_RESCAN \fP
.TP
\f(BINEED_REWRITE \fP
.TP
\f(BIEXTERNAL_SIGNER_SUPPORT_REQUIRED \fP
.TP
\f(BINONCRITICAL_ERROR \fP
.TP
\f(BITOO_NEW \fP
.TP
\f(BIUNKNOWN_DESCRIPTOR \fP
.TP
\f(BILOAD_FAIL \fP
.TP
\f(BIUNEXPECTED_LEGACY_ENTRY \fP
.TP
\f(BILEGACY_WALLET \fP
.TP
\f(BICORRUPT \fP
.SS "enum class \fBPageType\fP : uint8_t\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBTREE_INTERNAL \fP
.TP
\f(BIBTREE_LEAF \fP
.TP
\f(BIOVERFLOW_DATA \fP
.TP
\f(BIBTREE_META \fP
.SS "enum class \fBRecordType\fP : uint8_t\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIKEYDATA \fP
.TP
\f(BIOVERFLOW_DATA \fP
.TP
\f(BIDELETE \fP
.SS "enum class \fBSelectionAlgorithm\fP : uint8_t\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBNB \fP
.TP
\f(BIKNAPSACK \fP
.TP
\f(BISRD \fP
.TP
\f(BICG \fP
.TP
\f(BIMANUAL \fP
.SS "enum \fBWalletFlags\fP : uint64_t"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIWALLET_FLAG_AVOID_REUSE \fP
.TP
\f(BIWALLET_FLAG_KEY_ORIGIN_METADATA \fP
.TP
\f(BIWALLET_FLAG_LAST_HARDENED_XPUB_CACHED \fP
.TP
\f(BIWALLET_FLAG_DISABLE_PRIVATE_KEYS \fP
.TP
\f(BIWALLET_FLAG_BLANK_WALLET \fP
Flag set when a wallet contains no HD seed and no private keys, scripts, addresses, and other watch only things, and is therefore "blank\&."

.PP
The main function this flag serves is to distinguish a blank wallet from a newly created wallet when the wallet database is loaded, to avoid initialization that should only happen on first run\&.

.PP
A secondary function of this flag, which applies to descriptor wallets only, is to serve as an ongoing indication that descriptors in the wallet should be created manually, and that the wallet should not generate automatically generate new descriptors if it is later encrypted\&. To support this behavior, descriptor wallets unlike legacy wallets do not automatically unset the BLANK flag when things are imported\&.

.PP
This flag is also a mandatory flag to prevent previous versions of bitcoin from opening the wallet, thinking it was newly created, and then improperly reinitializing it\&. 
.TP
\f(BIWALLET_FLAG_DESCRIPTORS \fP
Indicate that this wallet supports \fBDescriptorScriptPubKeyMan\fP\&. 
.TP
\f(BIWALLET_FLAG_EXTERNAL_SIGNER \fP
Indicates that the wallet needs an external signer\&. 
.SH "Function Documentation"
.PP 
.SS "\fBRPCHelpMan\fP abandontransaction ()"

.SS "\fBRPCHelpMan\fP abortrescan ()"

.SS "bool AddWallet (\fBWalletContext\fP & context, const std::shared_ptr< \fBCWallet\fP > & wallet)"

.SS "bool AddWalletSetting (\fBinterfaces::Chain\fP & chain, const std::string & wallet_name)"

.PP
Add wallet name to persistent configuration so it will be loaded on startup\&. 
.SS "bool AllInputsMine (const \fBCWallet\fP & wallet, const \fBCTransaction\fP & tx)"
Returns whether all of the inputs belong to the wallet 
.SS "void AppendLastProcessedBlock (\fBUniValue\fP & entry, const \fBCWallet\fP & wallet)"

.SS "\fButil::Result\fP< \fBSelectionResult\fP > AttemptSelection (\fBinterfaces::Chain\fP & chain, const \fBCAmount\fP & nTargetValue, \fBOutputGroupTypeMap\fP & groups, const \fBCoinSelectionParams\fP & coin_selection_params, bool allow_mixed_output_types)"
Attempt to find a valid input set that preserves privacy by not mixing OutputTypes\&. \fR\fBChooseSelectionResult()\fP\fP will be called on each \fBOutputType\fP individually and the best the solution (according to the waste metric) will be chosen\&. If a valid input cannot be found from any single \fBOutputType\fP, fallback to running \fR\fBChooseSelectionResult()\fP\fP over all available coins\&.

.PP
\fBParameters\fP
.RS 4
\fIchain\fP The chain interface to get information on bump fees for unconfirmed UTXOs 
.br
\fInTargetValue\fP The target value 
.br
\fIgroups\fP The grouped outputs mapped by coin eligibility filters 
.br
\fIcoin_selection_params\fP Parameters for the coin selection 
.br
\fIallow_mixed_output_types\fP Relax restriction that SelectionResults must be of the same \fBOutputType\fP returns If successful, a \fBSelectionResult\fP containing the input set If failed, returns (1) an empty error message if the target was not reached (general "Insufficient funds") or (2) a specific error message if there was something particularly wrong (e\&.g\&. a selection result that surpassed the tx max weight size)\&. 
.RE
.PP

.SS "\fButil::Result\fP< \fBSelectionResult\fP > AutomaticCoinSelection (const \fBCWallet\fP & wallet, \fBCoinsResult\fP & available_coins, const \fBCAmount\fP & nTargetValue, const \fBCoinSelectionParams\fP & coin_selection_params)"
Select a set of coins such that nTargetValue is met; never select unconfirmed coins if they are not ours 
.PP
\fBParameters\fP
.RS 4
\fIwallet\fP The wallet which provides data necessary to spend the selected coins 
.br
\fIavailable_coins\fP The struct of coins, organized by \fBOutputType\fP, available for selection prior to filtering 
.br
\fInTargetValue\fP The target value 
.br
\fIcoin_selection_params\fP Parameters for this coin selection such as feerates, whether to avoid partial spends, and whether to subtract the fee from the outputs\&. returns If successful, a \fBSelectionResult\fP containing the selected coins If failed, returns (1) an empty error message if the target was not reached (general "Insufficient funds") or (2) an specific error message if there was something particularly wrong (e\&.g\&. a selection result that surpassed the tx max weight size)\&. 
.RE
.PP

.SS "\fBCoinsResult\fP AvailableCoins (const \fBCWallet\fP & wallet, const \fBCCoinControl\fP * coinControl = \fRnullptr\fP, std::optional< \fBCFeeRate\fP > feerate = \fRstd::nullopt\fP, const \fBCoinFilterParams\fP & params = \fR{}\fP)"
Populate the \fBCoinsResult\fP struct with vectors of available COutputs, organized by \fBOutputType\fP\&. 
.SS "\fBRPCHelpMan\fP backupwallet ()"

.SS "\fBfs::path\fP BDBDataFile (const \fBfs::path\fP & wallet_path)"

.SS "BENCHMARK (WalletBalanceClean , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "BENCHMARK (WalletBalanceDirty , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "BENCHMARK (WalletBalanceMine , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "BENCHMARK (WalletBalanceWatch , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "BENCHMARK (WalletCreateEncrypted , \fBbenchmark::PriorityLevel::LOW\fP )"

.SS "BENCHMARK (WalletCreatePlain , \fBbenchmark::PriorityLevel::LOW\fP )"

.SS "BENCHMARK (WalletIsMineDescriptors , \fBbenchmark::PriorityLevel::LOW\fP )"

.SS "BENCHMARK (WalletIsMineMigratedDescriptors , \fBbenchmark::PriorityLevel::LOW\fP )"

.SS "BENCHMARK (WalletLoadingDescriptors , \fBbenchmark::PriorityLevel::HIGH\fP )"

.SS "BENCHMARK (WalletMigration , \fBbenchmark::PriorityLevel::LOW\fP )"

.SS "BOOST_AUTO_TEST_CASE (ApproximateBestSubset )"

.SS "BOOST_AUTO_TEST_CASE (bnb_feerate_sensitivity_test )"

.SS "BOOST_AUTO_TEST_CASE (bnb_search_test )"

.SS "BOOST_AUTO_TEST_CASE (bnb_sffo_restriction )"

.SS "BOOST_AUTO_TEST_CASE (bnb_test )"

.SS "BOOST_AUTO_TEST_CASE (bump_fee_test )"

.SS "BOOST_AUTO_TEST_CASE (check_max_selection_weight )"

.SS "BOOST_AUTO_TEST_CASE (coin_grinder_tests )"

.SS "BOOST_AUTO_TEST_CASE (ComputeTimeSmart )"

.SS "BOOST_AUTO_TEST_CASE (concurrent_txn_dont_interfere )"

.SS "BOOST_AUTO_TEST_CASE (db_availability_after_write_error )"

.SS "BOOST_AUTO_TEST_CASE (db_cursor_prefix_byte_test )"

.SS "BOOST_AUTO_TEST_CASE (db_cursor_prefix_range_test )"

.SS "BOOST_AUTO_TEST_CASE (decrypt )"

.SS "BOOST_AUTO_TEST_CASE (DescriptorScriptPubKeyManTests )"

.SS "BOOST_AUTO_TEST_CASE (effective_value_test )"

.SS "BOOST_AUTO_TEST_CASE (encrypt )"

.SS "BOOST_AUTO_TEST_CASE (ensure_unique_wallet_name )"

.SS "BOOST_AUTO_TEST_CASE (erase_prefix )"

.SS "BOOST_AUTO_TEST_CASE (ismine_standard )"

.SS "BOOST_AUTO_TEST_CASE (knapsack_solver_test )"

.SS "BOOST_AUTO_TEST_CASE (outputs_grouping_tests )"

.SS "BOOST_AUTO_TEST_CASE (parse_hd_keypath )"

.SS "BOOST_AUTO_TEST_CASE (passphrase )"

.SS "BOOST_AUTO_TEST_CASE (psbt_updater_test )"

.SS "BOOST_AUTO_TEST_CASE (roundtrip )"

.SS "BOOST_AUTO_TEST_CASE (SelectCoins_effective_value_test )"

.SS "BOOST_AUTO_TEST_CASE (SelectCoins_test )"

.SS "BOOST_AUTO_TEST_CASE (srd_tests )"

.SS "BOOST_AUTO_TEST_CASE (txn_close_failure_dangling_txn )"

.SS "BOOST_AUTO_TEST_CASE (walletdb_readkeyvalue )"
When ReadKeyValue() reads from either a "key" or "wkey" it first reads the \fBDataStream\fP into a \fBCPrivKey\fP or CWalletKey respectively and then reads a hash of the pubkey and privkey into a \fBuint256\fP\&. Wallets from 0\&.8 or before do not store the pubkey/privkey hash, trying to read the hash from old wallets throws an exception, for backwards compatibility this read is wrapped in a try block to silently fail\&. The test here makes sure the type of exception thrown from \fBDataStream::read()\fP matches the type we expect, otherwise we need to update the "key"/"wkey" exception type caught\&.
.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_custom )"

.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_default )"

.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_does_not_exist )"

.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_is_not_directory )"

.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_is_not_relative )"

.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_no_trailing )"

.SS "BOOST_AUTO_TEST_CASE (walletinit_verify_walletdir_no_trailing2 )"

.SS "BOOST_AUTO_TEST_CASE (waste_test )"

.SS "BOOST_FIXTURE_TEST_CASE (BasicOutputTypesTest , ListCoinsTest )"

.SS "BOOST_FIXTURE_TEST_CASE (\fBCreateWallet\fP , \fBTestChain100Setup\fP )"
Test \fBCWallet::Create()\fP and its behavior handling potential race conditions if it's called the same time an incoming transaction shows up in the mempool or a new block\&.

.PP
It isn't possible to verify there aren't race condition in every case, so this test just checks two specific cases and ensures that timing of notifications in these cases doesn't prevent the wallet from detecting transactions\&.

.PP
In the first case, block and mempool transactions are created before the wallet is loaded, but notifications about these transactions are delayed until after it is loaded\&. The notifications are superfluous in this case, so the test verifies the transactions are detected before they arrive\&.

.PP
In the second case, block and mempool transactions are created after the wallet rescan and notifications are immediately synced, to verify the wallet must already have a handler in place for them, and there's no gap after rescanning where new transactions in new blocks could be lost\&. 
.SS "BOOST_FIXTURE_TEST_CASE (CreateWalletWithoutChain , \fBBasicTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (dummy_input_size_test , \fBTestChain100Setup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (ListCoinsTest , \fBListCoinsTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (LoadReceiveRequests , \fBTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (RemoveTxs , \fBTestChain100Setup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (scan_for_wallet_transactions , \fBTestChain100Setup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (SubtractFee , \fBTestChain100Setup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (update_non_range_descriptor , \fBTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (wallet_coinsresult_test , \fBBasicTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (wallet_descriptor_test , \fBBasicTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (wallet_disableprivkeys , \fBTestChain100Setup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (wallet_duplicated_preset_inputs_test , \fBTestChain100Setup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (wallet_load_descriptors , \fBTestingSetup\fP )"

.SS "BOOST_FIXTURE_TEST_CASE (write_wallet_settings_concurrently , \fBTestingSetup\fP )"

.SS "\fBRPCHelpMan\fP bumpfee ()"

.SS "void CachedTxGetAmounts (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx, std::list< \fBCOutputEntry\fP > & listReceived, std::list< \fBCOutputEntry\fP > & listSent, \fBCAmount\fP & nFee, bool include_change)"

.SS "\fBCAmount\fP CachedTxGetChange (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx)"

.SS "\fBCAmount\fP CachedTxGetCredit (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx, bool avoid_reuse)"

.SS "\fBCAmount\fP CachedTxGetDebit (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx, bool avoid_reuse)"

.SS "bool CachedTxIsFromMe (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx)"

.SS "bool CachedTxIsTrusted (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx)"

.SS "bool CachedTxIsTrusted (const \fBCWallet\fP & wallet, const \fBCWalletTx\fP & wtx, std::set< \fBTxid\fP > & trusted_parents)"

.SS "int CalculateMaximumSignedInputSize (const \fBCTxOut\fP & txout, const \fBCOutPoint\fP outpoint, const \fBSigningProvider\fP * provider, bool can_grind_r, const \fBCCoinControl\fP * coin_control)"

.SS "int CalculateMaximumSignedInputSize (const \fBCTxOut\fP & txout, const \fBCWallet\fP * pwallet, const \fBCCoinControl\fP * coin_control)"
Get the marginal bytes if spending the specified output from this transaction\&. Use CoinControl to determine whether to expect signature grinding when calculating the size of the input spend\&. 
.SS "\fBTxSize\fP CalculateMaximumSignedTxSize (const \fBCTransaction\fP & tx, const \fBCWallet\fP * wallet, const \fBCCoinControl\fP * coin_control)"

.SS "\fBTxSize\fP CalculateMaximumSignedTxSize (const \fBCTransaction\fP & tx, const \fBCWallet\fP * wallet, const \fBCCoinControl\fP * coin_control = \fRnullptr\fP)\->cs_wallet)"

.SS "\fBTxSize\fP CalculateMaximumSignedTxSize (const \fBCTransaction\fP & tx, const \fBCWallet\fP * wallet, const std::vector< \fBCTxOut\fP > & txouts, const \fBCCoinControl\fP * coin_control = \fRnullptr\fP)"
Calculate the size of the transaction using CoinControl to determine whether to expect signature grinding when calculating the size of the input spend\&. 
.SS "\fButil::Result\fP< \fBSelectionResult\fP > ChooseSelectionResult (\fBinterfaces::Chain\fP & chain, const \fBCAmount\fP & nTargetValue, \fBGroups\fP & groups, const \fBCoinSelectionParams\fP & coin_selection_params)"
Attempt to find a valid input set that meets the provided eligibility filter and target\&. Multiple coin selection algorithms will be run and the input set that produces the least waste (according to the waste metric) will be chosen\&.

.PP
\fBParameters\fP
.RS 4
\fIchain\fP The chain interface to get information on bump fees for unconfirmed UTXOs 
.br
\fInTargetValue\fP The target value 
.br
\fIgroups\fP The struct containing the outputs grouped by script and divided by (1) positive only outputs and (2) all outputs (positive + negative)\&. 
.br
\fIcoin_selection_params\fP Parameters for the coin selection returns If successful, a \fBSelectionResult\fP containing the input set If failed, returns (1) an empty error message if the target was not reached (general "Insufficient funds") or (2) a specific error message if there was something particularly wrong (e\&.g\&. a selection result that surpassed the tx max weight size)\&. 
.RE
.PP

.SS "\fButil::Result\fP< \fBSelectionResult\fP > CoinGrinder (std::vector< \fBOutputGroup\fP > & utxo_pool, const \fBCAmount\fP & selection_target, \fBCAmount\fP change_target, int max_selection_weight)"

.SS "\fBDescriptorScriptPubKeyMan\fP * CreateDescriptor (\fBCWallet\fP & keystore, const std::string & desc_str, const bool success)"

.SS "bool CreateFromDump (const \fBArgsManager\fP & args, const std::string & name, const \fBfs::path\fP & wallet_path, \fBbilingual_str\fP & error, std::vector< \fBbilingual_str\fP > & warnings)"

.SS "std::unique_ptr< \fBWalletDatabase\fP > CreateMockableWalletDatabase (\fBMockableData\fP records)"

.SS "std::vector< \fBCRecipient\fP > CreateRecipients (const std::vector< std::pair< \fBCTxDestination\fP, \fBCAmount\fP > > & outputs, const std::set< int > & subtract_fee_outputs)"

.SS "std::unique_ptr< \fBCWallet\fP > CreateSyncedWallet (\fBinterfaces::Chain\fP & chain, \fBCChain\fP & cchain, const \fBCKey\fP & key)"

.SS "\fButil::Result\fP< \fBCreatedTransactionResult\fP > CreateTransaction (\fBCWallet\fP & wallet, const std::vector< \fBCRecipient\fP > & vecSend, std::optional< unsigned int > change_pos, const \fBCCoinControl\fP & coin_control, bool sign = \fRtrue\fP)"
Create a new transaction paying the recipients with a set of coins selected by \fBSelectCoins()\fP; Also create the change output, when needed 
.PP
\fBNote\fP
.RS 4
passing change_pos as std::nullopt will result in setting a random position 
.RE
.PP

.SS "std::shared_ptr< \fBCWallet\fP > CreateWallet (\fBWalletContext\fP & context, const std::string & name, std::optional< bool > load_on_start, \fBDatabaseOptions\fP & options, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error, std::vector< \fBbilingual_str\fP > & warnings)"

.SS "bool DecryptKey (const \fBCKeyingMaterial\fP & master_key, const std::span< const unsigned char > crypted_secret, const \fBCPubKey\fP & pub_key, \fBCKey\fP & key)"

.SS "bool DecryptSecret (const \fBCKeyingMaterial\fP & master_key, const std::span< const unsigned char > ciphertext, const \fBuint256\fP & iv, \fBCKeyingMaterial\fP & plaintext)"

.SS "void DiscourageFeeSniping (\fBCMutableTransaction\fP & tx, \fBFastRandomContext\fP & rng_fast, \fBinterfaces::Chain\fP & chain, const \fBuint256\fP & block_hash, int block_height)"
Set a height-based locktime for new transactions (uses the height of the current chain tip unless we are not synced with the current chain 
.SS "bool DoMigration (\fBCWallet\fP & wallet, \fBWalletContext\fP & context, \fBbilingual_str\fP & error, \fBMigrationResult\fP & res)"

.SS "bool DumpWallet (const \fBArgsManager\fP & args, \fBWalletDatabase\fP & db, \fBbilingual_str\fP & error)"

.SS "std::unique_ptr< \fBWalletDatabase\fP > DuplicateMockDatabase (\fBWalletDatabase\fP & database)"

.SS "bool EncryptSecret (const \fBCKeyingMaterial\fP & vMasterKey, const \fBCKeyingMaterial\fP & vchPlaintext, const \fBuint256\fP & nIV, std::vector< unsigned char > & vchCiphertext)"

.SS "\fBRPCHelpMan\fP encryptwallet ()"

.SS "std::string EnsureUniqueWalletName (const \fBJSONRPCRequest\fP & request, std::optional< std::string_view > wallet_name)"
Ensures that a wallet name is specified across the endpoint and wallet_name\&. Throws \fR\fBRPC_INVALID_PARAMETER\fP\fP if none or different wallet names are specified\&. 
.SS "\fBWalletContext\fP & EnsureWalletContext (const std::any & context)"

.SS "void EnsureWalletIsUnlocked (const \fBCWallet\fP & wallet)"

.SS "\fButil::Result\fP< \fBPreSelectedInputs\fP > FetchSelectedInputs (const \fBCWallet\fP & wallet, const \fBCCoinControl\fP & coin_control, const \fBCoinSelectionParams\fP & coin_selection_params)"
Fetch and validate coin control selected inputs\&. Coins could be internal (from the wallet) or external\&. 
.SS "const \fBCTxOut\fP & FindNonChangeParentOutput (const \fBCWallet\fP & wallet, const \fBCOutPoint\fP & outpoint)"
Find non-change parent output\&. 
.SS "\fBRPCHelpMan\fP fundrawtransaction ()"

.SS "\fBCreatedTransactionResult\fP FundTransaction (\fBCWallet\fP & wallet, const \fBCMutableTransaction\fP & tx, const std::vector< \fBCRecipient\fP > & recipients, const \fBUniValue\fP & options, \fBCCoinControl\fP & coinControl, bool override_min_fee)"

.SS "\fButil::Result\fP< \fBCreatedTransactionResult\fP > FundTransaction (\fBCWallet\fP & wallet, const \fBCMutableTransaction\fP & tx, const std::vector< \fBCRecipient\fP > & recipients, std::optional< unsigned int > change_pos, bool lockUnspents, \fBCCoinControl\fP )"
Insert additional inputs into the transaction by calling \fBCreateTransaction()\fP; 
.SS "FUZZ_TARGET (coin_grinder )"

.SS "FUZZ_TARGET (coin_grinder_is_optimal )"

.SS "FUZZ_TARGET (coinselection_bnb )"

.SS "FUZZ_TARGET (coinselection_knapsack )"

.SS "FUZZ_TARGET (coinselection_srd )"

.SS "template<\fBCoinSelectionAlgorithm\fP Algorithm> void FuzzCoinSelectionAlgorithm (std::span< const uint8_t > buffer)"

.SS "\fBCAmount\fP GenerateChangeTarget (const \fBCAmount\fP payment_value, const \fBCAmount\fP change_fee, \fBFastRandomContext\fP & rng)\fR [nodiscard]\fP"
Choose a random change target for each transaction to make it harder to fingerprint the Core wallet based on the change output values of transactions it creates\&. Change target covers at least change fees and adds a random value on top of it\&. The random value is between 50ksat and min(2 * payment_value, 1milsat) When payment_value <= 25ksat, the value is just 50ksat\&.

.PP
Making change amounts similar to the payment value may help disguise which output(s) are payments are which ones are change\&. Using double the payment value may increase the number of inputs needed (and thus be more expensive in fees), but breaks analysis techniques which assume the coins selected are just sufficient to cover the payment amount ("unnecessary input" heuristic)\&.

.PP
\fBParameters\fP
.RS 4
\fIpayment_value\fP Average payment value of the transaction output(s)\&. 
.br
\fIchange_fee\fP Fee for creating a change output\&. 
.RE
.PP

.SS "\fBWalletDescriptor\fP GenerateWalletDescriptor (const \fBCExtPubKey\fP & master_key, const \fBOutputType\fP & addr_type, bool internal)"

.SS "std::map< \fBCTxDestination\fP, \fBCAmount\fP > GetAddressBalances (const \fBCWallet\fP & wallet)"

.SS "\fBRPCHelpMan\fP getaddressesbylabel ()"

.SS "std::set< std::set< \fBCTxDestination\fP > > GetAddressGroupings (const \fBCWallet\fP & wallet)"

.SS "\fBRPCHelpMan\fP getaddressinfo ()"

.SS "std::vector< \fBCKeyID\fP > GetAffectedKeys (const \fBCScript\fP & spk, const \fBSigningProvider\fP & provider)"

.SS "std::string GetAlgorithmName (const \fBSelectionAlgorithm\fP algo)"

.SS "bool GetAvoidReuseFlag (const \fBCWallet\fP & wallet, const \fBUniValue\fP & param)"

.SS "\fBBalance\fP GetBalance (const \fBCWallet\fP & wallet, const int min_depth, bool avoid_reuse)"

.SS "\fBRPCHelpMan\fP getbalance ()"

.SS "\fBRPCHelpMan\fP getbalances ()"

.SS "std::shared_ptr< \fBCWallet\fP > GetDefaultWallet (\fBWalletContext\fP & context, size_t & count)"

.SS "\fBCFeeRate\fP GetDiscardRate (const \fBCWallet\fP & wallet)"
Return the maximum feerate for discarding change\&. 
.SS "\fBRPCHelpMan\fP gethdkeys ()"

.SS "\fBCAmount\fP GetMinimumFee (const \fBCWallet\fP & wallet, unsigned int nTxBytes, const \fBCCoinControl\fP & coin_control, \fBFeeCalculation\fP * feeCalc)"
Estimate the minimum fee considering user set parameters and the required fee 
.SS "\fBCFeeRate\fP GetMinimumFeeRate (const \fBCWallet\fP & wallet, const \fBCCoinControl\fP & coin_control, \fBFeeCalculation\fP * feeCalc)"
Estimate the minimum fee rate considering user set parameters and the required fee 
.SS "\fBMockableDatabase\fP & GetMockableDatabase (\fBCWallet\fP & wallet)"

.SS "\fBRPCHelpMan\fP getnewaddress ()"

.SS "std::string getnewaddress (\fBCWallet\fP & w)"
Returns a new encoded destination from the wallet (hardcoded to BECH32) 
.SS "\fBCTxDestination\fP getNewDestination (\fBCWallet\fP & w, \fBOutputType\fP output_type)"
Returns a new destination, of an specific type, from the wallet 
.SS "\fBRPCHelpMan\fP getrawchangeaddress ()"

.SS "\fBRPCHelpMan\fP getreceivedbyaddress ()"

.SS "\fBRPCHelpMan\fP getreceivedbylabel ()"

.SS "\fBCAmount\fP GetRequiredFee (const \fBCWallet\fP & wallet, unsigned int nTxBytes)"
Return the minimum required absolute fee for this size based on the required fee rate 
.SS "\fBCFeeRate\fP GetRequiredFeeRate (const \fBCWallet\fP & wallet)"
Return the minimum required feerate taking into account the minimum relay feerate and user set minimum transaction feerate 
.SS "uint64_t GetSerializeSizeForRecipient (const \fBCRecipient\fP & recipient)"

.SS "\fBRPCHelpMan\fP gettransaction ()"

.SS "std::shared_ptr< \fBCWallet\fP > GetWallet (\fBWalletContext\fP & context, const std::string & name)"

.SS "\fBfs::path\fP GetWalletDir ()"

.PP
Get the path of the wallet directory\&. 
.SS "std::shared_ptr< \fBCWallet\fP > GetWalletForJSONRPCRequest (const \fBJSONRPCRequest\fP & request)"
Figures out what wallet, if any, to use for a \fBJSONRPCRequest\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIrequest\fP \fBJSONRPCRequest\fP that wishes to access a wallet 
.RE
.PP
\fBReturns\fP
.RS 4
nullptr if no wallet should be used, or a pointer to the \fBCWallet\fP 
.RE
.PP

.SS "bool GetWalletNameFromJSONRPCRequest (const \fBJSONRPCRequest\fP & request, std::string & wallet_name)"

.SS "std::span< const \fBCRPCCommand\fP > GetWalletRPCCommands ()"

.SS "std::vector< std::shared_ptr< \fBCWallet\fP > > GetWallets (\fBWalletContext\fP & context)"

.SS "std::vector< \fBOutputGroup\fP > & GroupCoins (const std::vector< \fBCOutput\fP > & available_coins, bool subtract_fee_outputs = \fRfalse\fP)\fR [inline]\fP"

.SS "\fBFilteredOutputGroups\fP GroupOutputs (const \fBCWallet\fP & wallet, const \fBCoinsResult\fP & coins, const \fBCoinSelectionParams\fP & coin_sel_params, const std::vector< \fBSelectionFilter\fP > & filters, std::vector< \fBOutputGroup\fP > & ret_discarded_groups)"

.SS "\fBFilteredOutputGroups\fP GroupOutputs (const \fBCWallet\fP & wallet, const \fBCoinsResult\fP & coins, const \fBCoinSelectionParams\fP & coin_sel_params, const std::vector< \fBSelectionFilter\fP > & filters)"
Group coins by the provided filters\&. 
.SS "std::unique_ptr< \fBinterfaces::Handler\fP > HandleLoadWallet (\fBWalletContext\fP & context, \fBLoadWalletFn\fP load_wallet)"

.SS "void HandleWalletError (const std::shared_ptr< \fBCWallet\fP > wallet, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error)"

.SS "bool HasLegacyRecords (\fBCWallet\fP & wallet)"

.PP
Returns true if there are any \fBDBKeys::LEGACY_TYPES\fP record in the wallet db\&. 
.SS "bool HasLegacyRecords (\fBCWallet\fP & wallet, \fBDatabaseBatch\fP & batch)"

.SS "\fBRPCHelpMan\fP importdescriptors ()"

.SS "\fBRPCHelpMan\fP importprunedfunds ()"

.SS "bool InputIsMine (const \fBCWallet\fP & wallet, const \fBCTxIn\fP & txin)"

.SS "std::set< int > InterpretSubtractFeeFromOutputInstructions (const \fBUniValue\fP & sffo_instructions, const std::vector< std::string > & destinations)"

.SS "bool IsBDBFile (const \fBfs::path\fP & path)"

.SS "bool IsDust (const \fBCRecipient\fP & recipient, const \fBCFeeRate\fP & dustRelayFee)"

.SS "bool IsSQLiteFile (const \fBfs::path\fP & path)"

.SS "\fBRPCHelpMan\fP keypoolrefill ()"

.SS "std::vector< \fBOutputGroup\fP > & KnapsackGroupOutputs (const \fBCoinsResult\fP & available_coins, \fBCWallet\fP & wallet, const \fBCoinEligibilityFilter\fP & filter)\fR [inline]\fP"

.SS "std::optional< \fBSelectionResult\fP > KnapsackSolver (std::vector< \fBOutputGroup\fP > & groups, const \fBCAmount\fP & nTargetValue, \fBCAmount\fP change_target, \fBFastRandomContext\fP & rng)"

.SS "\fButil::Result\fP< \fBSelectionResult\fP > KnapsackSolver (std::vector< \fBOutputGroup\fP > & groups, const \fBCAmount\fP & nTargetValue, \fBCAmount\fP change_target, \fBFastRandomContext\fP & rng, int max_selection_weight)"

.SS "std::string LabelFromValue (const \fBUniValue\fP & value)"

.SS "\fBRPCHelpMan\fP listaddressgroupings ()"

.SS "std::map< \fBCTxDestination\fP, std::vector< \fBCOutput\fP > > ListCoins (const \fBCWallet\fP & wallet)"
Return list of available coins and locked coins grouped by non-change output address\&. 
.SS "std::vector< std::pair< \fBfs::path\fP, std::string > > ListDatabases (const \fBfs::path\fP & path)"
Recursively list database paths in directory\&. 
.SS "\fBRPCHelpMan\fP listdescriptors ()"

.SS "\fBRPCHelpMan\fP listlabels ()"

.SS "\fBRPCHelpMan\fP listlockunspent ()"

.SS "\fBRPCHelpMan\fP listreceivedbyaddress ()"

.SS "\fBRPCHelpMan\fP listreceivedbylabel ()"

.SS "\fBRPCHelpMan\fP listsinceblock ()"

.SS "\fBRPCHelpMan\fP listtransactions ()"

.SS "\fBRPCHelpMan\fP listunspent ()"

.SS "bool LoadCryptedKey (\fBCWallet\fP * pwallet, \fBDataStream\fP & ssKey, \fBDataStream\fP & ssValue, std::string & strErr)"

.SS "bool LoadEncryptionKey (\fBCWallet\fP * pwallet, \fBDataStream\fP & ssKey, \fBDataStream\fP & ssValue, std::string & strErr)"

.SS "bool LoadHDChain (\fBCWallet\fP * pwallet, \fBDataStream\fP & ssValue, std::string & strErr)"

.SS "bool LoadKey (\fBCWallet\fP * pwallet, \fBDataStream\fP & ssKey, \fBDataStream\fP & ssValue, std::string & strErr)"

.SS "std::shared_ptr< \fBCWallet\fP > LoadWallet (\fBWalletContext\fP & context, const std::string & name, std::optional< bool > load_on_start, const \fBDatabaseOptions\fP & options, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error, std::vector< \fBbilingual_str\fP > & warnings)"

.SS "bool LoadWallets (\fBWalletContext\fP & context)"

.PP
Load wallet databases\&. 
.SS "\fBRPCHelpMan\fP lockunspent ()"

.SS "void LogDBInfo ()"

.SS "std::unique_ptr< \fBBerkeleyRODatabase\fP > MakeBerkeleyRODatabase (const \fBfs::path\fP & path, const \fBDatabaseOptions\fP & options, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error)"

.PP
Return object giving access to Berkeley Read Only database at specified path\&. 
.SS "std::unique_ptr< \fBWalletDatabase\fP > MakeDatabase (const \fBfs::path\fP & path, const \fBDatabaseOptions\fP & options, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error)"

.SS "\fBCoinSelectionParams\fP makeSelectionParams (\fBFastRandomContext\fP & rand, bool avoid_partial_spends)"

.SS "std::unique_ptr< \fBSQLiteDatabase\fP > MakeSQLiteDatabase (const \fBfs::path\fP & path, const \fBDatabaseOptions\fP & options, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error)"

.SS "std::unique_ptr< \fBWalletDatabase\fP > MakeWalletDatabase (const std::string & name, const \fBDatabaseOptions\fP & options, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error_string)"

.SS "bool malformed_descriptor (std::ios_base::failure e)"

.SS "void MaybeResendWalletTxs (\fBWalletContext\fP & context)"
Called periodically by the schedule thread\&. Prompts individual wallets to resend their transactions\&. Actual rebroadcast schedule is managed by the wallets themselves\&. 
.SS "\fButil::Result\fP< \fBMigrationResult\fP > MigrateLegacyToDescriptor (const std::string & wallet_name, const \fBSecureString\fP & passphrase, \fBWalletContext\fP & context)\fR [nodiscard]\fP"

.PP
Do all steps to migrate a legacy wallet to a descriptor wallet\&. 
.SS "\fButil::Result\fP< \fBMigrationResult\fP > MigrateLegacyToDescriptor (std::shared_ptr< \fBCWallet\fP > local_wallet, const \fBSecureString\fP & passphrase, \fBWalletContext\fP & context)\fR [nodiscard]\fP"

.PP
Requirement: The wallet provided to this function must be isolated, with no attachment to the node's context\&. 
.SS "void NotifyWalletLoaded (\fBWalletContext\fP & context, const std::shared_ptr< \fBCWallet\fP > & wallet)"

.SS "bool operator< (\fBBytePrefix\fP a, std::span< const std::byte > b)"

.SS "bool operator< (std::span< const std::byte > a, \fBBytePrefix\fP b)"

.SS "\fBCAmount\fP OutputGetChange (const \fBCWallet\fP & wallet, const \fBCTxOut\fP & txout)"

.SS "\fBCAmount\fP OutputGetCredit (const \fBCWallet\fP & wallet, const \fBCTxOut\fP & txout)"

.SS "bool OutputIsChange (const \fBCWallet\fP & wallet, const \fBCTxOut\fP & txout)"

.SS "\fBRPCHelpMan\fP psbtbumpfee ()"

.SS "std::optional< \fBAddressPurpose\fP > PurposeFromString (std::string_view s)\fR [inline]\fP"

.SS "std::string PurposeToString (\fBAddressPurpose\fP p)\fR [inline]\fP"

.SS "void PushParentDescriptors (const \fBCWallet\fP & wallet, const \fBCScript\fP & script_pubkey, \fBUniValue\fP & entry)"

.PP
Fetch parent descriptors of this scriptPubKey\&. 
.SS "void ReadDatabaseArgs (const \fBArgsManager\fP & args, \fBDatabaseOptions\fP & options)"

.SS "\fBRPCHelpMan\fP removeprunedfunds ()"

.SS "bool RemoveWallet (\fBWalletContext\fP & context, const std::shared_ptr< \fBCWallet\fP > & wallet, std::optional< bool > load_on_start)"

.SS "bool RemoveWallet (\fBWalletContext\fP & context, const std::shared_ptr< \fBCWallet\fP > & wallet, std::optional< bool > load_on_start, std::vector< \fBbilingual_str\fP > & warnings)"

.SS "bool RemoveWalletSetting (\fBinterfaces::Chain\fP & chain, const std::string & wallet_name)"

.PP
Remove wallet name from persistent configuration so it will not be loaded on startup\&. 
.SS "\fBRPCHelpMan\fP rescanblockchain ()"

.SS "std::shared_ptr< \fBCWallet\fP > RestoreWallet (\fBWalletContext\fP & context, const \fBfs::path\fP & backup_file, const std::string & wallet_name, std::optional< bool > load_on_start, \fBDatabaseStatus\fP & status, \fBbilingual_str\fP & error, std::vector< \fBbilingual_str\fP > & warnings, bool load_after_restore)"

.SS "\fBRPCHelpMan\fP restorewallet ()"

.SS "bool RunWithinTxn (\fBWalletDatabase\fP & database, std::string_view process_desc, const std::function< bool(\fBWalletBatch\fP &)> & func)"
Executes the provided function 'func' within a database transaction context\&.

.PP
This function ensures that all db modifications performed within 'func()' are atomically committed to the db at the end of the process\&. And, in case of a failure during execution, all performed changes are rolled back\&.

.PP
\fBParameters\fP
.RS 4
\fIdatabase\fP The db connection instance to perform the transaction on\&. 
.br
\fIprocess_desc\fP A description of the process being executed, used for logging purposes in the event of a failure\&. 
.br
\fIfunc\fP The function to be executed within the db txn context\&. It returns a boolean indicating whether to commit or roll back the txn\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the db txn executed successfully, false otherwise\&. 
.RE
.PP

.SS "bool ScriptIsChange (const \fBCWallet\fP & wallet, const \fBCScript\fP & script)"

.SS "\fButil::Result\fP< \fBSelectionResult\fP > SelectCoins (const \fBCWallet\fP & wallet, \fBCoinsResult\fP & available_coins, const \fBPreSelectedInputs\fP & pre_set_inputs, const \fBCAmount\fP & nTargetValue, const \fBCCoinControl\fP & coin_control, const \fBCoinSelectionParams\fP & coin_selection_params)"
Select all coins from coin_control, and if coin_control 'm_allow_other_inputs=true', call 'AutomaticCoinSelection' to select a set of coins such that nTargetValue - pre_set_inputs\&.total_amount is met\&. 
.SS "std::optional< \fBSelectionResult\fP > SelectCoinsBnB (std::vector< \fBOutputGroup\fP > & utxo_pool, const \fBCAmount\fP & selection_target, const \fBCAmount\fP & cost_of_change)"

.SS "\fButil::Result\fP< \fBSelectionResult\fP > SelectCoinsBnB (std::vector< \fBOutputGroup\fP > & utxo_pool, const \fBCAmount\fP & selection_target, const \fBCAmount\fP & cost_of_change, int max_selection_weight)"

.SS "\fButil::Result\fP< \fBSelectionResult\fP > SelectCoinsSRD (const std::vector< \fBOutputGroup\fP > & utxo_pool, \fBCAmount\fP target_value, \fBCAmount\fP change_fee, \fBFastRandomContext\fP & rng, int max_selection_weight)"
Select coins by Single Random Draw\&. OutputGroups are selected randomly from the eligible outputs until the target is satisfied

.PP
\fBParameters\fP
.RS 4
\fIutxo_pool\fP The positive effective value OutputGroups eligible for selection 
.br
\fItarget_value\fP The target value to select for 
.br
\fIrng\fP The randomness source to shuffle coins 
.br
\fImax_selection_weight\fP The maximum allowed weight for a selection result to be valid 
.RE
.PP
\fBReturns\fP
.RS 4
If successful, a valid \fBSelectionResult\fP, otherwise, \fButil::Error\fP 
.RE
.PP

.SS "\fBRPCHelpMan\fP send ()"

.SS "\fBRPCHelpMan\fP sendall ()"

.SS "\fBRPCHelpMan\fP sendmany ()"

.SS "\fBUniValue\fP SendMoney (\fBCWallet\fP & wallet, const \fBCCoinControl\fP & coin_control, std::vector< \fBCRecipient\fP > & recipients, \fBmapValue_t\fP map_value, bool verbose)"

.SS "\fBRPCHelpMan\fP sendtoaddress ()"

.SS "\fBRPCHelpMan\fP setlabel ()"

.SS "\fBRPCHelpMan\fP settxfee ()"

.SS "\fBRPCHelpMan\fP signmessage ()"

.SS "\fBRPCHelpMan\fP signrawtransactionwithwallet ()"

.SS "\fBRPCHelpMan\fP simulaterawtransaction ()"

.SS "std::string SQLiteDatabaseVersion ()"

.SS "\fBfs::path\fP SQLiteDataFile (const \fBfs::path\fP & path)"

.SS "void StartWallets (\fBWalletContext\fP & context)"

.PP
Complete startup of wallets\&. 
.SS "std::span< const std::byte > StringBytes (std::string_view str)\fR [inline]\fP"

.SS "void TestCoinsResult (ListCoinsTest & context, \fBOutputType\fP out_type, \fBCAmount\fP amount, std::map< \fBOutputType\fP, size_t > & expected_coins_sizes)"

.SS "void TestLoadWallet (const std::string & name, \fBDatabaseFormat\fP format, std::function< void(std::shared_ptr< \fBCWallet\fP >)> f)"

.SS "std::shared_ptr< \fBCWallet\fP > TestLoadWallet (std::unique_ptr< \fBWalletDatabase\fP > database, \fBWalletContext\fP & context, uint64_t create_flags)"

.SS "std::shared_ptr< \fBCWallet\fP > TestLoadWallet (\fBWalletContext\fP & context)"

.SS "void TestUnloadWallet (std::shared_ptr< \fBCWallet\fP > && wallet)"

.SS "\fBCAmount\fP TxGetChange (const \fBCWallet\fP & wallet, const \fBCTransaction\fP & tx)"

.SS "\fBCAmount\fP TxGetCredit (const \fBCWallet\fP & wallet, const \fBCTransaction\fP & tx)"

.SS "template<typename \fBT\fP> std::string TxStateString (const \fBT\fP & state)"

.PP
Return \fBTxState\fP or \fBSyncTxState\fP as a string for logging or debugging\&. 
.SS "void UnloadWallets (\fBWalletContext\fP & context)"

.SS "bool VerifyWallets (\fBWalletContext\fP & context)"

.PP
Responsible for reading and validating the -wallet arguments and verifying the wallet database\&. 
.SS "void WaitForDeleteWallet (std::shared_ptr< \fBCWallet\fP > && wallet)"
Explicitly delete the wallet\&. Blocks the current thread until the wallet is destructed\&. 
.SS "\fBRPCHelpMan\fP walletcreatefundedpsbt ()"

.SS "\fBRPCHelpMan\fP walletlock ()"

.SS "\fBRPCHelpMan\fP walletpassphrase ()"

.SS "\fBRPCHelpMan\fP walletpassphrasechange ()"

.SS "\fBRPCHelpMan\fP walletprocesspsbt ()"

.SH "Variable Documentation"
.PP 
.SS "const std::string ADDRESS_BCRT1_UNSPENDABLE = 'bcrt1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq3xueyj'"

.SS "uint32_t BTREE_MAGIC = 0x00053162\fR [constexpr]\fP"

.SS "uint32_t BTREE_MAGIC_OE = 0x62310500\fR [constexpr]\fP"

.SS "\fBOutputType\fP DEFAULT_ADDRESS_TYPE {\fBOutputType::BECH32\fP}\fR [constexpr]\fP"

.PP
Default for -addresstype\&. 
.SS "const int DEFAULT_MAX_DEPTH = 9999999"

.SS "const int DEFAULT_MIN_DEPTH = 0"

.SS "\fBCAmount\fP DEFAULT_PAY_TX_FEE = 0\fR [constexpr]\fP"

.PP
-paytxfee default 
.SS "\fBCAmount\fP DEFAULT_TRANSACTION_MAXFEE {COIN / 10}\fR [constexpr]\fP"

.PP
-maxtxfee default 
.SS "const int DEFAULT_WALLET_TX_VERSION = \fBCTransaction::CURRENT_VERSION\fP"

.SS "struct  { \&.\&.\&. }  descending"

.SS "struct  { \&.\&.\&. }  descending_effval_weight"

.SS "uint32_t DUMP_VERSION = 1"

.SS "const std::string HELP_REQUIRING_PASSPHRASE {'\\nRequires \fBwallet\fP passphrase to be set with \fBwalletpassphrase\fP call \fBif\fP \fBwallet\fP is encrypted\&.\\n'}"

.SS "\fBCAmount\fP HIGH_APS_FEE {COIN / 10000}\fR [constexpr]\fP"

.PP
discourage APS fee higher than this amount 
.SS "\fBCAmount\fP HIGH_MAX_TX_FEE {100 * \fBHIGH_TX_FEE_PER_KB\fP}\fR [constexpr]\fP"

.PP
-maxtxfee will warn if called with a higher fee than this amount (in satoshis) 
.SS "\fBCAmount\fP HIGH_TX_FEE_PER_KB {COIN / 100}\fR [constexpr]\fP"

.PP
Discourage users to set fees higher than this amount (in satoshis) per kB\&. 
.SS "int TEST_SQLITE_ERROR = \-999\fR [constexpr]\fP"

.SS "const unsigned int WALLET_CRYPTO_IV_SIZE = 16"

.SS "const unsigned int WALLET_CRYPTO_KEY_SIZE = 32"

.SS "const unsigned int WALLET_CRYPTO_SALT_SIZE = 8"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
