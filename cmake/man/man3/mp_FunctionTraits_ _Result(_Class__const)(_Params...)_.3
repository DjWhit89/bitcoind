.TH "FunctionTraits< _Result(_Class::*const)(_Params...)>" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
FunctionTraits< _Result(_Class::*const)(_Params...)>
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <proxy\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBParams\fP = \fBTypeList\fP<_Params\&.\&.\&.>"
.br
.ti -1c
.RI "using \fBResult\fP = _Result"
.br
.ti -1c
.RI "template<size_t N> using \fBParam\fP = typename std::tuple_element<N, std::tuple<_Params\&.\&.\&.>>::type"
.br
.ti -1c
.RI "using \fBFields\fP"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "template<size_t N> static decltype(auto) \fBFwd\fP (\fBParam\fP< N > &arg)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class _Class, class _Result, class\&.\&.\&. _Params>
.br
struct mp::FunctionTraits< _Result(_Class::*const)(_Params\&.\&.\&.)>"Specialization of above extracting result and params types assuming the template argument is a pointer-to-method type, decltype(&ClassName::methodName) 
.SH "Member Typedef Documentation"
.PP 
.SS "template<class _Class, class _Result, class\&.\&.\&. _Params> using \fBFields\fP"
\fBInitial value:\fP
.nf

        std::conditional_t<std::is_same_v<void, Result>, Params, TypeList<_Params\&.\&.\&., _Result>>
.PP
.fi

.SS "template<class _Class, class _Result, class\&.\&.\&. _Params> template<size_t N> using \fBParam\fP = typename std::tuple_element<N, std::tuple<_Params\&.\&.\&.>>::type"

.SS "template<class _Class, class _Result, class\&.\&.\&. _Params> using \fBParams\fP = \fBTypeList\fP<_Params\&.\&.\&.>"

.SS "template<class _Class, class _Result, class\&.\&.\&. _Params> using \fBResult\fP = _Result"

.SH "Member Function Documentation"
.PP 
.SS "template<class _Class, class _Result, class\&.\&.\&. _Params> template<size_t N> decltype(auto) Fwd (\fBParam\fP< N > & arg)\fR [inline]\fP, \fR [static]\fP"
Enable perfect forwarding for clientInvoke calls\&. If parameter is a value type or rvalue reference type, pass it as an rvalue-reference to MakeClientParam and BuildField calls so it can be moved from, and if it is an lvalue reference, pass it an lvalue reference so it won't be moved from\&. This method does the same thing as std::forward except it takes a parameter number instead of a type as a template argument, so generated code calling this can be less repetitive and verbose\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
