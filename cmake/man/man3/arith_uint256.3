.TH "arith_uint256" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
arith_uint256
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <arith_uint256\&.h>\fP
.PP
Inherits \fBbase_uint< 256 >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "constexpr \fBarith_uint256\fP ()=default"
.br
.ti -1c
.RI "constexpr \fBarith_uint256\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "constexpr \fBarith_uint256\fP (uint64_t b)"
.br
.ti -1c
.RI "\fBarith_uint256\fP & \fBSetCompact\fP (uint32_t nCompact, bool *pfNegative=nullptr, bool *pfOverflow=nullptr)"
.br
.ti -1c
.RI "uint32_t \fBGetCompact\fP (bool fNegative=false) const"
.br
.in -1c

Public Member Functions inherited from \fBbase_uint< 256 >\fP
.in +1c
.ti -1c
.RI "constexpr \fBbase_uint\fP ()"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator=\fP (const \fBbase_uint\fP &b)=default"
.br
.ti -1c
.RI "\fBbase_uint\fP \fBoperator~\fP () const"
.br
.ti -1c
.RI "\fBbase_uint\fP \fBoperator\-\fP () const"
.br
.ti -1c
.RI "double \fBgetdouble\fP () const"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator^=\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator&=\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator|=\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator<<=\fP (unsigned int shift)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator>>=\fP (unsigned int shift)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator+=\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator\-=\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator*=\fP (uint32_t b32)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator/=\fP (const \fBbase_uint\fP &b)"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fBbase_uint\fP & \fBoperator\-\-\fP ()"
.br
.ti -1c
.RI "int \fBCompareTo\fP (const \fBbase_uint\fP &b) const"
.br
.ti -1c
.RI "bool \fBEqualTo\fP (uint64_t b) const"
.br
.ti -1c
.RI "std::string \fBGetHex\fP () const"
.br
.ti -1c
.RI "std::string \fBToString\fP () const"
.br
.ti -1c
.RI "unsigned int \fBsize\fP () const"
.br
.ti -1c
.RI "unsigned int \fBbits\fP () const"
.br
.ti -1c
.RI "uint64_t \fBGetLow64\fP () const"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "\fBuint256\fP \fBArithToUint256\fP (const \fBarith_uint256\fP &a)"
.br
.ti -1c
.RI "\fBarith_uint256\fP \fBUintToArith256\fP (const \fBuint256\fP &a)"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Attributes inherited from \fBbase_uint< 256 >\fP
.in +1c
.ti -1c
.RI "uint32_t \fBpn\fP [\fBWIDTH\fP]"
.br
.in -1c

Static Protected Attributes inherited from \fBbase_uint< 256 >\fP
.in +1c
.ti -1c
.RI "static constexpr int \fBWIDTH\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
256-bit unsigned big integer\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBarith_uint256\fP ()\fR [constexpr]\fP, \fR [default]\fP"

.SS "\fBarith_uint256\fP (const \fBbase_uint\fP & b)\fR [inline]\fP, \fR [constexpr]\fP"

.SS "\fBarith_uint256\fP (uint64_t b)\fR [inline]\fP, \fR [constexpr]\fP"

.SH "Member Function Documentation"
.PP 
.SS "uint32_t GetCompact (bool fNegative = \fRfalse\fP) const"

.SS "\fBarith_uint256\fP & SetCompact (uint32_t nCompact, bool * pfNegative = \fRnullptr\fP, bool * pfOverflow = \fRnullptr\fP)"
The "compact" format is a representation of a whole number N using an unsigned 32bit number similar to a floating point format\&. The most significant 8 bits are the unsigned exponent of base 256\&. This exponent can be thought of as "number of bytes of N"\&. The lower 23 bits are the mantissa\&. Bit number 24 (0x800000) represents the sign of N\&. N = (-1^sign) * mantissa * 256^(exponent-3)

.PP
Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn()\&. MPI uses the most significant bit of the first byte as sign\&. Thus 0x1234560000 is compact (0x05123456) and 0xc0de000000 is compact (0x0600c0de)

.PP
Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities\&. Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "\fBuint256\fP ArithToUint256 (const \fBarith_uint256\fP & a)\fR [friend]\fP"

.SS "\fBarith_uint256\fP UintToArith256 (const \fBuint256\fP & a)\fR [friend]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
