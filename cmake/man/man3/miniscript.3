.TH "miniscript" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
miniscript
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBinternal\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBType\fP"
.br
.ti -1c
.RI "struct \fBNode\fP"
.br
.RI "A node in a miniscript expression\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBOpcode\fP = std::pair<\fBopcodetype\fP, std::vector<unsigned char>>"
.br
.ti -1c
.RI "template<typename Key> using \fBNodeRef\fP = std::unique_ptr<const \fBNode\fP<Key>>"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBFragment\fP { \fBJUST_0\fP, \fBJUST_1\fP, \fBPK_K\fP, \fBPK_H\fP, \fBOLDER\fP, \fBAFTER\fP, \fBSHA256\fP, \fBHASH256\fP, \fBRIPEMD160\fP, \fBHASH160\fP, \fBWRAP_A\fP, \fBWRAP_S\fP, \fBWRAP_C\fP, \fBWRAP_D\fP, \fBWRAP_V\fP, \fBWRAP_J\fP, \fBWRAP_N\fP, \fBAND_V\fP, \fBAND_B\fP, \fBOR_B\fP, \fBOR_C\fP, \fBOR_D\fP, \fBOR_I\fP, \fBANDOR\fP, \fBTHRESH\fP, \fBMULTI\fP, \fBMULTI_A\fP }"
.br
.RI "The different node types in miniscript\&. "
.ti -1c
.RI "enum class \fBAvailability\fP { \fBNO\fP, \fBYES\fP, \fBMAYBE\fP }"
.br
.ti -1c
.RI "enum class \fBMiniscriptContext\fP { \fBP2WSH\fP, \fBTAPSCRIPT\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "consteval \fBType\fP \fBoperator''_mst\fP (const char *c, size_t l)"
.br
.RI "Literal operator to construct \fBType\fP objects\&. "
.ti -1c
.RI "template<typename Key, typename\&.\&.\&. Args> \fBNodeRef\fP< Key > \fBMakeNodeRef\fP (Args &&\&.\&.\&. \fBargs\fP)"
.br
.RI "Construct a miniscript node as a unique_ptr\&. "
.ti -1c
.RI "constexpr bool \fBIsTapscript\fP (\fBMiniscriptContext\fP ms_ctx)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNodeRef\fP< typename Ctx::Key > \fBFromString\fP (const std::string &str, const Ctx &ctx)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNodeRef\fP< typename Ctx::Key > \fBFromScript\fP (const \fBCScript\fP &\fBscript\fP, const Ctx &ctx)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "template<typename Key> using \fBNodeRef\fP = std::unique_ptr<const \fBNode\fP<Key>>"

.SS "using \fBOpcode\fP = std::pair<\fBopcodetype\fP, std::vector<unsigned char>>"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBAvailability\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BINO \fP
.TP
\f(BIYES \fP
.TP
\f(BIMAYBE \fP
.SS "enum class \fBFragment\fP\fR [strong]\fP"

.PP
The different node types in miniscript\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIJUST_0 \fP
OP_0\&. 
.TP
\f(BIJUST_1 \fP
OP_1\&. 
.TP
\f(BIPK_K \fP
[key] 
.TP
\f(BIPK_H \fP
OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\&. 
.TP
\f(BIOLDER \fP
[n] OP_CHECKSEQUENCEVERIFY 
.TP
\f(BIAFTER \fP
[n] OP_CHECKLOCKTIMEVERIFY 
.TP
\f(BISHA256 \fP
OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\&. 
.TP
\f(BIHASH256 \fP
OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\&. 
.TP
\f(BIRIPEMD160 \fP
OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\&. 
.TP
\f(BIHASH160 \fP
OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\&. 
.TP
\f(BIWRAP_A \fP
OP_TOALTSTACK [X] OP_FROMALTSTACK\&. 
.TP
\f(BIWRAP_S \fP
OP_SWAP [X]\&. 
.TP
\f(BIWRAP_C \fP
[X] OP_CHECKSIG 
.TP
\f(BIWRAP_D \fP
OP_DUP OP_IF [X] OP_ENDIF\&. 
.TP
\f(BIWRAP_V \fP
[X] OP_VERIFY (or -VERIFY version of last opcode in X) 
.TP
\f(BIWRAP_J \fP
OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\&. 
.TP
\f(BIWRAP_N \fP
[X] OP_0NOTEQUAL 
.TP
\f(BIAND_V \fP
[X] [Y] 
.TP
\f(BIAND_B \fP
[X] [Y] OP_BOOLAND 
.TP
\f(BIOR_B \fP
[X] [Y] OP_BOOLOR 
.TP
\f(BIOR_C \fP
[X] OP_NOTIF [Y] OP_ENDIF 
.TP
\f(BIOR_D \fP
[X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF 
.TP
\f(BIOR_I \fP
OP_IF [X] OP_ELSE [Y] OP_ENDIF\&. 
.TP
\f(BIANDOR \fP
[X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF 
.TP
\f(BITHRESH \fP
[X1] ([Xn] OP_ADD)* [k] OP_EQUAL 
.TP
\f(BIMULTI \fP
[k] [key_n]* [n] OP_CHECKMULTISIG (only available within P2WSH context) 
.TP
\f(BIMULTI_A \fP
[key_0] OP_CHECKSIG ([key_n] OP_CHECKSIGADD)* [k] OP_NUMEQUAL (only within Tapscript ctx) 
.SS "enum class \fBMiniscriptContext\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIP2WSH \fP
.TP
\f(BITAPSCRIPT \fP
.SH "Function Documentation"
.PP 
.SS "template<typename Ctx> \fBNodeRef\fP< typename Ctx::Key > FromScript (const \fBCScript\fP & script, const Ctx & ctx)\fR [inline]\fP"

.SS "template<typename Ctx> \fBNodeRef\fP< typename Ctx::Key > FromString (const std::string & str, const Ctx & ctx)\fR [inline]\fP"

.SS "bool IsTapscript (\fBMiniscriptContext\fP ms_ctx)\fR [constexpr]\fP"
Whether the context Tapscript, ensuring the only other possibility is P2WSH\&. 
.SS "template<typename Key, typename\&.\&.\&. Args> \fBNodeRef\fP< Key > MakeNodeRef (Args &&\&.\&.\&. args)"

.PP
Construct a miniscript node as a unique_ptr\&. 
.SS "\fBType\fP operator''_mst (const char * c, size_t l)\fR [inline]\fP, \fR [consteval]\fP"

.PP
Literal operator to construct \fBType\fP objects\&. The only way to publicly construct a \fBType\fP is using this literal operator\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
