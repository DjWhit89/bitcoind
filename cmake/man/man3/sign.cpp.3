.TH "src/script/sign.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/script/sign.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <script/sign\&.h>\fP
.br
\fR#include <consensus/amount\&.h>\fP
.br
\fR#include <key\&.h>\fP
.br
\fR#include <musig\&.h>\fP
.br
\fR#include <policy/policy\&.h>\fP
.br
\fR#include <primitives/transaction\&.h>\fP
.br
\fR#include <random\&.h>\fP
.br
\fR#include <script/keyorigin\&.h>\fP
.br
\fR#include <script/miniscript\&.h>\fP
.br
\fR#include <script/script\&.h>\fP
.br
\fR#include <script/signingprovider\&.h>\fP
.br
\fR#include <script/solver\&.h>\fP
.br
\fR#include <uint256\&.h>\fP
.br
\fR#include <util/translation\&.h>\fP
.br
\fR#include <util/vector\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBSatisfier< Pk >\fP"
.br
.ti -1c
.RI "struct \fBWshSatisfier\fP"
.br
.ti -1c
.RI "struct \fBTapSatisfier\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef std::vector< unsigned char > \fBvaltype\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename M, typename K, typename V> \fBminiscript::Availability\fP \fBMsLookupHelper\fP (const M &map, const K &key, V &value)"
.br
.ti -1c
.RI "bool \fBProduceSignature\fP (const \fBSigningProvider\fP &provider, const \fBBaseSignatureCreator\fP &creator, const \fBCScript\fP &fromPubKey, \fBSignatureData\fP &sigdata)"
.br
.ti -1c
.RI "\fBSignatureData\fP \fBDataFromTransaction\fP (const \fBCMutableTransaction\fP &tx, unsigned int nIn, const \fBCTxOut\fP &txout)"
.br
.ti -1c
.RI "void \fBUpdateInput\fP (\fBCTxIn\fP &input, const \fBSignatureData\fP &data)"
.br
.ti -1c
.RI "bool \fBIsSegWitOutput\fP (const \fBSigningProvider\fP &provider, const \fBCScript\fP &\fBscript\fP)"
.br
.ti -1c
.RI "bool \fBSignTransaction\fP (\fBCMutableTransaction\fP &mtx, const \fBSigningProvider\fP *keystore, const std::map< \fBCOutPoint\fP, \fBCoin\fP > &coins, int nHashType, std::map< int, \fBbilingual_str\fP > &input_errors)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBBaseSignatureChecker\fP & \fBDUMMY_CHECKER\fP = DummySignatureChecker()"
.br
.ti -1c
.RI "const \fBBaseSignatureCreator\fP & \fBDUMMY_SIGNATURE_CREATOR\fP = DummySignatureCreator(32, 32)"
.br
.ti -1c
.RI "const \fBBaseSignatureCreator\fP & \fBDUMMY_MAXIMUM_SIGNATURE_CREATOR\fP = DummySignatureCreator(33, 32)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef std::vector<unsigned char> \fBvaltype\fP"

.SH "Function Documentation"
.PP 
.SS "\fBSignatureData\fP DataFromTransaction (const \fBCMutableTransaction\fP & tx, unsigned int nIn, const \fBCTxOut\fP & txout)"
Extract signature data from a transaction input, and insert it\&. 
.SS "bool IsSegWitOutput (const \fBSigningProvider\fP & provider, const \fBCScript\fP & script)"
Check whether a scriptPubKey is known to be segwit\&. 
.SS "template<typename M, typename K, typename V> \fBminiscript::Availability\fP MsLookupHelper (const M & map, const K & key, V & value)"

.SS "bool ProduceSignature (const \fBSigningProvider\fP & provider, const \fBBaseSignatureCreator\fP & creator, const \fBCScript\fP & scriptPubKey, \fBSignatureData\fP & sigdata)"
Produce a script signature using a generic signature creator\&. 
.SS "bool SignTransaction (\fBCMutableTransaction\fP & mtx, const \fBSigningProvider\fP * provider, const std::map< \fBCOutPoint\fP, \fBCoin\fP > & coins, int sighash, std::map< int, \fBbilingual_str\fP > & input_errors)"
Sign the \fBCMutableTransaction\fP 
.SS "void UpdateInput (\fBCTxIn\fP & input, const \fBSignatureData\fP & data)"

.SH "Variable Documentation"
.PP 
.SS "const \fBBaseSignatureChecker\fP& DUMMY_CHECKER = DummySignatureChecker()"
A signature checker that accepts all signatures 
.SS "const \fBBaseSignatureCreator\fP& DUMMY_MAXIMUM_SIGNATURE_CREATOR = DummySignatureCreator(33, 32)"
A signature creator that just produces 72-byte empty signatures\&. 
.SS "const \fBBaseSignatureCreator\fP& DUMMY_SIGNATURE_CREATOR = DummySignatureCreator(32, 32)"
A signature creator that just produces 71-byte empty signatures\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
