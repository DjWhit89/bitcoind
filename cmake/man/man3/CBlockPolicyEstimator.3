.TH "CBlockPolicyEstimator" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CBlockPolicyEstimator
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <block_policy_estimator\&.h>\fP
.PP
Inherits \fBCValidationInterface\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCBlockPolicyEstimator\fP (const \fBfs::path\fP &estimation_filepath, const bool read_stale_estimates)"
.br
.ti -1c
.RI "virtual \fB~CBlockPolicyEstimator\fP ()"
.br
.ti -1c
.RI "void \fBprocessBlock\fP (const std::vector< \fBRemovedMempoolTransactionInfo\fP > &txs_removed_for_block, unsigned int nBlockHeight) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "void \fBprocessTransaction\fP (const \fBNewMempoolTransactionInfo\fP &tx) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "bool \fBremoveTx\fP (\fBTxid\fP hash) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBestimateFee\fP (int confTarget) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "virtual \fBCFeeRate\fP \fBestimateSmartFee\fP (int confTarget, \fBFeeCalculation\fP *feeCalc, bool conservative) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "\fBCFeeRate\fP \fBestimateRawFee\fP (int confTarget, double successThreshold, \fBFeeEstimateHorizon\fP horizon, \fBEstimationResult\fP *result=nullptr) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "bool \fBWrite\fP (\fBAutoFile\fP &fileout) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "bool \fBRead\fP (\fBAutoFile\fP &filein) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "void \fBFlushUnconfirmed\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "virtual unsigned int \fBHighestTargetTracked\fP (\fBFeeEstimateHorizon\fP horizon) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "void \fBFlush\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "void \fBFlushFeeEstimates\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "std::chrono::hours \fBGetFeeEstimatorFileAge\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBTransactionAddedToMempool\fP (const \fBNewMempoolTransactionInfo\fP &tx, uint64_t) override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "void \fBTransactionRemovedFromMempool\fP (const \fBCTransactionRef\fP &tx, \fBMemPoolRemovalReason\fP, uint64_t) override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.ti -1c
.RI "void \fBMempoolTransactionsRemovedForBlock\fP (const std::vector< \fBRemovedMempoolTransactionInfo\fP > &txs_removed_for_block, unsigned int nBlockHeight) override \fBEXCLUSIVE_LOCKS_REQUIRED\fP(!m_cs_fee_estimator)"
.br
.in -1c

Protected Member Functions inherited from \fBCValidationInterface\fP
.in +1c
.ti -1c
.RI "\fB~CValidationInterface\fP ()=default"
.br
.ti -1c
.RI "virtual void \fBUpdatedBlockTip\fP (const \fBCBlockIndex\fP *pindexNew, const \fBCBlockIndex\fP *pindexFork, bool fInitialDownload)"
.br
.ti -1c
.RI "virtual void \fBActiveTipChange\fP (const \fBCBlockIndex\fP &new_tip, bool is_ibd)"
.br
.ti -1c
.RI "virtual void \fBBlockConnected\fP (const \fBkernel::ChainstateRole\fP &role, const std::shared_ptr< const \fBCBlock\fP > &block, const \fBCBlockIndex\fP *pindex)"
.br
.ti -1c
.RI "virtual void \fBBlockDisconnected\fP (const std::shared_ptr< const \fBCBlock\fP > &block, const \fBCBlockIndex\fP *pindex)"
.br
.ti -1c
.RI "virtual void \fBChainStateFlushed\fP (const \fBkernel::ChainstateRole\fP &role, const \fBCBlockLocator\fP &locator)"
.br
.ti -1c
.RI "virtual void \fBBlockChecked\fP (const std::shared_ptr< const \fBCBlock\fP > &, const \fBBlockValidationState\fP &)"
.br
.ti -1c
.RI "virtual void \fBNewPoWValidBlock\fP (const \fBCBlockIndex\fP *pindex, const std::shared_ptr< const \fBCBlock\fP > &block)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The BlockPolicyEstimator is used for estimating the feerate needed for a transaction to be included in a block within a certain number of blocks\&.

.PP
At a high level the algorithm works by grouping transactions into buckets based on having similar feerates and then tracking how long it takes transactions in the various buckets to be mined\&. It operates under the assumption that in general transactions of higher feerate will be included in blocks before transactions of lower feerate\&. So for example if you wanted to know what feerate you should put on a transaction to be included in a block within the next 5 blocks, you would start by looking at the bucket with the highest feerate transactions and verifying that a sufficiently high percentage of them were confirmed within 5 blocks and then you would look at the next highest feerate bucket, and so on, stopping at the last bucket to pass the test\&. The average feerate of transactions in this bucket will give you an indication of the lowest feerate you can put on a transaction and still have a sufficiently high chance of being confirmed within your desired 5 blocks\&.

.PP
Here is a brief description of the implementation: When a transaction enters the mempool, we track the height of the block chain at entry\&. All further calculations are conducted only on this set of "seen" transactions\&. Whenever a block comes in, we count the number of transactions in each bucket and the total amount of feerate paid in each bucket\&. Then we calculate how many blocks Y it took each transaction to be mined\&. We convert from a number of blocks to a number of periods Y' each encompassing "scale" blocks\&. This is tracked in 3 different data sets each up to a maximum number of periods\&. Within each data set we have an array of counters in each feerate bucket and we increment all the counters from Y' up to max periods representing that a tx was successfully confirmed in less than or equal to that many periods\&. We want to save a history of this information, so at any time we have a counter of the total number of transactions that happened in a given feerate bucket and the total number that were confirmed in each of the periods or less for any bucket\&. We save this history by keeping an exponentially decaying moving average of each one of these stats\&. This is done for a different decay in each of the 3 data sets to keep relevant data from different time horizons\&. Furthermore we also keep track of the number unmined (in mempool or left mempool without being included in a block) transactions in each bucket and for how many blocks they have been outstanding and use both of these numbers to increase the number of transactions we've seen in that feerate bucket when calculating an estimate for any number of confirmations below the number of blocks they've been outstanding\&.

.PP
We want to be able to estimate feerates that are needed on tx's to be included in a certain number of blocks\&. Every time a block is added to the best chain, this class records stats on the transactions included in that block 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCBlockPolicyEstimator\fP (const \fBfs::path\fP & estimation_filepath, const bool read_stale_estimates)"
Create new BlockPolicyEstimator and initialize stats tracking classes with default values 
.SS "~\fBCBlockPolicyEstimator\fP ()\fR [virtual]\fP, \fR [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "\fBCFeeRate\fP estimateFee (int confTarget) const"
DEPRECATED\&. Return a feerate estimate 
.SS "\fBCFeeRate\fP estimateRawFee (int confTarget, double successThreshold, \fBFeeEstimateHorizon\fP horizon, \fBEstimationResult\fP * result = \fRnullptr\fP) const"
Return a specific fee estimate calculation with a given success threshold and time horizon, and optionally return detailed data about calculation 
.SS "\fBCFeeRate\fP estimateSmartFee (int confTarget, \fBFeeCalculation\fP * feeCalc, bool conservative) const\fR [virtual]\fP"
Estimate feerate needed to get be included in a block within confTarget blocks\&. If no answer can be given at confTarget, return an estimate at the closest target where one can be given\&. 'conservative' estimates are valid over longer time horizons also\&.

.PP
estimateSmartFee returns the max of the feerates calculated with a 60% threshold required at target / 2, an 85% threshold required at target and a 95% threshold required at 2 * target\&. Each calculation is performed at the shortest time horizon which tracks the required target\&. Conservative estimates, however, required the 95% threshold at 2 * target be met for any longer time horizons also\&. true is passed to estimateCombined fee for target/2 and target so that we check the max confirms for shorter time horizons as well\&. This is necessary to preserve monotonically increasing estimates\&. For non-conservative estimates we do the same thing for 2*target, but for conservative estimates we want to skip these shorter horizons checks for 2*target because we are taking the max over all time horizons so we already have monotonically increasing estimates and the purpose of conservative estimates is not to let short term fluctuations lower our estimates by too much\&.

.PP
Note: In certain rare edge cases, monotonically increasing estimates may not be guaranteed\&. Specifically, given two targets N and M, where M > N, if a sub-estimate for target N fails to return a valid fee rate, while target M has valid fee rate for that sub-estimate, target M may result in a higher fee rate estimate than target N\&.

.PP
See: https://github.com/bitcoin/bitcoin/issues/11800#issuecomment-349697807
.SS "void Flush ()"
Drop still unconfirmed transactions and record current estimations, if the fee estimation file is present\&. 
.SS "void FlushFeeEstimates ()"
Record current fee estimations\&. 
.SS "void FlushUnconfirmed ()"
Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool 
.SS "std::chrono::hours GetFeeEstimatorFileAge ()"
Calculates the age of the file, since last modified 
.SS "unsigned int HighestTargetTracked (\fBFeeEstimateHorizon\fP horizon) const\fR [virtual]\fP"
Calculation of highest target that estimates are tracked for 
.SS "void MempoolTransactionsRemovedForBlock (const std::vector< \fBRemovedMempoolTransactionInfo\fP > & txs_removed_for_block, unsigned int nBlockHeight)\fR [override]\fP, \fR [protected]\fP, \fR [virtual]\fP"

.PP
Reimplemented from \fBCValidationInterface\fP\&.
.SS "void processBlock (const std::vector< \fBRemovedMempoolTransactionInfo\fP > & txs_removed_for_block, unsigned int nBlockHeight)"
Process all the transactions that have been included in a block 
.SS "void processTransaction (const \fBNewMempoolTransactionInfo\fP & tx)"
Process a transaction accepted to the mempool 
.SS "bool Read (\fBAutoFile\fP & filein)"
Read estimation data from a file 
.SS "bool removeTx (\fBTxid\fP hash)"
Remove a transaction from the mempool tracking stats for non BLOCK removal reasons 
.SS "void TransactionAddedToMempool (const \fBNewMempoolTransactionInfo\fP & tx, uint64_t )\fR [override]\fP, \fR [protected]\fP, \fR [virtual]\fP"
Overridden from \fBCValidationInterface\fP\&. 
.PP
Reimplemented from \fBCValidationInterface\fP\&.
.SS "void TransactionRemovedFromMempool (const \fBCTransactionRef\fP & tx, \fBMemPoolRemovalReason\fP reason, uint64_t mempool_sequence)\fR [override]\fP, \fR [protected]\fP, \fR [virtual]\fP"
Notifies listeners of a transaction leaving mempool\&.

.PP
This notification fires for transactions that are removed from the mempool for the following reasons:

.PP
.IP "\(bu" 2
EXPIRY (expired from mempool after -mempoolexpiry hours)
.IP "\(bu" 2
SIZELIMIT (removed in size limiting if the mempool exceeds -maxmempool megabytes)
.IP "\(bu" 2
REORG (removed during a reorg)
.IP "\(bu" 2
CONFLICT (removed because it conflicts with in-block transaction)
.IP "\(bu" 2
REPLACED (removed due to RBF replacement)
.PP

.PP
This does not fire for transactions that are removed from the mempool because they have been included in a block\&. Any client that is interested in transactions removed from the mempool for inclusion in a block can learn about those transactions from the MempoolTransactionsRemovedForBlock notification\&.

.PP
Transactions that are removed from the mempool because they conflict with a transaction in the new block will have TransactionRemovedFromMempool events fired \fIbefore\fP the BlockConnected event is fired\&. If multiple blocks are connected in one step, then the ordering could be:

.PP
.IP "\(bu" 2
TransactionRemovedFromMempool(tx1 from block A)
.IP "\(bu" 2
TransactionRemovedFromMempool(tx2 from block A)
.IP "\(bu" 2
TransactionRemovedFromMempool(tx1 from block B)
.IP "\(bu" 2
TransactionRemovedFromMempool(tx2 from block B)
.IP "\(bu" 2
BlockConnected(A)
.IP "\(bu" 2
BlockConnected(B)
.PP

.PP
Called on a background thread\&. 
.PP
Reimplemented from \fBCValidationInterface\fP\&.
.SS "bool Write (\fBAutoFile\fP & fileout) const"
Write estimation data to a file 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
