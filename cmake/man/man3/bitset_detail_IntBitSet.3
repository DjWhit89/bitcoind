.TH "IntBitSet< I >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IntBitSet< I >
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <bitset\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "constexpr \fBIntBitSet\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBIntBitSet\fP (const IntBitSet &) noexcept=default"
.br
.ti -1c
.RI "constexpr \fBIntBitSet\fP (std::initializer_list< unsigned > ilist) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet & \fBoperator=\fP (const IntBitSet &) noexcept=default"
.br
.ti -1c
.RI "constexpr IntBitSet & \fBoperator=\fP (std::initializer_list< unsigned > ilist) noexcept"
.br
.ti -1c
.RI "constexpr void \fBSet\fP (unsigned pos) noexcept"
.br
.ti -1c
.RI "constexpr void \fBSet\fP (unsigned pos, bool val) noexcept"
.br
.ti -1c
.RI "constexpr void \fBReset\fP (unsigned pos) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator[]\fP (unsigned pos) const noexcept"
.br
.ti -1c
.RI "constexpr unsigned \fBCount\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBNone\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBAny\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBIterator\fP \fBbegin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr IteratorEnd \fBend\fP () const noexcept"
.br
.ti -1c
.RI "constexpr unsigned \fBFirst\fP () const noexcept"
.br
.ti -1c
.RI "constexpr unsigned \fBLast\fP () const noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet & \fBoperator|=\fP (const IntBitSet &a) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet & \fBoperator&=\fP (const IntBitSet &a) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet & \fBoperator\-=\fP (const IntBitSet &a) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet & \fBoperator^=\fP (const IntBitSet &a) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBOverlaps\fP (const IntBitSet &a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBIsSupersetOf\fP (const IntBitSet &a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBIsSubsetOf\fP (const IntBitSet &a) const noexcept"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static constexpr IntBitSet \fBSingleton\fP (unsigned i) noexcept"
.br
.ti -1c
.RI "static constexpr IntBitSet \fBFill\fP (unsigned count) noexcept"
.br
.ti -1c
.RI "static constexpr unsigned \fBSize\fP () noexcept"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "constexpr IntBitSet \fBoperator&\fP (const IntBitSet &a, const IntBitSet &b) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet \fBoperator|\fP (const IntBitSet &a, const IntBitSet &b) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet \fBoperator\-\fP (const IntBitSet &a, const IntBitSet &b) noexcept"
.br
.ti -1c
.RI "constexpr IntBitSet \fBoperator^\fP (const IntBitSet &a, const IntBitSet &b) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator==\fP (const IntBitSet &a, const IntBitSet &b) noexcept=default"
.br
.ti -1c
.RI "constexpr void \fBswap\fP (IntBitSet &a, IntBitSet &b) noexcept"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename I>
.br
class bitset_detail::IntBitSet< I >"A bitset implementation backed by a single integer of type I\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename I> IntBitSet ()\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Construct an all-zero bitset\&. 
.SS "template<typename I> IntBitSet (const IntBitSet< I > & )\fR [constexpr]\fP, \fR [default]\fP, \fR [noexcept]\fP"
Copy construct a bitset\&. 
.SS "template<typename I> IntBitSet (std::initializer_list< unsigned > ilist)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Construct from a list of values\&. 
.SH "Member Function Documentation"
.PP 
.SS "template<typename I> bool Any () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Check if any bits are 1\&. 
.SS "template<typename I> \fBIterator\fP begin () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Return an object that iterates over all 1 bits (++ and * only allowed when != \fBend()\fP)\&. 
.SS "template<typename I> unsigned Count () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Compute the number of 1 bits in the bitset\&. 
.SS "template<typename I> IteratorEnd end () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Return a dummy object to compare Iterators with\&. 
.SS "template<typename I> constexpr IntBitSet Fill (unsigned count)\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Construct a bitset with bits 0\&.\&.count-1 (inclusive) set to 1\&. 
.SS "template<typename I> unsigned First () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Find the first element (requires \fBAny()\fP)\&. 
.SS "template<typename I> bool IsSubsetOf (const IntBitSet< I > & a) const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Check if bitset a is a subset of bitset b (= every 1 bit in a is also in b)\&. 
.SS "template<typename I> bool IsSupersetOf (const IntBitSet< I > & a) const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Check if bitset a is a superset of bitset b (= every 1 bit in b is also in a)\&. 
.SS "template<typename I> unsigned Last () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Find the last element (requires \fBAny()\fP)\&. 
.SS "template<typename I> bool None () const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Check if all bits are 0\&. 
.SS "template<typename I> IntBitSet & operator&= (const IntBitSet< I > & a)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set this object's bits to be the binary OR between respective bits from this and a\&. 
.SS "template<typename I> IntBitSet & operator\-= (const IntBitSet< I > & a)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set this object's bits to be the binary AND NOT between respective bits from this and a\&. 
.SS "template<typename I> IntBitSet & operator= (const IntBitSet< I > & )\fR [constexpr]\fP, \fR [default]\fP, \fR [noexcept]\fP"
Copy assign a bitset\&. 
.SS "template<typename I> IntBitSet & operator= (std::initializer_list< unsigned > ilist)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Assign from a list of positions (which will be made true, all others false)\&. 
.SS "template<typename I> bool operator[] (unsigned pos) const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Retrieve a bit at the given position\&. 
.SS "template<typename I> IntBitSet & operator^= (const IntBitSet< I > & a)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set this object's bits to be the binary XOR between respective bits from this as a\&. 
.SS "template<typename I> IntBitSet & operator|= (const IntBitSet< I > & a)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set this object's bits to be the binary AND between respective bits from this and a\&. 
.SS "template<typename I> bool Overlaps (const IntBitSet< I > & a) const\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Check if the intersection between two sets is non-empty\&. 
.SS "template<typename I> void Reset (unsigned pos)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set a bit to 0\&. 
.SS "template<typename I> void Set (unsigned pos)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set a bit to 1\&. 
.SS "template<typename I> void Set (unsigned pos, bool val)\fR [inline]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Set a bit to the specified value\&. 
.SS "template<typename I> constexpr IntBitSet Singleton (unsigned i)\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Construct a bitset with the singleton i\&. 
.SS "template<typename I> constexpr unsigned Size ()\fR [inline]\fP, \fR [static]\fP, \fR [constexpr]\fP, \fR [noexcept]\fP"
Return the number of bits that this object holds\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<typename I> IntBitSet operator& (const IntBitSet< I > & a, const IntBitSet< I > & b)\fR [friend]\fP"
Return an object with the binary AND between respective bits from a and b\&. 
.SS "template<typename I> IntBitSet operator\- (const IntBitSet< I > & a, const IntBitSet< I > & b)\fR [friend]\fP"
Return an object with the binary AND NOT between respective bits from a and b\&. 
.SS "template<typename I> bool operator== (const IntBitSet< I > & a, const IntBitSet< I > & b)\fR [friend]\fP"
Check if bitset a and bitset b are identical\&. 
.SS "template<typename I> IntBitSet operator^ (const IntBitSet< I > & a, const IntBitSet< I > & b)\fR [friend]\fP"
Return an object with the binary XOR between respective bits from a and b\&. 
.SS "template<typename I> IntBitSet operator| (const IntBitSet< I > & a, const IntBitSet< I > & b)\fR [friend]\fP"
Return an object with the binary OR between respective bits from a and b\&. 
.SS "template<typename I> void swap (IntBitSet< I > & a, IntBitSet< I > & b)\fR [friend]\fP"
Swap two bitsets\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
