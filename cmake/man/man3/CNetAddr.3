.TH "CNetAddr" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CNetAddr
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <netaddress\&.h>\fP
.PP
Inherited by \fBCService\fP\&.
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBSerParams\fP"
.br
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum class \fBEncoding\fP { \fBV1\fP, \fBV2\fP }"
.br
.ti -1c
.RI "enum \fBBIP155Network\fP : uint8_t { \fBIPV4\fP = 1, \fBIPV6\fP = 2, \fBTORV2\fP = 3, \fBTORV3\fP = 4, \fBI2P\fP = 5, \fBCJDNS\fP = 6 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBCNetAddr\fP ()"
.br
.ti -1c
.RI "\fBCNetAddr\fP (const struct in_addr &ipv4Addr)"
.br
.ti -1c
.RI "void \fBSetIP\fP (const \fBCNetAddr\fP &ip)"
.br
.ti -1c
.RI "void \fBSetLegacyIPv6\fP (std::span< const uint8_t > ipv6)"
.br
.ti -1c
.RI "bool \fBSetInternal\fP (const std::string &\fBname\fP)"
.br
.ti -1c
.RI "bool \fBSetSpecial\fP (std::string_view addr)"
.br
.ti -1c
.RI "bool \fBIsBindAny\fP () const"
.br
.ti -1c
.RI "bool \fBIsIPv4\fP () const"
.br
.ti -1c
.RI "bool \fBIsIPv6\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC1918\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC2544\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC6598\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC5737\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC3849\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC3927\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC3964\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC4193\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC4380\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC4843\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC7343\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC4862\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC6052\fP () const"
.br
.ti -1c
.RI "bool \fBIsRFC6145\fP () const"
.br
.ti -1c
.RI "bool \fBIsHeNet\fP () const"
.br
.ti -1c
.RI "bool \fBIsTor\fP () const"
.br
.ti -1c
.RI "bool \fBIsI2P\fP () const"
.br
.ti -1c
.RI "bool \fBIsCJDNS\fP () const"
.br
.ti -1c
.RI "bool \fBHasCJDNSPrefix\fP () const"
.br
.ti -1c
.RI "bool \fBIsLocal\fP () const"
.br
.ti -1c
.RI "bool \fBIsRoutable\fP () const"
.br
.ti -1c
.RI "bool \fBIsInternal\fP () const"
.br
.ti -1c
.RI "bool \fBIsValid\fP () const"
.br
.ti -1c
.RI "bool \fBIsPrivacyNet\fP () const"
.br
.ti -1c
.RI "bool \fBIsAddrV1Compatible\fP () const"
.br
.ti -1c
.RI "enum \fBNetwork\fP \fBGetNetwork\fP () const"
.br
.ti -1c
.RI "std::string \fBToStringAddr\fP () const"
.br
.ti -1c
.RI "bool \fBGetInAddr\fP (struct in_addr *pipv4Addr) const"
.br
.ti -1c
.RI "\fBNetwork\fP \fBGetNetClass\fP () const"
.br
.ti -1c
.RI "uint32_t \fBGetLinkedIPv4\fP () const"
.br
.RI "For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32\&. "
.ti -1c
.RI "bool \fBHasLinkedIPv4\fP () const"
.br
.RI "Whether this address has a linked IPv4 address (see \fBGetLinkedIPv4()\fP)\&. "
.ti -1c
.RI "std::vector< unsigned char > \fBGetAddrBytes\fP () const"
.br
.ti -1c
.RI "int \fBGetReachabilityFrom\fP (const \fBCNetAddr\fP &paddrPartner) const"
.br
.ti -1c
.RI "\fBCNetAddr\fP (const struct in6_addr &pipv6Addr, const uint32_t scope=0)"
.br
.ti -1c
.RI "bool \fBGetIn6Addr\fP (struct in6_addr *pipv6Addr) const"
.br
.ti -1c
.RI "bool \fBIsRelayable\fP () const"
.br
.ti -1c
.RI "template<typename Stream> void \fBSerialize\fP (Stream &s) const"
.br
.ti -1c
.RI "template<typename Stream> void \fBUnserialize\fP (Stream &s)"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr \fBSerParams\fP \fBV1\fP {\fBEncoding::V1\fP}"
.br
.ti -1c
.RI "static constexpr \fBSerParams\fP \fBV2\fP {\fBEncoding::V2\fP}"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBprevector\fP< ADDR_IPV6_SIZE, uint8_t > \fBm_addr\fP {ADDR_IPV6_SIZE, 0x0}"
.br
.ti -1c
.RI "\fBNetwork\fP \fBm_net\fP {\fBNET_IPV6\fP}"
.br
.ti -1c
.RI "uint32_t \fBm_scope_id\fP {0}"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBCSubNet\fP"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBCNetAddr\fP &a, const \fBCNetAddr\fP &b)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBCNetAddr\fP &a, const \fBCNetAddr\fP &b)"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBNetwork\fP address\&. 
.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBBIP155Network\fP : uint8_t"
BIP155 network ids recognized by this software\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIIPV4 \fP
.TP
\f(BIIPV6 \fP
.TP
\f(BITORV2 \fP
.TP
\f(BITORV3 \fP
.TP
\f(BII2P \fP
.TP
\f(BICJDNS \fP
.SS "enum class \fBEncoding\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIV1 \fP
.TP
\f(BIV2 \fP
BIP155 encoding\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBCNetAddr\fP ()\fR [default]\fP"
Construct an unspecified IPv6 network address (::/128)\&.

.PP
\fBNote\fP
.RS 4
This address is considered invalid by \fBCNetAddr::IsValid()\fP 
.RE
.PP

.SS "\fBCNetAddr\fP (const struct in_addr & ipv4Addr)\fR [explicit]\fP"

.SS "\fBCNetAddr\fP (const struct in6_addr & pipv6Addr, const uint32_t scope = \fR0\fP)\fR [explicit]\fP"

.SH "Member Function Documentation"
.PP 
.SS "std::vector< unsigned char > GetAddrBytes () const"

.SS "bool GetIn6Addr (struct in6_addr * pipv6Addr) const"
Try to get our IPv6 (or CJDNS) address\&.

.PP
\fBParameters\fP
.RS 4
\fIpipv6Addr\fP The in6_addr struct to which to copy\&.
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not the operation was successful, in particular, whether or not our address was an IPv6 address\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBCNetAddr::IsIPv6()\fP 
.RE
.PP

.SS "bool GetInAddr (struct in_addr * pipv4Addr) const"
Try to get our IPv4 address\&.

.PP
\fBParameters\fP
.RS 4
\fIpipv4Addr\fP The in_addr struct to which to copy\&.
.RE
.PP
\fBReturns\fP
.RS 4
Whether or not the operation was successful, in particular, whether or not our address was an IPv4 address\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBCNetAddr::IsIPv4()\fP 
.RE
.PP

.SS "uint32_t GetLinkedIPv4 () const"

.PP
For IPv4, mapped IPv4, SIIT translated IPv4, Teredo, 6to4 tunneled addresses, return the relevant IPv4 address as a uint32\&. 
.SS "\fBNetwork\fP GetNetClass () const"

.SS "enum \fBNetwork\fP GetNetwork () const"

.SS "int GetReachabilityFrom (const \fBCNetAddr\fP & paddrPartner) const"
Calculates a metric for how reachable (*this) is from a given partner 
.SS "bool HasCJDNSPrefix () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "bool HasLinkedIPv4 () const"

.PP
Whether this address has a linked IPv4 address (see \fBGetLinkedIPv4()\fP)\&. 
.SS "bool IsAddrV1Compatible () const"
Check if the current object can be serialized in pre-ADDRv2/BIP155 format\&. 
.SS "bool IsBindAny () const"

.SS "bool IsCJDNS () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "bool IsHeNet () const"

.SS "bool IsI2P () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "bool IsInternal () const"

.PP
\fBReturns\fP
.RS 4
Whether or not this is a dummy address that represents a name\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBCNetAddr::SetInternal(const std::string &)\fP 
.RE
.PP

.SS "bool IsIPv4 () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "bool IsIPv6 () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "bool IsLocal () const"

.SS "bool IsPrivacyNet () const\fR [inline]\fP, \fR [nodiscard]\fP"
Whether this object is a privacy network\&. TODO: consider adding \fBIsCJDNS()\fP here when more peers adopt CJDNS, see: https://github.com/bitcoin/bitcoin/pull/27411#issuecomment-1497176155 
.SS "bool IsRelayable () const\fR [inline]\fP"
Whether this address should be relayed to other peers even if we can't reach it ourselves\&. 
.SS "bool IsRFC1918 () const"

.SS "bool IsRFC2544 () const"

.SS "bool IsRFC3849 () const"

.SS "bool IsRFC3927 () const"

.SS "bool IsRFC3964 () const"

.SS "bool IsRFC4193 () const"

.SS "bool IsRFC4380 () const"

.SS "bool IsRFC4843 () const"

.SS "bool IsRFC4862 () const"

.SS "bool IsRFC5737 () const"

.SS "bool IsRFC6052 () const"

.SS "bool IsRFC6145 () const"

.SS "bool IsRFC6598 () const"

.SS "bool IsRFC7343 () const"

.SS "bool IsRoutable () const"

.PP
\fBReturns\fP
.RS 4
Whether or not this network address is publicly routable on the global internet\&.
.RE
.PP
\fBNote\fP
.RS 4
A routable address is always valid\&. As in, the set of routable addresses is a subset of the set of valid addresses\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBCNetAddr::IsValid()\fP 
.RE
.PP

.SS "bool IsTor () const\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "bool IsValid () const"

.PP
\fBReturns\fP
.RS 4
Whether or not this network address is a valid address that \fIcould\fP be used to refer to an actual host\&.
.RE
.PP
\fBNote\fP
.RS 4
A valid address may or may not be publicly routable on the global internet\&. As in, the set of valid addresses is a superset of the set of publicly routable addresses\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBCNetAddr::IsRoutable()\fP 
.RE
.PP

.SS "template<typename Stream> void Serialize (Stream & s) const\fR [inline]\fP"
Serialize to a stream\&. 
.SS "bool SetInternal (const std::string & name)"
Create an "internal" address that represents a name or FQDN\&. \fBAddrMan\fP uses these fake addresses to keep track of which DNS seeds were used\&. 
.PP
\fBReturns\fP
.RS 4
Whether or not the operation was successful\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBNET_INTERNAL\fP, INTERNAL_IN_IPV6_PREFIX, \fBCNetAddr::IsInternal()\fP, \fBCNetAddr::IsRFC4193()\fP 
.RE
.PP

.SS "void SetIP (const \fBCNetAddr\fP & ip)"

.SS "void SetLegacyIPv6 (std::span< const uint8_t > ipv6)"
Set from a legacy IPv6 address\&. Legacy IPv6 address may be a normal IPv6 address, or another address (e\&.g\&. IPv4) disguised as IPv6\&. This encoding is used in the legacy \fRaddr\fP encoding\&. 
.SS "bool SetSpecial (std::string_view addr)"
Parse a Tor or I2P address and set this object to it\&. 
.PP
\fBParameters\fP
.RS 4
\fIaddr\fP Address to parse, for example pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd\&.onion or ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq\&.b32\&.i2p\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Whether the operation was successful\&. 
.RE
.PP
\fBSee also\fP
.RS 4
\fBCNetAddr::IsTor()\fP, \fBCNetAddr::IsI2P()\fP 
.RE
.PP

.SS "std::string ToStringAddr () const"

.SS "template<typename Stream> void Unserialize (Stream & s)\fR [inline]\fP"
Unserialize from a stream\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "friend class \fBCSubNet\fP\fR [friend]\fP"

.SS "bool operator< (const \fBCNetAddr\fP & a, const \fBCNetAddr\fP & b)\fR [friend]\fP"

.SS "bool operator== (const \fBCNetAddr\fP & a, const \fBCNetAddr\fP & b)\fR [friend]\fP"

.SH "Field Documentation"
.PP 
.SS "\fBprevector\fP<ADDR_IPV6_SIZE, uint8_t> m_addr {ADDR_IPV6_SIZE, 0x0}\fR [protected]\fP"
Raw representation of the network address\&. In network byte order (big endian) for IPv4 and IPv6\&. 
.SS "\fBNetwork\fP m_net {\fBNET_IPV6\fP}\fR [protected]\fP"
\fBNetwork\fP to which this address belongs\&. 
.SS "uint32_t m_scope_id {0}\fR [protected]\fP"
Scope id if scoped/link-local IPV6 address\&. See https://tools.ietf.org/html/rfc4007 
.SS "\fBSerParams\fP V1 {\fBEncoding::V1\fP}\fR [static]\fP, \fR [constexpr]\fP"

.SS "\fBSerParams\fP V2 {\fBEncoding::V2\fP}\fR [static]\fP, \fR [constexpr]\fP"


.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
