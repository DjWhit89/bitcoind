.TH "AEADChaCha20Poly1305" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
AEADChaCha20Poly1305
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <chacha20poly1305\&.h>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBNonce96\fP = \fBChaCha20::Nonce96\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAEADChaCha20Poly1305\fP (std::span< const std::byte > key) noexcept"
.br
.ti -1c
.RI "void \fBSetKey\fP (std::span< const std::byte > key) noexcept"
.br
.ti -1c
.RI "void \fBEncrypt\fP (std::span< const std::byte > plain, std::span< const std::byte > aad, \fBNonce96\fP \fBnonce\fP, std::span< std::byte > cipher) noexcept"
.br
.ti -1c
.RI "void \fBEncrypt\fP (std::span< const std::byte > plain1, std::span< const std::byte > plain2, std::span< const std::byte > aad, \fBNonce96\fP \fBnonce\fP, std::span< std::byte > cipher) noexcept"
.br
.ti -1c
.RI "bool \fBDecrypt\fP (std::span< const std::byte > cipher, std::span< const std::byte > aad, \fBNonce96\fP \fBnonce\fP, std::span< std::byte > plain) noexcept"
.br
.ti -1c
.RI "bool \fBDecrypt\fP (std::span< const std::byte > cipher, std::span< const std::byte > aad, \fBNonce96\fP \fBnonce\fP, std::span< std::byte > plain1, std::span< std::byte > plain2) noexcept"
.br
.ti -1c
.RI "void \fBKeystream\fP (\fBNonce96\fP \fBnonce\fP, std::span< std::byte > keystream) noexcept"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static constexpr unsigned \fBKEYLEN\fP = 32"
.br
.ti -1c
.RI "static constexpr unsigned \fBEXPANSION\fP = \fBPoly1305::TAGLEN\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The AEAD_CHACHA20_POLY1305 authenticated encryption algorithm from RFC8439 section 2\&.8\&. 
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBNonce96\fP = \fBChaCha20::Nonce96\fP"
96-bit nonce type\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBAEADChaCha20Poly1305\fP (std::span< const std::byte > key)\fR [noexcept]\fP"
Initialize an AEAD instance with a specified 32-byte key\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool Decrypt (std::span< const std::byte > cipher, std::span< const std::byte > aad, \fBNonce96\fP nonce, std::span< std::byte > plain)\fR [inline]\fP, \fR [noexcept]\fP"
Decrypt a message with a specified 96-bit nonce and aad\&. Returns true if valid\&.

.PP
Requires cipher\&.size() = plain\&.size() + EXPANSION\&. 
.SS "bool Decrypt (std::span< const std::byte > cipher, std::span< const std::byte > aad, \fBNonce96\fP nonce, std::span< std::byte > plain1, std::span< std::byte > plain2)\fR [noexcept]\fP"
Decrypt a message with a specified 96-bit nonce and aad and split the result\&. Returns true if valid\&.

.PP
Requires cipher\&.size() = plain1\&.size() + plain2\&.size() + EXPANSION\&. 
.SS "void Encrypt (std::span< const std::byte > plain, std::span< const std::byte > aad, \fBNonce96\fP nonce, std::span< std::byte > cipher)\fR [inline]\fP, \fR [noexcept]\fP"
Encrypt a message with a specified 96-bit nonce and aad\&.

.PP
Requires cipher\&.size() = plain\&.size() + EXPANSION\&. 
.SS "void Encrypt (std::span< const std::byte > plain1, std::span< const std::byte > plain2, std::span< const std::byte > aad, \fBNonce96\fP nonce, std::span< std::byte > cipher)\fR [noexcept]\fP"
Encrypt a message (given split into plain1 + plain2) with a specified 96-bit nonce and aad\&.

.PP
Requires cipher\&.size() = plain1\&.size() + plain2\&.size() + EXPANSION\&. 
.SS "void Keystream (\fBNonce96\fP nonce, std::span< std::byte > keystream)\fR [noexcept]\fP"
Get a number of keystream bytes from the underlying stream cipher\&.

.PP
This is equivalent to \fBEncrypt()\fP with plain set to that many zero bytes, and dropping the last EXPANSION bytes off the result\&. 
.SS "void SetKey (std::span< const std::byte > key)\fR [noexcept]\fP"
Switch to another 32-byte key\&. 
.SH "Field Documentation"
.PP 
.SS "unsigned EXPANSION = \fBPoly1305::TAGLEN\fP\fR [static]\fP, \fR [constexpr]\fP"
Expansion when encrypting\&. 
.SS "unsigned KEYLEN = 32\fR [static]\fP, \fR [constexpr]\fP"
Expected size of key argument in constructor\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
