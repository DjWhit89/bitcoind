.TH "Chain" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Chain
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <chain\&.h>\fP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBNotifications\fP"
.br
.RI "\fBChain\fP notifications\&. "
.ti -1c
.RI "struct \fBNotifyOptions\fP"
.br
.RI "\fBOptions\fP specifying which chain notifications are required\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "virtual \fB~Chain\fP ()=default"
.br
.ti -1c
.RI "virtual std::optional< int > \fBgetHeight\fP ()=0"
.br
.ti -1c
.RI "virtual \fBuint256\fP \fBgetBlockHash\fP (int height)=0"
.br
.RI "Get block hash\&. Height must be valid or this function will abort\&. "
.ti -1c
.RI "virtual bool \fBhaveBlockOnDisk\fP (int height)=0"
.br
.ti -1c
.RI "virtual std::optional< int > \fBfindLocatorFork\fP (const \fBCBlockLocator\fP &locator)=0"
.br
.ti -1c
.RI "virtual bool \fBhasBlockFilterIndex\fP (\fBBlockFilterType\fP filter_type)=0"
.br
.RI "Returns whether a block filter index is available\&. "
.ti -1c
.RI "virtual std::optional< bool > \fBblockFilterMatchesAny\fP (\fBBlockFilterType\fP filter_type, const \fBuint256\fP &block_hash, const \fBGCSFilter::ElementSet\fP &filter_set)=0"
.br
.ti -1c
.RI "virtual bool \fBfindBlock\fP (const \fBuint256\fP &hash, const \fBFoundBlock\fP &block={})=0"
.br
.ti -1c
.RI "virtual bool \fBfindFirstBlockWithTimeAndHeight\fP (int64_t min_time, int min_height, const \fBFoundBlock\fP &block={})=0"
.br
.ti -1c
.RI "virtual bool \fBfindAncestorByHeight\fP (const \fBuint256\fP &block_hash, int ancestor_height, const \fBFoundBlock\fP &ancestor_out={})=0"
.br
.ti -1c
.RI "virtual bool \fBfindAncestorByHash\fP (const \fBuint256\fP &block_hash, const \fBuint256\fP &ancestor_hash, const \fBFoundBlock\fP &ancestor_out={})=0"
.br
.ti -1c
.RI "virtual bool \fBfindCommonAncestor\fP (const \fBuint256\fP &block_hash1, const \fBuint256\fP &block_hash2, const \fBFoundBlock\fP &ancestor_out={}, const \fBFoundBlock\fP &block1_out={}, const \fBFoundBlock\fP &block2_out={})=0"
.br
.ti -1c
.RI "virtual void \fBfindCoins\fP (std::map< \fBCOutPoint\fP, \fBCoin\fP > &coins)=0"
.br
.ti -1c
.RI "virtual double \fBguessVerificationProgress\fP (const \fBuint256\fP &block_hash)=0"
.br
.ti -1c
.RI "virtual bool \fBhasBlocks\fP (const \fBuint256\fP &block_hash, int min_height=0, std::optional< int > max_height={})=0"
.br
.ti -1c
.RI "virtual \fBRBFTransactionState\fP \fBisRBFOptIn\fP (const \fBCTransaction\fP &tx)=0"
.br
.RI "Check if transaction is RBF opt in\&. "
.ti -1c
.RI "virtual bool \fBisInMempool\fP (const \fBTxid\fP &txid)=0"
.br
.RI "Check if transaction is in mempool\&. "
.ti -1c
.RI "virtual bool \fBhasDescendantsInMempool\fP (const \fBTxid\fP &txid)=0"
.br
.RI "Check if transaction has descendants in mempool\&. "
.ti -1c
.RI "virtual bool \fBbroadcastTransaction\fP (const \fBCTransactionRef\fP &tx, const \fBCAmount\fP &max_tx_fee, \fBnode::TxBroadcast\fP broadcast_method, std::string &err_string)=0"
.br
.ti -1c
.RI "virtual void \fBgetTransactionAncestry\fP (const \fBTxid\fP &txid, size_t &ancestors, size_t &cluster_count, size_t *ancestorsize=nullptr, \fBCAmount\fP *ancestorfees=nullptr)=0"
.br
.RI "Calculate mempool ancestor and cluster counts for the given transaction\&. "
.ti -1c
.RI "virtual std::map< \fBCOutPoint\fP, \fBCAmount\fP > \fBcalculateIndividualBumpFees\fP (const std::vector< \fBCOutPoint\fP > &outpoints, const \fBCFeeRate\fP &target_feerate)=0"
.br
.RI "For each outpoint, calculate the fee-bumping cost to spend this outpoint at the specified\&. "
.ti -1c
.RI "virtual std::optional< \fBCAmount\fP > \fBcalculateCombinedBumpFee\fP (const std::vector< \fBCOutPoint\fP > &outpoints, const \fBCFeeRate\fP &target_feerate)=0"
.br
.RI "Calculate the combined bump fee for an input set per the same strategy\&. "
.ti -1c
.RI "virtual void \fBgetPackageLimits\fP (unsigned int &limit_ancestor_count, unsigned int &limit_descendant_count)=0"
.br
.ti -1c
.RI "virtual \fButil::Result\fP< void > \fBcheckChainLimits\fP (const \fBCTransactionRef\fP &tx)=0"
.br
.RI "Check if transaction will pass the mempool's chain limits\&. "
.ti -1c
.RI "virtual \fBCFeeRate\fP \fBestimateSmartFee\fP (int num_blocks, bool conservative, \fBFeeCalculation\fP *calc=nullptr)=0"
.br
.RI "Estimate smart fee\&. "
.ti -1c
.RI "virtual unsigned int \fBestimateMaxBlocks\fP ()=0"
.br
.RI "Fee estimator max target\&. "
.ti -1c
.RI "virtual \fBCFeeRate\fP \fBmempoolMinFee\fP ()=0"
.br
.RI "Mempool minimum fee\&. "
.ti -1c
.RI "virtual \fBCFeeRate\fP \fBrelayMinFee\fP ()=0"
.br
.RI "Relay current minimum fee (from -minrelaytxfee and -incrementalrelayfee settings)\&. "
.ti -1c
.RI "virtual \fBCFeeRate\fP \fBrelayIncrementalFee\fP ()=0"
.br
.RI "Relay incremental fee setting (-incrementalrelayfee), reflecting cost of relay\&. "
.ti -1c
.RI "virtual \fBCFeeRate\fP \fBrelayDustFee\fP ()=0"
.br
.RI "Relay dust fee setting (-dustrelayfee), reflecting lowest rate it's economical to spend\&. "
.ti -1c
.RI "virtual bool \fBhavePruned\fP ()=0"
.br
.RI "Check if any block has been pruned\&. "
.ti -1c
.RI "virtual std::optional< int > \fBgetPruneHeight\fP ()=0"
.br
.RI "Get the current prune height\&. "
.ti -1c
.RI "virtual bool \fBisReadyToBroadcast\fP ()=0"
.br
.RI "Check if the node is ready to broadcast transactions\&. "
.ti -1c
.RI "virtual bool \fBisInitialBlockDownload\fP ()=0"
.br
.RI "Check if in IBD\&. "
.ti -1c
.RI "virtual bool \fBshutdownRequested\fP ()=0"
.br
.RI "Check if shutdown requested\&. "
.ti -1c
.RI "virtual void \fBinitMessage\fP (const std::string &message)=0"
.br
.RI "Send init message\&. "
.ti -1c
.RI "virtual void \fBinitWarning\fP (const \fBbilingual_str\fP &message)=0"
.br
.RI "Send init warning\&. "
.ti -1c
.RI "virtual void \fBinitError\fP (const \fBbilingual_str\fP &message)=0"
.br
.RI "Send init error\&. "
.ti -1c
.RI "virtual void \fBshowProgress\fP (const std::string &title, int progress, bool resume_possible)=0"
.br
.RI "Send progress indicator\&. "
.ti -1c
.RI "virtual std::unique_ptr< \fBHandler\fP > \fBhandleNotifications\fP (std::shared_ptr< \fBNotifications\fP > notifications)=0"
.br
.RI "Register handler for notifications\&. "
.ti -1c
.RI "virtual void \fBwaitForNotificationsIfTipChanged\fP (const \fBuint256\fP &old_tip)=0"
.br
.ti -1c
.RI "virtual std::unique_ptr< \fBHandler\fP > \fBhandleRpc\fP (const \fBCRPCCommand\fP &\fBcommand\fP)=0"
.br
.ti -1c
.RI "virtual bool \fBrpcEnableDeprecated\fP (const std::string &method)=0"
.br
.RI "Check if deprecated RPC is enabled\&. "
.ti -1c
.RI "virtual \fBcommon::SettingsValue\fP \fBgetSetting\fP (const std::string &arg)=0"
.br
.RI "Get settings value\&. "
.ti -1c
.RI "virtual std::vector< \fBcommon::SettingsValue\fP > \fBgetSettingsList\fP (const std::string &arg)=0"
.br
.RI "Get list of settings values\&. "
.ti -1c
.RI "virtual \fBcommon::SettingsValue\fP \fBgetRwSetting\fP (const std::string &\fBname\fP)=0"
.br
.RI "Return <datadir>/settings\&.json setting value\&. "
.ti -1c
.RI "virtual bool \fBupdateRwSetting\fP (const std::string &\fBname\fP, const \fBSettingsUpdate\fP &update_function)=0"
.br
.ti -1c
.RI "virtual bool \fBoverwriteRwSetting\fP (const std::string &\fBname\fP, \fBcommon::SettingsValue\fP value, \fBSettingsAction\fP action=\fBSettingsAction::WRITE\fP)=0"
.br
.ti -1c
.RI "virtual bool \fBdeleteRwSettings\fP (const std::string &\fBname\fP, \fBSettingsAction\fP action=\fBSettingsAction::WRITE\fP)=0"
.br
.ti -1c
.RI "virtual void \fBrequestMempoolTransactions\fP (\fBNotifications\fP &notifications)=0"
.br
.ti -1c
.RI "virtual bool \fBhasAssumedValidChain\fP ()=0"
.br
.ti -1c
.RI "virtual \fBnode::NodeContext\fP * \fBcontext\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Interface giving clients (wallet processes, maybe other analysis tools in the future) ability to access to the chain state, receive notifications, estimate fees, and submit transactions\&.

.PP
TODO: Current chain methods are too low level, exposing too much of the internal workings of the bitcoin node, and not being very convenient to use\&. \fBChain\fP methods should be cleaned up and simplified over time\&. Examples:

.PP
.IP "\(bu" 2
The initMessages() and \fBshowProgress()\fP methods which the wallet uses to send notifications to the GUI should go away when GUI and wallet can directly communicate with each other without going through the node (https://github.com/bitcoin/bitcoin/pull/15288#discussion_r253321096)\&.
.IP "\(bu" 2
The handleRpc, registerRpcs, rpcEnableDeprecated methods and other RPC methods can go away if wallets listen for HTTP requests on their own ports instead of registering to handle requests on the node HTTP port\&.
.IP "\(bu" 2
Move fee estimation queries to an asynchronous interface and let the wallet cache it, fee estimation being driven by node mempool, wallet should be the consumer\&.
.IP "\(bu" 2
\fR\fBguessVerificationProgress\fP\fP and similar methods can go away if rescan logic moves out of the wallet, and the wallet just requests scans from the node (https://github.com/bitcoin/bitcoin/issues/11756) 
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "virtual ~\fBChain\fP ()\fR [virtual]\fP, \fR [default]\fP"

.SH "Member Function Documentation"
.PP 
.SS "virtual std::optional< bool > blockFilterMatchesAny (\fBBlockFilterType\fP filter_type, const \fBuint256\fP & block_hash, const \fBGCSFilter::ElementSet\fP & filter_set)\fR [pure virtual]\fP"
Returns whether any of the elements match the block via a BIP 157 block filter or std::nullopt if the block filter for this block couldn't be found\&. 
.SS "virtual bool broadcastTransaction (const \fBCTransactionRef\fP & tx, const \fBCAmount\fP & max_tx_fee, \fBnode::TxBroadcast\fP broadcast_method, std::string & err_string)\fR [pure virtual]\fP"
Process a local transaction, optionally adding it to the mempool and optionally broadcasting it to the network\&. 
.PP
\fBParameters\fP
.RS 4
\fItx\fP Transaction to process\&. 
.br
\fImax_tx_fee\fP Don't add the transaction to the mempool or broadcast it if its fee is higher than this\&. 
.br
\fIbroadcast_method\fP Whether to add the transaction to the mempool and how/whether to broadcast it\&. 
.br
\fIerr_string\fP Set if an error occurs\&. 
.RE
.PP
\fBReturns\fP
.RS 4
False if the transaction could not be added due to the fee or for another reason\&. 
.RE
.PP

.SS "virtual std::optional< \fBCAmount\fP > calculateCombinedBumpFee (const std::vector< \fBCOutPoint\fP > & outpoints, const \fBCFeeRate\fP & target_feerate)\fR [pure virtual]\fP"

.PP
Calculate the combined bump fee for an input set per the same strategy\&. 
.SS "virtual std::map< \fBCOutPoint\fP, \fBCAmount\fP > calculateIndividualBumpFees (const std::vector< \fBCOutPoint\fP > & outpoints, const \fBCFeeRate\fP & target_feerate)\fR [pure virtual]\fP"

.PP
For each outpoint, calculate the fee-bumping cost to spend this outpoint at the specified\&. 
.SS "virtual \fButil::Result\fP< void > checkChainLimits (const \fBCTransactionRef\fP & tx)\fR [pure virtual]\fP"

.PP
Check if transaction will pass the mempool's chain limits\&. 
.SS "virtual \fBnode::NodeContext\fP * context ()\fR [inline]\fP, \fR [virtual]\fP"
Get internal node context\&. Useful for testing, but not accessible across processes\&. 
.SS "virtual bool deleteRwSettings (const std::string & name, \fBSettingsAction\fP action = \fR\fBSettingsAction::WRITE\fP\fP)\fR [pure virtual]\fP"
Delete a given setting in <datadir>/settings\&.json\&. This method provides a simpler alternative to overwriteRwSetting when erasing a setting, for ease of use and readability\&. 
.SS "virtual unsigned int estimateMaxBlocks ()\fR [pure virtual]\fP"

.PP
Fee estimator max target\&. 
.SS "virtual \fBCFeeRate\fP estimateSmartFee (int num_blocks, bool conservative, \fBFeeCalculation\fP * calc = \fRnullptr\fP)\fR [pure virtual]\fP"

.PP
Estimate smart fee\&. 
.SS "virtual bool findAncestorByHash (const \fBuint256\fP & block_hash, const \fBuint256\fP & ancestor_hash, const \fBFoundBlock\fP & ancestor_out = \fR{}\fP)\fR [pure virtual]\fP"
Return whether block descends from a specified ancestor, and optionally return ancestor information\&. 
.SS "virtual bool findAncestorByHeight (const \fBuint256\fP & block_hash, int ancestor_height, const \fBFoundBlock\fP & ancestor_out = \fR{}\fP)\fR [pure virtual]\fP"
Find ancestor of block at specified height and optionally return ancestor information\&. 
.SS "virtual bool findBlock (const \fBuint256\fP & hash, const \fBFoundBlock\fP & block = \fR{}\fP)\fR [pure virtual]\fP"
Return whether node has the block and optionally return block metadata or contents\&. 
.SS "virtual void findCoins (std::map< \fBCOutPoint\fP, \fBCoin\fP > & coins)\fR [pure virtual]\fP"
Look up unspent output information\&. Returns coins in the mempool and in the current chain UTXO set\&. Iterates through all the keys in the map and populates the values\&. 
.SS "virtual bool findCommonAncestor (const \fBuint256\fP & block_hash1, const \fBuint256\fP & block_hash2, const \fBFoundBlock\fP & ancestor_out = \fR{}\fP, const \fBFoundBlock\fP & block1_out = \fR{}\fP, const \fBFoundBlock\fP & block2_out = \fR{}\fP)\fR [pure virtual]\fP"
Find most recent common ancestor between two blocks and optionally return block information\&. 
.SS "virtual bool findFirstBlockWithTimeAndHeight (int64_t min_time, int min_height, const \fBFoundBlock\fP & block = \fR{}\fP)\fR [pure virtual]\fP"
Find first block in the chain with timestamp >= the given time and height >= than the given height, return false if there is no block with a high enough timestamp and height\&. Optionally return block information\&. 
.SS "virtual std::optional< int > findLocatorFork (const \fBCBlockLocator\fP & locator)\fR [pure virtual]\fP"
Return height of the highest block on chain in common with the locator, which will either be the original block used to create the locator, or one of its ancestors\&. 
.SS "virtual \fBuint256\fP getBlockHash (int height)\fR [pure virtual]\fP"

.PP
Get block hash\&. Height must be valid or this function will abort\&. 
.SS "virtual std::optional< int > getHeight ()\fR [pure virtual]\fP"
Get current chain height, not including genesis block (returns 0 if chain only contains genesis block, nullopt if chain does not contain any blocks) 
.SS "virtual void getPackageLimits (unsigned int & limit_ancestor_count, unsigned int & limit_descendant_count)\fR [pure virtual]\fP"
Get the node's package limits\&. Currently only returns the ancestor and descendant count limits, but could be enhanced to return more policy settings\&. 
.SS "virtual std::optional< int > getPruneHeight ()\fR [pure virtual]\fP"

.PP
Get the current prune height\&. 
.SS "virtual \fBcommon::SettingsValue\fP getRwSetting (const std::string & name)\fR [pure virtual]\fP"

.PP
Return <datadir>/settings\&.json setting value\&. 
.SS "virtual \fBcommon::SettingsValue\fP getSetting (const std::string & arg)\fR [pure virtual]\fP"

.PP
Get settings value\&. 
.SS "virtual std::vector< \fBcommon::SettingsValue\fP > getSettingsList (const std::string & arg)\fR [pure virtual]\fP"

.PP
Get list of settings values\&. 
.SS "virtual void getTransactionAncestry (const \fBTxid\fP & txid, size_t & ancestors, size_t & cluster_count, size_t * ancestorsize = \fRnullptr\fP, \fBCAmount\fP * ancestorfees = \fRnullptr\fP)\fR [pure virtual]\fP"

.PP
Calculate mempool ancestor and cluster counts for the given transaction\&. 
.SS "virtual double guessVerificationProgress (const \fBuint256\fP & block_hash)\fR [pure virtual]\fP"
Estimate fraction of total transactions verified if blocks up to the specified block hash are verified\&. 
.SS "virtual std::unique_ptr< \fBHandler\fP > handleNotifications (std::shared_ptr< \fBNotifications\fP > notifications)\fR [pure virtual]\fP"

.PP
Register handler for notifications\&. 
.SS "virtual std::unique_ptr< \fBHandler\fP > handleRpc (const \fBCRPCCommand\fP & command)\fR [pure virtual]\fP"
Register handler for RPC\&. Command is not copied, so reference needs to remain valid until \fBHandler\fP is disconnected\&. 
.SS "virtual bool hasAssumedValidChain ()\fR [pure virtual]\fP"
Return true if an assumed-valid snapshot is in use\&. Note that this returns true even after the snapshot is validated, until the next node restart\&. 
.SS "virtual bool hasBlockFilterIndex (\fBBlockFilterType\fP filter_type)\fR [pure virtual]\fP"

.PP
Returns whether a block filter index is available\&. 
.SS "virtual bool hasBlocks (const \fBuint256\fP & block_hash, int min_height = \fR0\fP, std::optional< int > max_height = \fR{}\fP)\fR [pure virtual]\fP"
Return true if data is available for all blocks in the specified range of blocks\&. This checks all blocks that are ancestors of block_hash in the height range from min_height to max_height, inclusive\&. 
.SS "virtual bool hasDescendantsInMempool (const \fBTxid\fP & txid)\fR [pure virtual]\fP"

.PP
Check if transaction has descendants in mempool\&. 
.SS "virtual bool haveBlockOnDisk (int height)\fR [pure virtual]\fP"
Check that the block is available on disk (i\&.e\&. has not been pruned), and contains transactions\&. 
.SS "virtual bool havePruned ()\fR [pure virtual]\fP"

.PP
Check if any block has been pruned\&. 
.SS "virtual void initError (const \fBbilingual_str\fP & message)\fR [pure virtual]\fP"

.PP
Send init error\&. 
.SS "virtual void initMessage (const std::string & message)\fR [pure virtual]\fP"

.PP
Send init message\&. 
.SS "virtual void initWarning (const \fBbilingual_str\fP & message)\fR [pure virtual]\fP"

.PP
Send init warning\&. 
.SS "virtual bool isInitialBlockDownload ()\fR [pure virtual]\fP"

.PP
Check if in IBD\&. 
.SS "virtual bool isInMempool (const \fBTxid\fP & txid)\fR [pure virtual]\fP"

.PP
Check if transaction is in mempool\&. 
.SS "virtual \fBRBFTransactionState\fP isRBFOptIn (const \fBCTransaction\fP & tx)\fR [pure virtual]\fP"

.PP
Check if transaction is RBF opt in\&. 
.SS "virtual bool isReadyToBroadcast ()\fR [pure virtual]\fP"

.PP
Check if the node is ready to broadcast transactions\&. 
.SS "virtual \fBCFeeRate\fP mempoolMinFee ()\fR [pure virtual]\fP"

.PP
Mempool minimum fee\&. 
.SS "virtual bool overwriteRwSetting (const std::string & name, \fBcommon::SettingsValue\fP value, \fBSettingsAction\fP action = \fR\fBSettingsAction::WRITE\fP\fP)\fR [pure virtual]\fP"
Replace a setting in <datadir>/settings\&.json with a new value\&. Null can be passed to erase the setting\&. This method provides a simpler alternative to updateRwSetting when atomically reading and updating the setting is not required\&. 
.SS "virtual \fBCFeeRate\fP relayDustFee ()\fR [pure virtual]\fP"

.PP
Relay dust fee setting (-dustrelayfee), reflecting lowest rate it's economical to spend\&. 
.SS "virtual \fBCFeeRate\fP relayIncrementalFee ()\fR [pure virtual]\fP"

.PP
Relay incremental fee setting (-incrementalrelayfee), reflecting cost of relay\&. 
.SS "virtual \fBCFeeRate\fP relayMinFee ()\fR [pure virtual]\fP"

.PP
Relay current minimum fee (from -minrelaytxfee and -incrementalrelayfee settings)\&. 
.SS "virtual void requestMempoolTransactions (\fBNotifications\fP & notifications)\fR [pure virtual]\fP"
Synchronously send transactionAddedToMempool notifications about all current mempool transactions to the specified handler and return after the last one is sent\&. These notifications aren't coordinated with async notifications sent by handleNotifications, so out of date async notifications from handleNotifications can arrive during and after synchronous notifications from requestMempoolTransactions\&. Clients need to be prepared to handle this by ignoring notifications about unknown removed transactions and already added new transactions\&. 
.SS "virtual bool rpcEnableDeprecated (const std::string & method)\fR [pure virtual]\fP"

.PP
Check if deprecated RPC is enabled\&. 
.SS "virtual void showProgress (const std::string & title, int progress, bool resume_possible)\fR [pure virtual]\fP"

.PP
Send progress indicator\&. 
.SS "virtual bool shutdownRequested ()\fR [pure virtual]\fP"

.PP
Check if shutdown requested\&. 
.SS "virtual bool updateRwSetting (const std::string & name, const \fBSettingsUpdate\fP & update_function)\fR [pure virtual]\fP"
Updates a setting in <datadir>/settings\&.json\&. Null can be passed to erase the setting\&. There is intentionally no support for writing null values to settings\&.json\&. Depending on the action returned by the update function, this will either update the setting in memory or write the updated settings to disk\&. 
.SS "virtual void waitForNotificationsIfTipChanged (const \fBuint256\fP & old_tip)\fR [pure virtual]\fP"
Wait for pending notifications to be processed unless block hash points to the current chain tip\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
