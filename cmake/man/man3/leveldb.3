.TH "leveldb" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
leveldb
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBconfig\fP"
.br
.ti -1c
.RI "namespace \fBlog\fP"
.br
.ti -1c
.RI "namespace \fBport\fP"
.br
.ti -1c
.RI "namespace \fBcrc32c\fP"
.br
.ti -1c
.RI "namespace \fBtest\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBBenchmark\fP"
.br
.ti -1c
.RI "class \fBAutoCompactTest\fP"
.br
.ti -1c
.RI "class \fBCorruptionTest\fP"
.br
.ti -1c
.RI "class \fBDBImpl\fP"
.br
.ti -1c
.RI "class \fBTestEnv\fP"
.br
.ti -1c
.RI "class \fBSpecialEnv\fP"
.br
.ti -1c
.RI "class \fBDBTest\fP"
.br
.ti -1c
.RI "class \fBModelDB\fP"
.br
.ti -1c
.RI "struct \fBParsedInternalKey\fP"
.br
.ti -1c
.RI "class \fBInternalKeyComparator\fP"
.br
.ti -1c
.RI "class \fBInternalFilterPolicy\fP"
.br
.ti -1c
.RI "class \fBInternalKey\fP"
.br
.ti -1c
.RI "class \fBLookupKey\fP"
.br
.ti -1c
.RI "class \fBFormatTest\fP"
.br
.ti -1c
.RI "class \fBTestWritableFile\fP"
.br
.ti -1c
.RI "class \fBFaultInjectionTestEnv\fP"
.br
.ti -1c
.RI "class \fBFaultInjectionTest\fP"
.br
.ti -1c
.RI "class \fBFileNameTest\fP"
.br
.ti -1c
.RI "class \fBMemTableIterator\fP"
.br
.ti -1c
.RI "class \fBMemTable\fP"
.br
.ti -1c
.RI "class \fBRecoveryTest\fP"
.br
.ti -1c
.RI "class \fBSkipList\fP"
.br
.ti -1c
.RI "class \fBComparator\fP"
.br
.ti -1c
.RI "class \fBSkipTest\fP"
.br
.ti -1c
.RI "class \fBConcurrentTest\fP"
.br
.ti -1c
.RI "class \fBTestState\fP"
.br
.ti -1c
.RI "class \fBSnapshotImpl\fP"
.br
.ti -1c
.RI "class \fBSnapshotList\fP"
.br
.ti -1c
.RI "struct \fBTableAndFile\fP"
.br
.ti -1c
.RI "class \fBTableCache\fP"
.br
.ti -1c
.RI "struct \fBFileMetaData\fP"
.br
.ti -1c
.RI "class \fBVersionEdit\fP"
.br
.ti -1c
.RI "class \fBVersionEditTest\fP"
.br
.ti -1c
.RI "class \fBVersion\fP"
.br
.ti -1c
.RI "class \fBVersionSet\fP"
.br
.ti -1c
.RI "class \fBCompaction\fP"
.br
.ti -1c
.RI "class \fBFindFileTest\fP"
.br
.ti -1c
.RI "class \fBAddBoundaryInputsTest\fP"
.br
.ti -1c
.RI "class \fBWriteBatchInternal\fP"
.br
.ti -1c
.RI "class \fBWriteBatchTest\fP"
.br
.ti -1c
.RI "class \fBMemEnvTest\fP"
.br
.ti -1c
.RI "class \fBCache\fP"
.br
.ti -1c
.RI "class \fBSnapshot\fP"
.br
.ti -1c
.RI "struct \fBRange\fP"
.br
.ti -1c
.RI "class \fBDB\fP"
.br
.ti -1c
.RI "class \fBEnv\fP"
.br
.ti -1c
.RI "class \fBSequentialFile\fP"
.br
.ti -1c
.RI "class \fBRandomAccessFile\fP"
.br
.ti -1c
.RI "class \fBWritableFile\fP"
.br
.ti -1c
.RI "class \fBLogger\fP"
.br
.ti -1c
.RI "class \fBFileLock\fP"
.br
.ti -1c
.RI "class \fBEnvWrapper\fP"
.br
.ti -1c
.RI "class \fBFilterPolicy\fP"
.br
.ti -1c
.RI "class \fBIterator\fP"
.br
.ti -1c
.RI "struct \fBOptions\fP"
.br
.ti -1c
.RI "struct \fBReadOptions\fP"
.br
.ti -1c
.RI "struct \fBWriteOptions\fP"
.br
.ti -1c
.RI "class \fBSlice\fP"
.br
.ti -1c
.RI "class \fBStatus\fP"
.br
.ti -1c
.RI "class \fBTable\fP"
.br
.ti -1c
.RI "class \fBTableBuilder\fP"
.br
.ti -1c
.RI "class \fBWriteBatch\fP"
.br
.ti -1c
.RI "class \fBIssue200\fP"
.br
.ti -1c
.RI "class \fBIssue320\fP"
.br
.ti -1c
.RI "class \fBBlock\fP"
.br
.ti -1c
.RI "class \fBBlockBuilder\fP"
.br
.ti -1c
.RI "class \fBFilterBlockBuilder\fP"
.br
.ti -1c
.RI "class \fBFilterBlockReader\fP"
.br
.ti -1c
.RI "class \fBTestHashFilter\fP"
.br
.ti -1c
.RI "class \fBFilterBlockTest\fP"
.br
.ti -1c
.RI "class \fBBlockHandle\fP"
.br
.ti -1c
.RI "class \fBFooter\fP"
.br
.ti -1c
.RI "struct \fBBlockContents\fP"
.br
.ti -1c
.RI "class \fBIteratorWrapper\fP"
.br
.ti -1c
.RI "class \fBStringSink\fP"
.br
.ti -1c
.RI "class \fBStringSource\fP"
.br
.ti -1c
.RI "class \fBConstructor\fP"
.br
.ti -1c
.RI "class \fBBlockConstructor\fP"
.br
.ti -1c
.RI "class \fBTableConstructor\fP"
.br
.ti -1c
.RI "class \fBKeyConvertingIterator\fP"
.br
.ti -1c
.RI "class \fBMemTableConstructor\fP"
.br
.ti -1c
.RI "class \fBDBConstructor\fP"
.br
.ti -1c
.RI "struct \fBTestArgs\fP"
.br
.ti -1c
.RI "class \fBHarness\fP"
.br
.ti -1c
.RI "class \fBMemTableTest\fP"
.br
.ti -1c
.RI "class \fBTableTest\fP"
.br
.ti -1c
.RI "class \fBArena\fP"
.br
.ti -1c
.RI "class \fBArenaTest\fP"
.br
.ti -1c
.RI "class \fBBloomTest\fP"
.br
.ti -1c
.RI "class \fBCacheTest\fP"
.br
.ti -1c
.RI "class \fBCoding\fP"
.br
.ti -1c
.RI "class \fBEnvPosixTest\fP"
.br
.ti -1c
.RI "class \fBEnvPosixTestHelper\fP"
.br
.ti -1c
.RI "class \fBEnvTest\fP"
.br
.ti -1c
.RI "struct \fBState\fP"
.br
.ti -1c
.RI "class \fBEnvWindowsTest\fP"
.br
.ti -1c
.RI "class \fBEnvWindowsTestHelper\fP"
.br
.ti -1c
.RI "class \fBHASH\fP"
.br
.ti -1c
.RI "class \fBHistogram\fP"
.br
.ti -1c
.RI "class \fBLogging\fP"
.br
.ti -1c
.RI "class \fBMutexLock\fP"
.br
.ti -1c
.RI "class \fBNoDestructor\fP"
.br
.ti -1c
.RI "class \fBNoDestructorTest\fP"
.br
.ti -1c
.RI "class \fBPosixLogger\fP"
.br
.ti -1c
.RI "class \fBRandom\fP"
.br
.ti -1c
.RI "class \fBWindowsLogger\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint64_t \fBSequenceNumber\fP"
.br
.ti -1c
.RI "typedef uint64_t \fBKey\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, std::string, STLLessThan > \fBKVMap\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBValueType\fP { \fBkTypeDeletion\fP = 0x0, \fBkTypeValue\fP = 0x1 }"
.br
.ti -1c
.RI "enum \fBFileType\fP { \fBkLogFile\fP, \fBkDBLockFile\fP, \fBkTableFile\fP, \fBkDescriptorFile\fP, \fBkCurrentFile\fP, \fBkTempFile\fP, \fBkInfoLogFile\fP }"
.br
.ti -1c
.RI "enum \fBTag\fP { \fBkComparator\fP = 1, \fBkLogNumber\fP = 2, \fBkNextFileNumber\fP = 3, \fBkLastSequence\fP = 4, \fBkCompactPointer\fP = 5, \fBkDeletedFile\fP = 6, \fBkNewFile\fP = 7, \fBkPrevLogNumber\fP = 9 }"
.br
.ti -1c
.RI "enum \fBCompressionType\fP { \fBkNoCompression\fP = 0x0, \fBkSnappyCompression\fP = 0x1 }"
.br
.ti -1c
.RI "enum \fBTestType\fP { \fBTABLE_TEST\fP, \fBBLOCK_TEST\fP, \fBMEMTABLE_TEST\fP, \fBDB_TEST\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBTEST\fP (\fBAutoCompactTest\fP, ReadAll)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAutoCompactTest\fP, ReadHalf)"
.br
.ti -1c
.RI "\fBStatus\fP \fBBuildTable\fP (const std::string &dbname, \fBEnv\fP *env, const \fBOptions\fP &options, \fBTableCache\fP *table_cache, \fBIterator\fP *iter, \fBFileMetaData\fP *meta)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, Recovery)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, RecoverWriteError)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, NewFileErrorDuringWrite)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, TableFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, TableFileRepair)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, TableFileIndexData)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, MissingDescriptor)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, SequenceNumberRecovery)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, CorruptedDescriptor)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, CompactionInputError)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, CompactionInputErrorParanoid)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCorruptionTest\fP, UnrelatedKeys)"
.br
.ti -1c
.RI "\fBOptions\fP \fBSanitizeOptions\fP (const std::string &dbname, const \fBInternalKeyComparator\fP *icmp, const \fBInternalFilterPolicy\fP *ipolicy, const \fBOptions\fP &src)"
.br
.ti -1c
.RI "\fBStatus\fP \fBDestroyDB\fP (const std::string &dbname, const \fBOptions\fP &options)"
.br
.ti -1c
.RI "\fBIterator\fP * \fBNewDBIterator\fP (\fBDBImpl\fP *db, const \fBComparator\fP *user_key_comparator, \fBIterator\fP *internal_iter, \fBSequenceNumber\fP \fBsequence\fP, uint32_t seed)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, Empty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, EmptyKey)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, EmptyValue)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, ReadWrite)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, PutDeleteGet)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetFromImmutableLayer)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetFromVersions)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetMemUsage)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetSnapshot)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetIdenticalSnapshots)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IterateOverEmptySnapshot)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetLevel0Ordering)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetOrderedByLevels)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetPicksCorrectFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, GetEncountersEmptyLevel)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IterEmpty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IterSingle)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IterMulti)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IterSmallAndLargeMix)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IterMultiWithDelete)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, Recover)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, RecoveryWithEmptyLog)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, RecoverDuringMemtableCompaction)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, MinorCompactionsHappen)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, RecoverWithLargeLog)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, CompactionsGenerateMultipleFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, RepeatedWritesToSameKey)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, SparseMerge)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, ApproximateSizes)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, ApproximateSizes_MixOfSmallAndLarge)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, IteratorPinsRef)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, \fBSnapshot\fP)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, HiddenValuesAreRemoved)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, DeletionMarkers1)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, DeletionMarkers2)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, OverlapInLevel0)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, L0_CompactionBug_Issue44_a)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, L0_CompactionBug_Issue44_b)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, Fflush_Issue474)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, ComparatorCheck)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, CustomComparator)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, ManualCompaction)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, DBOpen_Options)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, DestroyEmptyDir)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, DestroyOpenDB)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, Locking)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, NoSpace)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, NonWritableFileSystem)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, WriteSyncError)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, ManifestWriteError)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, MissingSSTFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, StillReadSST)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, FilesDeletedAfterCompaction)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, BloomFilter)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, MultiThreaded)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBDBTest\fP, Randomized)"
.br
.ti -1c
.RI "std::string \fBMakeKey\fP (unsigned int num)"
.br
.ti -1c
.RI "void \fBBM_LogAndApply\fP (int iters, int num_base_files)"
.br
.ti -1c
.RI "void \fBAppendInternalKey\fP (std::string *result, const \fBParsedInternalKey\fP &key)"
.br
.ti -1c
.RI "size_t \fBInternalKeyEncodingLength\fP (const \fBParsedInternalKey\fP &key)"
.br
.ti -1c
.RI "bool \fBParseInternalKey\fP (const \fBSlice\fP &internal_key, \fBParsedInternalKey\fP *result)"
.br
.ti -1c
.RI "\fBSlice\fP \fBExtractUserKey\fP (const \fBSlice\fP &internal_key)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFormatTest\fP, InternalKey_EncodeDecode)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFormatTest\fP, InternalKey_DecodeFromEmpty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFormatTest\fP, InternalKeyShortSeparator)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFormatTest\fP, InternalKeyShortestSuccessor)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFormatTest\fP, ParsedInternalKeyDebugString)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFormatTest\fP, InternalKeyDebugString)"
.br
.ti -1c
.RI "\fBStatus\fP \fBDumpFile\fP (\fBEnv\fP *env, const std::string &fname, \fBWritableFile\fP *dst)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFaultInjectionTest\fP, FaultTestNoLogReuse)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFaultInjectionTest\fP, FaultTestWithLogReuse)"
.br
.ti -1c
.RI "\fBStatus\fP \fBWriteStringToFileSync\fP (\fBEnv\fP *env, const \fBSlice\fP &data, const std::string &fname)"
.br
.ti -1c
.RI "std::string \fBLogFileName\fP (const std::string &dbname, uint64_t number)"
.br
.ti -1c
.RI "std::string \fBTableFileName\fP (const std::string &dbname, uint64_t number)"
.br
.ti -1c
.RI "std::string \fBSSTTableFileName\fP (const std::string &dbname, uint64_t number)"
.br
.ti -1c
.RI "std::string \fBDescriptorFileName\fP (const std::string &dbname, uint64_t number)"
.br
.ti -1c
.RI "std::string \fBCurrentFileName\fP (const std::string &dbname)"
.br
.ti -1c
.RI "std::string \fBLockFileName\fP (const std::string &dbname)"
.br
.ti -1c
.RI "std::string \fBTempFileName\fP (const std::string &dbname, uint64_t number)"
.br
.ti -1c
.RI "std::string \fBInfoLogFileName\fP (const std::string &dbname)"
.br
.ti -1c
.RI "std::string \fBOldInfoLogFileName\fP (const std::string &dbname)"
.br
.ti -1c
.RI "bool \fBParseFileName\fP (const std::string &filename, uint64_t *number, \fBFileType\fP *type)"
.br
.ti -1c
.RI "\fBStatus\fP \fBSetCurrentFile\fP (\fBEnv\fP *env, const std::string &dbname, uint64_t descriptor_number)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFileNameTest\fP, Parse)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFileNameTest\fP, Construction)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, ManifestReused)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, LargeManifestCompacted)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, NoLogFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, LogFileReuse)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, MultipleMemTables)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, MultipleLogFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBRecoveryTest\fP, ManifestMissing)"
.br
.ti -1c
.RI "\fBStatus\fP \fBRepairDB\fP (const std::string &dbname, const \fBOptions\fP &options)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, Empty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, InsertAndLookup)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, ConcurrentWithoutThreads)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, Concurrent1)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, Concurrent2)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, Concurrent3)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, Concurrent4)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBSkipTest\fP, Concurrent5)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBVersionEditTest\fP, EncodeDecode)"
.br
.ti -1c
.RI "int \fBFindFile\fP (const \fBInternalKeyComparator\fP &icmp, const std::vector< \fBFileMetaData\fP * > &files, const \fBSlice\fP &key)"
.br
.ti -1c
.RI "bool \fBSomeFileOverlapsRange\fP (const \fBInternalKeyComparator\fP &icmp, bool disjoint_sorted_files, const std::vector< \fBFileMetaData\fP * > &files, const \fBSlice\fP *smallest_user_key, const \fBSlice\fP *largest_user_key)"
.br
.ti -1c
.RI "bool \fBFindLargestKey\fP (const \fBInternalKeyComparator\fP &icmp, const std::vector< \fBFileMetaData\fP * > &files, \fBInternalKey\fP *largest_key)"
.br
.ti -1c
.RI "\fBFileMetaData\fP * \fBFindSmallestBoundaryFile\fP (const \fBInternalKeyComparator\fP &icmp, const std::vector< \fBFileMetaData\fP * > &level_files, const \fBInternalKey\fP &largest_key)"
.br
.ti -1c
.RI "void \fBAddBoundaryInputs\fP (const \fBInternalKeyComparator\fP &icmp, const std::vector< \fBFileMetaData\fP * > &level_files, std::vector< \fBFileMetaData\fP * > *compaction_files)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFindFileTest\fP, Empty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFindFileTest\fP, Single)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFindFileTest\fP, Multiple)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFindFileTest\fP, MultipleNullBoundaries)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFindFileTest\fP, OverlapSequenceChecks)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFindFileTest\fP, OverlappingFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestEmptyFileSets)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestEmptyLevelFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestEmptyCompactionFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestNoBoundaryFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestOneBoundaryFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestTwoBoundaryFiles)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBAddBoundaryInputsTest\fP, TestDisjoinFilePointers)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBWriteBatchTest\fP, Empty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBWriteBatchTest\fP, Multiple)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBWriteBatchTest\fP, Corruption)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBWriteBatchTest\fP, Append)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBWriteBatchTest\fP, ApproximateSize)"
.br
.ti -1c
.RI "\fBEnv\fP * \fBNewMemEnv\fP (\fBEnv\fP *base_env)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, Basics)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, ReadWrite)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, Locks)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, Misc)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, LargeWrite)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, OverwriteOpenFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemEnvTest\fP, \fBDBTest\fP)"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP \fBCache\fP * \fBNewLRUCache\fP (size_t capacity)"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP const \fBComparator\fP * \fBBytewiseComparator\fP ()"
.br
.ti -1c
.RI "void \fBLog\fP (\fBLogger\fP *info_log, const char *format,\&.\&.\&.)"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP \fBStatus\fP \fBWriteStringToFile\fP (\fBEnv\fP *env, const \fBSlice\fP &data, const std::string &fname)"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP \fBStatus\fP \fBReadFileToString\fP (\fBEnv\fP *env, const std::string &fname, std::string *data)"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP const \fBFilterPolicy\fP * \fBNewBloomFilterPolicy\fP (int bits_per_key)"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP \fBIterator\fP * \fBNewEmptyIterator\fP ()"
.br
.ti -1c
.RI "\fBLEVELDB_EXPORT\fP \fBIterator\fP * \fBNewErrorIterator\fP (const \fBStatus\fP &status)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBSlice\fP &x, const \fBSlice\fP &y)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBSlice\fP &x, const \fBSlice\fP &y)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBIssue200\fP, Test)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBIssue320\fP, Test)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFilterBlockTest\fP, EmptyBuilder)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFilterBlockTest\fP, SingleChunk)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBFilterBlockTest\fP, MultiChunk)"
.br
.ti -1c
.RI "\fBStatus\fP \fBReadBlock\fP (\fBRandomAccessFile\fP *file, const \fBReadOptions\fP &options, const \fBBlockHandle\fP &handle, \fBBlockContents\fP *result)"
.br
.ti -1c
.RI "\fBIterator\fP * \fBNewMergingIterator\fP (const \fBComparator\fP *comparator, \fBIterator\fP **children, int n)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, Empty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, ZeroRestartPointsInBlock)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, SimpleEmptyKey)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, SimpleSingle)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, SimpleMulti)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, SimpleSpecialKey)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, Randomized)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHarness\fP, RandomizedLongDB)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBMemTableTest\fP, Simple)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBTableTest\fP, ApproximateOffsetOfPlain)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBTableTest\fP, ApproximateOffsetOfCompressed)"
.br
.ti -1c
.RI "\fBIterator\fP * \fBNewTwoLevelIterator\fP (\fBIterator\fP *index_iter, BlockFunction block_function, void *arg, const \fBReadOptions\fP &options)"
.br
.ti -1c
.RI "\fBIterator\fP * \fBNewTwoLevelIterator\fP (\fBIterator\fP *index_iter, \fBIterator\fP *(*block_function)(void *arg, const \fBReadOptions\fP &options, const \fBSlice\fP &index_value), void *arg, const \fBReadOptions\fP &options)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBArenaTest\fP, Empty)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBArenaTest\fP, Simple)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBBloomTest\fP, EmptyFilter)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBBloomTest\fP, Small)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBBloomTest\fP, VaryingLengths)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, HitAndMiss)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, Erase)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, EntriesArePinned)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, EvictionPolicy)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, UseExceedsCacheSize)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, HeavyEntries)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, NewId)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, Prune)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCacheTest\fP, ZeroSizeCache)"
.br
.ti -1c
.RI "void \fBPutFixed32\fP (std::string *dst, uint32_t value)"
.br
.ti -1c
.RI "void \fBPutFixed64\fP (std::string *dst, uint64_t value)"
.br
.ti -1c
.RI "char * \fBEncodeVarint32\fP (char *dst, uint32_t v)"
.br
.ti -1c
.RI "void \fBPutVarint32\fP (std::string *dst, uint32_t v)"
.br
.ti -1c
.RI "char * \fBEncodeVarint64\fP (char *dst, uint64_t v)"
.br
.ti -1c
.RI "void \fBPutVarint64\fP (std::string *dst, uint64_t v)"
.br
.ti -1c
.RI "void \fBPutLengthPrefixedSlice\fP (std::string *dst, const \fBSlice\fP &value)"
.br
.ti -1c
.RI "int \fBVarintLength\fP (uint64_t v)"
.br
.ti -1c
.RI "const char * \fBGetVarint32PtrFallback\fP (const char *p, const char *limit, uint32_t *value)"
.br
.ti -1c
.RI "bool \fBGetVarint32\fP (\fBSlice\fP *input, uint32_t *value)"
.br
.ti -1c
.RI "const char * \fBGetVarint64Ptr\fP (const char *p, const char *limit, uint64_t *value)"
.br
.ti -1c
.RI "bool \fBGetVarint64\fP (\fBSlice\fP *input, uint64_t *value)"
.br
.ti -1c
.RI "const char * \fBGetLengthPrefixedSlice\fP (const char *p, const char *limit, \fBSlice\fP *result)"
.br
.ti -1c
.RI "bool \fBGetLengthPrefixedSlice\fP (\fBSlice\fP *input, \fBSlice\fP *result)"
.br
.ti -1c
.RI "const char * \fBGetVarint32Ptr\fP (const char *p, const char *limit, uint32_t *v)"
.br
.ti -1c
.RI "void \fBEncodeFixed32\fP (char *dst, uint32_t value)"
.br
.ti -1c
.RI "void \fBEncodeFixed64\fP (char *dst, uint64_t value)"
.br
.ti -1c
.RI "uint32_t \fBDecodeFixed32\fP (const char *ptr)"
.br
.ti -1c
.RI "uint64_t \fBDecodeFixed64\fP (const char *ptr)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Fixed32)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Fixed64)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, EncodingOutput)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Varint32)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Varint64)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Varint32Overflow)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Varint32Truncation)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Varint64Overflow)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Varint64Truncation)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBCoding\fP, Strings)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvPosixTest\fP, TestOpenOnRead)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, ReadWrite)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, RunImmediately)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, RunMany)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, StartThread)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, TestOpenNonExistentFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, ReopenWritableFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvTest\fP, ReopenAppendableFile)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBEnvWindowsTest\fP, TestOpenOnRead)"
.br
.ti -1c
.RI "uint32_t \fBHash\fP (const char *data, size_t n, uint32_t seed)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBHASH\fP, SignedUnsignedIssue)"
.br
.ti -1c
.RI "void \fBAppendNumberTo\fP (std::string *str, uint64_t num)"
.br
.ti -1c
.RI "void \fBAppendEscapedStringTo\fP (std::string *str, const \fBSlice\fP &value)"
.br
.ti -1c
.RI "std::string \fBNumberToString\fP (uint64_t num)"
.br
.ti -1c
.RI "std::string \fBEscapeString\fP (const \fBSlice\fP &value)"
.br
.ti -1c
.RI "bool \fBConsumeDecimalNumber\fP (\fBSlice\fP *in, uint64_t *val)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBLogging\fP, \fBNumberToString\fP)"
.br
.ti -1c
.RI "void \fBConsumeDecimalNumberRoundtripTest\fP (uint64_t number, const std::string &padding='')"
.br
.ti -1c
.RI "\fBTEST\fP (\fBLogging\fP, ConsumeDecimalNumberRoundtrip)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBLogging\fP, ConsumeDecimalNumberRoundtripWithPadding)"
.br
.ti -1c
.RI "void \fBConsumeDecimalNumberOverflowTest\fP (const std::string &input_string)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBLogging\fP, ConsumeDecimalNumberOverflow)"
.br
.ti -1c
.RI "void \fBConsumeDecimalNumberNoDigitsTest\fP (const std::string &input_string)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBLogging\fP, ConsumeDecimalNumberNoDigits)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBNoDestructorTest\fP, StackInstance)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBNoDestructorTest\fP, StaticInstance)"
.br
.ti -1c
.RI "\fBTEST\fP (\fBStatus\fP, MoveConstructor)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const int \fBkNumNonTableCacheFiles\fP = 10"
.br
.ti -1c
.RI "class \fBLEVELDB_EXPORT\fP \fBCache\fP"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef uint64_t \fBKey\fP"

.SS "typedef std::map<std::string, std::string, STLLessThan> \fBKVMap\fP"

.SS "typedef uint64_t \fBSequenceNumber\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBCompressionType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIkNoCompression \fP
.TP
\f(BIkSnappyCompression \fP
.SS "enum \fBFileType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIkLogFile \fP
.TP
\f(BIkDBLockFile \fP
.TP
\f(BIkTableFile \fP
.TP
\f(BIkDescriptorFile \fP
.TP
\f(BIkCurrentFile \fP
.TP
\f(BIkTempFile \fP
.TP
\f(BIkInfoLogFile \fP
.SS "enum \fBTag\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIkComparator \fP
.TP
\f(BIkLogNumber \fP
.TP
\f(BIkNextFileNumber \fP
.TP
\f(BIkLastSequence \fP
.TP
\f(BIkCompactPointer \fP
.TP
\f(BIkDeletedFile \fP
.TP
\f(BIkNewFile \fP
.TP
\f(BIkPrevLogNumber \fP
.SS "enum \fBTestType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BITABLE_TEST \fP
.TP
\f(BIBLOCK_TEST \fP
.TP
\f(BIMEMTABLE_TEST \fP
.TP
\f(BIDB_TEST \fP
.SS "enum \fBValueType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIkTypeDeletion \fP
.TP
\f(BIkTypeValue \fP
.SH "Function Documentation"
.PP 
.SS "void AddBoundaryInputs (const \fBInternalKeyComparator\fP & icmp, const std::vector< \fBFileMetaData\fP * > & level_files, std::vector< \fBFileMetaData\fP * > * compaction_files)"

.SS "void AppendEscapedStringTo (std::string * str, const \fBSlice\fP & value)"

.SS "void AppendInternalKey (std::string * result, const \fBParsedInternalKey\fP & key)"

.SS "void AppendNumberTo (std::string * str, uint64_t num)"

.SS "void BM_LogAndApply (int iters, int num_base_files)"

.SS "\fBStatus\fP BuildTable (const std::string & dbname, \fBEnv\fP * env, const \fBOptions\fP & options, \fBTableCache\fP * table_cache, \fBIterator\fP * iter, \fBFileMetaData\fP * meta)"

.SS "const \fBComparator\fP * BytewiseComparator ()"

.SS "bool ConsumeDecimalNumber (\fBSlice\fP * in, uint64_t * val)"

.SS "void ConsumeDecimalNumberNoDigitsTest (const std::string & input_string)"

.SS "void ConsumeDecimalNumberOverflowTest (const std::string & input_string)"

.SS "void ConsumeDecimalNumberRoundtripTest (uint64_t number, const std::string & padding = \fR''\fP)"

.SS "std::string CurrentFileName (const std::string & dbname)"

.SS "uint32_t DecodeFixed32 (const char * ptr)\fR [inline]\fP"

.SS "uint64_t DecodeFixed64 (const char * ptr)\fR [inline]\fP"

.SS "std::string DescriptorFileName (const std::string & dbname, uint64_t number)"

.SS "\fBLEVELDB_EXPORT\fP \fBStatus\fP DestroyDB (const std::string & dbname, const \fBOptions\fP & options)"

.SS "\fBLEVELDB_EXPORT\fP \fBStatus\fP DumpFile (\fBEnv\fP * env, const std::string & fname, \fBWritableFile\fP * dst)"

.SS "void EncodeFixed32 (char * dst, uint32_t value)\fR [inline]\fP"

.SS "void EncodeFixed64 (char * dst, uint64_t value)\fR [inline]\fP"

.SS "char * EncodeVarint32 (char * dst, uint32_t v)"

.SS "char * EncodeVarint64 (char * dst, uint64_t v)"

.SS "std::string EscapeString (const \fBSlice\fP & value)"

.SS "\fBSlice\fP ExtractUserKey (const \fBSlice\fP & internal_key)\fR [inline]\fP"

.SS "int FindFile (const \fBInternalKeyComparator\fP & icmp, const std::vector< \fBFileMetaData\fP * > & files, const \fBSlice\fP & key)"

.SS "bool FindLargestKey (const \fBInternalKeyComparator\fP & icmp, const std::vector< \fBFileMetaData\fP * > & files, \fBInternalKey\fP * largest_key)"

.SS "\fBFileMetaData\fP * FindSmallestBoundaryFile (const \fBInternalKeyComparator\fP & icmp, const std::vector< \fBFileMetaData\fP * > & level_files, const \fBInternalKey\fP & largest_key)"

.SS "const char * GetLengthPrefixedSlice (const char * p, const char * limit, \fBSlice\fP * result)"

.SS "bool GetLengthPrefixedSlice (\fBSlice\fP * input, \fBSlice\fP * result)"

.SS "bool GetVarint32 (\fBSlice\fP * input, uint32_t * value)"

.SS "const char * GetVarint32Ptr (const char * p, const char * limit, uint32_t * v)\fR [inline]\fP"

.SS "const char * GetVarint32PtrFallback (const char * p, const char * limit, uint32_t * value)"

.SS "bool GetVarint64 (\fBSlice\fP * input, uint64_t * value)"

.SS "const char * GetVarint64Ptr (const char * p, const char * limit, uint64_t * value)"

.SS "uint32_t Hash (const char * data, size_t n, uint32_t seed)"

.SS "std::string InfoLogFileName (const std::string & dbname)"

.SS "size_t InternalKeyEncodingLength (const \fBParsedInternalKey\fP & key)\fR [inline]\fP"

.SS "std::string LockFileName (const std::string & dbname)"

.SS "void Log (\fBLogger\fP * info_log, const char * format,  \&.\&.\&.)"

.SS "std::string LogFileName (const std::string & dbname, uint64_t number)"

.SS "std::string MakeKey (unsigned int num)"

.SS "const \fBFilterPolicy\fP * NewBloomFilterPolicy (int bits_per_key)"

.SS "\fBIterator\fP * NewDBIterator (\fBDBImpl\fP * db, const \fBComparator\fP * user_key_comparator, \fBIterator\fP * internal_iter, \fBSequenceNumber\fP sequence, uint32_t seed)"

.SS "\fBIterator\fP * NewEmptyIterator ()"

.SS "\fBIterator\fP * NewErrorIterator (const \fBStatus\fP & status)"

.SS "\fBCache\fP * NewLRUCache (size_t capacity)"

.SS "\fBLEVELDB_EXPORT\fP \fBEnv\fP * NewMemEnv (\fBEnv\fP * base_env)"

.SS "\fBIterator\fP * NewMergingIterator (const \fBComparator\fP * comparator, \fBIterator\fP ** children, int n)"

.SS "\fBIterator\fP * NewTwoLevelIterator (\fBIterator\fP * index_iter, BlockFunction block_function, void * arg, const \fBReadOptions\fP & options)"

.SS "\fBIterator\fP * NewTwoLevelIterator (\fBIterator\fP * index_iter, \fBIterator\fP *(* block_function )(void *arg, const \fBReadOptions\fP &options, const \fBSlice\fP &index_value), void * arg, const \fBReadOptions\fP & options)"

.SS "std::string NumberToString (uint64_t num)"

.SS "std::string OldInfoLogFileName (const std::string & dbname)"

.SS "bool operator!= (const \fBSlice\fP & x, const \fBSlice\fP & y)\fR [inline]\fP"

.SS "bool operator== (const \fBSlice\fP & x, const \fBSlice\fP & y)\fR [inline]\fP"

.SS "bool ParseFileName (const std::string & filename, uint64_t * number, \fBFileType\fP * type)"

.SS "bool ParseInternalKey (const \fBSlice\fP & internal_key, \fBParsedInternalKey\fP * result)\fR [inline]\fP"

.SS "void PutFixed32 (std::string * dst, uint32_t value)"

.SS "void PutFixed64 (std::string * dst, uint64_t value)"

.SS "void PutLengthPrefixedSlice (std::string * dst, const \fBSlice\fP & value)"

.SS "void PutVarint32 (std::string * dst, uint32_t v)"

.SS "void PutVarint64 (std::string * dst, uint64_t v)"

.SS "\fBStatus\fP ReadBlock (\fBRandomAccessFile\fP * file, const \fBReadOptions\fP & options, const \fBBlockHandle\fP & handle, \fBBlockContents\fP * result)"

.SS "\fBStatus\fP ReadFileToString (\fBEnv\fP * env, const std::string & fname, std::string * data)"

.SS "\fBLEVELDB_EXPORT\fP \fBStatus\fP RepairDB (const std::string & dbname, const \fBOptions\fP & options)"

.SS "\fBOptions\fP SanitizeOptions (const std::string & dbname, const \fBInternalKeyComparator\fP * icmp, const \fBInternalFilterPolicy\fP * ipolicy, const \fBOptions\fP & src)"

.SS "\fBStatus\fP SetCurrentFile (\fBEnv\fP * env, const std::string & dbname, uint64_t descriptor_number)"

.SS "bool SomeFileOverlapsRange (const \fBInternalKeyComparator\fP & icmp, bool disjoint_sorted_files, const std::vector< \fBFileMetaData\fP * > & files, const \fBSlice\fP * smallest_user_key, const \fBSlice\fP * largest_user_key)"

.SS "std::string SSTTableFileName (const std::string & dbname, uint64_t number)"

.SS "std::string TableFileName (const std::string & dbname, uint64_t number)"

.SS "std::string TempFileName (const std::string & dbname, uint64_t number)"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestDisjoinFilePointers )"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestEmptyCompactionFiles )"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestEmptyFileSets )"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestEmptyLevelFiles )"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestNoBoundaryFiles )"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestOneBoundaryFiles )"

.SS "TEST (\fBAddBoundaryInputsTest\fP , TestTwoBoundaryFiles )"

.SS "TEST (\fBArenaTest\fP , Empty )"

.SS "TEST (\fBArenaTest\fP , Simple )"

.SS "TEST (\fBAutoCompactTest\fP , ReadAll )"

.SS "TEST (\fBAutoCompactTest\fP , ReadHalf )"

.SS "TEST (\fBBloomTest\fP , EmptyFilter )"

.SS "TEST (\fBBloomTest\fP , Small )"

.SS "TEST (\fBBloomTest\fP , VaryingLengths )"

.SS "TEST (\fBCacheTest\fP , EntriesArePinned )"

.SS "TEST (\fBCacheTest\fP , Erase )"

.SS "TEST (\fBCacheTest\fP , EvictionPolicy )"

.SS "TEST (\fBCacheTest\fP , HeavyEntries )"

.SS "TEST (\fBCacheTest\fP , HitAndMiss )"

.SS "TEST (\fBCacheTest\fP , NewId )"

.SS "TEST (\fBCacheTest\fP , Prune )"

.SS "TEST (\fBCacheTest\fP , UseExceedsCacheSize )"

.SS "TEST (\fBCacheTest\fP , ZeroSizeCache )"

.SS "TEST (\fBCoding\fP , EncodingOutput )"

.SS "TEST (\fBCoding\fP , Fixed32 )"

.SS "TEST (\fBCoding\fP , Fixed64 )"

.SS "TEST (\fBCoding\fP , Strings )"

.SS "TEST (\fBCoding\fP , Varint32 )"

.SS "TEST (\fBCoding\fP , Varint32Overflow )"

.SS "TEST (\fBCoding\fP , Varint32Truncation )"

.SS "TEST (\fBCoding\fP , Varint64 )"

.SS "TEST (\fBCoding\fP , Varint64Overflow )"

.SS "TEST (\fBCoding\fP , Varint64Truncation )"

.SS "TEST (\fBCorruptionTest\fP , CompactionInputError )"

.SS "TEST (\fBCorruptionTest\fP , CompactionInputErrorParanoid )"

.SS "TEST (\fBCorruptionTest\fP , CorruptedDescriptor )"

.SS "TEST (\fBCorruptionTest\fP , MissingDescriptor )"

.SS "TEST (\fBCorruptionTest\fP , NewFileErrorDuringWrite )"

.SS "TEST (\fBCorruptionTest\fP , RecoverWriteError )"

.SS "TEST (\fBCorruptionTest\fP , Recovery )"

.SS "TEST (\fBCorruptionTest\fP , SequenceNumberRecovery )"

.SS "TEST (\fBCorruptionTest\fP , TableFile )"

.SS "TEST (\fBCorruptionTest\fP , TableFileIndexData )"

.SS "TEST (\fBCorruptionTest\fP , TableFileRepair )"

.SS "TEST (\fBCorruptionTest\fP , UnrelatedKeys )"

.SS "TEST (\fBDBTest\fP , ApproximateSizes )"

.SS "TEST (\fBDBTest\fP , ApproximateSizes_MixOfSmallAndLarge )"

.SS "TEST (\fBDBTest\fP , BloomFilter )"

.SS "TEST (\fBDBTest\fP , CompactionsGenerateMultipleFiles )"

.SS "TEST (\fBDBTest\fP , ComparatorCheck )"

.SS "TEST (\fBDBTest\fP , CustomComparator )"

.SS "TEST (\fBDBTest\fP , DBOpen_Options )"

.SS "TEST (\fBDBTest\fP , DeletionMarkers1 )"

.SS "TEST (\fBDBTest\fP , DeletionMarkers2 )"

.SS "TEST (\fBDBTest\fP , DestroyEmptyDir )"

.SS "TEST (\fBDBTest\fP , DestroyOpenDB )"

.SS "TEST (\fBDBTest\fP , Empty )"

.SS "TEST (\fBDBTest\fP , EmptyKey )"

.SS "TEST (\fBDBTest\fP , EmptyValue )"

.SS "TEST (\fBDBTest\fP , Fflush_Issue474 )"

.SS "TEST (\fBDBTest\fP , FilesDeletedAfterCompaction )"

.SS "TEST (\fBDBTest\fP , GetEncountersEmptyLevel )"

.SS "TEST (\fBDBTest\fP , GetFromImmutableLayer )"

.SS "TEST (\fBDBTest\fP , GetFromVersions )"

.SS "TEST (\fBDBTest\fP , GetIdenticalSnapshots )"

.SS "TEST (\fBDBTest\fP , GetLevel0Ordering )"

.SS "TEST (\fBDBTest\fP , GetMemUsage )"

.SS "TEST (\fBDBTest\fP , GetOrderedByLevels )"

.SS "TEST (\fBDBTest\fP , GetPicksCorrectFile )"

.SS "TEST (\fBDBTest\fP , GetSnapshot )"

.SS "TEST (\fBDBTest\fP , HiddenValuesAreRemoved )"

.SS "TEST (\fBDBTest\fP , IterateOverEmptySnapshot )"

.SS "TEST (\fBDBTest\fP , IteratorPinsRef )"

.SS "TEST (\fBDBTest\fP , IterEmpty )"

.SS "TEST (\fBDBTest\fP , IterMulti )"

.SS "TEST (\fBDBTest\fP , IterMultiWithDelete )"

.SS "TEST (\fBDBTest\fP , IterSingle )"

.SS "TEST (\fBDBTest\fP , IterSmallAndLargeMix )"

.SS "TEST (\fBDBTest\fP , L0_CompactionBug_Issue44_a )"

.SS "TEST (\fBDBTest\fP , L0_CompactionBug_Issue44_b )"

.SS "TEST (\fBDBTest\fP , Locking )"

.SS "TEST (\fBDBTest\fP , ManifestWriteError )"

.SS "TEST (\fBDBTest\fP , ManualCompaction )"

.SS "TEST (\fBDBTest\fP , MinorCompactionsHappen )"

.SS "TEST (\fBDBTest\fP , MissingSSTFile )"

.SS "TEST (\fBDBTest\fP , MultiThreaded )"

.SS "TEST (\fBDBTest\fP , NonWritableFileSystem )"

.SS "TEST (\fBDBTest\fP , NoSpace )"

.SS "TEST (\fBDBTest\fP , OverlapInLevel0 )"

.SS "TEST (\fBDBTest\fP , PutDeleteGet )"

.SS "TEST (\fBDBTest\fP , Randomized )"

.SS "TEST (\fBDBTest\fP , ReadWrite )"

.SS "TEST (\fBDBTest\fP , Recover )"

.SS "TEST (\fBDBTest\fP , RecoverDuringMemtableCompaction )"

.SS "TEST (\fBDBTest\fP , RecoverWithLargeLog )"

.SS "TEST (\fBDBTest\fP , RecoveryWithEmptyLog )"

.SS "TEST (\fBDBTest\fP , RepeatedWritesToSameKey )"

.SS "TEST (\fBDBTest\fP , \fBSnapshot\fP )"

.SS "TEST (\fBDBTest\fP , SparseMerge )"

.SS "TEST (\fBDBTest\fP , StillReadSST )"

.SS "TEST (\fBDBTest\fP , WriteSyncError )"

.SS "TEST (\fBEnvPosixTest\fP , TestOpenOnRead )"

.SS "TEST (\fBEnvTest\fP , ReadWrite )"

.SS "TEST (\fBEnvTest\fP , ReopenAppendableFile )"

.SS "TEST (\fBEnvTest\fP , ReopenWritableFile )"

.SS "TEST (\fBEnvTest\fP , RunImmediately )"

.SS "TEST (\fBEnvTest\fP , RunMany )"

.SS "TEST (\fBEnvTest\fP , StartThread )"

.SS "TEST (\fBEnvTest\fP , TestOpenNonExistentFile )"

.SS "TEST (\fBEnvWindowsTest\fP , TestOpenOnRead )"

.SS "TEST (\fBFaultInjectionTest\fP , FaultTestNoLogReuse )"

.SS "TEST (\fBFaultInjectionTest\fP , FaultTestWithLogReuse )"

.SS "TEST (\fBFileNameTest\fP , Construction )"

.SS "TEST (\fBFileNameTest\fP , Parse )"

.SS "TEST (\fBFilterBlockTest\fP , EmptyBuilder )"

.SS "TEST (\fBFilterBlockTest\fP , MultiChunk )"

.SS "TEST (\fBFilterBlockTest\fP , SingleChunk )"

.SS "TEST (\fBFindFileTest\fP , Empty )"

.SS "TEST (\fBFindFileTest\fP , Multiple )"

.SS "TEST (\fBFindFileTest\fP , MultipleNullBoundaries )"

.SS "TEST (\fBFindFileTest\fP , OverlappingFiles )"

.SS "TEST (\fBFindFileTest\fP , OverlapSequenceChecks )"

.SS "TEST (\fBFindFileTest\fP , Single )"

.SS "TEST (\fBFormatTest\fP , InternalKey_DecodeFromEmpty )"

.SS "TEST (\fBFormatTest\fP , InternalKey_EncodeDecode )"

.SS "TEST (\fBFormatTest\fP , InternalKeyDebugString )"

.SS "TEST (\fBFormatTest\fP , InternalKeyShortestSuccessor )"

.SS "TEST (\fBFormatTest\fP , InternalKeyShortSeparator )"

.SS "TEST (\fBFormatTest\fP , ParsedInternalKeyDebugString )"

.SS "TEST (\fBHarness\fP , Empty )"

.SS "TEST (\fBHarness\fP , Randomized )"

.SS "TEST (\fBHarness\fP , RandomizedLongDB )"

.SS "TEST (\fBHarness\fP , SimpleEmptyKey )"

.SS "TEST (\fBHarness\fP , SimpleMulti )"

.SS "TEST (\fBHarness\fP , SimpleSingle )"

.SS "TEST (\fBHarness\fP , SimpleSpecialKey )"

.SS "TEST (\fBHarness\fP , ZeroRestartPointsInBlock )"

.SS "TEST (\fBHASH\fP , SignedUnsignedIssue )"

.SS "TEST (\fBIssue200\fP , Test )"

.SS "TEST (\fBIssue320\fP , Test )"

.SS "TEST (\fBLogging\fP , ConsumeDecimalNumberNoDigits )"

.SS "TEST (\fBLogging\fP , ConsumeDecimalNumberOverflow )"

.SS "TEST (\fBLogging\fP , ConsumeDecimalNumberRoundtrip )"

.SS "TEST (\fBLogging\fP , ConsumeDecimalNumberRoundtripWithPadding )"

.SS "TEST (\fBLogging\fP , \fBNumberToString\fP )"

.SS "TEST (\fBMemEnvTest\fP , Basics )"

.SS "TEST (\fBMemEnvTest\fP , \fBDBTest\fP )"

.SS "TEST (\fBMemEnvTest\fP , LargeWrite )"

.SS "TEST (\fBMemEnvTest\fP , Locks )"

.SS "TEST (\fBMemEnvTest\fP , Misc )"

.SS "TEST (\fBMemEnvTest\fP , OverwriteOpenFile )"

.SS "TEST (\fBMemEnvTest\fP , ReadWrite )"

.SS "TEST (\fBMemTableTest\fP , Simple )"

.SS "TEST (\fBNoDestructorTest\fP , StackInstance )"

.SS "TEST (\fBNoDestructorTest\fP , StaticInstance )"

.SS "TEST (\fBRecoveryTest\fP , LargeManifestCompacted )"

.SS "TEST (\fBRecoveryTest\fP , LogFileReuse )"

.SS "TEST (\fBRecoveryTest\fP , ManifestMissing )"

.SS "TEST (\fBRecoveryTest\fP , ManifestReused )"

.SS "TEST (\fBRecoveryTest\fP , MultipleLogFiles )"

.SS "TEST (\fBRecoveryTest\fP , MultipleMemTables )"

.SS "TEST (\fBRecoveryTest\fP , NoLogFiles )"

.SS "TEST (\fBSkipTest\fP , Concurrent1 )"

.SS "TEST (\fBSkipTest\fP , Concurrent2 )"

.SS "TEST (\fBSkipTest\fP , Concurrent3 )"

.SS "TEST (\fBSkipTest\fP , Concurrent4 )"

.SS "TEST (\fBSkipTest\fP , Concurrent5 )"

.SS "TEST (\fBSkipTest\fP , ConcurrentWithoutThreads )"

.SS "TEST (\fBSkipTest\fP , Empty )"

.SS "TEST (\fBSkipTest\fP , InsertAndLookup )"

.SS "TEST (\fBStatus\fP , MoveConstructor )"

.SS "TEST (\fBTableTest\fP , ApproximateOffsetOfCompressed )"

.SS "TEST (\fBTableTest\fP , ApproximateOffsetOfPlain )"

.SS "TEST (\fBVersionEditTest\fP , EncodeDecode )"

.SS "TEST (\fBWriteBatchTest\fP , Append )"

.SS "TEST (\fBWriteBatchTest\fP , ApproximateSize )"

.SS "TEST (\fBWriteBatchTest\fP , Corruption )"

.SS "TEST (\fBWriteBatchTest\fP , Empty )"

.SS "TEST (\fBWriteBatchTest\fP , Multiple )"

.SS "int VarintLength (uint64_t v)"

.SS "\fBStatus\fP WriteStringToFile (\fBEnv\fP * env, const \fBSlice\fP & data, const std::string & fname)"

.SS "\fBStatus\fP WriteStringToFileSync (\fBEnv\fP * env, const \fBSlice\fP & data, const std::string & fname)"

.SH "Variable Documentation"
.PP 
.SS "class \fBLEVELDB_EXPORT\fP \fBCache\fP"

.SS "const int kNumNonTableCacheFiles = 10"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
