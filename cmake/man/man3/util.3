.TH "util" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
util
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBdetail\fP"
.br
.ti -1c
.RI "namespace \fBhex_literals\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBConstevalFormatString\fP"
.br
.RI "A wrapper for a compile-time partially validated format string\&. "
.ti -1c
.RI "class \fBUnexpected\fP"
.br
.ti -1c
.RI "class \fBExpected\fP"
.br
.ti -1c
.RI "struct \fBOverloaded\fP"
.br
.ti -1c
.RI "struct \fBError\fP"
.br
.ti -1c
.RI "class \fBResult\fP"
.br
.ti -1c
.RI "class \fBSignalInterrupt\fP"
.br
.ti -1c
.RI "class \fBTaskRunnerInterface\fP"
.br
.ti -1c
.RI "class \fBImmediateTaskRunner\fP"
.br
.ti -1c
.RI "struct \fBTranslatedLiteral\fP"
.br
.RI "Compile-time literal string that can be translated with an optional translation function\&. "
.ti -1c
.RI "struct \fBBilingualFmt\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBLockResult\fP { \fBSuccess\fP, \fBErrorWrite\fP, \fBErrorLock\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename \fBT\fP> \fBT\fP * \fBAnyPtr\fP (const std::any &any) noexcept"
.br
.ti -1c
.RI "int \fBExecVp\fP (const char *file, char *const argv[])"
.br
.ti -1c
.RI "\fBfs::path\fP \fBGetExePath\fP (std::string_view argv0)"
.br
.ti -1c
.RI "\fBLockResult\fP \fBLockDirectory\fP (const \fBfs::path\fP &directory, const \fBfs::path\fP &lockfile_name, bool probe_only)"
.br
.ti -1c
.RI "template<typename Tdst, typename Tsrc> void \fBinsert\fP (Tdst &dst, const Tsrc &src)"
.br
.RI "Simplification of std insertion\&. "
.ti -1c
.RI "template<typename TsetT, typename Tsrc> void \fBinsert\fP (std::set< TsetT > &dst, const Tsrc &src)"
.br
.ti -1c
.RI "template<typename \fBT\fP> \fBbilingual_str\fP \fBErrorString\fP (const \fBResult\fP< \fBT\fP > &result)"
.br
.ti -1c
.RI "consteval uint8_t \fBConstevalHexDigit\fP (const char c)"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> constexpr auto \fBoperator''_hex\fP ()"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> constexpr auto \fBoperator''_hex_u8\fP ()"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> constexpr auto \fBoperator''_hex_v\fP ()"
.br
.ti -1c
.RI "template<\fButil::detail::Hex\fP str> auto \fBoperator''_hex_v_u8\fP ()"
.br
.ti -1c
.RI "void \fBReplaceAll\fP (std::string &in_out, const std::string &search, const std::string &substitute)"
.br
.ti -1c
.RI "template<typename \fBT\fP = std::span<const char>> std::vector< \fBT\fP > \fBSplit\fP (const std::span< const char > &sp, std::string_view separators, bool include_sep=false)"
.br
.ti -1c
.RI "template<typename \fBT\fP = std::span<const char>> std::vector< \fBT\fP > \fBSplit\fP (const std::span< const char > &sp, char sep, bool include_sep=false)"
.br
.ti -1c
.RI "std::vector< std::string > \fBSplitString\fP (std::string_view str, char sep)"
.br
.ti -1c
.RI "std::vector< std::string > \fBSplitString\fP (std::string_view str, std::string_view separators)"
.br
.ti -1c
.RI "std::string_view \fBTrimStringView\fP (std::string_view str, std::string_view pattern=' \\f\\n\\r\\t\\v')"
.br
.ti -1c
.RI "std::string \fBTrimString\fP (std::string_view str, std::string_view pattern=' \\f\\n\\r\\t\\v')"
.br
.ti -1c
.RI "std::string_view \fBRemoveSuffixView\fP (std::string_view str, std::string_view suffix)"
.br
.ti -1c
.RI "std::string_view \fBRemovePrefixView\fP (std::string_view str, std::string_view \fBprefix\fP)"
.br
.ti -1c
.RI "std::string \fBRemovePrefix\fP (std::string_view str, std::string_view \fBprefix\fP)"
.br
.ti -1c
.RI "template<typename C, typename \fBS\fP, typename UnaryOp> auto \fBJoin\fP (const C &container, const \fBS\fP &separator, UnaryOp unary_op)"
.br
.ti -1c
.RI "template<typename C, typename \fBS\fP> auto \fBJoin\fP (const C &container, const \fBS\fP &separator)"
.br
.ti -1c
.RI "std::string \fBMakeUnorderedList\fP (const std::vector< std::string > &items)"
.br
.ti -1c
.RI "bool \fBContainsNoNUL\fP (std::string_view str) noexcept"
.br
.ti -1c
.RI "template<typename \fBT\fP> std::string \fBToString\fP (const \fBT\fP &t)"
.br
.ti -1c
.RI "template<typename T1, size_t PREFIX_LEN> bool \fBHasPrefix\fP (const T1 &obj, const std::array< uint8_t, PREFIX_LEN > &\fBprefix\fP)"
.br
.ti -1c
.RI "void \fBTraceThread\fP (std::string_view thread_name, std::function< void()> thread_func)"
.br
.ti -1c
.RI "void \fBThreadRename\fP (const std::string &)"
.br
.ti -1c
.RI "void \fBThreadSetInternalName\fP (const std::string &)"
.br
.RI "Set the internal (in-memory) name of the current thread only\&. "
.ti -1c
.RI "std::string \fBThreadGetInternalName\fP ()"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBTranslatedLiteral\fP &lit)"
.br
.ti -1c
.RI "template<typename \fBT\fP> \fBT\fP \fBoperator+\fP (const \fBT\fP &lhs, const \fBTranslatedLiteral\fP &rhs)"
.br
.ti -1c
.RI "template<typename \fBT\fP> \fBT\fP \fBoperator+\fP (const \fBTranslatedLiteral\fP &lhs, const \fBT\fP &rhs)"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "enum class \fBLockResult\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISuccess \fP
.TP
\f(BIErrorWrite \fP
.TP
\f(BIErrorLock \fP
.SH "Function Documentation"
.PP 
.SS "template<typename \fBT\fP> \fBT\fP * AnyPtr (const std::any & any)\fR [noexcept]\fP"
Helper function to access the contained object of a std::any instance\&. Returns a pointer to the object if passed instance has a value and the type matches, nullptr otherwise\&. 
.SS "uint8_t ConstevalHexDigit (const char c)\fR [consteval]\fP"
consteval version of \fBHexDigit()\fP without the lookup table\&. 
.SS "bool ContainsNoNUL (std::string_view str)\fR [inline]\fP, \fR [nodiscard]\fP, \fR [noexcept]\fP"
Check if a string does not contain any embedded NUL (\\0) characters 
.SS "template<typename \fBT\fP> \fBbilingual_str\fP ErrorString (const \fBResult\fP< \fBT\fP > & result)"

.SS "int ExecVp (const char * file, char *const argv[])"
Cross-platform wrapper for POSIX execvp function\&. Arguments and return value are the same as for POSIX execvp, and the argv array should consist of null terminated strings and be null terminated itself, like the POSIX function\&. 
.SS "\fBfs::path\fP GetExePath (std::string_view argv0)"
Return path to current executable assuming it was invoked with argv0\&. If path could not be determined, returns an empty path\&. 
.SS "template<typename T1, size_t PREFIX_LEN> bool HasPrefix (const T1 & obj, const std::array< uint8_t, PREFIX_LEN > & prefix)\fR [inline]\fP, \fR [nodiscard]\fP"
Check whether a container begins with the given prefix\&. 
.SS "template<typename TsetT, typename Tsrc> void insert (std::set< TsetT > & dst, const Tsrc & src)\fR [inline]\fP"

.SS "template<typename Tdst, typename Tsrc> void insert (Tdst & dst, const Tsrc & src)\fR [inline]\fP"

.PP
Simplification of std insertion\&. 
.SS "template<typename C, typename \fBS\fP> auto Join (const C & container, const \fBS\fP & separator)"

.SS "template<typename C, typename \fBS\fP, typename UnaryOp> auto Join (const C & container, const \fBS\fP & separator, UnaryOp unary_op)"
Join all container items\&. Typically used to concatenate strings but accepts containers with elements of any type\&.

.PP
\fBParameters\fP
.RS 4
\fIcontainer\fP The items to join 
.br
\fIseparator\fP The separator 
.br
\fIunary_op\fP Apply this operator to each item 
.RE
.PP

.SS "\fBLockResult\fP LockDirectory (const \fBfs::path\fP & directory, const \fBfs::path\fP & lockfile_name, bool probe_only)\fR [nodiscard]\fP"

.SS "std::string MakeUnorderedList (const std::vector< std::string > & items)\fR [inline]\fP"
Create an unordered multi-line list of items\&. 
.SS "template<typename \fBT\fP> \fBT\fP operator+ (const \fBT\fP & lhs, const \fBTranslatedLiteral\fP & rhs)"

.SS "template<typename \fBT\fP> \fBT\fP operator+ (const \fBTranslatedLiteral\fP & lhs, const \fBT\fP & rhs)"

.SS "std::ostream & operator<< (std::ostream & os, const \fBTranslatedLiteral\fP & lit)\fR [inline]\fP"

.SS "std::string RemovePrefix (std::string_view str, std::string_view prefix)\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "std::string_view RemovePrefixView (std::string_view str, std::string_view prefix)\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "std::string_view RemoveSuffixView (std::string_view str, std::string_view suffix)\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "void ReplaceAll (std::string & in_out, const std::string & search, const std::string & substitute)"

.SS "template<typename \fBT\fP = std::span<const char>> std::vector< \fBT\fP > Split (const std::span< const char > & sp, char sep, bool include_sep = \fRfalse\fP)"
Split a string on every instance of sep, returning a vector\&.

.PP
If sep does not occur in sp, a singleton with the entirety of sp is returned\&.

.PP
Note that this function does not care about braces, so splitting "foo(bar(1),2),3) on ',' will return {"foo(bar(1)", "2)", "3)"}\&. 
.SS "template<typename \fBT\fP = std::span<const char>> std::vector< \fBT\fP > Split (const std::span< const char > & sp, std::string_view separators, bool include_sep = \fRfalse\fP)"
Split a string on any char found in separators, returning a vector\&.

.PP
If sep does not occur in sp, a singleton with the entirety of sp is returned\&.

.PP
\fBParameters\fP
.RS 4
\fIinclude_sep\fP Whether to include the separator at the end of the left side of the splits\&.
.RE
.PP
Note that this function does not care about braces, so splitting "foo(bar(1),2),3) on ',' will return {"foo(bar(1)", "2)", "3)"}\&.If include_sep == true, splitting "foo(bar(1),2),3) on ',' will return:
.IP "\(bu" 2
foo(bar(1),
.IP "\(bu" 2
2),
.IP "\(bu" 2
3) 
.PP

.SS "std::vector< std::string > SplitString (std::string_view str, char sep)\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "std::vector< std::string > SplitString (std::string_view str, std::string_view separators)\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "std::string ThreadGetInternalName ()"
Get the thread's internal (in-memory) name; used e\&.g\&. for identification in logging\&. 
.SS "void ThreadRename (const std::string & name)"
Rename a thread both in terms of an internal (in-memory) name as well as its system thread name\&. 
.PP
\fBNote\fP
.RS 4
Do not call this for the main thread, as this will interfere with UNIX utilities such as top and killall\&. Use ThreadSetInternalName instead\&. 
.RE
.PP

.SS "void ThreadSetInternalName (const std::string & name)"

.PP
Set the internal (in-memory) name of the current thread only\&. 
.SS "template<typename \fBT\fP> std::string ToString (const \fBT\fP & t)"
Locale-independent version of std::to_string 
.SS "void TraceThread (std::string_view thread_name, std::function< void()> thread_func)"
A wrapper for do-something-once thread functions\&. 
.SS "std::string TrimString (std::string_view str, std::string_view pattern = \fR' \\f\\n\\r\\t\\v'\fP)\fR [inline]\fP, \fR [nodiscard]\fP"

.SS "std::string_view TrimStringView (std::string_view str, std::string_view pattern = \fR' \\f\\n\\r\\t\\v'\fP)\fR [inline]\fP, \fR [nodiscard]\fP"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
