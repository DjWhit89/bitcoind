.TH "TestChainstateManager" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TestChainstateManager
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <validation\&.h>\fP
.PP
Inherits \fBChainstateManager\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBDisableNextWrite\fP ()"
.br
.ti -1c
.RI "void \fBResetIbd\fP ()"
.br
.ti -1c
.RI "void \fBJumpOutOfIbd\fP ()"
.br
.ti -1c
.RI "void \fBInvalidBlockFound\fP (\fBCBlockIndex\fP *pindex, const \fBBlockValidationState\fP &state) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBInvalidChainFound\fP (\fBCBlockIndex\fP *pindexNew) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBFindMostWorkChain\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBResetBestInvalid\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.in -1c

Public Member Functions inherited from \fBChainstateManager\fP
.in +1c
.ti -1c
.RI "\fBChainstateManager\fP (const \fButil::SignalInterrupt\fP &interrupt, \fBOptions\fP\fBOptions\fP options, \fBnode::BlockManager::Options\fP blockman_options)"
.br
.ti -1c
.RI "const \fBCChainParams\fP & \fBGetParams\fP () const"
.br
.ti -1c
.RI "const \fBConsensus::Params\fP & \fBGetConsensus\fP () const"
.br
.ti -1c
.RI "bool \fBShouldCheckBlockIndex\fP () const"
.br
.ti -1c
.RI "const \fBarith_uint256\fP & \fBMinimumChainWork\fP () const"
.br
.ti -1c
.RI "const \fBuint256\fP & \fBAssumedValidBlock\fP () const"
.br
.ti -1c
.RI "\fBkernel::Notifications\fP & \fBGetNotifications\fP () const"
.br
.ti -1c
.RI "void \fBCheckBlockIndex\fP () const"
.br
.ti -1c
.RI "\fBRecursiveMutex\fP & \fBGetMutex\fP () const \fBLOCK_RETURNED\fP("
.br
.ti -1c
.RI "int32_t nBlockSequenceId \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "void \fBResetBlockSequenceCounters\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "\fBCBlockIndex\fP *m_best_header \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.ti -1c
.RI "\fBChainstate\fP * \fBHistoricalChainstate\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.RI "Return historical chainstate targeting a specific block, if any\&. "
.ti -1c
.RI "\fBChainstate\fP & \fBValidatedChainstate\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "std::unique_ptr< \fBChainstate\fP > \fBRemoveChainstate\fP (\fBChainstate\fP &chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.RI "Remove a chainstate\&. "
.ti -1c
.RI "\fBnode::BlockMap\fP & \fBBlockIndex\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP("
.br
.ti -1c
.RI "bool \fBIsInitialBlockDownload\fP () const"
.br
.ti -1c
.RI "double \fBGuessVerificationProgress\fP (const \fBCBlockIndex\fP *pindex) const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "void \fBLoadExternalBlockFile\fP (\fBAutoFile\fP &file_in, \fBFlatFilePos\fP *dbp=nullptr, std::multimap< \fBuint256\fP, \fBFlatFilePos\fP > *blocks_with_unknown_parent=nullptr)"
.br
.ti -1c
.RI "bool \fBProcessNewBlock\fP (const std::shared_ptr< const \fBCBlock\fP > &block, bool force_processing, bool min_pow_checked, bool *new_block) \fBLOCKS_EXCLUDED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBProcessNewBlockHeaders\fP (std::span< const \fBCBlockHeader\fP > headers, bool min_pow_checked, \fBBlockValidationState\fP &state, const \fBCBlockIndex\fP **ppindex=nullptr) \fBLOCKS_EXCLUDED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBAcceptBlock\fP (const std::shared_ptr< const \fBCBlock\fP > &pblock, \fBBlockValidationState\fP &state, \fBCBlockIndex\fP **ppindex, bool fRequested, const \fBFlatFilePos\fP *dbp, bool *fNewBlock, bool min_pow_checked) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "void \fBReceivedBlockTransactions\fP (const \fBCBlock\fP &block, \fBCBlockIndex\fP *pindexNew, const \fBFlatFilePos\fP &pos) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "\fBMempoolAcceptResult\fP \fBProcessTransaction\fP (const \fBCTransactionRef\fP &tx, bool test_accept=false) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.ti -1c
.RI "bool \fBLoadBlockIndex\fP () \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBcs_main\fP)"
.br
.RI "Load the block tree and coins database from disk, initializing state if we're running with -reindex\&. "
.ti -1c
.RI "void MaybeRebalanceCaches() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void \fBUpdateUncommittedBlockStructures\fP (\fBCBlock\fP &block, const \fBCBlockIndex\fP *pindexPrev) const"
.br
.ti -1c
.RI "std::vector< unsigned char > \fBGenerateCoinbaseCommitment\fP (\fBCBlock\fP &block, const \fBCBlockIndex\fP *pindexPrev) const"
.br
.ti -1c
.RI "void \fBReportHeadersPresync\fP (const \fBarith_uint256\fP &work, int64_t height, int64_t timestamp)"
.br
.ti -1c
.RI "\fB~ChainstateManager\fP ()"
.br
.ti -1c
.RI "std::vector< std::unique_ptr< \fBChainstate\fP > > m_chainstates \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.in -1c
.in +1c
.ti -1c
.RI "\fBChainstate\fP & \fBActiveChainstate\fP () const"
.br
.ti -1c
.RI "\fBCChain\fP & \fBActiveChain\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "int \fBActiveHeight\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.ti -1c
.RI "\fBCBlockIndex\fP * \fBActiveTip\fP () const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBChainstateManager\fP
.in +1c
.ti -1c
.RI "using \fBOptions\fP = \fBkernel::ChainstateManagerOpts\fP"
.br
.in -1c

Data Fields inherited from \fBChainstateManager\fP
.in +1c
.ti -1c
.RI "std::function< void()> \fBsnapshot_download_completed\fP = std::function<void()>()"
.br
.ti -1c
.RI "const \fButil::SignalInterrupt\fP & \fBm_interrupt\fP"
.br
.ti -1c
.RI "const \fBOptions\fP\fBOptions\fP \fBm_options\fP"
.br
.ti -1c
.RI "\fBnode::BlockManager\fP \fBm_blockman\fP"
.br
.ti -1c
.RI "\fBValidationCache\fP \fBm_validation_cache\fP"
.br
.ti -1c
.RI "std::atomic< bool > \fBm_cached_finished_ibd\fP {false}"
.br
.ti -1c
.RI "int32_t \fBnBlockReverseSequenceId\fP = \-1"
.br
.ti -1c
.RI "\fBarith_uint256\fP \fBnLastPreciousChainwork\fP = 0"
.br
.ti -1c
.RI "size_t \fBm_total_coinstip_cache\fP {0}"
.br
.ti -1c
.RI "size_t \fBm_total_coinsdb_cache\fP {0}"
.br
.ti -1c
.RI "\fBChainstate\fP &InitializeChainstate(\fBCTxMemPool\fP *mempool) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fButil::Result\fP< \fBCBlockIndex\fP * \fBActivateSnapshot\fP )(\fBAutoFile\fP &coins_file, const \fBnode::SnapshotMetadata\fP &metadata, bool in_memory)"
.br
.ti -1c
.RI "\fBSnapshotCompletionResult\fP MaybeValidateSnapshot(\fBChainstate\fP &validated_cs, \fBChainstate\fP &unvalidated_cs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBChainstate\fP \fBCurrentChainstate\fP )() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBGetMutex\fP())"
.br
.RI "Return current chainstate targeting the most-work, network tip\&. "
.ti -1c
.RI "\fBVersionBitsCache\fP \fBm_versionbitscache\fP"
.br
.ti -1c
.RI "\fBChainstate\fP *LoadAssumeutxoChainstate() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBChainstate\fP &AddChainstate(std::unique_ptr< \fBChainstate\fP > chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(void ResetChainstates() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool DeleteChainstate(\fBChainstate\fP &chainstate) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(bool ValidatedSnapshotCleanup(\fBChainstate\fP &validated_cs, \fBChainstate\fP &unvalidated_cs) \fBEXCLUSIVE_LOCKS_REQUIRED\fP(std::optional< std::pair< const \fBCBlockIndex\fP *, const \fBCBlockIndex\fP * > > GetHistoricalBlockRange() const \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fButil::Result\fP< void > ActivateBestChains() \fBLOCKS_EXCLUDED\fP(void RecalculateBestHeader() \fBEXCLUSIVE_LOCKS_REQUIRED\fP(\fBCCheckQueue\fP< \fBCScriptCheck\fP > \fBGetCheckQueue\fP )()"
.br
.RI "Add new chainstate\&. "
.in -1c

Protected Member Functions inherited from \fBChainstateManager\fP
.in +1c
.ti -1c
.RI "\fBCBlockIndex\fP *m_best_invalid \fBGUARDED_BY\fP (\fB::cs_main\fP)"
.br
.in -1c
.SH "Member Function Documentation"
.PP 
.SS "void DisableNextWrite ()"
Disable the next write of all chainstates 
.SS "\fBCBlockIndex\fP * FindMostWorkChain ()"

.SS "void InvalidBlockFound (\fBCBlockIndex\fP * pindex, const \fBBlockValidationState\fP & state)"
Wrappers that avoid making chainstatemanager internals public for tests 
.SS "void InvalidChainFound (\fBCBlockIndex\fP * pindexNew)"

.SS "void JumpOutOfIbd ()"
Toggle IsInitialBlockDownload from true to false 
.SS "void ResetBestInvalid ()"

.SS "void ResetIbd ()"
Reset the ibd cache to its initial state 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
