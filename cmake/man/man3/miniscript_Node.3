.TH "Node< Key >" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Node< Key > \- A node in a miniscript expression\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fR#include <miniscript\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~Node\fP ()"
.br
.ti -1c
.RI "\fBNodeRef\fP< Key > \fBClone\fP () const"
.br
.ti -1c
.RI "template<typename Ctx> \fBCScript\fP \fBToScript\fP (const Ctx &ctx) const"
.br
.ti -1c
.RI "template<typename CTx> std::optional< std::string > \fBToString\fP (const CTx &ctx) const"
.br
.ti -1c
.RI "template<typename Ctx> void \fBDuplicateKeyCheck\fP (const Ctx &ctx) const"
.br
.ti -1c
.RI "size_t \fBScriptSize\fP () const"
.br
.RI "Return the size of the script for this expression (faster than \fBToScript()\fP\&.size())\&. "
.ti -1c
.RI "std::optional< uint32_t > \fBGetOps\fP () const"
.br
.RI "Return the maximum number of ops needed to satisfy this script non-malleably\&. "
.ti -1c
.RI "uint32_t \fBGetStaticOps\fP () const"
.br
.RI "Return the number of ops in the script (not counting the dynamic ones that depend on execution)\&. "
.ti -1c
.RI "bool \fBCheckOpsLimit\fP () const"
.br
.RI "Check the ops limit of this script against the consensus limit\&. "
.ti -1c
.RI "bool \fBIsBKW\fP () const"
.br
.ti -1c
.RI "std::optional< uint32_t > \fBGetStackSize\fP () const"
.br
.ti -1c
.RI "std::optional< uint32_t > \fBGetExecStackSize\fP () const"
.br
.RI "Return the maximum size of the stack during execution of this script\&. "
.ti -1c
.RI "bool \fBCheckStackSize\fP () const"
.br
.RI "Check the maximum stack size for this script against the policy limit\&. "
.ti -1c
.RI "bool \fBIsNotSatisfiable\fP () const"
.br
.RI "Whether no satisfaction exists for this node\&. "
.ti -1c
.RI "std::optional< uint32_t > \fBGetWitnessSize\fP () const"
.br
.ti -1c
.RI "\fBType\fP \fBGetType\fP () const"
.br
.RI "Return the expression type\&. "
.ti -1c
.RI "\fBMiniscriptContext\fP \fBGetMsCtx\fP () const"
.br
.RI "Return the script context for this node\&. "
.ti -1c
.RI "const \fBNode\fP * \fBFindInsaneSub\fP () const"
.br
.RI "Find an insane subnode which has no insane children\&. Nullptr if there is none\&. "
.ti -1c
.RI "template<typename F> bool \fBIsSatisfiable\fP (F fn) const"
.br
.ti -1c
.RI "bool \fBIsValid\fP () const"
.br
.RI "Check whether this node is valid at all\&. "
.ti -1c
.RI "bool \fBIsValidTopLevel\fP () const"
.br
.RI "Check whether this node is valid as a script on its own\&. "
.ti -1c
.RI "bool \fBIsNonMalleable\fP () const"
.br
.RI "Check whether this script can always be satisfied in a non-malleable way\&. "
.ti -1c
.RI "bool \fBNeedsSignature\fP () const"
.br
.RI "Check whether this script always needs a signature\&. "
.ti -1c
.RI "bool \fBCheckTimeLocksMix\fP () const"
.br
.RI "Check whether there is no satisfaction path that contains both timelocks and heightlocks\&. "
.ti -1c
.RI "bool \fBCheckDuplicateKey\fP () const"
.br
.RI "Check whether there is no duplicate key across this fragment and all its sub-fragments\&. "
.ti -1c
.RI "bool \fBValidSatisfactions\fP () const"
.br
.RI "Whether successful non-malleable satisfactions are guaranteed to be valid\&. "
.ti -1c
.RI "bool \fBIsSaneSubexpression\fP () const"
.br
.RI "Whether the apparent policy of this node matches its script semantics\&. Doesn't guarantee it is a safe script on its own\&. "
.ti -1c
.RI "bool \fBIsSane\fP () const"
.br
.RI "Check whether this node is safe as a script on its own\&. "
.ti -1c
.RI "template<typename Ctx> \fBAvailability\fP \fBSatisfy\fP (const Ctx &ctx, std::vector< std::vector< unsigned char > > &stack, bool nonmalleable=true) const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBNode\fP< Key > &arg) const"
.br
.RI "Equality testing\&. "
.ti -1c
.RI "\fBNode\fP (\fBinternal::NoDupCheck\fP, \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< unsigned char > arg, uint32_t val=0)"
.br
.ti -1c
.RI "\fBNode\fP (\fBinternal::NoDupCheck\fP, \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< unsigned char > arg, uint32_t val=0)"
.br
.ti -1c
.RI "\fBNode\fP (\fBinternal::NoDupCheck\fP, \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< Key > key, uint32_t val=0)"
.br
.ti -1c
.RI "\fBNode\fP (\fBinternal::NoDupCheck\fP, \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< Key > key, uint32_t val=0)"
.br
.ti -1c
.RI "\fBNode\fP (\fBinternal::NoDupCheck\fP, \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, uint32_t val=0)"
.br
.ti -1c
.RI "\fBNode\fP (\fBinternal::NoDupCheck\fP, \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, uint32_t val=0)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNode\fP (const Ctx &ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< unsigned char > arg, uint32_t val=0)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNode\fP (const Ctx &ctx, \fBFragment\fP nt, std::vector< unsigned char > arg, uint32_t val=0)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNode\fP (const Ctx &ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< Key > key, uint32_t val=0)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNode\fP (const Ctx &ctx, \fBFragment\fP nt, std::vector< Key > key, uint32_t val=0)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNode\fP (const Ctx &ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, uint32_t val=0)"
.br
.ti -1c
.RI "template<typename Ctx> \fBNode\fP (const Ctx &ctx, \fBFragment\fP nt, uint32_t val=0)"
.br
.ti -1c
.RI "\fBNode\fP (const \fBNode\fP &)=delete"
.br
.ti -1c
.RI "\fBNode\fP & \fBoperator=\fP (const \fBNode\fP &)=delete"
.br
.in -1c
.SS "Data Fields"

.in +1c
.ti -1c
.RI "const \fBFragment\fP \fBfragment\fP"
.br
.RI "What node type this node is\&. "
.ti -1c
.RI "const uint32_t \fBk\fP = 0"
.br
.RI "The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\&. "
.ti -1c
.RI "const std::vector< Key > \fBkeys\fP"
.br
.RI "The keys used by this expression (only for PK_K/PK_H/MULTI)\&. "
.ti -1c
.RI "const std::vector< unsigned char > \fBdata\fP"
.br
.RI "The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10)\&. "
.ti -1c
.RI "std::vector< \fBNodeRef\fP< Key > > \fBsubs\fP"
.br
.RI "Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\&. "
.ti -1c
.RI "const \fBMiniscriptContext\fP \fBm_script_ctx\fP"
.br
.RI "The Script context for this node\&. Either P2WSH or Tapscript\&. "
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "int \fBCompare\fP (const \fBNode\fP< Key > &node1, const \fBNode\fP< Key > &node2)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename Key>
.br
struct miniscript::Node< Key >"A node in a miniscript expression\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename Key> ~\fBNode\fP ()\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (\fBinternal::NoDupCheck\fP , \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< unsigned char > arg, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (\fBinternal::NoDupCheck\fP , \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< unsigned char > arg, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (\fBinternal::NoDupCheck\fP , \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< Key > key, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (\fBinternal::NoDupCheck\fP , \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< Key > key, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (\fBinternal::NoDupCheck\fP , \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (\fBinternal::NoDupCheck\fP , \fBMiniscriptContext\fP script_ctx, \fBFragment\fP nt, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> \fBNode\fP (const Ctx & ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< unsigned char > arg, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> \fBNode\fP (const Ctx & ctx, \fBFragment\fP nt, std::vector< unsigned char > arg, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> \fBNode\fP (const Ctx & ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, std::vector< Key > key, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> \fBNode\fP (const Ctx & ctx, \fBFragment\fP nt, std::vector< Key > key, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> \fBNode\fP (const Ctx & ctx, \fBFragment\fP nt, std::vector< \fBNodeRef\fP< Key > > sub, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> \fBNode\fP (const Ctx & ctx, \fBFragment\fP nt, uint32_t val = \fR0\fP)\fR [inline]\fP"

.SS "template<typename Key> \fBNode\fP (const \fBNode\fP< Key > & )\fR [delete]\fP"

.SH "Member Function Documentation"
.PP 
.SS "template<typename Key> bool CheckDuplicateKey () const\fR [inline]\fP"

.PP
Check whether there is no duplicate key across this fragment and all its sub-fragments\&. 
.SS "template<typename Key> bool CheckOpsLimit () const\fR [inline]\fP"

.PP
Check the ops limit of this script against the consensus limit\&. 
.SS "template<typename Key> bool CheckStackSize () const\fR [inline]\fP"

.PP
Check the maximum stack size for this script against the policy limit\&. 
.SS "template<typename Key> bool CheckTimeLocksMix () const\fR [inline]\fP"

.PP
Check whether there is no satisfaction path that contains both timelocks and heightlocks\&. 
.SS "template<typename Key> \fBNodeRef\fP< Key > Clone () const\fR [inline]\fP"

.SS "template<typename Key> template<typename Ctx> void DuplicateKeyCheck (const Ctx & ctx) const\fR [inline]\fP"
Update duplicate key information in this \fBNode\fP\&.

.PP
This uses a custom key comparator provided by the context in order to still detect duplicates for more complicated types\&. 
.SS "template<typename Key> const \fBNode\fP * FindInsaneSub () const\fR [inline]\fP"

.PP
Find an insane subnode which has no insane children\&. Nullptr if there is none\&. 
.SS "template<typename Key> std::optional< uint32_t > GetExecStackSize () const\fR [inline]\fP"

.PP
Return the maximum size of the stack during execution of this script\&. 
.SS "template<typename Key> \fBMiniscriptContext\fP GetMsCtx () const\fR [inline]\fP"

.PP
Return the script context for this node\&. 
.SS "template<typename Key> std::optional< uint32_t > GetOps () const\fR [inline]\fP"

.PP
Return the maximum number of ops needed to satisfy this script non-malleably\&. 
.SS "template<typename Key> std::optional< uint32_t > GetStackSize () const\fR [inline]\fP"
Return the maximum number of stack elements needed to satisfy this script non-malleably\&. 
.SS "template<typename Key> uint32_t GetStaticOps () const\fR [inline]\fP"

.PP
Return the number of ops in the script (not counting the dynamic ones that depend on execution)\&. 
.SS "template<typename Key> \fBType\fP GetType () const\fR [inline]\fP"

.PP
Return the expression type\&. 
.SS "template<typename Key> std::optional< uint32_t > GetWitnessSize () const\fR [inline]\fP"
Return the maximum size in bytes of a witness to satisfy this script non-malleably\&. Note this does not include the witness script push\&. 
.SS "template<typename Key> bool IsBKW () const\fR [inline]\fP"
Whether this node is of type B, K or W\&. (That is, anything but V\&.) 
.SS "template<typename Key> bool IsNonMalleable () const\fR [inline]\fP"

.PP
Check whether this script can always be satisfied in a non-malleable way\&. 
.SS "template<typename Key> bool IsNotSatisfiable () const\fR [inline]\fP"

.PP
Whether no satisfaction exists for this node\&. 
.SS "template<typename Key> bool IsSane () const\fR [inline]\fP"

.PP
Check whether this node is safe as a script on its own\&. 
.SS "template<typename Key> bool IsSaneSubexpression () const\fR [inline]\fP"

.PP
Whether the apparent policy of this node matches its script semantics\&. Doesn't guarantee it is a safe script on its own\&. 
.SS "template<typename Key> template<typename F> bool IsSatisfiable (F fn) const\fR [inline]\fP"
Determine whether a Miniscript node is satisfiable\&. fn(node) will be invoked for all key, time, and hashing nodes, and should return their satisfiability\&. 
.SS "template<typename Key> bool IsValid () const\fR [inline]\fP"

.PP
Check whether this node is valid at all\&. 
.SS "template<typename Key> bool IsValidTopLevel () const\fR [inline]\fP"

.PP
Check whether this node is valid as a script on its own\&. 
.SS "template<typename Key> bool NeedsSignature () const\fR [inline]\fP"

.PP
Check whether this script always needs a signature\&. 
.SS "template<typename Key> \fBNode\fP & operator= (const \fBNode\fP< Key > & )\fR [delete]\fP"

.SS "template<typename Key> bool operator== (const \fBNode\fP< Key > & arg) const\fR [inline]\fP"

.PP
Equality testing\&. 
.SS "template<typename Key> template<typename Ctx> \fBAvailability\fP Satisfy (const Ctx & ctx, std::vector< std::vector< unsigned char > > & stack, bool nonmalleable = \fRtrue\fP) const\fR [inline]\fP"
Produce a witness for this script, if possible and given the information available in the context\&. The non-malleable satisfaction is guaranteed to be valid if it exists, and ValidSatisfaction() is true\&. If \fBIsSane()\fP holds, this satisfaction is guaranteed to succeed in case the node's conditions are satisfied (private keys and hash preimages available, locktimes satisfied)\&. 
.SS "template<typename Key> size_t ScriptSize () const\fR [inline]\fP"

.PP
Return the size of the script for this expression (faster than \fBToScript()\fP\&.size())\&. 
.SS "template<typename Key> template<typename Ctx> \fBCScript\fP ToScript (const Ctx & ctx) const\fR [inline]\fP"

.SS "template<typename Key> template<typename CTx> std::optional< std::string > ToString (const CTx & ctx) const\fR [inline]\fP"

.SS "template<typename Key> bool ValidSatisfactions () const\fR [inline]\fP"

.PP
Whether successful non-malleable satisfactions are guaranteed to be valid\&. 
.SH "Friends And Related Symbol Documentation"
.PP 
.SS "template<typename Key> int Compare (const \fBNode\fP< Key > & node1, const \fBNode\fP< Key > & node2)\fR [friend]\fP"
Compare two miniscript subtrees, using a non-recursive algorithm\&. 
.SH "Field Documentation"
.PP 
.SS "template<typename Key> const std::vector<unsigned char> data"

.PP
The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10)\&. 
.SS "template<typename Key> const \fBFragment\fP fragment"

.PP
What node type this node is\&. 
.SS "template<typename Key> const uint32_t k = 0"

.PP
The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\&. 
.SS "template<typename Key> const std::vector<Key> keys"

.PP
The keys used by this expression (only for PK_K/PK_H/MULTI)\&. 
.SS "template<typename Key> const \fBMiniscriptContext\fP m_script_ctx"

.PP
The Script context for this node\&. Either P2WSH or Tapscript\&. 
.SS "template<typename Key> std::vector<\fBNodeRef\fP<Key> > subs\fR [mutable]\fP"

.PP
Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
