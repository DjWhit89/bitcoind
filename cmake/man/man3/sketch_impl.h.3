.TH "src/minisketch/src/sketch_impl.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/minisketch/src/sketch_impl.h
.SH SYNOPSIS
.br
.PP
\fR#include <random>\fP
.br
\fR#include 'util\&.h'\fP
.br
\fR#include 'sketch\&.h'\fP
.br
\fR#include 'int_utils\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBSketchImpl< F >\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename F> void \fBPolyMod\fP (const std::vector< typename F::Elem > &mod, std::vector< typename F::Elem > &val, const F &field)"
.br
.ti -1c
.RI "template<typename F> void \fBDivMod\fP (const std::vector< typename F::Elem > &mod, std::vector< typename F::Elem > &val, std::vector< typename F::Elem > &div, const F &field)"
.br
.ti -1c
.RI "template<typename F> F::Elem \fBMakeMonic\fP (std::vector< typename F::Elem > &a, const F &field)"
.br
.ti -1c
.RI "template<typename F> void \fBGCD\fP (std::vector< typename F::Elem > &a, std::vector< typename F::Elem > &b, const F &field)"
.br
.ti -1c
.RI "template<typename F> void \fBSqr\fP (std::vector< typename F::Elem > &poly, const F &field)"
.br
.ti -1c
.RI "template<typename F> void \fBTraceMod\fP (const std::vector< typename F::Elem > &mod, std::vector< typename F::Elem > &out, const typename F::Elem &param, const F &field)"
.br
.ti -1c
.RI "template<typename F> bool \fBRecFindRoots\fP (std::vector< std::vector< typename F::Elem > > &stack, size_t pos, std::vector< typename F::Elem > &roots, bool fully_factorizable, int depth, typename F::Elem randv, const F &field)"
.br
.ti -1c
.RI "template<typename F> std::vector< typename F::Elem > \fBFindRoots\fP (const std::vector< typename F::Elem > &poly, typename F::Elem basis, const F &field)"
.br
.ti -1c
.RI "template<typename F> std::vector< typename F::Elem > \fBBerlekampMassey\fP (const std::vector< typename F::Elem > &syndromes, size_t max_degree, const F &field)"
.br
.ti -1c
.RI "template<typename F> std::vector< typename F::Elem > \fBReconstructAllSyndromes\fP (const std::vector< typename F::Elem > &odd_syndromes, const F &field)"
.br
.ti -1c
.RI "template<typename F> void \fBAddToOddSyndromes\fP (std::vector< typename F::Elem > &osyndromes, typename F::Elem data, const F &field)"
.br
.ti -1c
.RI "template<typename F> std::vector< typename F::Elem > \fBFullDecode\fP (const std::vector< typename F::Elem > &osyndromes, const F &field)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "template<typename F> void AddToOddSyndromes (std::vector< typename F::Elem > & osyndromes, typename F::Elem data, const F & field)"

.SS "template<typename F> std::vector< typename F::Elem > BerlekampMassey (const std::vector< typename F::Elem > & syndromes, size_t max_degree, const F & field)"

.SS "template<typename F> void DivMod (const std::vector< typename F::Elem > & mod, std::vector< typename F::Elem > & val, std::vector< typename F::Elem > & div, const F & field)"
Compute the quotient of a polynomial division of val by mod, putting the quotient in div and the remainder in val\&. 
.SS "template<typename F> std::vector< typename F::Elem > FindRoots (const std::vector< typename F::Elem > & poly, typename F::Elem basis, const F & field)"
Returns the roots of a fully factorizable polynomial

.PP
This function assumes that the input polynomial is square-free and not the zero polynomial (represented by an empty vector)\&.

.PP
In case the square-free polynomial is not fully factorizable, i\&.e\&., it has fewer roots than its degree, the empty vector is returned\&. 
.SS "template<typename F> std::vector< typename F::Elem > FullDecode (const std::vector< typename F::Elem > & osyndromes, const F & field)"

.SS "template<typename F> void GCD (std::vector< typename F::Elem > & a, std::vector< typename F::Elem > & b, const F & field)"
Compute the GCD of two polynomials, putting the result in a\&. b will be cleared\&. 
.SS "template<typename F> F::Elem MakeMonic (std::vector< typename F::Elem > & a, const F & field)"
Make a polynomial monic\&. 
.SS "template<typename F> void PolyMod (const std::vector< typename F::Elem > & mod, std::vector< typename F::Elem > & val, const F & field)"
Compute the remainder of a polynomial division of val by mod, putting the result in mod\&. 
.SS "template<typename F> bool RecFindRoots (std::vector< std::vector< typename F::Elem > > & stack, size_t pos, std::vector< typename F::Elem > & roots, bool fully_factorizable, int depth, typename F::Elem randv, const F & field)"
One step of the root finding algorithm; finds roots of stack[pos] and adds them to roots\&. Stack elements >= pos are destroyed\&.

.PP
It operates on a stack of polynomials\&. The polynomial operated on is \fRstack[pos]\fP, where elements of \fRstack\fP with index higher than \fRpos\fP are used as scratch space\&.

.PP
\fRstack[pos]\fP is assumed to be square-free polynomial\&. If \fRfully_factorizable\fP is true, it is also assumed to have no irreducible factors of degree higher than 1\&.

.PP
This implements the Berlekamp trace algorithm, plus an efficient test to fail fast in case the polynomial cannot be fully factored\&. 
.SS "template<typename F> std::vector< typename F::Elem > ReconstructAllSyndromes (const std::vector< typename F::Elem > & odd_syndromes, const F & field)"

.SS "template<typename F> void Sqr (std::vector< typename F::Elem > & poly, const F & field)"
Square a polynomial\&. 
.SS "template<typename F> void TraceMod (const std::vector< typename F::Elem > & mod, std::vector< typename F::Elem > & out, const typename F::Elem & param, const F & field)"
Compute the trace map of (param*x) modulo mod, putting the result in out\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
