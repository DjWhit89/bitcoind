.TH "src/rpc/rawtransaction_util.cpp" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/rpc/rawtransaction_util.cpp
.SH SYNOPSIS
.br
.PP
\fR#include <rpc/rawtransaction_util\&.h>\fP
.br
\fR#include <coins\&.h>\fP
.br
\fR#include <consensus/amount\&.h>\fP
.br
\fR#include <core_io\&.h>\fP
.br
\fR#include <key_io\&.h>\fP
.br
\fR#include <policy/policy\&.h>\fP
.br
\fR#include <primitives/transaction\&.h>\fP
.br
\fR#include <rpc/request\&.h>\fP
.br
\fR#include <rpc/util\&.h>\fP
.br
\fR#include <script/sign\&.h>\fP
.br
\fR#include <script/signingprovider\&.h>\fP
.br
\fR#include <tinyformat\&.h>\fP
.br
\fR#include <univalue\&.h>\fP
.br
\fR#include <util/rbf\&.h>\fP
.br
\fR#include <util/string\&.h>\fP
.br
\fR#include <util/strencodings\&.h>\fP
.br
\fR#include <util/translation\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBAddInputs\fP (\fBCMutableTransaction\fP &rawTx, const \fBUniValue\fP &inputs_in, std::optional< bool > rbf)"
.br
.ti -1c
.RI "\fBUniValue\fP \fBNormalizeOutputs\fP (const \fBUniValue\fP &outputs_in)"
.br
.ti -1c
.RI "std::vector< std::pair< \fBCTxDestination\fP, \fBCAmount\fP > > \fBParseOutputs\fP (const \fBUniValue\fP &outputs)"
.br
.ti -1c
.RI "void \fBAddOutputs\fP (\fBCMutableTransaction\fP &rawTx, const \fBUniValue\fP &outputs_in)"
.br
.ti -1c
.RI "\fBCMutableTransaction\fP \fBConstructTransaction\fP (const \fBUniValue\fP &inputs_in, const \fBUniValue\fP &outputs_in, const \fBUniValue\fP &locktime, std::optional< bool > rbf, const uint32_t version)"
.br
.ti -1c
.RI "void \fBParsePrevouts\fP (const \fBUniValue\fP &prevTxsUnival, \fBFlatSigningProvider\fP *keystore, std::map< \fBCOutPoint\fP, \fBCoin\fP > &coins)"
.br
.ti -1c
.RI "void \fBSignTransaction\fP (\fBCMutableTransaction\fP &mtx, const \fBSigningProvider\fP *keystore, const std::map< \fBCOutPoint\fP, \fBCoin\fP > &coins, const \fBUniValue\fP &hashType, \fBUniValue\fP &result)"
.br
.ti -1c
.RI "void \fBSignTransactionResultToJSON\fP (\fBCMutableTransaction\fP &mtx, bool complete, const std::map< \fBCOutPoint\fP, \fBCoin\fP > &coins, const std::map< int, \fBbilingual_str\fP > &input_errors, \fBUniValue\fP &result)"
.br
.ti -1c
.RI "std::vector< \fBRPCResult\fP > \fBDecodeTxDoc\fP (const std::string &txid_field_doc, bool \fBwallet\fP)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void AddInputs (\fBCMutableTransaction\fP & rawTx, const \fBUniValue\fP & inputs_in, std::optional< bool > rbf)"

.SS "void AddOutputs (\fBCMutableTransaction\fP & rawTx, const \fBUniValue\fP & outputs_in)"
Normalize, parse, and add outputs to the transaction 
.SS "\fBCMutableTransaction\fP ConstructTransaction (const \fBUniValue\fP & inputs_in, const \fBUniValue\fP & outputs_in, const \fBUniValue\fP & locktime, std::optional< bool > rbf, const uint32_t version)"
Create a transaction from univalue parameters 
.SS "std::vector< \fBRPCResult\fP > DecodeTxDoc (const std::string & txid_field_doc, bool wallet)"
Explain the \fBUniValue\fP "decoded" transaction object, may include extra fields if processed by wallet 
.SS "\fBUniValue\fP NormalizeOutputs (const \fBUniValue\fP & outputs_in)"
Normalize univalue-represented outputs 
.SS "std::vector< std::pair< \fBCTxDestination\fP, \fBCAmount\fP > > ParseOutputs (const \fBUniValue\fP & outputs)"
Parse normalized outputs into destination, amount tuples 
.SS "void ParsePrevouts (const \fBUniValue\fP & prevTxsUnival, \fBFlatSigningProvider\fP * keystore, std::map< \fBCOutPoint\fP, \fBCoin\fP > & coins)"
Parse a prevtxs \fBUniValue\fP array and get the map of coins from it

.PP
\fBParameters\fP
.RS 4
\fIprevTxsUnival\fP Array of previous txns outputs that tx depends on but may not yet be in the block chain 
.br
\fIkeystore\fP A pointer to the temporary keystore if there is one 
.br
\fIcoins\fP Map of unspent outputs - coins in mempool and current chain UTXO set, may be extended by previous txns outputs after call 
.RE
.PP

.SS "void SignTransaction (\fBCMutableTransaction\fP & mtx, const \fBSigningProvider\fP * keystore, const std::map< \fBCOutPoint\fP, \fBCoin\fP > & coins, const \fBUniValue\fP & hashType, \fBUniValue\fP & result)"
Sign a transaction with the given keystore and previous transactions

.PP
\fBParameters\fP
.RS 4
\fImtx\fP The transaction to-be-signed 
.br
\fIkeystore\fP Temporary keystore containing signing keys 
.br
\fIcoins\fP Map of unspent outputs 
.br
\fIhashType\fP The signature hash type 
.br
\fIresult\fP JSON object where signed transaction results accumulate 
.RE
.PP

.SS "void SignTransactionResultToJSON (\fBCMutableTransaction\fP & mtx, bool complete, const std::map< \fBCOutPoint\fP, \fBCoin\fP > & coins, const std::map< int, \fBbilingual_str\fP > & input_errors, \fBUniValue\fP & result)"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
