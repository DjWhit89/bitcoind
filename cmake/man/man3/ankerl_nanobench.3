.TH "ankerl::nanobench" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ankerl::nanobench
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBtemplates\fP"
.br
.ti -1c
.RI "namespace \fBdetail\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBConfig\fP"
.br
.ti -1c
.RI "class \fBResult\fP"
.br
.ti -1c
.RI "class \fBRng\fP"
.br
.ti -1c
.RI "class \fBBench\fP"
.br
.RI "Main entry point to nanobench's benchmarking facility\&. "
.ti -1c
.RI "class \fBBigO\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBClock\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBrender\fP (char const *mustacheTemplate, \fBBench\fP const &bench, std::ostream &out)"
.br
.RI "Renders output from a mustache-like template and benchmark results\&. "
.ti -1c
.RI "void \fBrender\fP (std::string const &mustacheTemplate, \fBBench\fP const &bench, std::ostream &out)"
.br
.ti -1c
.RI "void \fBrender\fP (char const *mustacheTemplate, std::vector< \fBResult\fP > const &results, std::ostream &out)"
.br
.ti -1c
.RI "void \fBrender\fP (std::string const &mustacheTemplate, std::vector< \fBResult\fP > const &results, std::ostream &out)"
.br
.ti -1c
.RI "template<typename Arg> void \fBdoNotOptimizeAway\fP (Arg &&arg)"
.br
.RI "Makes sure none of the given arguments are optimized away by the compiler\&. "
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, \fBBigO\fP const &bigO)"
.br
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &os, std::vector< \fBankerl::nanobench::BigO\fP > const &bigOs)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBClock\fP"
\fBInitial value:\fP
.nf
 std::conditional<std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock,
                               std::chrono::steady_clock>::type
.PP
.fi

.SH "Function Documentation"
.PP 
.SS "template<typename Arg> void doNotOptimizeAway (Arg && arg)"

.PP
Makes sure none of the given arguments are optimized away by the compiler\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIArg\fP Type of the argument that shouldn't be optimized away\&. 
.RE
.PP
\fBParameters\fP
.RS 4
\fIarg\fP The input that we mark as being used, even though we don't do anything with it\&. 
.RE
.PP

.SS "std::ostream & operator<< (std::ostream & os, \fBBigO\fP const & bigO)"

.SS "std::ostream & operator<< (std::ostream & os, std::vector< \fBankerl::nanobench::BigO\fP > const & bigOs)"

.SS "void render (char const * mustacheTemplate, \fBBench\fP const & bench, std::ostream & out)"

.PP
Renders output from a mustache-like template and benchmark results\&. The templating facility here is heavily inspired by \fRmustache - logic-less templates\fP\&. It adds a few more features that are necessary to get all of the captured data out of nanobench\&. Please read the excellent \fRmustache manual\fP to see what this is all about\&.

.PP
nanobench output has two nested layers, \fIresult\fP and \fImeasurement\fP\&. Here is a hierarchy of the allowed tags:

.PP
.IP "\(bu" 2
\fR{{#result}}\fP Marks the begin of the result layer\&. Whatever comes after this will be instantiated as often as a benchmark result is available\&. Within it, you can use these tags:
.IP "  \(bu" 4
\fR{{title}}\fP See \fBBench::title\fP\&.
.IP "  \(bu" 4
\fR{{\fBname\fP}}\fP Benchmark name, usually directly provided with \fBBench::run\fP, but can also be set with \fBBench::name\fP\&.
.IP "  \(bu" 4
\fR{{unit}}\fP Unit, e\&.g\&. \fRbyte\fP\&. Defaults to \fRop\fP, see \fBBench::unit\fP\&.
.IP "  \(bu" 4
\fR{{batch}}\fP Batch size, see \fBBench::batch\fP\&.
.IP "  \(bu" 4
\fR{{complexityN}}\fP Value used for asymptotic complexity calculation\&. See \fBBench::complexityN\fP\&.
.IP "  \(bu" 4
\fR{{epochs}}\fP Number of epochs, see \fBBench::epochs\fP\&.
.IP "  \(bu" 4
\fR{{clockResolution}}\fP Accuracy of the clock, i\&.e\&. what's the smallest time possible to measure with the clock\&. For modern systems, this can be around 20 ns\&. This value is automatically determined by nanobench at the first benchmark that is run, and used as a static variable throughout the application's runtime\&.
.IP "  \(bu" 4
\fR{{clockResolutionMultiple}}\fP Configuration multiplier for \fRclockResolution\fP\&. See \fBBench::clockResolutionMultiple\fP\&. This is the target runtime for each measurement (epoch)\&. That means the more accurate your clock is, the faster will be the benchmark\&. Basing the measurement's runtime on the clock resolution is the main reason why nanobench is so fast\&.
.IP "  \(bu" 4
\fR{{maxEpochTime}}\fP Configuration for a maximum time each measurement (epoch) is allowed to take\&. Note that at least a single iteration will be performed, even when that takes longer than maxEpochTime\&. See \fBBench::maxEpochTime\fP\&.
.IP "  \(bu" 4
\fR{{minEpochTime}}\fP Minimum epoch time, defaults to 1ms\&. See \fBBench::minEpochTime\fP\&.
.IP "  \(bu" 4
\fR{{minEpochIterations}}\fP See \fBBench::minEpochIterations\fP\&.
.IP "  \(bu" 4
\fR{{epochIterations}}\fP See \fBBench::epochIterations\fP\&.
.IP "  \(bu" 4
\fR{{warmup}}\fP Number of iterations used before measuring starts\&. See \fBBench::warmup\fP\&.
.IP "  \(bu" 4
\fR{{relative}}\fP True or false, depending on the setting you have used\&. See \fBBench::relative\fP\&.
.IP "  \(bu" 4
\fR{{context(variableName)}}\fP See \fBBench::context\fP\&.
.PP

.PP
Apart from these tags, it is also possible to use some mathematical operations on the measurement data\&. The operations are of the form \fR{{\fBcommand(name)\fP}}\fP\&. Currently \fR\fBname\fP\fP can be one of \fRelapsed\fP, \fRiterations\fP\&. If performance counters are available (currently only on current Linux systems), you also have \fRpagefaults\fP, \fRcpucycles\fP, \fRcontextswitches\fP, \fRinstructions\fP, \fRbranchinstructions\fP, and \fRbranchmisses\fP\&. All the measures (except \fRiterations\fP) are provided for a single iteration (so \fRelapsed\fP is the time a single iteration took)\&. The following tags are available:
.IP "  \(bu" 4
\fR{{median(<\fBname\fP>)}}\fP Calculate median of a measurement data set, e\&.g\&. \fR{{median(elapsed)}}\fP\&.
.IP "  \(bu" 4
\fR{{average(<\fBname\fP>)}}\fP Average (mean) calculation\&.
.IP "  \(bu" 4
\fR{{medianAbsolutePercentError(<\fBname\fP>)}}\fP Calculates MdAPE, the Median Absolute Percentage Error\&. The MdAPE is an excellent metric for the variation of measurements\&. It is more robust to outliers than the \fRMean absolute percentage error (M-APE)\fP\&.   \[      \mathrm{MdAPE}(e) = \mathrm{med}\{| \frac{e_i - \mathrm{med}\{e\}}{e_i}| \}
\] E\&.g\&. for \fIelapsed\fP: First, $ \mathrm{med}\{e\} $ calculates the median by sorting and then taking the middle element of all \fIelapsed\fP measurements\&. This is used to calculate the absolute percentage error to this median for each measurement, as in $ | \frac{e_i - \mathrm{med}\{e\}}{e_i}| $\&. All these results are sorted, and the middle value is chosen as the median absolute percent error\&.

.PP
This measurement is a bit hard to interpret, but it is very robust against outliers\&. E\&.g\&. a value of 5% means that half of the measurements deviate less than 5% from the median, and the other deviate more than 5% from the median\&.
.IP "  \(bu" 4
\fR{{\fBsum\fP(<\fBname\fP>)}}\fP Sum of all the measurements\&. E\&.g\&. \fR{{\fBsum(iterations)\fP}}\fP will give you the total number of iterations measured in this benchmark\&.
.IP "  \(bu" 4
\fR{{minimum(<\fBname\fP>)}}\fP Minimum of all measurements\&.
.IP "  \(bu" 4
\fR{{maximum(<\fBname\fP>)}}\fP Maximum of all measurements\&.
.IP "  \(bu" 4
\fR{{sumProduct(<first>, <second>)}}\fP Calculates the sum of the products of corresponding measures:   \[         \mathrm{sumProduct}(a,b) = \sum_{i=1}^{n}a_i\cdot b_i
\] E\&.g\&. to calculate total runtime of the benchmark, you multiply iterations with elapsed time for each measurement, and sum these results up: \fR{{sumProduct(iterations, elapsed)}}\fP\&.
.IP "  \(bu" 4
\fR{{#measurement}}\fP To access individual measurement results, open the begin tag for measurements\&.
.IP "    \(bu" 6
\fR{{elapsed}}\fP Average elapsed wall clock time per iteration, in seconds\&.
.IP "    \(bu" 6
\fR{{iterations}}\fP Number of iterations in the measurement\&. The number of iterations will fluctuate due to some applied randomness, to enhance accuracy\&.
.IP "    \(bu" 6
\fR{{pagefaults}}\fP Average number of pagefaults per iteration\&.
.IP "    \(bu" 6
\fR{{cpucycles}}\fP Average number of CPU cycles processed per iteration\&.
.IP "    \(bu" 6
\fR{{contextswitches}}\fP Average number of context switches per iteration\&.
.IP "    \(bu" 6
\fR{{instructions}}\fP Average number of retired instructions per iteration\&.
.IP "    \(bu" 6
\fR{{branchinstructions}}\fP Average number of branches executed per iteration\&.
.IP "    \(bu" 6
\fR{{branchmisses}}\fP Average number of branches that were missed per iteration\&.
.PP

.IP "  \(bu" 4
\fR{{/measurement}}\fP Ends the measurement tag\&.
.PP

.IP "\(bu" 2
\fR{{/result}}\fP Marks the end of the result layer\&. This is the end marker for the template part that will be instantiated for each benchmark result\&.

.PP
For the layer tags \fIresult\fP and \fImeasurement\fP you additionally can use these special markers:
.IP "  \(bu" 4
\fR{{#-first}}\fP - Begin marker of a template that will be instantiated \fIonly for the first\fP entry in the layer\&. Use is only allowed between the begin and end marker of the layer\&. So between \fR{{#result}}\fP and \fR{{/result}}\fP, or between \fR{{#measurement}}\fP and \fR{{/measurement}}\fP\&. Finish the template with \fR{{/-first}}\fP\&.
.IP "  \(bu" 4
\fR{{^-first}}\fP - Begin marker of a template that will be instantiated \fIfor each except the first\fP entry in the layer\&. This, this is basically the inversion of \fR{{#-first}}\fP\&. Use is only allowed between the begin and end marker of the layer\&. So between \fR{{#result}}\fP and \fR{{/result}}\fP, or between \fR{{#measurement}}\fP and \fR{{/measurement}}\fP\&.
.IP "  \(bu" 4
\fR{{/-first}}\fP - End marker for either \fR{{#-first}}\fP or \fR{{^-first}}\fP\&.
.IP "  \(bu" 4
\fR{{#-last}}\fP - Begin marker of a template that will be instantiated \fIonly for the last\fP entry in the layer\&. Use is only allowed between the begin and end marker of the layer\&. So between \fR{{#result}}\fP and \fR{{/result}}\fP, or between \fR{{#measurement}}\fP and \fR{{/measurement}}\fP\&. Finish the template with \fR{{/-last}}\fP\&.
.IP "  \(bu" 4
\fR{{^-last}}\fP - Begin marker of a template that will be instantiated \fIfor each except the last\fP entry in the layer\&. This, this is basically the inversion of \fR{{#-last}}\fP\&. Use is only allowed between the begin and end marker of the layer\&. So between \fR{{#result}}\fP and \fR{{/result}}\fP, or between \fR{{#measurement}}\fP and \fR{{/measurement}}\fP\&.
.IP "  \(bu" 4
\fR{{/-last}}\fP - End marker for either \fR{{#-last}}\fP or \fR{{^-last}}\fP\&.
.PP

.PP

.PP
.PP
.nf
embed:rst

For an overview of all the possible data you can get out of nanobench, please see the tutorial at :ref:`tutorial-template-json`\&.

The templates that ship with nanobench are:

* :cpp:func:`templates::csv() <ankerl::nanobench::templates::csv()>`
* :cpp:func:`templates::json() <ankerl::nanobench::templates::json()>`
* :cpp:func:`templates::htmlBoxplot() <ankerl::nanobench::templates::htmlBoxplot()>`
* :cpp:func:`templates::pyperf() <ankerl::nanobench::templates::pyperf()>`
.fi
.PP

.PP
\fBParameters\fP
.RS 4
\fImustacheTemplate\fP The template\&. 
.br
\fIbench\fP Benchmark, containing all the results\&. 
.br
\fIout\fP Output for the generated output\&. 
.RE
.PP

.SS "void render (char const * mustacheTemplate, std::vector< \fBResult\fP > const & results, std::ostream & out)"
Same as \fBrender(char const* mustacheTemplate, Bench const& bench, std::ostream& out)\fP, but for when you only have results available\&.

.PP
\fBParameters\fP
.RS 4
\fImustacheTemplate\fP The template\&. 
.br
\fIresults\fP All the results to be used for rendering\&. 
.br
\fIout\fP Output for the generated output\&. 
.RE
.PP

.SS "void render (std::string const & mustacheTemplate, \fBBench\fP const & bench, std::ostream & out)"

.SS "void render (std::string const & mustacheTemplate, std::vector< \fBResult\fP > const & results, std::ostream & out)"

.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
