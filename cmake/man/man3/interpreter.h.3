.TH "src/script/interpreter.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/script/interpreter.h
.SH SYNOPSIS
.br
.PP
\fR#include <consensus/amount\&.h>\fP
.br
\fR#include <hash\&.h>\fP
.br
\fR#include <primitives/transaction\&.h>\fP
.br
\fR#include <script/script_error\&.h>\fP
.br
\fR#include <script/verify_flags\&.h>\fP
.br
\fR#include <span\&.h>\fP
.br
\fR#include <uint256\&.h>\fP
.br
\fR#include <cstddef>\fP
.br
\fR#include <cstdint>\fP
.br
\fR#include <optional>\fP
.br
\fR#include <vector>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBPrecomputedTransactionData\fP"
.br
.ti -1c
.RI "struct \fBScriptExecutionData\fP"
.br
.ti -1c
.RI "class \fBSigHashCache\fP"
.br
.ti -1c
.RI "class \fBBaseSignatureChecker\fP"
.br
.ti -1c
.RI "class \fBGenericTransactionSignatureChecker< T >\fP"
.br
.ti -1c
.RI "class \fBDeferringSignatureChecker\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "using \fBTransactionSignatureChecker\fP = \fBGenericTransactionSignatureChecker\fP<\fBCTransaction\fP>"
.br
.ti -1c
.RI "using \fBMutableTransactionSignatureChecker\fP = \fBGenericTransactionSignatureChecker\fP<\fBCMutableTransaction\fP>"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBSIGHASH_ALL\fP = 1, \fBSIGHASH_NONE\fP = 2, \fBSIGHASH_SINGLE\fP = 3, \fBSIGHASH_ANYONECANPAY\fP = 0x80, \fBSIGHASH_DEFAULT\fP = 0, \fBSIGHASH_OUTPUT_MASK\fP = 3, \fBSIGHASH_INPUT_MASK\fP = 0x80 }"
.br
.ti -1c
.RI "enum class \fBscript_verify_flag_name\fP : uint8_t { \fBSCRIPT_VERIFY_P2SH\fP, \fBSCRIPT_VERIFY_STRICTENC\fP, \fBSCRIPT_VERIFY_DERSIG\fP, \fBSCRIPT_VERIFY_LOW_S\fP, \fBSCRIPT_VERIFY_NULLDUMMY\fP, \fBSCRIPT_VERIFY_SIGPUSHONLY\fP, \fBSCRIPT_VERIFY_MINIMALDATA\fP, \fBSCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS\fP, \fBSCRIPT_VERIFY_CLEANSTACK\fP, \fBSCRIPT_VERIFY_CHECKLOCKTIMEVERIFY\fP, \fBSCRIPT_VERIFY_CHECKSEQUENCEVERIFY\fP, \fBSCRIPT_VERIFY_WITNESS\fP, \fBSCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\fP, \fBSCRIPT_VERIFY_MINIMALIF\fP, \fBSCRIPT_VERIFY_NULLFAIL\fP, \fBSCRIPT_VERIFY_WITNESS_PUBKEYTYPE\fP, \fBSCRIPT_VERIFY_CONST_SCRIPTCODE\fP, \fBSCRIPT_VERIFY_TAPROOT\fP, \fBSCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION\fP, \fBSCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS\fP, \fBSCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE\fP, \fBSCRIPT_VERIFY_END_MARKER\fP }"
.br
.ti -1c
.RI "enum class \fBSigVersion\fP { \fBBASE\fP = 0, \fBWITNESS_V0\fP = 1, \fBTAPROOT\fP = 2, \fBTAPSCRIPT\fP = 3 }"
.br
.ti -1c
.RI "enum class \fBMissingDataBehavior\fP { \fBASSERT_FAIL\fP, \fBFAIL\fP }"
.br
.ti -1c
.RI "enum class \fBscript_verify_flag_name\fP "
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBCheckSignatureEncoding\fP (const std::vector< unsigned char > &vchSig, \fBscript_verify_flags\fP \fBflags\fP, \fBScriptError\fP *serror)"
.br
.ti -1c
.RI "template<class \fBT\fP> \fBuint256\fP \fBSignatureHash\fP (const \fBCScript\fP &scriptCode, const \fBT\fP &txTo, unsigned int nIn, int32_t nHashType, const \fBCAmount\fP &amount, \fBSigVersion\fP sigversion, const \fBPrecomputedTransactionData\fP *cache=nullptr, \fBSigHashCache\fP *sighash_cache=nullptr)"
.br
.ti -1c
.RI "template<typename \fBT\fP> bool \fBSignatureHashSchnorr\fP (\fBuint256\fP &hash_out, \fBScriptExecutionData\fP &execdata, const \fBT\fP &tx_to, uint32_t in_pos, uint8_t hash_type, \fBSigVersion\fP sigversion, const \fBPrecomputedTransactionData\fP &cache, \fBMissingDataBehavior\fP mdb)"
.br
.ti -1c
.RI "\fBuint256\fP \fBComputeTapleafHash\fP (uint8_t leaf_version, std::span< const unsigned char > \fBscript\fP)"
.br
.ti -1c
.RI "\fBuint256\fP \fBComputeTapbranchHash\fP (std::span< const unsigned char > a, std::span< const unsigned char > b)"
.br
.ti -1c
.RI "\fBuint256\fP \fBComputeTaprootMerkleRoot\fP (std::span< const unsigned char > control, const \fBuint256\fP &tapleaf_hash)"
.br
.ti -1c
.RI "bool \fBEvalScript\fP (std::vector< std::vector< unsigned char > > &stack, const \fBCScript\fP &\fBscript\fP, \fBscript_verify_flags\fP \fBflags\fP, const \fBBaseSignatureChecker\fP &checker, \fBSigVersion\fP sigversion, \fBScriptExecutionData\fP &execdata, \fBScriptError\fP *error=nullptr)"
.br
.ti -1c
.RI "bool \fBEvalScript\fP (std::vector< std::vector< unsigned char > > &stack, const \fBCScript\fP &\fBscript\fP, \fBscript_verify_flags\fP \fBflags\fP, const \fBBaseSignatureChecker\fP &checker, \fBSigVersion\fP sigversion, \fBScriptError\fP *error=nullptr)"
.br
.ti -1c
.RI "bool \fBVerifyScript\fP (const \fBCScript\fP &scriptSig, const \fBCScript\fP &scriptPubKey, const \fBCScriptWitness\fP *witness, \fBscript_verify_flags\fP \fBflags\fP, const \fBBaseSignatureChecker\fP &checker, \fBScriptError\fP *serror=nullptr)"
.br
.ti -1c
.RI "size_t \fBCountWitnessSigOps\fP (const \fBCScript\fP &scriptSig, const \fBCScript\fP &scriptPubKey, const \fBCScriptWitness\fP &witness, \fBscript_verify_flags\fP \fBflags\fP)"
.br
.ti -1c
.RI "int \fBFindAndDelete\fP (\fBCScript\fP &\fBscript\fP, const \fBCScript\fP &b)"
.br
.ti -1c
.RI "const std::map< std::string, \fBscript_verify_flag_name\fP > & \fBScriptFlagNamesToEnum\fP ()"
.br
.ti -1c
.RI "std::vector< std::string > \fBGetScriptFlagNames\fP (\fBscript_verify_flags\fP \fBflags\fP)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBHashWriter\fP \fBHASHER_TAPSIGHASH\fP"
.br
.RI "Hasher with tag "TapSighash" pre-fed to it\&. "
.ti -1c
.RI "const \fBHashWriter\fP \fBHASHER_TAPLEAF\fP"
.br
.RI "Hasher with tag "TapLeaf" pre-fed to it\&. "
.ti -1c
.RI "const \fBHashWriter\fP \fBHASHER_TAPBRANCH\fP"
.br
.RI "Hasher with tag "TapBranch" pre-fed to it\&. "
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "using \fBMutableTransactionSignatureChecker\fP = \fBGenericTransactionSignatureChecker\fP<\fBCMutableTransaction\fP>"

.SS "using \fBTransactionSignatureChecker\fP = \fBGenericTransactionSignatureChecker\fP<\fBCTransaction\fP>"

.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
Signature hash types/flags 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISIGHASH_ALL \fP
.TP
\f(BISIGHASH_NONE \fP
.TP
\f(BISIGHASH_SINGLE \fP
.TP
\f(BISIGHASH_ANYONECANPAY \fP
.TP
\f(BISIGHASH_DEFAULT \fP
Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL\&. 
.TP
\f(BISIGHASH_OUTPUT_MASK \fP
.TP
\f(BISIGHASH_INPUT_MASK \fP
.SS "enum class \fBMissingDataBehavior\fP\fR [strong]\fP"
Enum to specify what *TransactionSignatureChecker's behavior should be when dealing with missing transaction data\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIASSERT_FAIL \fP
Abort execution through assertion failure (for consensus code)\&. 
.TP
\f(BIFAIL \fP
Just act as if the signature was invalid\&. 
.SS "enum class \fBscript_verify_flag_name\fP : uint8_t\fR [strong]\fP"

.SS "enum class \fBscript_verify_flag_name\fP : uint8_t\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BISCRIPT_VERIFY_P2SH \fP
.TP
\f(BISCRIPT_VERIFY_STRICTENC \fP
.TP
\f(BISCRIPT_VERIFY_DERSIG \fP
.TP
\f(BISCRIPT_VERIFY_LOW_S \fP
.TP
\f(BISCRIPT_VERIFY_NULLDUMMY \fP
.TP
\f(BISCRIPT_VERIFY_SIGPUSHONLY \fP
.TP
\f(BISCRIPT_VERIFY_MINIMALDATA \fP
.TP
\f(BISCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS \fP
.TP
\f(BISCRIPT_VERIFY_CLEANSTACK \fP
.TP
\f(BISCRIPT_VERIFY_CHECKLOCKTIMEVERIFY \fP
.TP
\f(BISCRIPT_VERIFY_CHECKSEQUENCEVERIFY \fP
.TP
\f(BISCRIPT_VERIFY_WITNESS \fP
.TP
\f(BISCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM \fP
.TP
\f(BISCRIPT_VERIFY_MINIMALIF \fP
.TP
\f(BISCRIPT_VERIFY_NULLFAIL \fP
.TP
\f(BISCRIPT_VERIFY_WITNESS_PUBKEYTYPE \fP
.TP
\f(BISCRIPT_VERIFY_CONST_SCRIPTCODE \fP
.TP
\f(BISCRIPT_VERIFY_TAPROOT \fP
.TP
\f(BISCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION \fP
.TP
\f(BISCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS \fP
.TP
\f(BISCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE \fP
.TP
\f(BISCRIPT_VERIFY_END_MARKER \fP
.SS "enum class \fBSigVersion\fP\fR [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIBASE \fP
Bare scripts and BIP16 P2SH-wrapped redeemscripts\&. 
.TP
\f(BIWITNESS_V0 \fP
Witness v0 (P2WPKH and P2WSH); see BIP 141\&. 
.TP
\f(BITAPROOT \fP
Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341\&. 
.TP
\f(BITAPSCRIPT \fP
Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342\&. 
.SH "Function Documentation"
.PP 
.SS "bool CheckSignatureEncoding (const std::vector< unsigned char > & vchSig, \fBscript_verify_flags\fP flags, \fBScriptError\fP * serror)"

.SS "\fBuint256\fP ComputeTapbranchHash (std::span< const unsigned char > a, std::span< const unsigned char > b)"
Compute the BIP341 tapbranch hash from two branches\&. Spans must be 32 bytes each\&. 
.SS "\fBuint256\fP ComputeTapleafHash (uint8_t leaf_version, std::span< const unsigned char > script)"
Compute the BIP341 tapleaf hash from leaf version & script\&. 
.SS "\fBuint256\fP ComputeTaprootMerkleRoot (std::span< const unsigned char > control, const \fBuint256\fP & tapleaf_hash)"
Compute the BIP341 taproot script tree Merkle root from control block and leaf hash\&. Requires control block to have valid length (33 + k*32, with k in {0,1,\&.\&.,128})\&. 
.SS "size_t CountWitnessSigOps (const \fBCScript\fP & scriptSig, const \fBCScript\fP & scriptPubKey, const \fBCScriptWitness\fP & witness, \fBscript_verify_flags\fP flags)"

.SS "bool EvalScript (std::vector< std::vector< unsigned char > > & stack, const \fBCScript\fP & script, \fBscript_verify_flags\fP flags, const \fBBaseSignatureChecker\fP & checker, \fBSigVersion\fP sigversion, \fBScriptError\fP * error = \fRnullptr\fP)"

.SS "bool EvalScript (std::vector< std::vector< unsigned char > > & stack, const \fBCScript\fP & script, \fBscript_verify_flags\fP flags, const \fBBaseSignatureChecker\fP & checker, \fBSigVersion\fP sigversion, \fBScriptExecutionData\fP & execdata, \fBScriptError\fP * error = \fRnullptr\fP)"

.SS "int FindAndDelete (\fBCScript\fP & script, const \fBCScript\fP & b)"

.SS "std::vector< std::string > GetScriptFlagNames (\fBscript_verify_flags\fP flags)"

.SS "const std::map< std::string, \fBscript_verify_flag_name\fP > & ScriptFlagNamesToEnum ()"

.SS "template<class \fBT\fP> \fBuint256\fP SignatureHash (const \fBCScript\fP & scriptCode, const \fBT\fP & txTo, unsigned int nIn, int32_t nHashType, const \fBCAmount\fP & amount, \fBSigVersion\fP sigversion, const \fBPrecomputedTransactionData\fP * cache = \fRnullptr\fP, \fBSigHashCache\fP * sighash_cache = \fRnullptr\fP)"

.SS "template<typename \fBT\fP> bool SignatureHashSchnorr (\fBuint256\fP & hash_out, \fBScriptExecutionData\fP & execdata, const \fBT\fP & tx_to, uint32_t in_pos, uint8_t hash_type, \fBSigVersion\fP sigversion, const \fBPrecomputedTransactionData\fP & cache, \fBMissingDataBehavior\fP mdb)"

.SS "bool VerifyScript (const \fBCScript\fP & scriptSig, const \fBCScript\fP & scriptPubKey, const \fBCScriptWitness\fP * witness, \fBscript_verify_flags\fP flags, const \fBBaseSignatureChecker\fP & checker, \fBScriptError\fP * serror = \fRnullptr\fP)"

.SH "Variable Documentation"
.PP 
.SS "const \fBHashWriter\fP HASHER_TAPBRANCH\fR [extern]\fP"

.PP
Hasher with tag "TapBranch" pre-fed to it\&. 
.SS "const \fBHashWriter\fP HASHER_TAPLEAF\fR [extern]\fP"

.PP
Hasher with tag "TapLeaf" pre-fed to it\&. 
.SS "const \fBHashWriter\fP HASHER_TAPSIGHASH\fR [extern]\fP"

.PP
Hasher with tag "TapSighash" pre-fed to it\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
