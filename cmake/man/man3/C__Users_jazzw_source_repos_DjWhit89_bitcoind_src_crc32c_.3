.TH "src/crc32c Directory Reference" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/crc32c Directory Reference
.SH SYNOPSIS
.br
.PP
.SS "Directories"

.in +1c
.ti -1c
.RI "directory \fBinclude\fP"
.br
.ti -1c
.RI "directory \fBsrc\fP"
.br
.in -1c
.SS "Files"

.in +1c
.ti -1c
.RI "file \fB\&.ycm_extra_conf\&.py\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SH "CRC32C"
.PP
\fR\fP
.PP
New file format authors should consider \fRHighwayHash\fP\&. The initial version of this code was extracted from \fRLevelDB\fP, which is a stable key-value store that is widely used at Google\&.

.PP
This project collects a few CRC32C implementations under an umbrella that dispatches to a suitable implementation based on the host computer's hardware capabilities\&.

.PP
CRC32C is specified as the CRC that uses the iSCSI polynomial in \fRRFC 3720\fP\&. The polynomial was introduced by G\&. Castagnoli, S\&. Braeuer and M\&. Herrmann\&. CRC32C is used in software such as Btrfs, ext4, Ceph and leveldb\&.
.SH "Usage"
.PP
.PP
.nf
#include "crc32c/crc32c\&.h"

int main() {
  const std::uint8_t buffer[] = {0, 0, 0, 0};
  std::uint32_t result;

  // Process a raw buffer\&.
  result = crc32c::Crc32c(buffer, 4);

  // Process a std::string\&.
  std::string string;
  string\&.resize(4);
  result = crc32c::Crc32c(string);

  // If you have C++17 support, process a std::string_view\&.
  std::string_view string_view(string);
  result = crc32c::Crc32c(string_view);

  return 0;
}
.fi
.PP
.SH "Prerequisites"
.PP
This project uses \fRCMake\fP for building and testing\&. CMake is available in all popular Linux distributions, as well as in \fRHomebrew\fP\&.

.PP
This project uses submodules for dependency management\&.

.PP
.PP
.nf
git submodule update \-\-init \-\-recursive
.fi
.PP

.PP
If you're using \fRAtom\fP, the following packages can help\&.

.PP
.PP
.nf
apm install autocomplete\-clang build build\-cmake clang\-format language\-cmake \\
    linter linter\-clang
.fi
.PP

.PP
If you don't mind more setup in return for more speed, replace \fRautocomplete-clang\fP and \fRlinter-clang\fP with \fRyou-complete-me\fP\&. This requires \fRsetting up ycmd\fP\&.

.PP
.PP
.nf
apm install autocomplete\-plus build build\-cmake clang\-format language\-cmake \\
    linter you\-complete\-me
.fi
.PP
.SH "Building"
.PP
The following commands build and install the project\&.

.PP
.PP
.nf
mkdir build
cd build
cmake \-DCRC32C_BUILD_TESTS=0 \-DCRC32C_BUILD_BENCHMARKS=0 \&.\&. && make all install
.fi
.PP
.SH "Development"
.PP
The following command (when executed from \fRbuild/\fP) (re)builds the project and runs the tests\&.

.PP
.PP
.nf
cmake \&.\&. && cmake \-\-build \&. && ctest \-\-output\-on\-failure
.fi
.PP
.SS "Android testing"
The following command builds the project against the Android NDK, which is useful for benchmarking against ARM processors\&.

.PP
.PP
.nf
cmake \&.\&. \-DCMAKE_SYSTEM_NAME=Android \-DCMAKE_ANDROID_ARCH_ABI=arm64\-v8a \\
    \-DCMAKE_ANDROID_NDK=$HOME/Library/Android/sdk/ndk\-bundle \\
    \-DCMAKE_ANDROID_NDK_TOOLCHAIN_VERSION=clang \\
    \-DCMAKE_ANDROID_STL_TYPE=c++_static \-DCRC32C_USE_GLOG=0 \\
    \-DCMAKE_BUILD_TYPE=Release && cmake \-\-build \&.
.fi
.PP

.PP
The following commands install and run the benchmarks\&.

.PP
.PP
.nf
adb push crc32c_bench /data/local/tmp
adb shell chmod +x /data/local/tmp/crc32c_bench
adb shell 'cd /data/local/tmp && \&./crc32c_bench'
adb shell rm /data/local/tmp/crc32c_bench
.fi
.PP

.PP
The following commands install and run the tests\&.

.PP
.PP
.nf
adb push crc32c_tests /data/local/tmp
adb shell chmod +x /data/local/tmp/crc32c_tests
adb shell 'cd /data/local/tmp && \&./crc32c_tests'
adb shell rm /data/local/tmp/crc32c_tests
.fi
.PP
 
