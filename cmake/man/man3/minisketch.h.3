.TH "src/minisketch/include/minisketch.h" 3 "Version 2.8" "bitcoind" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/minisketch/include/minisketch.h
.SH SYNOPSIS
.br
.PP
\fR#include <stdint\&.h>\fP
.br
\fR#include <stdlib\&.h>\fP
.br
\fR#include <unistd\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMINISKETCH_API\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBminisketch\fP \fBminisketch\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBMINISKETCH_API\fP int \fBminisketch_bits_supported\fP (uint32_t bits)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP uint32_t \fBminisketch_implementation_max\fP (void)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP int \fBminisketch_implementation_supported\fP (uint32_t bits, uint32_t implementation)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP \fBminisketch\fP * \fBminisketch_create\fP (uint32_t bits, uint32_t implementation, size_t capacity)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP uint32_t \fBminisketch_bits\fP (const \fBminisketch\fP *sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP size_t \fBminisketch_capacity\fP (const \fBminisketch\fP *sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP uint32_t \fBminisketch_implementation\fP (const \fBminisketch\fP *sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP void \fBminisketch_set_seed\fP (\fBminisketch\fP *sketch, uint64_t seed)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP \fBminisketch\fP * \fBminisketch_clone\fP (const \fBminisketch\fP *sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP void \fBminisketch_destroy\fP (\fBminisketch\fP *sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP size_t \fBminisketch_serialized_size\fP (const \fBminisketch\fP *sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP void \fBminisketch_serialize\fP (const \fBminisketch\fP *sketch, unsigned char *output)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP void \fBminisketch_deserialize\fP (\fBminisketch\fP *sketch, const unsigned char *input)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP void \fBminisketch_add_uint64\fP (\fBminisketch\fP *sketch, uint64_t element)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP size_t \fBminisketch_merge\fP (\fBminisketch\fP *sketch, const \fBminisketch\fP *other_sketch)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP ssize_t \fBminisketch_decode\fP (const \fBminisketch\fP *sketch, size_t max_elements, uint64_t *output)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP size_t \fBminisketch_compute_capacity\fP (uint32_t bits, size_t max_elements, uint32_t fpbits)"
.br
.ti -1c
.RI "\fBMINISKETCH_API\fP size_t \fBminisketch_compute_max_elements\fP (uint32_t bits, size_t capacity, uint32_t fpbits)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define MINISKETCH_API"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBminisketch\fP \fBminisketch\fP"
Opaque type for decoded sketches\&. 
.SH "Function Documentation"
.PP 
.SS "\fBMINISKETCH_API\fP void minisketch_add_uint64 (\fBminisketch\fP * sketch, uint64_t element)"
Add an element to a sketch\&.

.PP
If the element to be added is too large for the sketch, the most significant bits of the element are dropped\&. More precisely, if the element size of \fRsketch\fP is b bits, then this function adds the unsigned integer represented by the b least significant bits of \fRelement\fP to \fRsketch\fP\&.

.PP
If the element to be added is 0 (after potentially dropping the most significant bits), then this function is a no-op\&. Sketches cannot contain an element with the value 0\&.

.PP
Note that adding the same element a second time removes it again\&. 
.SS "\fBMINISKETCH_API\fP uint32_t minisketch_bits (const \fBminisketch\fP * sketch)"
Get the element size of a sketch in bits\&. 
.SS "\fBMINISKETCH_API\fP int minisketch_bits_supported (uint32_t bits)"
Determine whether support for elements of \fRbits\fP bits was compiled in\&. 
.SS "\fBMINISKETCH_API\fP size_t minisketch_capacity (const \fBminisketch\fP * sketch)"
Get the capacity of a sketch\&. 
.SS "\fBMINISKETCH_API\fP \fBminisketch\fP * minisketch_clone (const \fBminisketch\fP * sketch)"
Clone a sketch\&.

.PP
The result must be destroyed using minisketch_destroy\&. 
.SS "\fBMINISKETCH_API\fP size_t minisketch_compute_capacity (uint32_t bits, size_t max_elements, uint32_t fpbits)"
Compute the capacity needed to achieve a certain rate of false positives\&.

.PP
A sketch with capacity c and no more than c elements can always be decoded correctly\&. However, if it has more than c elements, or contains just random bytes, it is possible that it will still decode, but the result will be nonsense\&. This can be counteracted by increasing the capacity slightly\&.

.PP
Given a field size bits, an intended number of elements that can be decoded max_elements, and a false positive probability of 1 in 2**fpbits, this function computes the necessary capacity\&. It is only guaranteed to be accurate up to fpbits=256\&. 
.SS "\fBMINISKETCH_API\fP size_t minisketch_compute_max_elements (uint32_t bits, size_t capacity, uint32_t fpbits)"
Compute what max_elements can be decoded for a certain rate of false positives\&.

.PP
This is the inverse operation of minisketch_compute_capacity\&. It determines, given a field size bits, a capacity of a sketch, and an acceptable false positive probability of 1 in 2**fpbits, what the maximum allowed max_elements value is\&. If no value of max_elements would give the desired false positive probability, 0 is returned\&.

.PP
Note that this is not an exact inverse of minisketch_compute_capacity\&. For example, with bits=32, fpbits=16, and max_elements=8, minisketch_compute_capacity will return 9, as capacity 8 would only have a false positive chance of 1 in 2^15\&.3\&. Increasing the capacity to 9 however decreases the fp chance to 1 in 2^47\&.3, enough for max_elements=9 (with fp chance of 1 in 2^18\&.5)\&. Therefore, minisketch_compute_max_elements with capacity=9 will return 9\&. 
.SS "\fBMINISKETCH_API\fP \fBminisketch\fP * minisketch_create (uint32_t bits, uint32_t implementation, size_t capacity)"
Construct a sketch for a given element size, implementation and capacity\&.

.PP
If the combination of \fRbits\fP and \fRimplementation\fP is unavailable, or when OOM occurs, NULL is returned\&. If minisketch_implementation_supported returns 1 for the specified bits and implementation, this will always succeed (except when allocation fails)\&.

.PP
If the result is not NULL, it must be destroyed using minisketch_destroy\&. 
.SS "\fBMINISKETCH_API\fP ssize_t minisketch_decode (const \fBminisketch\fP * sketch, size_t max_elements, uint64_t * output)"
Decode a sketch\&.

.PP
\fRoutput\fP is a pointer to an array of \fRmax_element\fP uint64_t's, which will be filled with the elements in this sketch\&.

.PP
The return value is the number of decoded elements, or -1 if decoding failed\&. 
.SS "\fBMINISKETCH_API\fP void minisketch_deserialize (\fBminisketch\fP * sketch, const unsigned char * input)"
Deserialize a sketch from bytes\&. 
.SS "\fBMINISKETCH_API\fP void minisketch_destroy (\fBminisketch\fP * sketch)"
Destroy a sketch\&.

.PP
The pointer that was passed in may not be used anymore afterwards\&. 
.SS "\fBMINISKETCH_API\fP uint32_t minisketch_implementation (const \fBminisketch\fP * sketch)"
Get the implementation of a sketch\&. 
.SS "\fBMINISKETCH_API\fP uint32_t minisketch_implementation_max (void )"
Determine the maximum number of implementations available\&.

.PP
Multiple implementations may be available for a given element size, with different performance characteristics on different hardware\&.

.PP
Each implementation is identified by a number from 0 to the output of this function call, inclusive\&. Note that not every combination of implementation and element size may exist (see further)\&. 
.SS "\fBMINISKETCH_API\fP int minisketch_implementation_supported (uint32_t bits, uint32_t implementation)"
Determine if the a combination of bits and implementation number is available\&.

.PP
Returns 1 if it is, 0 otherwise\&. 
.SS "\fBMINISKETCH_API\fP size_t minisketch_merge (\fBminisketch\fP * sketch, const \fBminisketch\fP * other_sketch)"
Merge the elements of another sketch into this sketch\&.

.PP
After merging, \fRsketch\fP will contain every element that existed in one but not both of the input sketches\&. It can be seen as an exclusive or operation on the set elements\&. If the capacity of \fRother_sketch\fP is lower than \fRsketch\fP's, merging reduces the capacity of \fRsketch\fP to that of \fRother_sketch\fP\&.

.PP
This function returns the capacity of \fRsketch\fP after merging has been performed (where this capacity is at least 1), or 0 to indicate that merging has failed because the two input sketches differ in their element size or implementation\&. If 0 is returned, \fRsketch\fP (and its capacity) have not been modified\&.

.PP
It is also possible to perform this operation directly on the serializations of two sketches with the same element size and capacity by performing a bitwise XOR of the serializations\&. 
.SS "\fBMINISKETCH_API\fP void minisketch_serialize (const \fBminisketch\fP * sketch, unsigned char * output)"
Serialize a sketch to bytes\&. 
.SS "\fBMINISKETCH_API\fP size_t minisketch_serialized_size (const \fBminisketch\fP * sketch)"
Compute the size in bytes for serializing a given sketch\&. 
.SS "\fBMINISKETCH_API\fP void minisketch_set_seed (\fBminisketch\fP * sketch, uint64_t seed)"
Set the seed for randomizing algorithm choices to a fixed value\&.

.PP
By default, sketches are initialized with a random seed\&. This is important to avoid scenarios where an attacker could force worst-case behavior\&.

.PP
This function initializes the seed to a user-provided value (any 64-bit integer is acceptable, regardless of field size)\&.

.PP
When seed is -1, a fixed internal value with predictable behavior is used\&. It is only intended for testing\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for bitcoind from the source code\&.
